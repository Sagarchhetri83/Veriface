"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@tensorflow";
exports.ids = ["vendor-chunks/@tensorflow"];
exports.modules = {

/***/ "(ssr)/./node_modules/@tensorflow/tfjs-core/dist/tf-core.esm.js":
/*!****************************************************************!*\
  !*** ./node_modules/@tensorflow/tfjs-core/dist/tf-core.esm.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AdadeltaOptimizer: () => (/* binding */ bd),\n/* harmony export */   AdagradOptimizer: () => (/* binding */ wd),\n/* harmony export */   AdamOptimizer: () => (/* binding */ Cd),\n/* harmony export */   AdamaxOptimizer: () => (/* binding */ Ed),\n/* harmony export */   DataStorage: () => (/* binding */ xo),\n/* harmony export */   ENV: () => (/* binding */ s),\n/* harmony export */   Environment: () => (/* binding */ o),\n/* harmony export */   KernelBackend: () => (/* binding */ bo),\n/* harmony export */   MomentumOptimizer: () => (/* binding */ Id),\n/* harmony export */   Optimizer: () => (/* binding */ xd),\n/* harmony export */   RMSPropOptimizer: () => (/* binding */ kd),\n/* harmony export */   Rank: () => (/* binding */ Ct),\n/* harmony export */   Reduction: () => (/* binding */ ch),\n/* harmony export */   SGDOptimizer: () => (/* binding */ Rd),\n/* harmony export */   Tensor: () => (/* binding */ wt),\n/* harmony export */   TensorBuffer: () => (/* binding */ gt),\n/* harmony export */   Variable: () => (/* binding */ St),\n/* harmony export */   abs: () => (/* binding */ ru),\n/* harmony export */   acos: () => (/* binding */ ou),\n/* harmony export */   acosh: () => (/* binding */ au),\n/* harmony export */   add: () => (/* binding */ rc),\n/* harmony export */   addN: () => (/* binding */ oc),\n/* harmony export */   addStrict: () => (/* binding */ ac),\n/* harmony export */   all: () => (/* binding */ Cl),\n/* harmony export */   any: () => (/* binding */ El),\n/* harmony export */   argMax: () => (/* binding */ Rl),\n/* harmony export */   argMin: () => (/* binding */ Il),\n/* harmony export */   asin: () => (/* binding */ iu),\n/* harmony export */   asinh: () => (/* binding */ su),\n/* harmony export */   atan: () => (/* binding */ uu),\n/* harmony export */   atan2: () => (/* binding */ ic),\n/* harmony export */   atanh: () => (/* binding */ cu),\n/* harmony export */   avgPool: () => (/* binding */ fl),\n/* harmony export */   avgPool3d: () => (/* binding */ vl),\n/* harmony export */   backend: () => (/* binding */ hn),\n/* harmony export */   backend_util: () => (/* binding */ Uo),\n/* harmony export */   basicLSTMCell: () => (/* binding */ zl),\n/* harmony export */   batchNorm: () => (/* binding */ ju),\n/* harmony export */   batchNorm2d: () => (/* binding */ Xu),\n/* harmony export */   batchNorm3d: () => (/* binding */ Yu),\n/* harmony export */   batchNorm4d: () => (/* binding */ $u),\n/* harmony export */   batchNormalization: () => (/* binding */ Ku),\n/* harmony export */   batchNormalization2d: () => (/* binding */ Gu),\n/* harmony export */   batchNormalization3d: () => (/* binding */ Hu),\n/* harmony export */   batchNormalization4d: () => (/* binding */ qu),\n/* harmony export */   batchToSpaceND: () => (/* binding */ vr),\n/* harmony export */   booleanMaskAsync: () => (/* binding */ Uc),\n/* harmony export */   broadcastTo: () => (/* binding */ mr),\n/* harmony export */   browser: () => (/* binding */ id),\n/* harmony export */   buffer: () => (/* binding */ dr),\n/* harmony export */   cast: () => (/* binding */ gr),\n/* harmony export */   ceil: () => (/* binding */ lu),\n/* harmony export */   clipByValue: () => (/* binding */ hu),\n/* harmony export */   clone: () => (/* binding */ yr),\n/* harmony export */   complex: () => (/* binding */ Dn),\n/* harmony export */   concat: () => (/* binding */ Yn),\n/* harmony export */   concat1d: () => (/* binding */ $n),\n/* harmony export */   concat2d: () => (/* binding */ Qn),\n/* harmony export */   concat3d: () => (/* binding */ Jn),\n/* harmony export */   concat4d: () => (/* binding */ Zn),\n/* harmony export */   conv1d: () => (/* binding */ Hc),\n/* harmony export */   conv2d: () => (/* binding */ qc),\n/* harmony export */   conv2dTranspose: () => (/* binding */ Zc),\n/* harmony export */   conv3d: () => (/* binding */ Kc),\n/* harmony export */   conv3dTranspose: () => (/* binding */ tl),\n/* harmony export */   cos: () => (/* binding */ fu),\n/* harmony export */   cosh: () => (/* binding */ du),\n/* harmony export */   cumsum: () => (/* binding */ xr),\n/* harmony export */   customGrad: () => (/* binding */ vo),\n/* harmony export */   deprecationWarn: () => (/* binding */ Xe),\n/* harmony export */   depthToSpace: () => (/* binding */ br),\n/* harmony export */   depthwiseConv2d: () => (/* binding */ Yc),\n/* harmony export */   diag: () => (/* binding */ eh),\n/* harmony export */   disableDeprecationWarnings: () => (/* binding */ je),\n/* harmony export */   dispose: () => (/* binding */ tn),\n/* harmony export */   disposeVariables: () => (/* binding */ Ye),\n/* harmony export */   div: () => (/* binding */ sc),\n/* harmony export */   divNoNan: () => (/* binding */ uc),\n/* harmony export */   divStrict: () => (/* binding */ cc),\n/* harmony export */   dot: () => (/* binding */ nl),\n/* harmony export */   dropout: () => (/* binding */ nh),\n/* harmony export */   elu: () => (/* binding */ _l),\n/* harmony export */   enableDebugMode: () => (/* binding */ Ke),\n/* harmony export */   enableProdMode: () => (/* binding */ qe),\n/* harmony export */   engine: () => (/* binding */ $e),\n/* harmony export */   env: () => (/* binding */ i),\n/* harmony export */   equal: () => (/* binding */ Rc),\n/* harmony export */   equalStrict: () => (/* binding */ Ic),\n/* harmony export */   erf: () => (/* binding */ pu),\n/* harmony export */   exp: () => (/* binding */ vu),\n/* harmony export */   expandDims: () => (/* binding */ wr),\n/* harmony export */   expm1: () => (/* binding */ mu),\n/* harmony export */   eye: () => (/* binding */ Cr),\n/* harmony export */   fft: () => (/* binding */ Xl),\n/* harmony export */   fill: () => (/* binding */ Hn),\n/* harmony export */   findBackend: () => (/* binding */ un),\n/* harmony export */   findBackendFactory: () => (/* binding */ cn),\n/* harmony export */   floor: () => (/* binding */ gu),\n/* harmony export */   floorDiv: () => (/* binding */ lc),\n/* harmony export */   frame: () => (/* binding */ ih),\n/* harmony export */   fused: () => (/* binding */ zh),\n/* harmony export */   gather: () => (/* binding */ Lc),\n/* harmony export */   gatherND: () => (/* binding */ th),\n/* harmony export */   gather_util: () => (/* binding */ Xr),\n/* harmony export */   getBackend: () => (/* binding */ an),\n/* harmony export */   getGradient: () => (/* binding */ h),\n/* harmony export */   getKernel: () => (/* binding */ l),\n/* harmony export */   getKernelsForBackend: () => (/* binding */ f),\n/* harmony export */   grad: () => (/* binding */ co),\n/* harmony export */   grads: () => (/* binding */ lo),\n/* harmony export */   greater: () => (/* binding */ kc),\n/* harmony export */   greaterEqual: () => (/* binding */ Sc),\n/* harmony export */   greaterEqualStrict: () => (/* binding */ Ac),\n/* harmony export */   greaterStrict: () => (/* binding */ Dc),\n/* harmony export */   hammingWindow: () => (/* binding */ ah),\n/* harmony export */   hannWindow: () => (/* binding */ oh),\n/* harmony export */   ifft: () => (/* binding */ Yl),\n/* harmony export */   imag: () => (/* binding */ Nn),\n/* harmony export */   image: () => (/* binding */ Oh),\n/* harmony export */   inTopKAsync: () => (/* binding */ lh),\n/* harmony export */   io: () => (/* binding */ ed),\n/* harmony export */   irfft: () => (/* binding */ Ql),\n/* harmony export */   isFinite: () => (/* binding */ Du),\n/* harmony export */   isInf: () => (/* binding */ Au),\n/* harmony export */   isNaN: () => (/* binding */ Su),\n/* harmony export */   keep: () => (/* binding */ en),\n/* harmony export */   leakyRelu: () => (/* binding */ Ol),\n/* harmony export */   less: () => (/* binding */ Tc),\n/* harmony export */   lessEqual: () => (/* binding */ Nc),\n/* harmony export */   lessEqualStrict: () => (/* binding */ Fc),\n/* harmony export */   lessStrict: () => (/* binding */ _c),\n/* harmony export */   linalg: () => (/* binding */ Ih),\n/* harmony export */   linspace: () => (/* binding */ qn),\n/* harmony export */   localResponseNormalization: () => (/* binding */ Ul),\n/* harmony export */   log: () => (/* binding */ yu),\n/* harmony export */   log1p: () => (/* binding */ xu),\n/* harmony export */   logSigmoid: () => (/* binding */ bu),\n/* harmony export */   logSoftmax: () => (/* binding */ yo),\n/* harmony export */   logSumExp: () => (/* binding */ kl),\n/* harmony export */   logicalAnd: () => (/* binding */ Qu),\n/* harmony export */   logicalNot: () => (/* binding */ Ju),\n/* harmony export */   logicalOr: () => (/* binding */ Zu),\n/* harmony export */   logicalXor: () => (/* binding */ tc),\n/* harmony export */   losses: () => (/* binding */ bh),\n/* harmony export */   matMul: () => (/* binding */ el),\n/* harmony export */   math: () => (/* binding */ od),\n/* harmony export */   max: () => (/* binding */ Sl),\n/* harmony export */   maxPool: () => (/* binding */ hl),\n/* harmony export */   maxPool3d: () => (/* binding */ pl),\n/* harmony export */   maximum: () => (/* binding */ hc),\n/* harmony export */   maximumStrict: () => (/* binding */ fc),\n/* harmony export */   mean: () => (/* binding */ Al),\n/* harmony export */   memory: () => (/* binding */ Qe),\n/* harmony export */   min: () => (/* binding */ Dl),\n/* harmony export */   minimum: () => (/* binding */ dc),\n/* harmony export */   minimumStrict: () => (/* binding */ pc),\n/* harmony export */   mod: () => (/* binding */ vc),\n/* harmony export */   modStrict: () => (/* binding */ mc),\n/* harmony export */   moments: () => (/* binding */ Tl),\n/* harmony export */   movingAverage: () => (/* binding */ Hl),\n/* harmony export */   mul: () => (/* binding */ gc),\n/* harmony export */   mulStrict: () => (/* binding */ yc),\n/* harmony export */   multiRNNCell: () => (/* binding */ Gl),\n/* harmony export */   multinomial: () => (/* binding */ Er),\n/* harmony export */   neg: () => (/* binding */ wu),\n/* harmony export */   nextFrame: () => (/* binding */ Td),\n/* harmony export */   norm: () => (/* binding */ Vl),\n/* harmony export */   notEqual: () => (/* binding */ Oc),\n/* harmony export */   notEqualStrict: () => (/* binding */ Mc),\n/* harmony export */   oneHot: () => (/* binding */ Rr),\n/* harmony export */   ones: () => (/* binding */ zn),\n/* harmony export */   onesLike: () => (/* binding */ jn),\n/* harmony export */   op: () => (/* binding */ An),\n/* harmony export */   outerProduct: () => (/* binding */ rl),\n/* harmony export */   pad: () => (/* binding */ Ir),\n/* harmony export */   pad1d: () => (/* binding */ kr),\n/* harmony export */   pad2d: () => (/* binding */ Sr),\n/* harmony export */   pad3d: () => (/* binding */ Ar),\n/* harmony export */   pad4d: () => (/* binding */ Dr),\n/* harmony export */   pool: () => (/* binding */ dl),\n/* harmony export */   pow: () => (/* binding */ xc),\n/* harmony export */   powStrict: () => (/* binding */ bc),\n/* harmony export */   prelu: () => (/* binding */ Ml),\n/* harmony export */   print: () => (/* binding */ pr),\n/* harmony export */   prod: () => (/* binding */ Fl),\n/* harmony export */   profile: () => (/* binding */ Je),\n/* harmony export */   rand: () => (/* binding */ Tr),\n/* harmony export */   randomGamma: () => (/* binding */ Fr),\n/* harmony export */   randomNormal: () => (/* binding */ Nr),\n/* harmony export */   randomUniform: () => (/* binding */ _r),\n/* harmony export */   range: () => (/* binding */ Kn),\n/* harmony export */   ready: () => (/* binding */ on),\n/* harmony export */   real: () => (/* binding */ Tn),\n/* harmony export */   reciprocal: () => (/* binding */ Cu),\n/* harmony export */   registerBackend: () => (/* binding */ ln),\n/* harmony export */   registerGradient: () => (/* binding */ p),\n/* harmony export */   registerKernel: () => (/* binding */ d),\n/* harmony export */   relu: () => (/* binding */ Bl),\n/* harmony export */   relu6: () => (/* binding */ Pl),\n/* harmony export */   removeBackend: () => (/* binding */ sn),\n/* harmony export */   reshape: () => (/* binding */ Or),\n/* harmony export */   reverse: () => (/* binding */ ol),\n/* harmony export */   reverse1d: () => (/* binding */ al),\n/* harmony export */   reverse2d: () => (/* binding */ il),\n/* harmony export */   reverse3d: () => (/* binding */ sl),\n/* harmony export */   reverse4d: () => (/* binding */ ul),\n/* harmony export */   rfft: () => (/* binding */ $l),\n/* harmony export */   round: () => (/* binding */ Eu),\n/* harmony export */   rsqrt: () => (/* binding */ Ru),\n/* harmony export */   scalar: () => (/* binding */ On),\n/* harmony export */   scatterND: () => (/* binding */ jl),\n/* harmony export */   scatter_util: () => (/* binding */ to),\n/* harmony export */   selu: () => (/* binding */ Ll),\n/* harmony export */   separableConv2d: () => (/* binding */ Jc),\n/* harmony export */   serialization: () => (/* binding */ ld),\n/* harmony export */   setBackend: () => (/* binding */ rn),\n/* harmony export */   setPlatform: () => (/* binding */ fn),\n/* harmony export */   setdiff1dAsync: () => (/* binding */ Vr),\n/* harmony export */   sigmoid: () => (/* binding */ Iu),\n/* harmony export */   sign: () => (/* binding */ ku),\n/* harmony export */   signal: () => (/* binding */ uh),\n/* harmony export */   sin: () => (/* binding */ Tu),\n/* harmony export */   sinh: () => (/* binding */ Nu),\n/* harmony export */   slice: () => (/* binding */ ml),\n/* harmony export */   slice1d: () => (/* binding */ gl),\n/* harmony export */   slice2d: () => (/* binding */ yl),\n/* harmony export */   slice3d: () => (/* binding */ xl),\n/* harmony export */   slice4d: () => (/* binding */ bl),\n/* harmony export */   slice_util: () => (/* binding */ uo),\n/* harmony export */   softmax: () => (/* binding */ go),\n/* harmony export */   softplus: () => (/* binding */ Fu),\n/* harmony export */   spaceToBatchND: () => (/* binding */ Mr),\n/* harmony export */   sparseToDense: () => (/* binding */ Zl),\n/* harmony export */   spectral: () => (/* binding */ Jl),\n/* harmony export */   split: () => (/* binding */ tr),\n/* harmony export */   sqrt: () => (/* binding */ _u),\n/* harmony export */   square: () => (/* binding */ tu),\n/* harmony export */   squaredDifference: () => (/* binding */ nu),\n/* harmony export */   squaredDifferenceStrict: () => (/* binding */ wc),\n/* harmony export */   squeeze: () => (/* binding */ Br),\n/* harmony export */   stack: () => (/* binding */ Pr),\n/* harmony export */   step: () => (/* binding */ Ou),\n/* harmony export */   stft: () => (/* binding */ sh),\n/* harmony export */   stridedSlice: () => (/* binding */ ql),\n/* harmony export */   sub: () => (/* binding */ Cc),\n/* harmony export */   subStrict: () => (/* binding */ Ec),\n/* harmony export */   sum: () => (/* binding */ Nl),\n/* harmony export */   sumOutType: () => (/* binding */ Tt),\n/* harmony export */   tan: () => (/* binding */ Mu),\n/* harmony export */   tanh: () => (/* binding */ Bu),\n/* harmony export */   tensor: () => (/* binding */ Fn),\n/* harmony export */   tensor1d: () => (/* binding */ Mn),\n/* harmony export */   tensor2d: () => (/* binding */ Bn),\n/* harmony export */   tensor3d: () => (/* binding */ Pn),\n/* harmony export */   tensor4d: () => (/* binding */ Ln),\n/* harmony export */   tensor5d: () => (/* binding */ Wn),\n/* harmony export */   tensor6d: () => (/* binding */ Un),\n/* harmony export */   tensor_util: () => (/* binding */ Mt),\n/* harmony export */   test_util: () => (/* binding */ md),\n/* harmony export */   tidy: () => (/* binding */ Ze),\n/* harmony export */   tile: () => (/* binding */ Lr),\n/* harmony export */   time: () => (/* binding */ nn),\n/* harmony export */   topk: () => (/* binding */ Kl),\n/* harmony export */   train: () => (/* binding */ Ad),\n/* harmony export */   transpose: () => (/* binding */ Wl),\n/* harmony export */   truncatedNormal: () => (/* binding */ Wr),\n/* harmony export */   unregisterGradient: () => (/* binding */ m),\n/* harmony export */   unregisterKernel: () => (/* binding */ v),\n/* harmony export */   unsortedSegmentSum: () => (/* binding */ Wc),\n/* harmony export */   unstack: () => (/* binding */ Ur),\n/* harmony export */   util: () => (/* binding */ st),\n/* harmony export */   valueAndGrad: () => (/* binding */ ho),\n/* harmony export */   valueAndGrads: () => (/* binding */ fo),\n/* harmony export */   variable: () => (/* binding */ Vn),\n/* harmony export */   variableGrads: () => (/* binding */ po),\n/* harmony export */   version_core: () => (/* binding */ gd),\n/* harmony export */   webgl: () => (/* binding */ yd),\n/* harmony export */   where: () => (/* binding */ ec),\n/* harmony export */   whereAsync: () => (/* binding */ nc),\n/* harmony export */   zeros: () => (/* binding */ Gn),\n/* harmony export */   zerosLike: () => (/* binding */ Xn)\n/* harmony export */ });\n/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */ var t = function(e, n) {\n    return (t = Object.setPrototypeOf || ({\n        __proto__: []\n    }) instanceof Array && function(t, e) {\n        t.__proto__ = e;\n    } || function(t, e) {\n        for(var n in e)e.hasOwnProperty(n) && (t[n] = e[n]);\n    })(e, n);\n};\nfunction e(e, n) {\n    function r() {\n        this.constructor = e;\n    }\n    t(e, n), e.prototype = null === n ? Object.create(n) : (r.prototype = n.prototype, new r);\n}\nfunction n(t, e, n, r) {\n    return new (n || (n = Promise))(function(o, a) {\n        function i(t) {\n            try {\n                u(r.next(t));\n            } catch (t) {\n                a(t);\n            }\n        }\n        function s(t) {\n            try {\n                u(r.throw(t));\n            } catch (t) {\n                a(t);\n            }\n        }\n        function u(t) {\n            t.done ? o(t.value) : new n(function(e) {\n                e(t.value);\n            }).then(i, s);\n        }\n        u((r = r.apply(t, e || [])).next());\n    });\n}\nfunction r(t, e) {\n    var n, r, o, a, i = {\n        label: 0,\n        sent: function() {\n            if (1 & o[0]) throw o[1];\n            return o[1];\n        },\n        trys: [],\n        ops: []\n    };\n    return a = {\n        next: s(0),\n        throw: s(1),\n        return: s(2)\n    }, \"function\" == typeof Symbol && (a[Symbol.iterator] = function() {\n        return this;\n    }), a;\n    function s(a) {\n        return function(s) {\n            return function(a) {\n                if (n) throw new TypeError(\"Generator is already executing.\");\n                for(; i;)try {\n                    if (n = 1, r && (o = 2 & a[0] ? r.return : a[0] ? r.throw || ((o = r.return) && o.call(r), 0) : r.next) && !(o = o.call(r, a[1])).done) return o;\n                    switch(r = 0, o && (a = [\n                        2 & a[0],\n                        o.value\n                    ]), a[0]){\n                        case 0:\n                        case 1:\n                            o = a;\n                            break;\n                        case 4:\n                            return i.label++, {\n                                value: a[1],\n                                done: !1\n                            };\n                        case 5:\n                            i.label++, r = a[1], a = [\n                                0\n                            ];\n                            continue;\n                        case 7:\n                            a = i.ops.pop(), i.trys.pop();\n                            continue;\n                        default:\n                            if (!(o = (o = i.trys).length > 0 && o[o.length - 1]) && (6 === a[0] || 2 === a[0])) {\n                                i = 0;\n                                continue;\n                            }\n                            if (3 === a[0] && (!o || a[1] > o[0] && a[1] < o[3])) {\n                                i.label = a[1];\n                                break;\n                            }\n                            if (6 === a[0] && i.label < o[1]) {\n                                i.label = o[1], o = a;\n                                break;\n                            }\n                            if (o && i.label < o[2]) {\n                                i.label = o[2], i.ops.push(a);\n                                break;\n                            }\n                            o[2] && i.ops.pop(), i.trys.pop();\n                            continue;\n                    }\n                    a = e.call(t, i);\n                } catch (t) {\n                    a = [\n                        6,\n                        t\n                    ], r = 0;\n                } finally{\n                    n = o = 0;\n                }\n                if (5 & a[0]) throw a[1];\n                return {\n                    value: a[0] ? a[1] : void 0,\n                    done: !0\n                };\n            }([\n                a,\n                s\n            ]);\n        };\n    }\n}\nvar o = function() {\n    function t(t) {\n        this.global = t, this.flags = {}, this.flagRegistry = {}, this.urlFlags = {}, this.populateURLFlags();\n    }\n    return t.prototype.setPlatform = function(t, e) {\n        null != this.platform && console.warn(\"Platform \" + this.platformName + \" has already been set. Overwriting the platform with \" + e + \".\"), this.platformName = t, this.platform = e;\n    }, t.prototype.registerFlag = function(t, e, n) {\n        if (this.flagRegistry[t] = {\n            evaluationFn: e,\n            setHook: n\n        }, null != this.urlFlags[t]) {\n            var r = this.urlFlags[t];\n            console.warn(\"Setting feature override from URL \" + t + \": \" + r + \".\"), this.set(t, r);\n        }\n    }, t.prototype.get = function(t) {\n        return t in this.flags ? this.flags[t] : (this.flags[t] = this.evaluateFlag(t), this.flags[t]);\n    }, t.prototype.getNumber = function(t) {\n        return this.get(t);\n    }, t.prototype.getBool = function(t) {\n        return this.get(t);\n    }, t.prototype.getFlags = function() {\n        return this.flags;\n    }, Object.defineProperty(t.prototype, \"features\", {\n        get: function() {\n            return this.flags;\n        },\n        enumerable: !0,\n        configurable: !0\n    }), t.prototype.set = function(t, e) {\n        if (null == this.flagRegistry[t]) throw new Error(\"Cannot set flag \" + t + \" as it has not been registered.\");\n        this.flags[t] = e, null != this.flagRegistry[t].setHook && this.flagRegistry[t].setHook(e);\n    }, t.prototype.evaluateFlag = function(t) {\n        if (null == this.flagRegistry[t]) throw new Error(\"Cannot evaluate flag '\" + t + \"': no evaluation function found.\");\n        return this.flagRegistry[t].evaluationFn();\n    }, t.prototype.setFlags = function(t) {\n        this.flags = Object.assign({}, t);\n    }, t.prototype.reset = function() {\n        this.flags = {}, this.urlFlags = {}, this.populateURLFlags();\n    }, t.prototype.populateURLFlags = function() {\n        var t = this;\n        if (void 0 !== this.global && void 0 !== this.global.location && void 0 !== this.global.location.search) {\n            var e, n, r = (e = this.global.location.search, n = {}, e.replace(/[?&]([^=?&]+)(?:=([^&]*))?/g, function(t) {\n                for(var e = [], r = 1; r < arguments.length; r++)e[r - 1] = arguments[r];\n                return a(n, e[0], e[1]), e.join(\"=\");\n            }), n);\n            if (\"tfjsflags\" in r) r.tfjsflags.split(\",\").forEach(function(e) {\n                var n = e.split(\":\"), r = n[0], o = n[1];\n                t.urlFlags[r] = function(t, e) {\n                    if (\"true\" === (e = e.toLowerCase()) || \"false\" === e) return \"true\" === e;\n                    if (\"\" + +e === e) return +e;\n                    throw new Error(\"Could not parse value flag value \" + e + \" for flag \" + t + \".\");\n                }(r, o);\n            });\n        }\n    }, t;\n}();\nfunction a(t, e, n) {\n    t[decodeURIComponent(e)] = decodeURIComponent(n || \"\");\n}\nfunction i() {\n    return s;\n}\nvar s = null;\nvar u = new Map, c = new Map;\nfunction l(t, e) {\n    var n = g(t, e);\n    return u.get(n);\n}\nfunction h(t) {\n    return c.get(t);\n}\nfunction f(t) {\n    for(var e = u.entries(), n = [];;){\n        var r = e.next(), o = r.done, a = r.value;\n        if (o) break;\n        var i = a[0], s = a[1];\n        i.split(\"_\")[0] === t && n.push(s);\n    }\n    return n;\n}\nfunction d(t) {\n    var e = t.kernelName, n = t.backendName, r = g(e, n);\n    if (u.has(r)) throw new Error(\"The kernel '\" + e + \"' for backend '\" + n + \"' is already registered\");\n    u.set(r, t);\n}\nfunction p(t) {\n    var e = t.kernelName;\n    c.has(e) && console.warn(\"Overriding the gradient for '\" + e + \"'\"), c.set(e, t);\n}\nfunction v(t, e) {\n    var n = g(t, e);\n    if (!u.has(n)) throw new Error(\"The kernel '\" + t + \"' for backend '\" + e + \"' is not registered\");\n    u.delete(n);\n}\nfunction m(t) {\n    if (!c.has(t)) throw new Error(\"The gradient '\" + t + \"' for backend is not registered\");\n    c.delete(t);\n}\nfunction g(t, e) {\n    return e + \"_\" + t;\n}\nfunction y(t) {\n    for(var e = t.length, n = 0, r = 0; e > 0;)r = Math.random() * e | 0, n = t[--e], t[e] = t[r], t[r] = n;\n}\nfunction x(t, e, n) {\n    return Math.max(t, Math.min(e, n));\n}\nfunction b(t) {\n    return t % 2 == 0 ? t : t + 1;\n}\nfunction w(t) {\n    for(var e = 0, n = 0; n < t.length; n++)e += t[n];\n    return e;\n}\nfunction C(t, e) {\n    if (!t) throw new Error(\"string\" == typeof e ? e : e());\n}\nfunction E(t, e, n) {\n    void 0 === n && (n = \"\"), C(S(t, e), function() {\n        return n + \" Shapes \" + t + \" and \" + e + \" must match\";\n    });\n}\nfunction R(t) {\n    C(null != t, function() {\n        return \"The input to the tensor constructor must be a non-null value.\";\n    });\n}\nfunction I(t, e, n) {\n    if (void 0 === e && (e = []), void 0 === n && (n = !1), null == e && (e = []), Array.isArray(t) || V(t) && !n) for(var r = 0; r < t.length; ++r)I(t[r], e, n);\n    else e.push(t);\n    return e;\n}\nfunction k(t) {\n    if (0 === t.length) return 1;\n    for(var e = t[0], n = 1; n < t.length; n++)e *= t[n];\n    return e;\n}\nfunction S(t, e) {\n    if (t === e) return !0;\n    if (null == t || null == e) return !1;\n    if (t.length !== e.length) return !1;\n    for(var n = 0; n < t.length; n++)if (t[n] !== e[n]) return !1;\n    return !0;\n}\nfunction A(t) {\n    return t % 1 == 0;\n}\nfunction D(t) {\n    if (null != Math.tanh) return Math.tanh(t);\n    if (t === 1 / 0) return 1;\n    if (t === -1 / 0) return -1;\n    var e = Math.exp(2 * t);\n    return (e - 1) / (e + 1);\n}\nfunction T(t) {\n    var e = Math.ceil(Math.sqrt(t));\n    return [\n        e,\n        Math.ceil(t / e)\n    ];\n}\nfunction N(t, e) {\n    return e <= t.length ? t : t + \" \".repeat(e - t.length);\n}\nfunction F(t, e, n) {\n    return void 0 === e && (e = function(t) {\n        return 0;\n    }), new Promise(function(r, o) {\n        var a = 0, i = function() {\n            if (t()) r();\n            else {\n                a++;\n                var s = e(a);\n                null != n && a >= n ? o() : setTimeout(i, s);\n            }\n        };\n        i();\n    });\n}\nfunction _(t, e) {\n    for(var n = 1, r = -1, o = 0; o < t.length; ++o)if (t[o] >= 0) n *= t[o];\n    else if (-1 === t[o]) {\n        if (-1 !== r) throw Error(\"Shapes can only have 1 implicit size. Found -1 at dim \" + r + \" and dim \" + o);\n        r = o;\n    } else if (t[o] < 0) throw Error(\"Shapes can not be < 0. Found \" + t[o] + \" at dim \" + o);\n    if (-1 === r) {\n        if (e > 0 && e !== n) throw Error(\"Size(\" + e + \") must match the product of shape \" + t);\n        return t;\n    }\n    if (0 === n) throw Error(\"Cannot infer the missing size in [\" + t + \"] when there are 0 elements\");\n    if (e % n != 0) throw Error(\"The implicit shape can't be a fractional number. Got \" + e + \" / \" + n);\n    var a = t.slice();\n    return a[r] = e / n, a;\n}\nfunction O(t, e) {\n    var n = e.length;\n    return C((t = null == t ? e.map(function(t, e) {\n        return e;\n    }) : [].concat(t)).every(function(t) {\n        return t >= -n && t < n;\n    }), function() {\n        return \"All values in axis param must be in range [-\" + n + \", \" + n + \") but got axis \" + t;\n    }), C(t.every(function(t) {\n        return A(t);\n    }), function() {\n        return \"All values in axis param must be integers but got axis \" + t;\n    }), t.map(function(t) {\n        return t < 0 ? n + t : t;\n    });\n}\nfunction M(t, e) {\n    for(var n = [], r = [], o = null != e && Array.isArray(e) && 0 === e.length, a = null == e || o ? null : O(e, t).sort(), i = 0, s = 0; s < t.length; ++s){\n        if (null != a) {\n            if (a[i] === s && 1 !== t[s]) throw new Error(\"Can't squeeze axis \" + s + \" since its dim '\" + t[s] + \"' is not 1\");\n            (null == a[i] || a[i] > s) && 1 === t[s] && (n.push(t[s]), r.push(s)), a[i] <= s && i++;\n        }\n        1 !== t[s] && (n.push(t[s]), r.push(s));\n    }\n    return {\n        newShape: n,\n        keptDims: r\n    };\n}\nfunction B(t, e) {\n    var n = null;\n    if (null == t || \"float32\" === t) n = new Float32Array(e);\n    else if (\"int32\" === t) n = new Int32Array(e);\n    else {\n        if (\"bool\" !== t) throw new Error(\"Unknown data type \" + t);\n        n = new Uint8Array(e);\n    }\n    return n;\n}\nfunction P(t, e) {\n    var n = null;\n    if (null == t || \"float32\" === t) n = new Float32Array(e);\n    else if (\"int32\" === t) n = new Int32Array(e);\n    else if (\"bool\" === t) n = new Uint8Array(e);\n    else {\n        if (\"string\" !== t) throw new Error(\"Unknown data type \" + t);\n        n = new Array(e);\n    }\n    return n;\n}\nfunction L(t, e) {\n    for(var n = 0; n < t.length; n++){\n        var r = t[n];\n        if (isNaN(r) || !isFinite(r)) throw Error(\"A tensor of type \" + e + \" being uploaded contains \" + r + \".\");\n    }\n}\nfunction W(t) {\n    return \"bool\" === t || \"complex64\" === t || \"float32\" === t || \"int32\" === t || \"string\" === t;\n}\nfunction U(t, e) {\n    return \"complex64\" !== e && (\"float32\" !== e || \"complex64\" === t) && (\"int32\" !== e || \"float32\" === t || \"complex64\" === t) && (\"bool\" !== e || \"bool\" !== t);\n}\nfunction V(t) {\n    return t instanceof Float32Array || t instanceof Int32Array || t instanceof Uint8Array;\n}\nfunction z(t) {\n    if (\"float32\" === t || \"int32\" === t) return 4;\n    if (\"complex64\" === t) return 8;\n    if (\"bool\" === t) return 1;\n    throw new Error(\"Unknown dtype \" + t);\n}\nfunction G(t) {\n    if (null == t) return 0;\n    var e = 0;\n    return t.forEach(function(t) {\n        return e += t.length;\n    }), e;\n}\nfunction H(t) {\n    return \"string\" == typeof t || t instanceof String;\n}\nfunction q(t) {\n    return \"boolean\" == typeof t;\n}\nfunction K(t) {\n    return \"number\" == typeof t;\n}\nfunction j(t) {\n    return Array.isArray(t) ? j(t[0]) : t instanceof Float32Array ? \"float32\" : t instanceof Int32Array || t instanceof Uint8Array ? \"int32\" : K(t) ? \"float32\" : H(t) ? \"string\" : q(t) ? \"bool\" : \"float32\";\n}\nfunction X(t) {\n    return !!(t && t.constructor && t.call && t.apply);\n}\nfunction Y(t, e) {\n    for(var n = e; n < t; ++n)if (t % n == 0) return n;\n    return t;\n}\nfunction $(t) {\n    var e = t.length;\n    if (e < 2) return [];\n    var n = new Array(e - 1);\n    n[e - 2] = t[e - 1];\n    for(var r = e - 3; r >= 0; --r)n[r] = n[r + 1] * t[r + 1];\n    return n;\n}\nfunction Q(t, e, n) {\n    if (\"string\" === e) throw new Error(\"Cannot convert a string[] to a TypedArray\");\n    if (Array.isArray(t) && (t = I(t)), n && L(t, e), function(t, e) {\n        return t instanceof Float32Array && \"float32\" === e || t instanceof Int32Array && \"int32\" === e || t instanceof Uint8Array && \"bool\" === e;\n    }(t, e)) return t;\n    if (null == e || \"float32\" === e || \"complex64\" === e) return new Float32Array(t);\n    if (\"int32\" === e) return new Int32Array(t);\n    if (\"bool\" === e) {\n        for(var r = new Uint8Array(t.length), o = 0; o < r.length; ++o)0 !== Math.round(t[o]) && (r[o] = 1);\n        return r;\n    }\n    throw new Error(\"Unknown data type \" + e);\n}\nfunction J(t, e) {\n    if (0 === t.length) return e[0];\n    var n = t.reduce(function(t, e) {\n        return t * e;\n    });\n    if (0 === n) return [];\n    if (n !== e.length) throw new Error(\"[\" + t + \"] does not match the input size.\");\n    return function t(e, n, r) {\n        var o = new Array;\n        if (1 === n.length) for(var a = n[0], i = 0; i < a; i++)o[i] = r[e + i];\n        else {\n            a = n[0];\n            var s = n.slice(1), u = s.reduce(function(t, e) {\n                return t * e;\n            });\n            for(i = 0; i < a; i++)o[i] = t(e + i * u, s, r);\n        }\n        return o;\n    }(0, t, e);\n}\nfunction Z(t, e) {\n    for(var n = tt(t, e), r = 0; r < n.length; r++)n[r] = 1;\n    return n;\n}\nfunction tt(t, e) {\n    if (null == e || \"float32\" === e || \"complex64\" === e) return new Float32Array(t);\n    if (\"int32\" === e) return new Int32Array(t);\n    if (\"bool\" === e) return new Uint8Array(t);\n    throw new Error(\"Unknown data type \" + e);\n}\nfunction et() {\n    return i().platform.now();\n}\nfunction nt(t) {\n    t.forEach(function(e) {\n        C(Number.isInteger(e) && e >= 0, function() {\n            return \"Tensor must have a shape comprised of positive integers but got shape [\" + t + \"].\";\n        });\n    });\n}\nfunction rt(t, e) {\n    return void 0 === e && (e = \"utf-8\"), e = e || \"utf-8\", i().platform.encode(t, e);\n}\nfunction ot(t, e) {\n    return void 0 === e && (e = \"utf-8\"), e = e || \"utf-8\", i().platform.decode(t, e);\n}\nfunction at(t, e, n) {\n    if (0 === e) return 0;\n    if (1 === e) return t[0];\n    for(var r = t[t.length - 1], o = 0; o < t.length - 1; ++o)r += n[o] * t[o];\n    return r;\n}\nfunction it(t, e, n) {\n    if (0 === e) return [];\n    if (1 === e) return [\n        t\n    ];\n    for(var r = new Array(e), o = 0; o < r.length - 1; ++o)r[o] = Math.floor(t / n[o]), t -= r[o] * n[o];\n    return r[r.length - 1] = t, r;\n}\nvar st = Object.freeze({\n    shuffle: y,\n    clamp: x,\n    nearestLargerEven: b,\n    sum: w,\n    randUniform: function(t, e) {\n        var n = Math.random();\n        return e * n + (1 - n) * t;\n    },\n    distSquared: function(t, e) {\n        for(var n = 0, r = 0; r < t.length; r++){\n            var o = Number(t[r]) - Number(e[r]);\n            n += o * o;\n        }\n        return n;\n    },\n    assert: C,\n    assertShapesMatch: E,\n    assertNonNull: R,\n    flatten: I,\n    sizeFromShape: k,\n    isScalarShape: function(t) {\n        return 0 === t.length;\n    },\n    arraysEqual: S,\n    isInt: A,\n    tanh: D,\n    sizeToSquarishShape: T,\n    createShuffledIndices: function(t) {\n        for(var e = new Uint32Array(t), n = 0; n < t; ++n)e[n] = n;\n        return y(e), e;\n    },\n    rightPad: N,\n    repeatedTry: F,\n    inferFromImplicitShape: _,\n    parseAxisParam: O,\n    squeezeShape: M,\n    getTypedArrayFromDType: B,\n    getArrayFromDType: P,\n    checkConversionForErrors: L,\n    isValidDtype: W,\n    hasEncodingLoss: U,\n    isTypedArray: V,\n    bytesPerElement: z,\n    bytesFromStringArray: G,\n    isString: H,\n    isBoolean: q,\n    isNumber: K,\n    inferDtype: j,\n    isFunction: X,\n    nearestDivisor: Y,\n    computeStrides: $,\n    toTypedArray: Q,\n    toNestedArray: J,\n    makeOnesTypedArray: Z,\n    makeZerosTypedArray: tt,\n    now: et,\n    assertNonNegativeIntegerDimensions: nt,\n    fetch: function(t, e) {\n        return i().platform.fetch(t, e);\n    },\n    encodeString: rt,\n    decodeString: ot,\n    locToIndex: at,\n    indexToLoc: it\n}), ut = function() {\n    function t(t, e) {\n        this.backendTimer = t, this.logger = e, null == e && (this.logger = new ct);\n    }\n    return t.prototype.profileKernel = function(t, e, n) {\n        var r, o = this, a = this.backendTimer.time(function() {\n            r = n();\n        });\n        return r.forEach(function(n) {\n            n.data().then(function(r) {\n                !function(t, e, n) {\n                    if (\"float32\" !== e) return !1;\n                    for(var r = 0; r < t.length; r++){\n                        var o = t[r];\n                        if (isNaN(o) || !isFinite(o)) return console.warn(\"Found \" + o + \" in the result of '\" + n + \"'\"), !0;\n                    }\n                }(r, n.dtype, t), a.then(function(a) {\n                    var i = \"\";\n                    null != a.getExtraProfileInfo && (i = a.getExtraProfileInfo()), o.logger.logKernelProfile(t, n, r, a.kernelMs, e, i);\n                });\n            });\n        }), r;\n    }, t;\n}();\nvar ct = function() {\n    function t() {}\n    return t.prototype.logKernelProfile = function(t, e, n, r, o, a) {\n        var i = \"number\" == typeof r ? N(r + \"ms\", 9) : r.error, s = N(t, 25), u = e.rank, c = e.size, l = N(e.shape.toString(), 14), h = \"\";\n        for(var f in o){\n            var d = o[f].shape || e.shape, p = d.length;\n            h += f + \": \" + p + \"D \" + (p > 0 ? d : \"\") + \" \";\n        }\n        console.log(\"%c\" + s + \"\t%c\" + i + \"\t%c\" + u + \"D \" + l + \"\t%c\" + c + \"\t%c\" + h + \"\t%c\" + a, \"font-weight:bold\", \"color:red\", \"color:blue\", \"color: orange\", \"color: green\", \"color: steelblue\");\n    }, t;\n}();\nvar lt = 20, ht = 3, ft = 7;\nfunction dt(t, e, n, r) {\n    var o = $(e), a = function(t, e, n, r) {\n        var o = k(e), a = r[r.length - 1], i = new Array(a).fill(0), s = e.length, u = \"complex64\" === n ? mt(t) : t;\n        if (s > 1) for(var c = 0; c < o / a; c++)for(var l = c * a, h = 0; h < a; h++)i[h] = Math.max(i[h], pt(u[l + h], 0, n).length);\n        return i;\n    }(t, e, n, o), i = e.length, s = function t(e, n, r, o, a, i) {\n        void 0 === i && (i = !0);\n        var s = \"complex64\" === r ? 2 : 1, u = n[0], c = n.length;\n        if (0 === c) {\n            return \"complex64\" === r ? [\n                pt(mt(e)[0], 0, r)\n            ] : \"bool\" === r ? [\n                vt(e[0])\n            ] : [\n                e[0].toString()\n            ];\n        }\n        if (1 === c) {\n            if (u > lt) {\n                var l = ht * s, h = Array.from(e.slice(0, l)), f = Array.from(e.slice((u - ht) * s, u * s));\n                return \"complex64\" === r && (h = mt(h), f = mt(f)), [\n                    \"[\" + h.map(function(t, e) {\n                        return pt(t, a[e], r);\n                    }).join(\", \") + \", ..., \" + f.map(function(t, e) {\n                        return pt(t, a[u - ht + e], r);\n                    }).join(\", \") + \"]\"\n                ];\n            }\n            return [\n                \"[\" + (\"complex64\" === r ? mt(e) : Array.from(e)).map(function(t, e) {\n                    return pt(t, a[e], r);\n                }).join(\", \") + \"]\"\n            ];\n        }\n        var d = n.slice(1), p = o.slice(1), v = o[0] * s, m = [];\n        if (u > lt) {\n            for(var g = 0; g < ht; g++){\n                var y = (x = g * v) + v;\n                m.push.apply(m, t(e.slice(x, y), d, r, p, a, !1));\n            }\n            m.push(\"...\");\n            for(g = u - ht; g < u; g++){\n                y = (x = g * v) + v;\n                m.push.apply(m, t(e.slice(x, y), d, r, p, a, g === u - 1));\n            }\n        } else for(g = 0; g < u; g++){\n            var x;\n            y = (x = g * v) + v;\n            m.push.apply(m, t(e.slice(x, y), d, r, p, a, g === u - 1));\n        }\n        var b = 2 === c ? \",\" : \"\";\n        m[0] = \"[\" + m[0] + b;\n        for(g = 1; g < m.length - 1; g++)m[g] = \" \" + m[g] + b;\n        var w = \",\\n\";\n        for(g = 2; g < c; g++)w += \"\\n\";\n        return m[m.length - 1] = \" \" + m[m.length - 1] + \"]\" + (i ? \"\" : w), m;\n    }(t, e, n, o, a), u = [\n        \"Tensor\"\n    ];\n    return r && (u.push(\"  dtype: \" + n), u.push(\"  rank: \" + i), u.push(\"  shape: [\" + e + \"]\"), u.push(\"  values:\")), u.push(s.map(function(t) {\n        return \"    \" + t;\n    }).join(\"\\n\")), u.join(\"\\n\");\n}\nfunction pt(t, e, n) {\n    return N(Array.isArray(t) ? parseFloat(t[0].toFixed(ft)) + \" + \" + parseFloat(t[1].toFixed(ft)) + \"j\" : H(t) ? \"'\" + t + \"'\" : \"bool\" === n ? vt(t) : parseFloat(t.toFixed(ft)).toString(), e);\n}\nfunction vt(t) {\n    return 0 === t ? \"false\" : \"true\";\n}\nfunction mt(t) {\n    for(var e = [], n = 0; n < t.length; n += 2)e.push([\n        t[n],\n        t[n + 1]\n    ]);\n    return e;\n}\nvar gt = function() {\n    function t(t, e, n) {\n        var r = this;\n        if (this.dtype = e, this.shape = t.slice(), this.size = k(t), null != n) {\n            var o = n.length;\n            C(o === this.size, function() {\n                return \"Length of values '\" + o + \"' does not match the size inferred by the shape '\" + r.size + \"'.\";\n            });\n        }\n        if (\"complex64\" === e) throw new Error(\"complex64 dtype TensorBuffers are not supported. Please create a TensorBuffer for the real and imaginary parts separately and call tf.complex(real, imag).\");\n        this.values = n || P(e, this.size), this.strides = $(t);\n    }\n    return t.prototype.set = function(t) {\n        for(var e = this, n = [], r = 1; r < arguments.length; r++)n[r - 1] = arguments[r];\n        0 === n.length && (n = [\n            0\n        ]), C(n.length === this.rank, function() {\n            return \"The number of provided coordinates (\" + n.length + \") must match the rank (\" + e.rank + \")\";\n        });\n        var o = this.locToIndex(n);\n        this.values[o] = t;\n    }, t.prototype.get = function() {\n        for(var t = [], e = 0; e < arguments.length; e++)t[e] = arguments[e];\n        0 === t.length && (t = [\n            0\n        ]);\n        for(var n = 0, r = 0, o = t; r < o.length; r++){\n            var a = o[r];\n            if (a < 0 || a >= this.shape[n]) {\n                var i = \"Requested out of range element at \" + t + \".   Buffer shape=\" + this.shape;\n                throw new Error(i);\n            }\n            n++;\n        }\n        for(var s = t[t.length - 1], u = 0; u < t.length - 1; ++u)s += this.strides[u] * t[u];\n        return this.values[s];\n    }, t.prototype.locToIndex = function(t) {\n        if (0 === this.rank) return 0;\n        if (1 === this.rank) return t[0];\n        for(var e = t[t.length - 1], n = 0; n < t.length - 1; ++n)e += this.strides[n] * t[n];\n        return e;\n    }, t.prototype.indexToLoc = function(t) {\n        if (0 === this.rank) return [];\n        if (1 === this.rank) return [\n            t\n        ];\n        for(var e = new Array(this.shape.length), n = 0; n < e.length - 1; ++n)e[n] = Math.floor(t / this.strides[n]), t -= e[n] * this.strides[n];\n        return e[e.length - 1] = t, e;\n    }, Object.defineProperty(t.prototype, \"rank\", {\n        get: function() {\n            return this.shape.length;\n        },\n        enumerable: !0,\n        configurable: !0\n    }), t.prototype.toTensor = function() {\n        return yt().makeTensor(this.values, this.shape, this.dtype);\n    }, t;\n}(), yt = null, xt = null, bt = null;\nvar wt = function() {\n    function t(t, e, n, r) {\n        this.kept = !1, this.isDisposedInternal = !1, this.shape = t.slice(), this.dtype = e || \"float32\", this.size = k(t), this.strides = $(t), this.dataId = n, this.id = r, this.rankType = this.rank < 5 ? this.rank.toString() : \"higher\";\n    }\n    return t.prototype.flatten = function() {\n        return this.throwIfDisposed(), this.as1D();\n    }, t.prototype.asScalar = function() {\n        return this.throwIfDisposed(), C(1 === this.size, function() {\n            return \"The array must have only 1 element.\";\n        }), this.reshape([]);\n    }, t.prototype.as1D = function() {\n        return this.throwIfDisposed(), this.reshape([\n            this.size\n        ]);\n    }, t.prototype.as2D = function(t, e) {\n        return this.throwIfDisposed(), this.reshape([\n            t,\n            e\n        ]);\n    }, t.prototype.as3D = function(t, e, n) {\n        return this.throwIfDisposed(), this.reshape([\n            t,\n            e,\n            n\n        ]);\n    }, t.prototype.as4D = function(t, e, n, r) {\n        return this.throwIfDisposed(), this.reshape([\n            t,\n            e,\n            n,\n            r\n        ]);\n    }, t.prototype.as5D = function(t, e, n, r, o) {\n        return this.throwIfDisposed(), this.reshape([\n            t,\n            e,\n            n,\n            r,\n            o\n        ]);\n    }, t.prototype.asType = function(t) {\n        return this.throwIfDisposed(), xt.cast(this, t);\n    }, Object.defineProperty(t.prototype, \"rank\", {\n        get: function() {\n            return this.shape.length;\n        },\n        enumerable: !0,\n        configurable: !0\n    }), t.prototype.buffer = function() {\n        return n(this, void 0, void 0, function() {\n            var t;\n            return r(this, function(e) {\n                switch(e.label){\n                    case 0:\n                        return [\n                            4,\n                            this.data()\n                        ];\n                    case 1:\n                        return t = e.sent(), [\n                            2,\n                            xt.buffer(this.shape, this.dtype, t)\n                        ];\n                }\n            });\n        });\n    }, t.prototype.bufferSync = function() {\n        return xt.buffer(this.shape, this.dtype, this.dataSync());\n    }, t.prototype.array = function() {\n        return n(this, void 0, void 0, function() {\n            var t;\n            return r(this, function(e) {\n                switch(e.label){\n                    case 0:\n                        return [\n                            4,\n                            this.data()\n                        ];\n                    case 1:\n                        return t = e.sent(), [\n                            2,\n                            J(this.shape, t)\n                        ];\n                }\n            });\n        });\n    }, t.prototype.arraySync = function() {\n        return J(this.shape, this.dataSync());\n    }, t.prototype.data = function() {\n        return n(this, void 0, void 0, function() {\n            var t, e;\n            return r(this, function(n) {\n                switch(n.label){\n                    case 0:\n                        return this.throwIfDisposed(), t = yt().read(this.dataId), \"string\" !== this.dtype ? [\n                            3,\n                            2\n                        ] : [\n                            4,\n                            t\n                        ];\n                    case 1:\n                        e = n.sent();\n                        try {\n                            return [\n                                2,\n                                e.map(function(t) {\n                                    return ot(t);\n                                })\n                            ];\n                        } catch (t) {\n                            throw new Error(\"Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().\");\n                        }\n                        n.label = 2;\n                    case 2:\n                        return [\n                            2,\n                            t\n                        ];\n                }\n            });\n        });\n    }, t.prototype.dataSync = function() {\n        this.throwIfDisposed();\n        var t = yt().readSync(this.dataId);\n        if (\"string\" === this.dtype) try {\n            return t.map(function(t) {\n                return ot(t);\n            });\n        } catch (t) {\n            throw new Error(\"Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().\");\n        }\n        return t;\n    }, t.prototype.bytes = function() {\n        return n(this, void 0, void 0, function() {\n            var t;\n            return r(this, function(e) {\n                switch(e.label){\n                    case 0:\n                        return this.throwIfDisposed(), [\n                            4,\n                            yt().read(this.dataId)\n                        ];\n                    case 1:\n                        return t = e.sent(), \"string\" === this.dtype ? [\n                            2,\n                            t\n                        ] : [\n                            2,\n                            new Uint8Array(t.buffer)\n                        ];\n                }\n            });\n        });\n    }, t.prototype.dispose = function() {\n        this.isDisposed || (yt().disposeTensor(this), this.isDisposedInternal = !0);\n    }, Object.defineProperty(t.prototype, \"isDisposed\", {\n        get: function() {\n            return this.isDisposedInternal;\n        },\n        enumerable: !0,\n        configurable: !0\n    }), t.prototype.throwIfDisposed = function() {\n        if (this.isDisposed) throw new Error(\"Tensor is disposed.\");\n    }, t.prototype.toFloat = function() {\n        return this.asType(\"float32\");\n    }, t.prototype.toInt = function() {\n        return this.asType(\"int32\");\n    }, t.prototype.toBool = function() {\n        return this.asType(\"bool\");\n    }, t.prototype.print = function(t) {\n        return void 0 === t && (t = !1), xt.print(this, t);\n    }, t.prototype.reshape = function(t) {\n        return this.throwIfDisposed(), xt.reshape(this, t);\n    }, t.prototype.reshapeAs = function(t) {\n        return this.throwIfDisposed(), this.reshape(t.shape);\n    }, t.prototype.expandDims = function(t) {\n        return void 0 === t && (t = 0), xt.expandDims(this, t);\n    }, t.prototype.cumsum = function(t, e, n) {\n        return void 0 === t && (t = 0), void 0 === e && (e = !1), void 0 === n && (n = !1), xt.cumsum(this, t, e, n);\n    }, t.prototype.squeeze = function(t) {\n        return this.throwIfDisposed(), xt.squeeze(this, t);\n    }, t.prototype.clone = function() {\n        return this.throwIfDisposed(), xt.clone(this);\n    }, t.prototype.oneHot = function(t, e, n) {\n        return this.throwIfDisposed(), xt.oneHot(this, t, e, n);\n    }, t.prototype.toString = function(t) {\n        return void 0 === t && (t = !1), dt(this.dataSync(), this.shape, this.dtype, t);\n    }, t.prototype.tile = function(t) {\n        return this.throwIfDisposed(), xt.tile(this, t);\n    }, t.prototype.gather = function(t, e) {\n        return void 0 === e && (e = 0), this.throwIfDisposed(), xt.gather(this, t, e);\n    }, t.prototype.matMul = function(t, e, n) {\n        return void 0 === e && (e = !1), void 0 === n && (n = !1), this.throwIfDisposed(), xt.matMul(this, t, e, n);\n    }, t.prototype.dot = function(t) {\n        return this.throwIfDisposed(), xt.dot(this, t);\n    }, t.prototype.norm = function(t, e, n) {\n        return void 0 === t && (t = \"euclidean\"), void 0 === e && (e = null), void 0 === n && (n = !1), this.throwIfDisposed(), xt.norm(this, t, e, n);\n    }, t.prototype.slice = function(t, e) {\n        return this.throwIfDisposed(), xt.slice(this, t, e);\n    }, t.prototype.reverse = function(t) {\n        return this.throwIfDisposed(), xt.reverse(this, t);\n    }, t.prototype.concat = function(e, n) {\n        return void 0 === n && (n = 0), this.throwIfDisposed(), e instanceof t && (e = [\n            e\n        ]), xt.concat([\n            this\n        ].concat(e), n);\n    }, t.prototype.split = function(t, e) {\n        return void 0 === e && (e = 0), this.throwIfDisposed(), xt.split(this, t, e);\n    }, t.prototype.stack = function(t, e) {\n        return void 0 === e && (e = 0), xt.stack([\n            this,\n            t\n        ], e);\n    }, t.prototype.unstack = function(t) {\n        return void 0 === t && (t = 0), xt.unstack(this, t);\n    }, t.prototype.pad = function(t, e) {\n        return void 0 === e && (e = 0), xt.pad(this, t, e);\n    }, t.prototype.batchNormalization = function(t, e, n, r, o) {\n        return void 0 === n && (n = .001), bt(\"tf.batchNormalization() is going away. Use tf.batchNorm() instead, and note the positional argument change of scale, offset, and varianceEpsilon\"), this.batchNorm(t, e, o, r, n);\n    }, t.prototype.batchNorm = function(t, e, n, r, o) {\n        return void 0 === o && (o = .001), this.throwIfDisposed(), xt.batchNorm(this, t, e, n, r, o);\n    }, t.prototype.all = function(t, e) {\n        return void 0 === t && (t = null), void 0 === e && (e = !1), this.throwIfDisposed(), xt.all(this, t, e);\n    }, t.prototype.any = function(t, e) {\n        return void 0 === t && (t = null), void 0 === e && (e = !1), this.throwIfDisposed(), xt.any(this, t, e);\n    }, t.prototype.logSumExp = function(t, e) {\n        return void 0 === t && (t = null), void 0 === e && (e = !1), this.throwIfDisposed(), xt.logSumExp(this, t, e);\n    }, t.prototype.sum = function(t, e) {\n        return void 0 === t && (t = null), void 0 === e && (e = !1), this.throwIfDisposed(), xt.sum(this, t, e);\n    }, t.prototype.prod = function(t, e) {\n        return void 0 === t && (t = null), void 0 === e && (e = !1), this.throwIfDisposed(), xt.prod(this, t, e);\n    }, t.prototype.mean = function(t, e) {\n        return void 0 === t && (t = null), void 0 === e && (e = !1), this.throwIfDisposed(), xt.mean(this, t, e);\n    }, t.prototype.min = function(t, e) {\n        return void 0 === t && (t = null), void 0 === e && (e = !1), this.throwIfDisposed(), xt.min(this, t, e);\n    }, t.prototype.max = function(t, e) {\n        return void 0 === t && (t = null), void 0 === e && (e = !1), this.throwIfDisposed(), xt.max(this, t, e);\n    }, t.prototype.argMin = function(t) {\n        return void 0 === t && (t = null), this.throwIfDisposed(), xt.argMin(this, t);\n    }, t.prototype.argMax = function(t) {\n        return void 0 === t && (t = null), this.throwIfDisposed(), xt.argMax(this, t);\n    }, t.prototype.cast = function(t) {\n        return this.throwIfDisposed(), xt.cast(this, t);\n    }, t.prototype.add = function(t) {\n        return this.throwIfDisposed(), xt.add(this, t);\n    }, t.prototype.addStrict = function(t) {\n        return this.throwIfDisposed(), xt.addStrict(this, t);\n    }, t.prototype.atan2 = function(t) {\n        return this.throwIfDisposed(), xt.atan2(this, t);\n    }, t.prototype.sub = function(t) {\n        return this.throwIfDisposed(), xt.sub(this, t);\n    }, t.prototype.subStrict = function(t) {\n        return this.throwIfDisposed(), xt.subStrict(this, t);\n    }, t.prototype.pow = function(t) {\n        return this.throwIfDisposed(), xt.pow(this, t);\n    }, t.prototype.powStrict = function(t) {\n        return this.throwIfDisposed(), xt.powStrict(this, t);\n    }, t.prototype.mul = function(t) {\n        return this.throwIfDisposed(), xt.mul(this, t);\n    }, t.prototype.mulStrict = function(t) {\n        return this.throwIfDisposed(), xt.mulStrict(this, t);\n    }, t.prototype.div = function(t) {\n        return this.throwIfDisposed(), xt.div(this, t);\n    }, t.prototype.divNoNan = function(t) {\n        return this.throwIfDisposed(), xt.divNoNan(this, t);\n    }, t.prototype.floorDiv = function(t) {\n        return this.throwIfDisposed(), xt.floorDiv(this, t);\n    }, t.prototype.divStrict = function(t) {\n        return this.throwIfDisposed(), xt.divStrict(this, t);\n    }, t.prototype.minimum = function(t) {\n        return this.throwIfDisposed(), xt.minimum(this, t);\n    }, t.prototype.minimumStrict = function(t) {\n        return this.throwIfDisposed(), xt.minimumStrict(this, t);\n    }, t.prototype.maximum = function(t) {\n        return this.throwIfDisposed(), xt.maximum(this, t);\n    }, t.prototype.maximumStrict = function(t) {\n        return this.throwIfDisposed(), xt.maximumStrict(this, t);\n    }, t.prototype.mod = function(t) {\n        return this.throwIfDisposed(), xt.mod(this, t);\n    }, t.prototype.modStrict = function(t) {\n        return this.throwIfDisposed(), xt.modStrict(this, t);\n    }, t.prototype.squaredDifferenceStrict = function(t) {\n        return this.throwIfDisposed(), xt.squaredDifferenceStrict(this, t);\n    }, t.prototype.transpose = function(t) {\n        return this.throwIfDisposed(), xt.transpose(this, t);\n    }, t.prototype.notEqual = function(t) {\n        return this.throwIfDisposed(), xt.notEqual(this, t);\n    }, t.prototype.notEqualStrict = function(t) {\n        return this.throwIfDisposed(), xt.notEqualStrict(this, t);\n    }, t.prototype.less = function(t) {\n        return this.throwIfDisposed(), xt.less(this, t);\n    }, t.prototype.lessStrict = function(t) {\n        return this.throwIfDisposed(), xt.lessStrict(this, t);\n    }, t.prototype.equal = function(t) {\n        return this.throwIfDisposed(), xt.equal(this, t);\n    }, t.prototype.equalStrict = function(t) {\n        return this.throwIfDisposed(), xt.equalStrict(this, t);\n    }, t.prototype.lessEqual = function(t) {\n        return this.throwIfDisposed(), xt.lessEqual(this, t);\n    }, t.prototype.lessEqualStrict = function(t) {\n        return this.throwIfDisposed(), xt.lessEqualStrict(this, t);\n    }, t.prototype.greater = function(t) {\n        return this.throwIfDisposed(), xt.greater(this, t);\n    }, t.prototype.greaterStrict = function(t) {\n        return this.throwIfDisposed(), xt.greaterStrict(this, t);\n    }, t.prototype.greaterEqual = function(t) {\n        return this.throwIfDisposed(), xt.greaterEqual(this, t);\n    }, t.prototype.greaterEqualStrict = function(t) {\n        return this.throwIfDisposed(), xt.greaterEqualStrict(this, t);\n    }, t.prototype.logicalAnd = function(t) {\n        return this.throwIfDisposed(), xt.logicalAnd(this, t);\n    }, t.prototype.logicalOr = function(t) {\n        return this.throwIfDisposed(), xt.logicalOr(this, t);\n    }, t.prototype.logicalNot = function() {\n        return this.throwIfDisposed(), xt.logicalNot(this);\n    }, t.prototype.logicalXor = function(t) {\n        return this.throwIfDisposed(), xt.logicalXor(this, t);\n    }, t.prototype.where = function(t, e) {\n        return this.throwIfDisposed(), xt.where(t, this, e);\n    }, t.prototype.neg = function() {\n        return this.throwIfDisposed(), xt.neg(this);\n    }, t.prototype.ceil = function() {\n        return this.throwIfDisposed(), xt.ceil(this);\n    }, t.prototype.floor = function() {\n        return this.throwIfDisposed(), xt.floor(this);\n    }, t.prototype.sign = function() {\n        return this.throwIfDisposed(), xt.sign(this);\n    }, t.prototype.isNaN = function() {\n        return this.throwIfDisposed(), xt.isNaN(this);\n    }, t.prototype.isInf = function() {\n        return this.throwIfDisposed(), xt.isInf(this);\n    }, t.prototype.isFinite = function() {\n        return this.throwIfDisposed(), xt.isFinite(this);\n    }, t.prototype.exp = function() {\n        return this.throwIfDisposed(), xt.exp(this);\n    }, t.prototype.expm1 = function() {\n        return this.throwIfDisposed(), xt.expm1(this);\n    }, t.prototype.log = function() {\n        return this.throwIfDisposed(), xt.log(this);\n    }, t.prototype.log1p = function() {\n        return this.throwIfDisposed(), xt.log1p(this);\n    }, t.prototype.sqrt = function() {\n        return this.throwIfDisposed(), xt.sqrt(this);\n    }, t.prototype.rsqrt = function() {\n        return this.throwIfDisposed(), xt.rsqrt(this);\n    }, t.prototype.square = function() {\n        return this.throwIfDisposed(), xt.square(this);\n    }, t.prototype.reciprocal = function() {\n        return this.throwIfDisposed(), xt.reciprocal(this);\n    }, t.prototype.abs = function() {\n        return this.throwIfDisposed(), xt.abs(this);\n    }, t.prototype.clipByValue = function(t, e) {\n        return this.throwIfDisposed(), xt.clipByValue(this, t, e);\n    }, t.prototype.relu = function() {\n        return this.throwIfDisposed(), xt.relu(this);\n    }, t.prototype.relu6 = function() {\n        return this.throwIfDisposed(), xt.relu6(this);\n    }, t.prototype.elu = function() {\n        return this.throwIfDisposed(), xt.elu(this);\n    }, t.prototype.selu = function() {\n        return this.throwIfDisposed(), xt.selu(this);\n    }, t.prototype.leakyRelu = function(t) {\n        return void 0 === t && (t = .2), this.throwIfDisposed(), xt.leakyRelu(this, t);\n    }, t.prototype.prelu = function(t) {\n        return this.throwIfDisposed(), xt.prelu(this, t);\n    }, t.prototype.sigmoid = function() {\n        return this.throwIfDisposed(), xt.sigmoid(this);\n    }, t.prototype.logSigmoid = function() {\n        return this.throwIfDisposed(), xt.logSigmoid(this);\n    }, t.prototype.softplus = function() {\n        return this.throwIfDisposed(), xt.softplus(this);\n    }, t.prototype.zerosLike = function() {\n        return this.throwIfDisposed(), xt.zerosLike(this);\n    }, t.prototype.onesLike = function() {\n        return this.throwIfDisposed(), xt.onesLike(this);\n    }, t.prototype.sin = function() {\n        return this.throwIfDisposed(), xt.sin(this);\n    }, t.prototype.cos = function() {\n        return this.throwIfDisposed(), xt.cos(this);\n    }, t.prototype.tan = function() {\n        return this.throwIfDisposed(), xt.tan(this);\n    }, t.prototype.asin = function() {\n        return this.throwIfDisposed(), xt.asin(this);\n    }, t.prototype.acos = function() {\n        return this.throwIfDisposed(), xt.acos(this);\n    }, t.prototype.atan = function() {\n        return this.throwIfDisposed(), xt.atan(this);\n    }, t.prototype.sinh = function() {\n        return this.throwIfDisposed(), xt.sinh(this);\n    }, t.prototype.cosh = function() {\n        return this.throwIfDisposed(), xt.cosh(this);\n    }, t.prototype.tanh = function() {\n        return this.throwIfDisposed(), xt.tanh(this);\n    }, t.prototype.asinh = function() {\n        return this.throwIfDisposed(), xt.asinh(this);\n    }, t.prototype.acosh = function() {\n        return this.throwIfDisposed(), xt.acosh(this);\n    }, t.prototype.atanh = function() {\n        return this.throwIfDisposed(), xt.atanh(this);\n    }, t.prototype.erf = function() {\n        return this.throwIfDisposed(), xt.erf(this);\n    }, t.prototype.round = function() {\n        return this.throwIfDisposed(), xt.round(this);\n    }, t.prototype.step = function(t) {\n        return void 0 === t && (t = 0), this.throwIfDisposed(), xt.step(this, t);\n    }, t.prototype.softmax = function(t) {\n        return void 0 === t && (t = -1), this.throwIfDisposed(), xt.softmax(this, t);\n    }, t.prototype.logSoftmax = function(t) {\n        return void 0 === t && (t = -1), this.throwIfDisposed(), xt.logSoftmax(this, t);\n    }, t.prototype.resizeBilinear = function(t, e) {\n        return void 0 === e && (e = !1), this.throwIfDisposed(), xt.image.resizeBilinear(this, t, e);\n    }, t.prototype.resizeNearestNeighbor = function(t, e) {\n        return void 0 === e && (e = !1), this.throwIfDisposed(), xt.image.resizeNearestNeighbor(this, t, e);\n    }, t.prototype.conv1d = function(t, e, n, r, o, a) {\n        return void 0 === r && (r = \"NWC\"), void 0 === o && (o = 1), this.throwIfDisposed(), xt.conv1d(this, t, e, n, r, o, a);\n    }, t.prototype.conv2d = function(t, e, n, r, o, a) {\n        return void 0 === r && (r = \"NHWC\"), void 0 === o && (o = [\n            1,\n            1\n        ]), this.throwIfDisposed(), xt.conv2d(this, t, e, n, r, o, a);\n    }, t.prototype.conv2dTranspose = function(t, e, n, r, o) {\n        return this.throwIfDisposed(), xt.conv2dTranspose(this, t, e, n, r, o);\n    }, t.prototype.depthwiseConv2D = function(t, e, n, r, o, a) {\n        return void 0 === r && (r = \"NHWC\"), void 0 === o && (o = [\n            1,\n            1\n        ]), this.throwIfDisposed(), xt.depthwiseConv2d(this, t, e, n, r, o, a);\n    }, t.prototype.separableConv2d = function(t, e, n, r, o, a) {\n        return void 0 === o && (o = [\n            1,\n            1\n        ]), void 0 === a && (a = \"NHWC\"), this.throwIfDisposed(), xt.separableConv2d(this, t, e, n, r, o, a);\n    }, t.prototype.avgPool = function(t, e, n, r) {\n        return this.throwIfDisposed(), xt.avgPool(this, t, e, n, r);\n    }, t.prototype.maxPool = function(t, e, n, r) {\n        return this.throwIfDisposed(), xt.maxPool(this, t, e, n, r);\n    }, t.prototype.localResponseNormalization = function(t, e, n, r) {\n        return void 0 === t && (t = 5), void 0 === e && (e = 1), void 0 === n && (n = 1), void 0 === r && (r = .5), xt.localResponseNormalization(this, t, e, n, r);\n    }, t.prototype.pool = function(t, e, n, r, o) {\n        return this.throwIfDisposed(), xt.pool(this, t, e, n, r, o);\n    }, t.prototype.variable = function(t, e, n) {\n        return void 0 === t && (t = !0), this.throwIfDisposed(), yt().makeVariable(this, t, e, n);\n    }, t.prototype.unsortedSegmentSum = function(t, e) {\n        return this.throwIfDisposed(), xt.unsortedSegmentSum(this, t, e);\n    }, t.prototype.batchToSpaceND = function(t, e) {\n        return this.throwIfDisposed(), xt.batchToSpaceND(this, t, e);\n    }, t.prototype.spaceToBatchND = function(t, e) {\n        return this.throwIfDisposed(), xt.spaceToBatchND(this, t, e);\n    }, t.prototype.topk = function(t, e) {\n        return void 0 === t && (t = 1), void 0 === e && (e = !0), this.throwIfDisposed(), xt.topk(this, t, e);\n    }, t.prototype.stridedSlice = function(t, e, n, r, o, a, i, s) {\n        return void 0 === r && (r = 0), void 0 === o && (o = 0), void 0 === a && (a = 0), void 0 === i && (i = 0), void 0 === s && (s = 0), this.throwIfDisposed(), xt.stridedSlice(this, t, e, n, r, o, a, i, s);\n    }, t.prototype.depthToSpace = function(t, e) {\n        return this.throwIfDisposed(), xt.depthToSpace(this, t, e);\n    }, t.prototype.fft = function() {\n        return this.throwIfDisposed(), xt.spectral.fft(this);\n    }, t.prototype.ifft = function() {\n        return this.throwIfDisposed(), xt.spectral.ifft(this);\n    }, t.prototype.rfft = function() {\n        return this.throwIfDisposed(), xt.spectral.rfft(this);\n    }, t.prototype.irfft = function() {\n        return this.throwIfDisposed(), xt.spectral.irfft(this);\n    }, t;\n}();\nObject.defineProperty(wt, Symbol.hasInstance, {\n    value: function(t) {\n        return !!t && null != t.dataId && null != t.shape && null != t.dtype;\n    }\n});\nvar Ct, Et, Rt, It, kt, St = function(t) {\n    function n(e, n, r, o) {\n        var a = t.call(this, e.shape, e.dtype, e.dataId, o) || this;\n        return a.trainable = n, a.name = r, a;\n    }\n    return e(n, t), n.prototype.assign = function(t) {\n        if (t.dtype !== this.dtype) throw new Error(\"dtype of the new value (\" + t.dtype + \") and previous value (\" + this.dtype + \") must match\");\n        if (!S(t.shape, this.shape)) throw new Error(\"shape of the new value (\" + t.shape + \") and previous value (\" + this.shape + \") must match\");\n        yt().disposeTensor(this), this.dataId = t.dataId, yt().incRef(this, null);\n    }, n.prototype.dispose = function() {\n        yt().disposeVariable(this), this.isDisposedInternal = !0;\n    }, n;\n}(wt);\nObject.defineProperty(St, Symbol.hasInstance, {\n    value: function(t) {\n        return t instanceof wt && null != t.assign && t.assign instanceof Function;\n    }\n}), function(t) {\n    t.R0 = \"R0\", t.R1 = \"R1\", t.R2 = \"R2\", t.R3 = \"R3\", t.R4 = \"R4\", t.R5 = \"R5\", t.R6 = \"R6\";\n}(Ct || (Ct = {})), function(t) {\n    t.float32 = \"float32\", t.int32 = \"int32\", t.bool = \"int32\", t.complex64 = \"complex64\";\n}(Et || (Et = {})), function(t) {\n    t.float32 = \"float32\", t.int32 = \"int32\", t.bool = \"bool\", t.complex64 = \"complex64\";\n}(Rt || (Rt = {})), function(t) {\n    t.float32 = \"float32\", t.int32 = \"float32\", t.bool = \"float32\", t.complex64 = \"complex64\";\n}(It || (It = {})), function(t) {\n    t.float32 = \"complex64\", t.int32 = \"complex64\", t.bool = \"complex64\", t.complex64 = \"complex64\";\n}(kt || (kt = {}));\nvar At = {\n    float32: It,\n    int32: Et,\n    bool: Rt,\n    complex64: kt\n};\nfunction Dt(t, e) {\n    if (\"string\" === t || \"string\" === e) {\n        if (\"string\" === t && \"string\" === e) return \"string\";\n        throw new Error(\"Can not upcast \" + t + \" with \" + e);\n    }\n    return At[t][e];\n}\nfunction Tt(t) {\n    return Dt(t, \"int32\");\n}\nfunction Nt(t, e) {\n    if (t.dtype === e.dtype) return [\n        t,\n        e\n    ];\n    var n = Dt(t.dtype, e.dtype);\n    return [\n        t.cast(n),\n        e.cast(n)\n    ];\n}\nfunction Ft(t, e) {\n    C(t.dtype === e.dtype, function() {\n        return \"The dtypes of the first(\" + t.dtype + \") and second(\" + e.dtype + \") input must match\";\n    });\n}\nfunction _t(t) {\n    var e = [];\n    return function t(e, n, r) {\n        if (null == e) return;\n        if (e instanceof wt) return void n.push(e);\n        if (o = e, !Array.isArray(o) && \"object\" != typeof o) return;\n        var o;\n        var a = e;\n        for(var i in a){\n            var s = a[i];\n            r.has(s) || (r.add(s), t(s, n, r));\n        }\n    }(t, e, new Set), e;\n}\nvar Ot, Mt = Object.freeze({\n    makeTypesMatch: Nt,\n    assertTypesMatch: Ft,\n    isTensorInList: function(t, e) {\n        return e.some(function(e) {\n            return e.id === t.id;\n        });\n    },\n    getTensorsInContainer: _t\n}), Bt = function() {\n    function t() {\n        this.registeredVariables = {}, this.nextTapeNodeId = 0, this.numBytes = 0, this.numTensors = 0, this.numStringTensors = 0, this.numDataBuffers = 0, this.gradientDepth = 0, this.kernelDepth = 0, this.scopeStack = [], this.numDataMovesStack = [], this.nextScopeId = 0, this.tensorInfo = new WeakMap, this.profiling = !1, this.activeProfile = {\n            newBytes: 0,\n            newTensors: 0,\n            peakBytes: 0,\n            kernels: [],\n            result: null\n        };\n    }\n    return t.prototype.dispose = function() {\n        for(var t in this.registeredVariables)this.registeredVariables[t].dispose();\n    }, t;\n}(), Pt = function() {\n    function t(t) {\n        this.ENV = t, this.registry = {}, this.registryFactory = {}, this.pendingBackendInitId = 0, this.state = new Bt;\n    }\n    return t.prototype.ready = function() {\n        return n(this, void 0, void 0, function() {\n            var t, e, n;\n            return r(this, function(r) {\n                switch(r.label){\n                    case 0:\n                        if (null != this.pendingBackendInit) return [\n                            2,\n                            this.pendingBackendInit.then(function() {})\n                        ];\n                        if (null != this.backendInstance) return [\n                            2\n                        ];\n                        t = this.getSortedBackends(), e = 0, r.label = 1;\n                    case 1:\n                        return e < t.length ? (n = t[e], [\n                            4,\n                            this.initializeBackend(n).success\n                        ]) : [\n                            3,\n                            5\n                        ];\n                    case 2:\n                        return r.sent() ? [\n                            4,\n                            this.setBackend(n)\n                        ] : [\n                            3,\n                            4\n                        ];\n                    case 3:\n                        return r.sent(), [\n                            2\n                        ];\n                    case 4:\n                        return e++, [\n                            3,\n                            1\n                        ];\n                    case 5:\n                        throw new Error(\"Could not initialize any backends, all backend initializations failed.\");\n                }\n            });\n        });\n    }, Object.defineProperty(t.prototype, \"backend\", {\n        get: function() {\n            if (null != this.pendingBackendInit) throw new Error(\"Backend '\" + this.backendName + \"' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods\");\n            if (null == this.backendInstance) {\n                var t = this.initializeBackendsAndReturnBest(), e = t.name;\n                if (t.asyncInit) throw new Error(\"The highest priority backend '\" + e + \"' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods\");\n                this.setBackend(e);\n            }\n            return this.backendInstance;\n        },\n        enumerable: !0,\n        configurable: !0\n    }), t.prototype.backendNames = function() {\n        return Object.keys(this.registryFactory);\n    }, t.prototype.findBackend = function(t) {\n        if (!(t in this.registry)) {\n            if (!(t in this.registryFactory)) return null;\n            if (this.initializeBackend(t).asyncInit) return null;\n        }\n        return this.registry[t];\n    }, t.prototype.findBackendFactory = function(t) {\n        return t in this.registryFactory ? this.registryFactory[t].factory : null;\n    }, t.prototype.registerBackend = function(t, e, n) {\n        return void 0 === n && (n = 1), t in this.registryFactory ? (console.warn(t + \" backend was already registered. Reusing existing backend factory.\"), !1) : (this.registryFactory[t] = {\n            factory: e,\n            priority: n\n        }, !0);\n    }, t.prototype.setBackend = function(t) {\n        return n(this, void 0, void 0, function() {\n            var e, n, o;\n            return r(this, function(r) {\n                switch(r.label){\n                    case 0:\n                        if (null == this.registryFactory[t]) throw new Error(\"Backend name '\" + t + \"' not found in registry\");\n                        return this.backendName = t, null != this.registry[t] ? [\n                            3,\n                            4\n                        ] : (this.backendInstance = null, e = this.initializeBackend(t), n = e.success, e.asyncInit ? [\n                            4,\n                            n\n                        ] : [\n                            3,\n                            2\n                        ]);\n                    case 1:\n                        return o = r.sent(), [\n                            3,\n                            3\n                        ];\n                    case 2:\n                        o = n, r.label = 3;\n                    case 3:\n                        if (!o) return [\n                            2,\n                            !1\n                        ];\n                        r.label = 4;\n                    case 4:\n                        return this.backendInstance = this.registry[t], this.setupRegisteredKernels(), this.profiler = new ut(this.backendInstance), [\n                            2,\n                            !0\n                        ];\n                }\n            });\n        });\n    }, t.prototype.setupRegisteredKernels = function() {\n        var t = this;\n        f(this.backendName).forEach(function(e) {\n            null != e.setupFunc && e.setupFunc(t.backendInstance);\n        });\n    }, t.prototype.disposeRegisteredKernels = function(t) {\n        var e = this;\n        f(t).forEach(function(n) {\n            null != n.disposeFunc && n.disposeFunc(e.registry[t]);\n        });\n    }, t.prototype.initializeBackend = function(t) {\n        var e = this, n = this.registryFactory[t];\n        if (null == n) throw new Error(\"Cannot initialize backend \" + t + \", no registration found.\");\n        try {\n            var r = n.factory();\n            if (Promise.resolve(r) === r) {\n                var o = ++this.pendingBackendInitId, a = r.then(function(n) {\n                    return !(o < e.pendingBackendInitId) && (e.registry[t] = n, e.pendingBackendInit = null, !0);\n                }).catch(function(n) {\n                    return !(o < e.pendingBackendInitId) && (e.pendingBackendInit = null, console.warn(\"Initialization of backend \" + t + \" failed\"), console.warn(n.stack || n.message), !1);\n                });\n                return this.pendingBackendInit = a, {\n                    success: a,\n                    asyncInit: !0\n                };\n            }\n            return this.registry[t] = r, {\n                success: !0,\n                asyncInit: !1\n            };\n        } catch (e) {\n            return console.warn(\"Initialization of backend \" + t + \" failed\"), console.warn(e.stack || e.message), {\n                success: !1,\n                asyncInit: !1\n            };\n        }\n    }, t.prototype.removeBackend = function(t) {\n        if (!(t in this.registryFactory)) throw new Error(t + \" backend not found in registry\");\n        this.backendName === t && null != this.pendingBackendInit && this.pendingBackendInitId++, t in this.registry && (this.disposeRegisteredKernels(t), this.registry[t].dispose(), delete this.registry[t]), delete this.registryFactory[t], this.backendName === t && (this.pendingBackendInit = null, this.backendName = null, this.backendInstance = null);\n    }, t.prototype.getSortedBackends = function() {\n        var t = this;\n        if (0 === Object.keys(this.registryFactory).length) throw new Error(\"No backend found in registry.\");\n        return Object.keys(this.registryFactory).sort(function(e, n) {\n            return t.registryFactory[n].priority - t.registryFactory[e].priority;\n        });\n    }, t.prototype.initializeBackendsAndReturnBest = function() {\n        for(var t = this.getSortedBackends(), e = 0; e < t.length; e++){\n            var n = t[e], r = this.initializeBackend(n), o = r.success, a = r.asyncInit;\n            if (a || o) return {\n                name: n,\n                asyncInit: a\n            };\n        }\n        throw new Error(\"Could not initialize any backends, all backend initializations failed.\");\n    }, t.prototype.moveData = function(t, e) {\n        var n = this.state.tensorInfo.get(e), r = n.backend, o = this.readSync(e);\n        r.disposeData(e), n.backend = t, t.move(e, o, n.shape, n.dtype), this.shouldCheckForMemLeaks() && this.state.numDataMovesStack[this.state.numDataMovesStack.length - 1]++;\n    }, t.prototype.tidy = function(t, e) {\n        var n, r = this, o = null;\n        if (null == e) {\n            if (\"function\" != typeof t) throw new Error(\"Please provide a function to tidy()\");\n            e = t;\n        } else {\n            if (\"string\" != typeof t && !(t instanceof String)) throw new Error(\"When calling with two arguments, the first argument to tidy() must be a string\");\n            if (\"function\" != typeof e) throw new Error(\"When calling with two arguments, the 2nd argument to tidy() must be a function\");\n            o = t;\n        }\n        return this.scopedRun(function() {\n            return r.startScope(o);\n        }, function() {\n            return r.endScope(n);\n        }, function() {\n            return (n = e()) instanceof Promise && console.error(\"Cannot return a Promise inside of tidy.\"), n;\n        });\n    }, t.prototype.scopedRun = function(t, e, n) {\n        t();\n        try {\n            var r = n();\n            return e(), r;\n        } catch (t) {\n            throw e(), t;\n        }\n    }, t.prototype.nextTensorId = function() {\n        return t.nextTensorId++;\n    }, t.prototype.nextVariableId = function() {\n        return t.nextVariableId++;\n    }, t.prototype.clone = function(t) {\n        var e = this.makeTensorFromDataId(t.dataId, t.shape, t.dtype), n = {\n            x: t\n        };\n        return this.addTapeNode(this.state.activeScope.name, n, [\n            e\n        ], function(t) {\n            return {\n                x: function() {\n                    return t.toFloat();\n                }\n            };\n        }, []), e;\n    }, t.prototype.runKernel = function(t, e, n, r, o) {\n        return this.runKernelFunc(null, e, null, t, n, r, o);\n    }, t.prototype.shouldCheckForMemLeaks = function() {\n        return this.ENV.getBool(\"IS_TEST\");\n    }, t.prototype.checkKernelForMemLeak = function(t, e, n) {\n        var r = this.backend.numDataIds(), o = 0;\n        n.forEach(function(t) {\n            o += \"complex64\" === t.dtype ? 3 : 1;\n        });\n        var a = this.state.numDataMovesStack[this.state.numDataMovesStack.length - 1], i = r - e - o - a;\n        if (i > 0) throw new Error(\"Backend '\" + this.backendName + \"' has an internal memory leak (\" + i + \" data ids) after running '\" + t + \"'\");\n    }, t.prototype.runKernelFunc = function(t, e, n, r, o, a, i) {\n        var s, u = this;\n        void 0 === a && (a = []), void 0 === i && (i = []);\n        var c = [], h = this.isTapeOn();\n        null == r && (r = null != this.state.activeScope ? this.state.activeScope.name : \"\");\n        var f, d = function(t) {\n            h && (c = t.map(function(t) {\n                return u.keep(u.clone(t));\n            }));\n        }, p = this.state.numBytes, v = this.state.numTensors;\n        this.shouldCheckForMemLeaks() && this.state.numDataMovesStack.push(0);\n        var m, g = l(r, this.backendName);\n        return f = null != g ? function() {\n            var t = u.backend.numDataIds();\n            m = g.kernelFunc({\n                inputs: e,\n                attrs: o,\n                backend: u.backend\n            });\n            var n = Array.isArray(m) ? m : [\n                m\n            ];\n            u.shouldCheckForMemLeaks() && u.checkKernelForMemLeak(r, t, n);\n            var s = n.map(function(t) {\n                var e = t.dataId, n = t.shape, r = t.dtype;\n                return u.makeTensorFromDataId(e, n, r);\n            }), c = s.filter(function(t, e) {\n                return i[e];\n            });\n            return d((a || []).slice().concat(c)), s;\n        } : function() {\n            var e = u.backend.numDataIds();\n            m = u.tidy(function() {\n                return t(u.backend, d);\n            });\n            var n = Array.isArray(m) ? m : [\n                m\n            ];\n            return u.shouldCheckForMemLeaks() && u.checkKernelForMemLeak(r, e, n), n;\n        }, this.scopedRun(function() {\n            return u.state.kernelDepth++;\n        }, function() {\n            return u.state.kernelDepth--;\n        }, function() {\n            s = u.ENV.getBool(\"DEBUG\") ? u.profiler.profileKernel(r, e, function() {\n                return f();\n            }) : f();\n        }), h && this.addTapeNode(r, e, s, n, c), this.state.profiling && this.state.activeProfile.kernels.push({\n            name: r,\n            bytesAdded: this.state.numBytes - p,\n            totalBytesSnapshot: this.state.numBytes,\n            tensorsAdded: this.state.numTensors - v,\n            totalTensorsSnapshot: this.state.numTensors,\n            inputShapes: Object.keys(e).map(function(t) {\n                return e[t].shape;\n            }),\n            outputShapes: s.map(function(t) {\n                return t.shape;\n            })\n        }), Array.isArray(m) ? s : s[0];\n    }, t.prototype.makeTensor = function(t, e, n, r) {\n        if (null == t) throw new Error(\"Values passed to engine.makeTensor() are null\");\n        n = n || \"float32\", r = r || this.backend;\n        var o = t;\n        \"string\" === n && H(t[0]) && (o = t.map(function(t) {\n            return rt(t);\n        }));\n        var a = r.write(o, e, n), i = new wt(e, n, a, this.nextTensorId());\n        if (this.incRef(i, r), \"string\" === n) {\n            var s = this.state.tensorInfo.get(a), u = G(o);\n            this.state.numBytes += u - s.bytes, s.bytes = u;\n        }\n        return i;\n    }, t.prototype.makeTensorFromDataId = function(t, e, n, r) {\n        var o = new wt(e, n = n || \"float32\", t, this.nextTensorId());\n        return this.incRef(o, r), o;\n    }, t.prototype.makeVariable = function(t, e, n, r) {\n        void 0 === e && (e = !0), n = n || this.nextVariableId().toString(), null != r && r !== t.dtype && (t = t.asType(r));\n        var o = new St(t, e, n, this.nextTensorId());\n        if (null != this.state.registeredVariables[o.name]) throw new Error(\"Variable with name \" + o.name + \" was already registered\");\n        return this.state.registeredVariables[o.name] = o, this.incRef(o, this.backend), o;\n    }, t.prototype.incRef = function(t, e) {\n        var n = this.state.tensorInfo.has(t.dataId) ? this.state.tensorInfo.get(t.dataId).refCount : 0;\n        if (this.state.numTensors++, \"string\" === t.dtype && this.state.numStringTensors++, 0 === n) {\n            this.state.numDataBuffers++;\n            var r = 0;\n            \"complex64\" !== t.dtype && \"string\" !== t.dtype && (r = t.size * z(t.dtype)), this.state.tensorInfo.set(t.dataId, {\n                backend: e || this.backend,\n                dtype: t.dtype,\n                shape: t.shape,\n                bytes: r,\n                refCount: 0\n            }), this.state.numBytes += r;\n        }\n        this.state.tensorInfo.get(t.dataId).refCount++, t instanceof St || this.track(t);\n    }, t.prototype.disposeTensor = function(t) {\n        if (this.state.tensorInfo.has(t.dataId)) {\n            this.state.numTensors--, \"string\" === t.dtype && this.state.numStringTensors--;\n            var e = this.state.tensorInfo.get(t.dataId);\n            e.refCount <= 1 ? (\"complex64\" !== t.dtype && (this.state.numBytes -= e.bytes), this.state.numDataBuffers--, e.backend.disposeData(t.dataId), this.state.tensorInfo.delete(t.dataId)) : this.state.tensorInfo.get(t.dataId).refCount--;\n        }\n    }, t.prototype.disposeVariables = function() {\n        for(var t in this.state.registeredVariables){\n            var e = this.state.registeredVariables[t];\n            this.disposeVariable(e);\n        }\n    }, t.prototype.disposeVariable = function(t) {\n        this.disposeTensor(t), null != this.state.registeredVariables[t.name] && delete this.state.registeredVariables[t.name];\n    }, t.prototype.memory = function() {\n        var t = this.backend.memory();\n        return t.numTensors = this.state.numTensors, t.numDataBuffers = this.state.numDataBuffers, t.numBytes = this.state.numBytes, this.state.numStringTensors > 0 && (t.unreliable = !0, null == t.reasons && (t.reasons = []), t.reasons.push(\"Memory usage by string tensors is approximate (2 bytes per character)\")), t;\n    }, t.prototype.profile = function(t) {\n        return n(this, void 0, void 0, function() {\n            var e, n;\n            return r(this, function(r) {\n                return this.state.profiling = !0, e = this.state.numBytes, n = this.state.numTensors, this.state.activeProfile.kernels = [], this.state.activeProfile.result = t(), this.state.profiling = !1, this.state.activeProfile.peakBytes = Math.max.apply(Math, this.state.activeProfile.kernels.map(function(t) {\n                    return t.totalBytesSnapshot;\n                })), this.state.activeProfile.newBytes = this.state.numBytes - e, this.state.activeProfile.newTensors = this.state.numTensors - n, [\n                    2,\n                    this.state.activeProfile\n                ];\n            });\n        });\n    }, t.prototype.isTapeOn = function() {\n        return this.state.gradientDepth > 0 && 0 === this.state.kernelDepth;\n    }, t.prototype.addTapeNode = function(t, e, n, r, o) {\n        var a = this, i = {\n            id: this.state.nextTapeNodeId++,\n            kernelName: t,\n            inputs: e,\n            outputs: n,\n            saved: o\n        }, s = h(t);\n        null != s && (r = s.gradFunc), null != r && (i.gradient = function(t) {\n            return t = t.map(function(t, e) {\n                if (null == t) {\n                    var r = n[e], o = tt(r.size, r.dtype);\n                    return a.makeTensor(o, r.shape, r.dtype);\n                }\n                return t;\n            }), r(t.length > 1 ? t : t[0], o);\n        }), this.state.activeTape.push(i);\n    }, t.prototype.keep = function(t) {\n        return t.kept = !0, t;\n    }, t.prototype.startTape = function() {\n        0 === this.state.gradientDepth && (this.state.activeTape = []), this.state.gradientDepth++;\n    }, t.prototype.endTape = function() {\n        this.state.gradientDepth--;\n    }, t.prototype.startScope = function(t) {\n        var e = {\n            track: [],\n            name: \"unnamed scope\",\n            id: this.state.nextScopeId++\n        };\n        t && (e.name = t), this.state.scopeStack.push(e), this.state.activeScope = e;\n    }, t.prototype.endScope = function(t) {\n        for(var e = this, n = _t(t), r = new Set(n.map(function(t) {\n            return t.id;\n        })), o = 0; o < this.state.activeScope.track.length; o++){\n            var a = this.state.activeScope.track[o];\n            a.kept || r.has(a.id) || a.dispose();\n        }\n        var i = this.state.scopeStack.pop();\n        this.state.activeScope = 0 === this.state.scopeStack.length ? null : this.state.scopeStack[this.state.scopeStack.length - 1], n.forEach(function(t) {\n            t.kept || t.scopeId !== i.id || e.track(t);\n        });\n    }, t.prototype.gradients = function(t, e, n, r) {\n        var o = this;\n        if (void 0 === r && (r = !1), C(e.length > 0, function() {\n            return \"gradients() received an empty list of xs.\";\n        }), null != n && \"float32\" !== n.dtype) throw new Error(\"dy must have 'float32' dtype, but has '\" + n.dtype + \"'\");\n        var a = this.scopedRun(function() {\n            return o.startTape();\n        }, function() {\n            return o.endTape();\n        }, function() {\n            return o.tidy(\"forward\", t);\n        });\n        C(a instanceof wt, function() {\n            return \"The result y returned by f() must be a tensor.\";\n        });\n        var i = function(t, e, n) {\n            for(var r = {}, o = {}, a = 0; a < e.length; a++)r[e[a].id] = !0;\n            for(a = 0; a < t.length; a++){\n                var i = (p = t[a]).inputs;\n                for(var s in i){\n                    for(var u = i[s], c = !1, l = 0; l < e.length; l++)if (r[u.id]) {\n                        p.outputs.forEach(function(t) {\n                            return r[t.id] = !0;\n                        }), c = !0, o[p.id] = !0;\n                        break;\n                    }\n                    if (c) break;\n                }\n            }\n            var h = {};\n            h[n.id] = !0;\n            var f = {};\n            for(a = t.length - 1; a >= 0; a--)for(i = (p = t[a]).inputs, l = 0; l < p.outputs.length; l++)if (h[p.outputs[l].id]) {\n                for(var s in i)h[i[s].id] = !0, f[p.id] = !0;\n                break;\n            }\n            var d = [];\n            for(a = 0; a < t.length; a++){\n                var p;\n                if (o[(p = t[a]).id] && f[p.id]) {\n                    var v = {};\n                    for(var s in p.inputs){\n                        var m = p.inputs[s];\n                        r[m.id] && (v[s] = m);\n                    }\n                    var g = Object.assign({}, p);\n                    g.inputs = v, g.outputs = p.outputs, d.push(g);\n                }\n            }\n            return d;\n        }(this.state.activeTape, e, a);\n        if (!r && 0 === i.length && e.length > 0) throw new Error(\"Cannot compute gradient of y=f(x) with respect to x. Make sure that the f you passed encloses all operations that lead from x to y.\");\n        return this.tidy(\"backward\", function() {\n            var t, r, s = {};\n            s[a.id] = null == n ? (t = a.shape, r = Z(k(t), \"float32\"), Lt.makeTensor(r, t, \"float32\")) : n, function(t, e, n) {\n                for(var r = function(r) {\n                    var o = e[r], a = [];\n                    if (o.outputs.forEach(function(e) {\n                        var n = t[e.id];\n                        null != n ? a.push(n) : a.push(null);\n                    }), null == o.gradient) throw new Error(\"Cannot compute gradient: gradient function not found for \" + o.kernelName + \".\");\n                    var i = o.gradient(a), s = function(e) {\n                        if (!(e in i)) throw new Error(\"Cannot backprop through input \" + e + \". Available gradients found: \" + Object.keys(i) + \".\");\n                        var r = n(function() {\n                            return i[e]();\n                        });\n                        if (\"float32\" !== r.dtype) throw new Error(\"Error in gradient for op \" + o.kernelName + \". The gradient of input \" + e + \" must have 'float32' dtype, but has '\" + r.dtype + \"'\");\n                        var a = o.inputs[e];\n                        if (!S(r.shape, a.shape)) throw new Error(\"Error in gradient for op \" + o.kernelName + \". The gradient of input '\" + e + \"' has shape '\" + r.shape + \"', which does not match the shape of the input '\" + a.shape + \"'\");\n                        if (null == t[a.id]) t[a.id] = r;\n                        else {\n                            var s = t[a.id];\n                            t[a.id] = s.add(r), s.dispose();\n                        }\n                    };\n                    for(var u in o.inputs)s(u);\n                }, o = e.length - 1; o >= 0; o--)r(o);\n            }(s, i, function(t) {\n                return o.tidy(t);\n            });\n            var u = e.map(function(t) {\n                return s[t.id];\n            });\n            return 0 === o.state.gradientDepth && (o.state.activeTape.forEach(function(t) {\n                for(var e = 0, n = t.saved; e < n.length; e++){\n                    n[e].dispose();\n                }\n            }), o.state.activeTape = null), {\n                value: a,\n                grads: u\n            };\n        });\n    }, t.prototype.customGrad = function(t) {\n        var e = this;\n        return C(X(t), function() {\n            return \"The f passed in customGrad(f) must be a function.\";\n        }), function() {\n            for(var n, r = [], o = 0; o < arguments.length; o++)r[o] = arguments[o];\n            C(r.every(function(t) {\n                return t instanceof wt;\n            }), function() {\n                return \"The args passed in customGrad(f)(x1, x2,...) must all be tensors\";\n            });\n            var a = {};\n            return r.forEach(function(t, e) {\n                a[e] = t;\n            }), e.runKernelFunc(function(e, o) {\n                return C((n = t.apply(void 0, r.concat([\n                    o\n                ]))).value instanceof wt, function() {\n                    return \"The function f passed in customGrad(f) must return an object where `obj.value` is a tensor\";\n                }), C(X(n.gradFunc), function() {\n                    return \"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function.\";\n                }), n.value;\n            }, a, function(t, e) {\n                var o = n.gradFunc(t, e), a = Array.isArray(o) ? o : [\n                    o\n                ];\n                C(a.length === r.length, function() {\n                    return \"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns the same number of tensors as inputs passed to f(...).\";\n                }), C(a.every(function(t) {\n                    return t instanceof wt;\n                }), function() {\n                    return \"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns a list of only tensors.\";\n                });\n                var i = {};\n                return a.forEach(function(t, e) {\n                    i[e] = function() {\n                        return t;\n                    };\n                }), i;\n            });\n        };\n    }, t.prototype.readSync = function(t) {\n        return this.state.tensorInfo.get(t).backend.readSync(t);\n    }, t.prototype.read = function(t) {\n        return this.state.tensorInfo.get(t).backend.read(t);\n    }, t.prototype.time = function(t) {\n        return n(this, void 0, void 0, function() {\n            var e, n;\n            return r(this, function(r) {\n                switch(r.label){\n                    case 0:\n                        return e = et(), [\n                            4,\n                            this.backend.time(t)\n                        ];\n                    case 1:\n                        return (n = r.sent()).wallMs = et() - e, [\n                            2,\n                            n\n                        ];\n                }\n            });\n        });\n    }, t.prototype.track = function(t) {\n        return null != this.state.activeScope && (t.scopeId = this.state.activeScope.id, this.state.activeScope.track.push(t)), t;\n    }, Object.defineProperty(t.prototype, \"registeredVariables\", {\n        get: function() {\n            return this.state.registeredVariables;\n        },\n        enumerable: !0,\n        configurable: !0\n    }), t.prototype.reset = function() {\n        for(var t in this.pendingBackendInitId++, this.state.dispose(), this.ENV.reset(), this.state = new Bt, this.registry)this.disposeRegisteredKernels(t), this.registry[t].dispose(), delete this.registry[t];\n        this.backendName = null, this.backendInstance = null, this.pendingBackendInit = null;\n    }, t.nextTensorId = 0, t.nextVariableId = 0, t;\n}();\nvar Lt = function() {\n    var t = function() {\n        if (null == Ot) {\n            var t = void 0;\n            if (false) {}\n            else if (\"undefined\" != typeof global) t = global;\n            else if (\"undefined\" != typeof process) t = process;\n            else {\n                if (\"undefined\" == typeof self) throw new Error(\"Could not find a global object\");\n                t = self;\n            }\n            Ot = t;\n        }\n        return Ot;\n    }();\n    if (null == t._tfengine) {\n        var e = new o(t);\n        t._tfengine = new Pt(e);\n    }\n    return function(t) {\n        s = t;\n    }(t._tfengine.ENV), yt = function() {\n        return t._tfengine;\n    }, t._tfengine;\n}();\nfunction Wt() {\n    return  false || \"undefined\" != typeof WorkerGlobalScope;\n}\nvar Ut = i();\nUt.registerFlag(\"DEBUG\", function() {\n    return !1;\n}, function(t) {\n    t && console.warn(\"Debugging mode is ON. The output of every math call will be downloaded to CPU and checked for NaNs. This significantly impacts performance.\");\n}), Ut.registerFlag(\"IS_BROWSER\", function() {\n    return Wt();\n}), Ut.registerFlag(\"IS_NODE\", function() {\n    return \"undefined\" != typeof process && void 0 !== process.versions && void 0 !== process.versions.node;\n}), Ut.registerFlag(\"IS_CHROME\", function() {\n    return \"undefined\" != typeof navigator && null != navigator && null != navigator.userAgent && /Chrome/.test(navigator.userAgent) && /Google Inc/.test(navigator.vendor);\n}), Ut.registerFlag(\"PROD\", function() {\n    return !1;\n}), Ut.registerFlag(\"TENSORLIKE_CHECK_SHAPE_CONSISTENCY\", function() {\n    return Ut.getBool(\"DEBUG\");\n}), Ut.registerFlag(\"DEPRECATION_WARNINGS_ENABLED\", function() {\n    return !0;\n}), Ut.registerFlag(\"IS_TEST\", function() {\n    return !1;\n});\nvar Vt, zt, Gt, Ht = {}, qt = {\n    alpha: !1,\n    antialias: !1,\n    premultipliedAlpha: !1,\n    preserveDrawingBuffer: !1,\n    depth: !1,\n    stencil: !1,\n    failIfMajorPerformanceCaveat: !0\n};\nfunction Kt(t, e) {\n    Ht[t] = e;\n}\nfunction jt(t) {\n    t in Ht || (Ht[t] = function(t) {\n        if (1 !== t && 2 !== t) throw new Error(\"Cannot get WebGL rendering context, WebGL is disabled.\");\n        var e = function(t) {\n            if (\"undefined\" != typeof OffscreenCanvas && 2 === t) return new OffscreenCanvas(300, 150);\n            if (\"undefined\" != typeof document) return document.createElement(\"canvas\");\n            throw new Error(\"Cannot create a canvas in this context\");\n        }(t);\n        if (e.addEventListener(\"webglcontextlost\", function(e) {\n            e.preventDefault(), delete Ht[t];\n        }, !1), 1 === t) return e.getContext(\"webgl\", qt) || e.getContext(\"experimental-webgl\", qt);\n        return e.getContext(\"webgl2\", qt);\n    }(t));\n    var e = Ht[t];\n    return e.isContextLost() ? (delete Ht[t], jt(t)) : (e.disable(e.DEPTH_TEST), e.disable(e.STENCIL_TEST), e.disable(e.BLEND), e.disable(e.DITHER), e.disable(e.POLYGON_OFFSET_FILL), e.disable(e.SAMPLE_COVERAGE), e.enable(e.SCISSOR_TEST), e.enable(e.CULL_FACE), e.cullFace(e.BACK), Ht[t]);\n}\nfunction Xt(t, e) {\n    return [\n        e,\n        t\n    ];\n}\nfunction Yt(t) {\n    var e = k(t);\n    return T(Math.ceil(e / 4));\n}\nfunction $t(t, e) {\n    return [\n        Math.max(1, Math.ceil(e / 2)),\n        Math.max(1, Math.ceil(t / 2))\n    ];\n}\nfunction Qt(t, e) {\n    var n, r, o, a, s, u, c, l, h, f = t;\n    return 2 === i().getNumber(\"WEBGL_VERSION\") ? (n = f.R32F, r = f.R16F, o = f.RGBA16F, a = f.RGBA32F, s = f.RED, u = 4, c = 1, l = f.HALF_FLOAT, h = f.FLOAT) : (n = t.RGBA, r = t.RGBA, o = t.RGBA, a = f.RGBA, s = t.RGBA, u = 4, c = 4, l = null != e ? e.HALF_FLOAT_OES : null, h = t.FLOAT), {\n        internalFormatFloat: n,\n        internalFormatHalfFloat: r,\n        internalFormatPackedHalfFloat: o,\n        internalFormatPackedFloat: a,\n        textureFormatFloat: s,\n        downloadTextureFormat: t.RGBA,\n        downloadUnpackNumChannels: u,\n        defaultNumChannels: c,\n        textureTypeHalfFloat: l,\n        textureTypeFloat: h\n    };\n}\nfunction Jt(t, e, n) {\n    var r = n();\n    return e && function(t) {\n        var e = t.getError();\n        if (e !== t.NO_ERROR) throw new Error(\"WebGL Error: \" + ne(t, e));\n    }(t), r;\n}\n!function(t) {\n    t[t.DENSE = 0] = \"DENSE\", t[t.SHARED_BATCH = 1] = \"SHARED_BATCH\";\n}(Vt || (Vt = {})), function(t) {\n    t[t.RENDER = 0] = \"RENDER\", t[t.UPLOAD = 1] = \"UPLOAD\", t[t.PIXELS = 2] = \"PIXELS\", t[t.DOWNLOAD = 3] = \"DOWNLOAD\";\n}(zt || (zt = {})), function(t) {\n    t[t.UNPACKED_FLOAT16 = 0] = \"UNPACKED_FLOAT16\", t[t.UNPACKED_FLOAT32 = 1] = \"UNPACKED_FLOAT32\", t[t.PACKED_4X1_UNSIGNED_BYTE = 2] = \"PACKED_4X1_UNSIGNED_BYTE\", t[t.PACKED_2X2_FLOAT32 = 3] = \"PACKED_2X2_FLOAT32\", t[t.PACKED_2X2_FLOAT16 = 4] = \"PACKED_2X2_FLOAT16\";\n}(Gt || (Gt = {}));\nvar Zt = 5.96e-8, te = 65504;\nfunction ee(t) {\n    return !!(i().getBool(\"WEBGL_RENDER_FLOAT32_ENABLED\") || 0 === t || Zt < Math.abs(t) && Math.abs(t) < te);\n}\nfunction ne(t, e) {\n    switch(e){\n        case t.NO_ERROR:\n            return \"NO_ERROR\";\n        case t.INVALID_ENUM:\n            return \"INVALID_ENUM\";\n        case t.INVALID_VALUE:\n            return \"INVALID_VALUE\";\n        case t.INVALID_OPERATION:\n            return \"INVALID_OPERATION\";\n        case t.INVALID_FRAMEBUFFER_OPERATION:\n            return \"INVALID_FRAMEBUFFER_OPERATION\";\n        case t.OUT_OF_MEMORY:\n            return \"OUT_OF_MEMORY\";\n        case t.CONTEXT_LOST_WEBGL:\n            return \"CONTEXT_LOST_WEBGL\";\n        default:\n            return \"Unknown error code \" + e;\n    }\n}\nfunction re(t, e, n) {\n    return ke(t, e, function() {\n        return t.getExtension(n);\n    }, 'Extension \"' + n + '\" not supported on this browser.');\n}\nfunction oe(t, e, n) {\n    var r = ke(t, e, function() {\n        return t.createShader(t.VERTEX_SHADER);\n    }, \"Unable to create vertex WebGLShader.\");\n    if (Jt(t, e, function() {\n        return t.shaderSource(r, n);\n    }), Jt(t, e, function() {\n        return t.compileShader(r);\n    }), !1 === t.getShaderParameter(r, t.COMPILE_STATUS)) throw console.log(t.getShaderInfoLog(r)), new Error(\"Failed to compile vertex shader.\");\n    return r;\n}\nfunction ae(t, e, n) {\n    var r = ke(t, e, function() {\n        return t.createShader(t.FRAGMENT_SHADER);\n    }, \"Unable to create fragment WebGLShader.\");\n    if (Jt(t, e, function() {\n        return t.shaderSource(r, n);\n    }), Jt(t, e, function() {\n        return t.compileShader(r);\n    }), !1 === t.getShaderParameter(r, t.COMPILE_STATUS)) throw function(t, e) {\n        var n = ue.exec(e);\n        if (null == n) return console.log(\"Couldn't parse line number in error: \" + e), void console.log(t);\n        for(var r = +n[1], o = t.split(\"\\n\"), a = o.length.toString().length + 2, i = o.map(function(t, e) {\n            return N((e + 1).toString(), a) + t;\n        }), s = 0, u = 0; u < i.length; u++)s = Math.max(i[u].length, s);\n        var c = i.slice(0, r - 1), l = i.slice(r - 1, r), h = i.slice(r);\n        console.log(c.join(\"\\n\")), console.log(e.split(\"\\n\")[0]), console.log(\"%c \" + N(l[0], s), \"border:1px solid red; background-color:#e3d2d2; color:#a61717\"), console.log(h.join(\"\\n\"));\n    }(n, t.getShaderInfoLog(r)), new Error(\"Failed to compile fragment shader.\");\n    return r;\n}\nvar ie, se, ue = /ERROR: [0-9]+:([0-9]+):/g;\nfunction ce(t, e) {\n    return ke(t, e, function() {\n        return t.createProgram();\n    }, \"Unable to create WebGLProgram.\");\n}\nfunction le(t, e, n) {\n    if (Jt(t, e, function() {\n        return t.linkProgram(n);\n    }), !1 === t.getProgramParameter(n, t.LINK_STATUS)) throw console.log(t.getProgramInfoLog(n)), new Error(\"Failed to link vertex and fragment shaders.\");\n}\nfunction he(t, e, n) {\n    if (Jt(t, e, function() {\n        return t.validateProgram(n);\n    }), !1 === t.getProgramParameter(n, t.VALIDATE_STATUS)) throw console.log(t.getProgramInfoLog(n)), new Error(\"Shader program validation failed.\");\n}\nfunction fe(t, e, n) {\n    var r = ke(t, e, function() {\n        return t.createBuffer();\n    }, \"Unable to create WebGLBuffer\");\n    return Jt(t, e, function() {\n        return t.bindBuffer(t.ARRAY_BUFFER, r);\n    }), Jt(t, e, function() {\n        return t.bufferData(t.ARRAY_BUFFER, n, t.STATIC_DRAW);\n    }), r;\n}\nfunction de(t, e, n) {\n    var r = ke(t, e, function() {\n        return t.createBuffer();\n    }, \"Unable to create WebGLBuffer\");\n    return Jt(t, e, function() {\n        return t.bindBuffer(t.ELEMENT_ARRAY_BUFFER, r);\n    }), Jt(t, e, function() {\n        return t.bufferData(t.ELEMENT_ARRAY_BUFFER, n, t.STATIC_DRAW);\n    }), r;\n}\nfunction pe(t, e) {\n    return ke(t, e, function() {\n        return t.createTexture();\n    }, \"Unable to create WebGLTexture.\");\n}\nfunction ve(t, e) {\n    var n = i().getNumber(\"WEBGL_MAX_TEXTURE_SIZE\");\n    if (t <= 0 || e <= 0) {\n        var r = \"[\" + t + \"x\" + e + \"]\";\n        throw new Error(\"Requested texture size \" + r + \" is invalid.\");\n    }\n    if (t > n || e > n) {\n        r = \"[\" + t + \"x\" + e + \"]\";\n        throw new Error(\"Requested texture size \" + r + \" greater than WebGL maximum on this browser / GPU \" + (\"[\" + n + \"x\" + n + \"]\") + \".\");\n    }\n}\nfunction me(t, e) {\n    return ke(t, e, function() {\n        return t.createFramebuffer();\n    }, \"Unable to create WebGLFramebuffer.\");\n}\nfunction ge(t, e, n, r, o, a, i, s) {\n    var u = t.getAttribLocation(n, r);\n    return -1 !== u && (Jt(t, e, function() {\n        return t.bindBuffer(t.ARRAY_BUFFER, o);\n    }), Jt(t, e, function() {\n        return t.vertexAttribPointer(u, a, t.FLOAT, !1, i, s);\n    }), Jt(t, e, function() {\n        return t.enableVertexAttribArray(u);\n    }), !0);\n}\nfunction ye(t, e, n, r) {\n    Se(t, r), Jt(t, e, function() {\n        return t.activeTexture(t.TEXTURE0 + r);\n    }), Jt(t, e, function() {\n        return t.bindTexture(t.TEXTURE_2D, n);\n    });\n}\nfunction xe(t, e, n, r) {\n    return ke(t, e, function() {\n        return t.getUniformLocation(n, r);\n    }, 'uniform \"' + r + '\" not present in program.');\n}\nfunction be(t, e, n) {\n    return t.getUniformLocation(e, n);\n}\nfunction we(t, e, n, r, o, a) {\n    Jt(t, e, function() {\n        return ye(t, e, r, a);\n    }), Jt(t, e, function() {\n        return t.uniform1i(o, a);\n    });\n}\nfunction Ce(t, e, n, r) {\n    Jt(t, e, function() {\n        return t.bindFramebuffer(t.FRAMEBUFFER, r);\n    }), Jt(t, e, function() {\n        return t.framebufferTexture2D(t.FRAMEBUFFER, t.COLOR_ATTACHMENT0, t.TEXTURE_2D, n, 0);\n    });\n}\nfunction Ee(t, e, n) {\n    Jt(t, e, function() {\n        return t.bindFramebuffer(t.FRAMEBUFFER, n);\n    }), Jt(t, e, function() {\n        return t.framebufferTexture2D(t.FRAMEBUFFER, t.COLOR_ATTACHMENT0, t.TEXTURE_2D, null, 0);\n    });\n}\nfunction Re(t) {\n    var e = t.checkFramebufferStatus(t.FRAMEBUFFER);\n    if (e !== t.FRAMEBUFFER_COMPLETE) throw new Error(\"Error binding framebuffer: \" + Ie(t, e));\n}\nfunction Ie(t, e) {\n    switch(e){\n        case t.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:\n            return \"FRAMEBUFFER_INCOMPLETE_ATTACHMENT\";\n        case t.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:\n            return \"FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT\";\n        case t.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:\n            return \"FRAMEBUFFER_INCOMPLETE_DIMENSIONS\";\n        case t.FRAMEBUFFER_UNSUPPORTED:\n            return \"FRAMEBUFFER_UNSUPPORTED\";\n        default:\n            return \"unknown error \" + e;\n    }\n}\nfunction ke(t, e, n, r) {\n    var o = Jt(t, e, function() {\n        return n();\n    });\n    if (null == o) throw new Error(r);\n    return o;\n}\nfunction Se(t, e) {\n    var n = t.MAX_COMBINED_TEXTURE_IMAGE_UNITS - 1, r = e + t.TEXTURE0;\n    if (r < t.TEXTURE0 || r > n) throw new Error(\"textureUnit must be in \" + (\"[gl.TEXTURE0, gl.TEXTURE\" + n + \"]\") + \".\");\n}\nfunction Ae(t, e) {\n    return void 0 === e && (e = 2), k(t.slice(0, t.length - e));\n}\nfunction De(t) {\n    if (0 === t.length) throw Error(\"Cannot get rows and columns of an empty shape array.\");\n    return [\n        t.length > 1 ? t[t.length - 2] : 1,\n        t[t.length - 1]\n    ];\n}\nfunction Te(t) {\n    var e = [\n        1,\n        1,\n        1\n    ];\n    return 0 === t.length || 1 === t.length && 1 === t[0] || (e = [\n        Ae(t)\n    ].concat(De(t))), e;\n}\nfunction Ne(t, e) {\n    var n;\n    void 0 === e && (e = !1);\n    var r = i().getNumber(\"WEBGL_MAX_TEXTURE_SIZE\");\n    if (e && (r *= 2, 1 === (t = t.map(function(e, n) {\n        return n >= t.length - 2 ? b(t[n]) : t[n];\n    })).length && (t = [\n        2,\n        t[0]\n    ])), 2 !== t.length) {\n        var o = M(t);\n        t = o.newShape;\n    }\n    var a = k(t);\n    if (t.length <= 1 && a <= r) return [\n        1,\n        a\n    ];\n    if (2 === t.length && t[0] <= r && t[1] <= r) return t;\n    if (3 === t.length && t[0] * t[1] <= r && t[2] <= r) return [\n        t[0] * t[1],\n        t[2]\n    ];\n    if (3 === t.length && t[0] <= r && t[1] * t[2] <= r) return [\n        t[0],\n        t[1] * t[2]\n    ];\n    if (4 === t.length && t[0] * t[1] * t[2] <= r && t[3] <= r) return [\n        t[0] * t[1] * t[2],\n        t[3]\n    ];\n    if (4 === t.length && t[0] <= r && t[1] * t[2] * t[3] <= r) return [\n        t[0],\n        t[1] * t[2] * t[3]\n    ];\n    if (e) {\n        var s = Ae(t), u = 2, c = 2;\n        return t.length && (u = (n = De(t))[0], c = n[1]), T(a = s * (u / 2) * (c / 2)).map(function(t) {\n            return 2 * t;\n        });\n    }\n    return T(a);\n}\nfunction Fe(t) {\n    return t % 2 == 0;\n}\nfunction _e(t, e) {\n    if (S(t = t.slice(-2), e = e.slice(-2))) return !0;\n    if (!t.length || !e.length) return !0;\n    if (0 === t[0] || 0 === t[1] || 0 === e[0] || 0 === e[1]) return !0;\n    if (t.length !== e.length) {\n        var n = t.slice(-1)[0], r = e.slice(-1)[0];\n        if (n === r) return !0;\n        if (Fe(n) && Fe(r) && (1 === t[0] || 1 === e[0])) return !0;\n    }\n    return t[1] === e[1] && Fe(t[0]) && Fe(e[0]);\n}\nfunction Oe(t) {\n    if (null == ie) {\n        var e = jt(t);\n        ie = e.getParameter(e.MAX_TEXTURE_SIZE);\n    }\n    return ie;\n}\nfunction Me(t) {\n    if (null == se) {\n        var e = jt(t);\n        se = e.getParameter(e.MAX_TEXTURE_IMAGE_UNITS);\n    }\n    return Math.min(16, se);\n}\nfunction Be(t) {\n    if (0 === t) return 0;\n    var e = jt(t);\n    return Pe(e, \"EXT_disjoint_timer_query_webgl2\") && 2 === t ? 2 : Pe(e, \"EXT_disjoint_timer_query\") ? 1 : 0;\n}\nfunction Pe(t, e) {\n    return null != t.getExtension(e);\n}\nfunction Le(t) {\n    try {\n        if (null != jt(t)) return !0;\n    } catch (t) {\n        return !1;\n    }\n    return !1;\n}\nfunction We(t) {\n    if (0 === t) return !1;\n    var e = jt(t);\n    if (1 === t) {\n        if (!Pe(e, \"OES_texture_float\")) return !1;\n    } else if (!Pe(e, \"EXT_color_buffer_float\")) return !1;\n    return Ve(e);\n}\nfunction Ue(t) {\n    if (0 === t) return !1;\n    var e = jt(t);\n    if (1 !== t) {\n        if (Pe(e, \"EXT_color_buffer_float\")) return Ve(e);\n        if (Pe(e, \"EXT_color_buffer_half_float\")) {\n            var n = e.getExtension(\"EXT_color_buffer_half_float\");\n            return function(t, e) {\n                var n = Qt(t, e), r = t.createTexture();\n                t.bindTexture(t.TEXTURE_2D, r);\n                t.texImage2D(t.TEXTURE_2D, 0, n.internalFormatHalfFloat, 1, 1, 0, n.textureFormatFloat, n.textureTypeHalfFloat, null);\n                var o = t.createFramebuffer();\n                t.bindFramebuffer(t.FRAMEBUFFER, o), t.framebufferTexture2D(t.FRAMEBUFFER, t.COLOR_ATTACHMENT0, t.TEXTURE_2D, r, 0);\n                var a = t.checkFramebufferStatus(t.FRAMEBUFFER) === t.FRAMEBUFFER_COMPLETE;\n                return t.bindTexture(t.TEXTURE_2D, null), t.bindFramebuffer(t.FRAMEBUFFER, null), t.deleteTexture(r), t.deleteFramebuffer(o), a;\n            }(e, n);\n        }\n        return !1;\n    }\n    return !!Pe(e, \"OES_texture_float\") && !!Pe(e, \"WEBGL_color_buffer_float\") && Ve(e);\n}\nfunction Ve(t) {\n    var e = Qt(t), n = t.createTexture();\n    t.bindTexture(t.TEXTURE_2D, n);\n    t.texImage2D(t.TEXTURE_2D, 0, e.internalFormatFloat, 1, 1, 0, e.textureFormatFloat, e.textureTypeFloat, null);\n    var r = t.createFramebuffer();\n    t.bindFramebuffer(t.FRAMEBUFFER, r), t.framebufferTexture2D(t.FRAMEBUFFER, t.COLOR_ATTACHMENT0, t.TEXTURE_2D, n, 0);\n    var o = t.checkFramebufferStatus(t.FRAMEBUFFER) === t.FRAMEBUFFER_COMPLETE;\n    return t.bindTexture(t.TEXTURE_2D, null), t.bindFramebuffer(t.FRAMEBUFFER, null), t.deleteTexture(n), t.deleteFramebuffer(r), o;\n}\nfunction ze(t) {\n    return 2 === t && null != jt(t).fenceSync;\n}\nvar Ge = Object.freeze({\n    callAndCheck: Jt,\n    canBeRepresented: ee,\n    getWebGLErrorMessage: ne,\n    getExtensionOrThrow: re,\n    createVertexShader: oe,\n    createFragmentShader: ae,\n    createProgram: ce,\n    linkProgram: le,\n    validateProgram: he,\n    createStaticVertexBuffer: fe,\n    createStaticIndexBuffer: de,\n    getNumChannels: function() {\n        return 2 === i().getNumber(\"WEBGL_VERSION\") ? 1 : 4;\n    },\n    createTexture: pe,\n    validateTextureSize: ve,\n    createFramebuffer: me,\n    bindVertexBufferToProgramAttribute: ge,\n    bindTextureUnit: ye,\n    unbindTextureUnit: function(t, e, n) {\n        Se(t, n), Jt(t, e, function() {\n            return t.activeTexture(t.TEXTURE0 + n);\n        }), Jt(t, e, function() {\n            return t.bindTexture(t.TEXTURE_2D, null);\n        });\n    },\n    getProgramUniformLocationOrThrow: xe,\n    getProgramUniformLocation: be,\n    bindTextureToProgramUniformSampler: we,\n    bindCanvasToFramebuffer: function(t, e) {\n        Jt(t, e, function() {\n            return t.bindFramebuffer(t.FRAMEBUFFER, null);\n        }), Jt(t, e, function() {\n            return t.viewport(0, 0, t.canvas.width, t.canvas.height);\n        }), Jt(t, e, function() {\n            return t.scissor(0, 0, t.canvas.width, t.canvas.height);\n        });\n    },\n    bindColorTextureToFramebuffer: Ce,\n    unbindColorTextureFromFramebuffer: Ee,\n    validateFramebuffer: Re,\n    getFramebufferErrorMessage: Ie,\n    getBatchDim: Ae,\n    getRowsCols: De,\n    getShapeAs3D: Te,\n    getTextureShapeFromLogicalShape: Ne,\n    isReshapeFree: _e,\n    getWebGLMaxTextureSize: Oe,\n    resetMaxTextureSize: function() {\n        ie = null;\n    },\n    resetMaxTexturesInShader: function() {\n        se = null;\n    },\n    getMaxTexturesInShader: Me,\n    getWebGLDisjointQueryTimerVersion: Be,\n    hasExtension: Pe,\n    isWebGLVersionEnabled: Le,\n    isCapableOfRenderingToFloatTexture: We,\n    isDownloadFloatTextureEnabled: Ue,\n    isWebGLFenceEnabled: ze\n}), He = i();\nfunction qe() {\n    i().set(\"PROD\", !0);\n}\nfunction Ke() {\n    i().set(\"DEBUG\", !0);\n}\nfunction je() {\n    i().set(\"DEPRECATION_WARNINGS_ENABLED\", !1), console.warn(\"TensorFlow.js deprecation warnings have been disabled.\");\n}\nfunction Xe(t) {\n    i().getBool(\"DEPRECATION_WARNINGS_ENABLED\") && console.warn(t + \" You can disable deprecation warnings with tf.disableDeprecationWarnings().\");\n}\nfunction Ye() {\n    Lt.disposeVariables();\n}\nfunction $e() {\n    return Lt;\n}\nfunction Qe() {\n    return Lt.memory();\n}\nfunction Je(t) {\n    return Lt.profile(t);\n}\nfunction Ze(t, e) {\n    return Lt.tidy(t, e);\n}\nfunction tn(t) {\n    _t(t).forEach(function(t) {\n        return t.dispose();\n    });\n}\nfunction en(t) {\n    return Lt.keep(t);\n}\nfunction nn(t) {\n    return Lt.time(t);\n}\nfunction rn(t) {\n    return Lt.setBackend(t);\n}\nfunction on() {\n    return Lt.ready();\n}\nfunction an() {\n    return Lt.backendName;\n}\nfunction sn(t) {\n    Lt.removeBackend(t);\n}\nfunction un(t) {\n    return Lt.findBackend(t);\n}\nfunction cn(t) {\n    return Lt.findBackendFactory(t);\n}\nfunction ln(t, e, n) {\n    return void 0 === n && (n = 1), Lt.registerBackend(t, e, n);\n}\nfunction hn() {\n    return Lt.backend;\n}\nfunction fn(t, e) {\n    i().setPlatform(t, e);\n}\nfunction dn() {\n    for(var t = [], e = 0; e < arguments.length; e++)t[e] = arguments[e];\n    i().getBool(\"IS_TEST\") || console.warn.apply(console, t);\n}\nfunction pn(t, e) {\n    var n = t;\n    if (V(t)) return \"string\" === e ? [] : [\n        t.length\n    ];\n    if (!Array.isArray(t)) return [];\n    for(var r = []; Array.isArray(n) || V(n) && \"string\" !== e;)r.push(n.length), n = n[0];\n    return Array.isArray(t) && i().getBool(\"TENSORLIKE_CHECK_SHAPE_CONSISTENCY\") && function t(e, n, r) {\n        if (r = r || [], !Array.isArray(e) && !V(e)) return void C(0 === n.length, function() {\n            return \"Element arr[\" + r.join(\"][\") + \"] is a primitive, but should be an array/TypedArray of \" + n[0] + \" elements\";\n        });\n        C(n.length > 0, function() {\n            return \"Element arr[\" + r.join(\"][\") + \"] should be a primitive, but is an array of \" + e.length + \" elements\";\n        }), C(e.length === n[0], function() {\n            return \"Element arr[\" + r.join(\"][\") + \"] should have \" + n[0] + \" elements, but has \" + e.length + \" elements\";\n        });\n        for(var o = n.slice(1), a = 0; a < e.length; ++a)t(e[a], o, r.concat(a));\n    }(t, r, []), r;\n}\nfunction vn(t, e, n, r) {\n    if (null != t && (\"numeric\" !== t && t !== e || \"numeric\" === t && \"string\" === e)) throw new Error(\"Argument '\" + n + \"' passed to '\" + r + \"' must be \" + t + \" tensor, but got \" + e + \" tensor\");\n}\nfunction mn(t, e, n, r) {\n    if (void 0 === r && (r = \"numeric\"), t instanceof wt) return vn(r, t.dtype, e, n), t;\n    var o = j(t);\n    if (\"string\" !== o && [\n        \"bool\",\n        \"int32\",\n        \"float32\"\n    ].indexOf(r) >= 0 && (o = r), vn(r, o, e, n), null == t || !V(t) && !Array.isArray(t) && \"number\" != typeof t && \"boolean\" != typeof t && \"string\" != typeof t) {\n        var a = null == t ? \"null\" : t.constructor.name;\n        throw new Error(\"Argument '\" + e + \"' passed to '\" + n + \"' must be a Tensor or TensorLike, but got '\" + a + \"'\");\n    }\n    var s = pn(t, o);\n    V(t) || Array.isArray(t) || (t = [\n        t\n    ]);\n    var u = \"string\" !== o ? Q(t, o, i().getBool(\"DEBUG\")) : I(t, [], !0);\n    return Lt.makeTensor(u, s, o);\n}\nfunction gn(t, e, n, r) {\n    if (void 0 === r && (r = \"numeric\"), !Array.isArray(t)) throw new Error(\"Argument \" + e + \" passed to \" + n + \" must be a `Tensor[]` or `TensorLike[]`\");\n    return t.map(function(t, r) {\n        return mn(t, e + \"[\" + r + \"]\", n);\n    }, r);\n}\nfunction yn(t, e) {\n    for(var n = 0; n < t.length; ++n)if (t[t.length - n - 1] !== e - 1 - n) return !1;\n    return !0;\n}\nfunction xn(t, e, n) {\n    for(var r = t.length + e.length, o = [], a = 0, i = 0, s = 0; s < r; s++)-1 === n.indexOf(s) ? o.push(t[a++]) : o.push(e[i++]);\n    return o;\n}\nfunction bn(t, e) {\n    for(var n = [], r = t.length, o = 0; o < r; o++)-1 === e.indexOf(o) && n.push(t[o]);\n    return [\n        n,\n        e.map(function(e) {\n            return t[e];\n        })\n    ];\n}\nfunction wn(t, e) {\n    return xn(t, e.map(function(t) {\n        return 1;\n    }), e);\n}\nfunction Cn(t, e, n) {\n    C(yn(e, n), function() {\n        return t + \" supports only inner-most axes for now. Got axes \" + e + \" and rank-\" + n + \" input.\";\n    });\n}\nfunction En(t, e) {\n    if (yn(t, e)) return null;\n    for(var n = [], r = 0; r < e; ++r)-1 === t.indexOf(r) && n.push(r);\n    return t.forEach(function(t) {\n        return n.push(t);\n    }), n;\n}\nfunction Rn(t) {\n    return t.map(function(t, e) {\n        return [\n            e,\n            t\n        ];\n    }).sort(function(t, e) {\n        return t[1] - e[1];\n    }).map(function(t) {\n        return t[0];\n    });\n}\nfunction In(t, e) {\n    for(var n = [], r = e - t; r < e; ++r)n.push(r);\n    return n;\n}\nfunction kn(t, e) {\n    var n = t[0].length;\n    t.forEach(function(t, e) {\n        C(t.length === n, function() {\n            return \"Error in concat\" + n + \"D: rank of tensors[\" + e + \"] must be the same as the rank of the rest (\" + n + \")\";\n        });\n    }), C(e >= 0 && e < n, function() {\n        return \"Error in concat\" + n + \"D: axis must be between 0 and \" + (n - 1) + \".\";\n    });\n    var r = t[0];\n    t.forEach(function(t, o) {\n        for(var a = 0; a < n; a++)C(a === e || t[a] === r[a], function() {\n            return \"Error in concat\" + n + \"D: Shape of tensors[\" + o + \"] (\" + t + \") does not match the shape of the rest (\" + r + \") along the non-concatenated axis \" + o + \".\";\n        });\n    });\n}\nfunction Sn(t, e) {\n    for(var n = t[0].slice(), r = 1; r < t.length; r++)n[e] += t[r][e];\n    return n;\n}\nfunction An(t) {\n    var e = Object.keys(t);\n    if (1 !== e.length) throw new Error(\"Please provide an object with a single key (operation name) mapping to a function. Got an object with \" + e.length + \" keys.\");\n    var n = e[0], r = t[n];\n    n.endsWith(\"_\") && (n = n.substring(0, n.length - 1));\n    var o = function() {\n        for(var t = [], e = 0; e < arguments.length; e++)t[e] = arguments[e];\n        Lt.startScope(n);\n        try {\n            var o = r.apply(void 0, t);\n            return o instanceof Promise && console.error(\"Cannot return a Promise inside of tidy.\"), Lt.endScope(o), o;\n        } catch (t) {\n            throw Lt.endScope(null), t;\n        }\n    };\n    return Object.defineProperty(o, \"name\", {\n        value: n,\n        configurable: !0\n    }), o;\n}\nHe.registerFlag(\"HAS_WEBGL\", function() {\n    return He.getNumber(\"WEBGL_VERSION\") > 0;\n}), He.registerFlag(\"WEBGL_VERSION\", function() {\n    return Le(2) ? 2 : Le(1) ? 1 : 0;\n}), He.registerFlag(\"WEBGL_BUFFER_SUPPORTED\", function() {\n    return 2 === He.get(\"WEBGL_VERSION\");\n}), He.registerFlag(\"WEBGL_CPU_FORWARD\", function() {\n    return !0;\n}), He.registerFlag(\"WEBGL_FORCE_F16_TEXTURES\", function() {\n    return !1;\n}), He.registerFlag(\"WEBGL_PACK\", function() {\n    return He.getBool(\"HAS_WEBGL\");\n}), He.registerFlag(\"WEBGL_PACK_NORMALIZATION\", function() {\n    return He.getBool(\"WEBGL_PACK\");\n}), He.registerFlag(\"WEBGL_PACK_CLIP\", function() {\n    return He.getBool(\"WEBGL_PACK\");\n}), He.registerFlag(\"WEBGL_PACK_DEPTHWISECONV\", function() {\n    return !1;\n}), He.registerFlag(\"WEBGL_PACK_BINARY_OPERATIONS\", function() {\n    return He.getBool(\"WEBGL_PACK\");\n}), He.registerFlag(\"WEBGL_PACK_UNARY_OPERATIONS\", function() {\n    return He.getBool(\"WEBGL_PACK\");\n}), He.registerFlag(\"WEBGL_PACK_ARRAY_OPERATIONS\", function() {\n    return He.getBool(\"WEBGL_PACK\");\n}), He.registerFlag(\"WEBGL_PACK_IMAGE_OPERATIONS\", function() {\n    return He.getBool(\"WEBGL_PACK\");\n}), He.registerFlag(\"WEBGL_PACK_REDUCE\", function() {\n    return He.getBool(\"WEBGL_PACK\");\n}), He.registerFlag(\"WEBGL_LAZILY_UNPACK\", function() {\n    return He.getBool(\"WEBGL_PACK\");\n}), He.registerFlag(\"WEBGL_CONV_IM2COL\", function() {\n    return He.getBool(\"WEBGL_PACK\");\n}), He.registerFlag(\"WEBGL_MAX_TEXTURE_SIZE\", function() {\n    return Oe(He.getNumber(\"WEBGL_VERSION\"));\n}), He.registerFlag(\"WEBGL_MAX_TEXTURES_IN_SHADER\", function() {\n    return Me(He.getNumber(\"WEBGL_VERSION\"));\n}), He.registerFlag(\"WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION\", function() {\n    var t = He.getNumber(\"WEBGL_VERSION\");\n    return 0 === t ? 0 : Be(t);\n}), He.registerFlag(\"WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE\", function() {\n    return He.getNumber(\"WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION\") > 0 && (t = navigator.userAgent || navigator.vendor || window.opera, !(/(android|bb\\d+|meego).+mobile|avantgo|bada\\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(t) || /1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\\-(n|u)|c55\\/|capi|ccwa|cdm\\-|cell|chtm|cldc|cmd\\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\\-s|devi|dica|dmob|do(c|p)o|ds(12|\\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\\-|_)|g1 u|g560|gene|gf\\-5|g\\-mo|go(\\.w|od)|gr(ad|un)|haie|hcit|hd\\-(m|p|t)|hei\\-|hi(pt|ta)|hp( i|ip)|hs\\-c|ht(c(\\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\\-(20|go|ma)|i230|iac( |\\-|\\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\\/)|klon|kpt |kwc\\-|kyo(c|k)|le(no|xi)|lg( g|\\/(k|l|u)|50|54|\\-[a-w])|libw|lynx|m1\\-w|m3ga|m50\\/|ma(te|ui|xo)|mc(01|21|ca)|m\\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\\-2|po(ck|rt|se)|prox|psio|pt\\-g|qa\\-a|qc(07|12|21|32|60|\\-[2-7]|i\\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\\-|oo|p\\-)|sdk\\/|se(c(\\-|0|1)|47|mc|nd|ri)|sgh\\-|shar|sie(\\-|m)|sk\\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\\-|v\\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\\-|tdg\\-|tel(i|m)|tim\\-|t\\-mo|to(pl|sh)|ts(70|m\\-|m3|m5)|tx\\-9|up(\\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\\-|your|zeto|zte\\-/i.test(t.substr(0, 4))));\n    var t;\n}), He.registerFlag(\"WEBGL_RENDER_FLOAT32_CAPABLE\", function() {\n    return We(He.getNumber(\"WEBGL_VERSION\"));\n}), He.registerFlag(\"WEBGL_RENDER_FLOAT32_ENABLED\", function() {\n    return !He.getBool(\"WEBGL_FORCE_F16_TEXTURES\") && He.getBool(\"WEBGL_RENDER_FLOAT32_CAPABLE\");\n}), He.registerFlag(\"WEBGL_DOWNLOAD_FLOAT_ENABLED\", function() {\n    return Ue(He.getNumber(\"WEBGL_VERSION\"));\n}), He.registerFlag(\"WEBGL_FENCE_API_ENABLED\", function() {\n    return ze(He.getNumber(\"WEBGL_VERSION\"));\n}), He.registerFlag(\"WEBGL_SIZE_UPLOAD_UNIFORM\", function() {\n    return He.getBool(\"WEBGL_RENDER_FLOAT32_ENABLED\") ? 4 : 0;\n}), bt = Xe;\nvar Dn = An({\n    complex_: function(t, e) {\n        var n = mn(t, \"real\", \"complex\"), r = mn(e, \"imag\", \"complex\");\n        return E(n.shape, r.shape, \"real and imag shapes, \" + n.shape + \" and \" + r.shape + \", must match in call to tf.complex().\"), Lt.runKernelFunc(function(t) {\n            return t.complex(n, r);\n        }, {\n            $real: n,\n            $imag: r\n        });\n    }\n}), Tn = An({\n    real_: function(t) {\n        var e = mn(t, \"input\", \"real\");\n        return Lt.runKernelFunc(function(t) {\n            return t.real(e);\n        }, {\n            $input: e\n        });\n    }\n}), Nn = An({\n    imag_: function(t) {\n        var e = mn(t, \"input\", \"imag\");\n        return Lt.runKernelFunc(function(t) {\n            return t.imag(e);\n        }, {\n            $input: e\n        });\n    }\n});\nfunction Fn(t, e, n) {\n    return _n(t, e, pn(t, n), n);\n}\nfunction _n(t, e, n, r) {\n    if (null == r && (r = j(t)), \"complex64\" === r) throw new Error(\"Cannot construct a complex64 tensor directly. Please use tf.complex(real, imag).\");\n    if (!V(t) && !Array.isArray(t) && \"number\" != typeof t && \"boolean\" != typeof t && \"string\" != typeof t) throw new Error(\"values passed to tensor(values) must be a number/boolean/string or an array of numbers/booleans/strings, or a TypedArray\");\n    if (null != e) {\n        nt(e);\n        var o = k(e), a = k(n);\n        C(o === a, function() {\n            return \"Based on the provided shape, [\" + e + \"], the tensor should have \" + o + \" values but has \" + a;\n        });\n        for(var s = 0; s < n.length; ++s){\n            var u = n[s], c = s !== n.length - 1 || u !== k(e.slice(s));\n            C(n[s] === e[s] || !c, function() {\n                return \"Error creating a new Tensor. Inferred shape (\" + n + \") does not match the provided shape (\" + e + \"). \";\n            });\n        }\n    }\n    return V(t) || Array.isArray(t) || (t = [\n        t\n    ]), e = e || n, t = \"string\" !== r ? Q(t, r, i().getBool(\"DEBUG\")) : I(t, [], !0), Lt.makeTensor(t, e, r);\n}\nfunction On(t, e) {\n    if ((V(t) && \"string\" !== e || Array.isArray(t)) && \"complex64\" !== e) throw new Error(\"Error creating a new Scalar: value must be a primitive (number|boolean|string)\");\n    if (\"string\" === e && V(t) && !(t instanceof Uint8Array)) throw new Error(\"When making a scalar from encoded string, the value must be `Uint8Array`.\");\n    return _n(t, [], [], e);\n}\nfunction Mn(t, e) {\n    R(t);\n    var n = pn(t, e);\n    if (1 !== n.length) throw new Error(\"tensor1d() requires values to be a flat/TypedArray\");\n    return _n(t, null, n, e);\n}\nfunction Bn(t, e, n) {\n    if (R(t), null != e && 2 !== e.length) throw new Error(\"tensor2d() requires shape to have two numbers\");\n    var r = pn(t, n);\n    if (2 !== r.length && 1 !== r.length) throw new Error(\"tensor2d() requires values to be number[][] or flat/TypedArray\");\n    if (1 === r.length && null == e) throw new Error(\"tensor2d() requires shape to be provided when `values` are a flat/TypedArray\");\n    return _n(t, e, r, n);\n}\nfunction Pn(t, e, n) {\n    if (R(t), null != e && 3 !== e.length) throw new Error(\"tensor3d() requires shape to have three numbers\");\n    var r = pn(t, n);\n    if (3 !== r.length && 1 !== r.length) throw new Error(\"tensor3d() requires values to be number[][][] or flat/TypedArray\");\n    if (1 === r.length && null == e) throw new Error(\"tensor3d() requires shape to be provided when `values` are a flat array\");\n    return _n(t, e, r, n);\n}\nfunction Ln(t, e, n) {\n    if (R(t), null != e && 4 !== e.length) throw new Error(\"tensor4d() requires shape to have four numbers\");\n    var r = pn(t, n);\n    if (4 !== r.length && 1 !== r.length) throw new Error(\"tensor4d() requires values to be number[][][][] or flat/TypedArray\");\n    if (1 === r.length && null == e) throw new Error(\"tensor4d() requires shape to be provided when `values` are a flat array\");\n    return _n(t, e, r, n);\n}\nfunction Wn(t, e, n) {\n    if (R(t), null != e && 5 !== e.length) throw new Error(\"tensor5d() requires shape to have five numbers\");\n    var r = pn(t, n);\n    if (5 !== r.length && 1 !== r.length) throw new Error(\"tensor5d() requires values to be number[][][][][] or flat/TypedArray\");\n    if (1 === r.length && null == e) throw new Error(\"tensor5d() requires shape to be provided when `values` are a flat array\");\n    return _n(t, e, r, n);\n}\nfunction Un(t, e, n) {\n    if (R(t), null != e && 6 !== e.length) throw new Error(\"tensor6d() requires shape to have six numbers\");\n    var r = pn(t, n);\n    if (6 !== r.length && 1 !== r.length) throw new Error(\"tensor6d() requires values to be number[][][][][][] or flat/TypedArray\");\n    if (1 === r.length && null == e) throw new Error(\"tensor6d() requires shape to be provided when `values` are a flat array\");\n    return _n(t, e = e || r, r, n);\n}\nfunction Vn(t, e, n, r) {\n    return void 0 === e && (e = !0), Lt.makeVariable(t, e, n, r);\n}\nfunction zn(t, e) {\n    if (void 0 === e && (e = \"float32\"), \"complex64\" === e) {\n        var n = zn(t, \"float32\"), r = Gn(t, \"float32\");\n        return Dn(n, r);\n    }\n    var o = Z(k(t), e);\n    return Lt.makeTensor(o, t, e);\n}\nfunction Gn(t, e) {\n    if (void 0 === e && (e = \"float32\"), \"complex64\" === e) {\n        var n = Gn(t, \"float32\"), r = Gn(t, \"float32\");\n        return Dn(n, r);\n    }\n    var o = tt(k(t), e);\n    return Lt.makeTensor(o, t, e);\n}\nfunction Hn(t, e, n) {\n    return Lt.runKernelFunc(function(r) {\n        return r.fill(t, e, n);\n    }, {});\n}\nfunction qn(t, e, n) {\n    if (n <= 0) throw new Error(\"The number of values should be positive.\");\n    return Lt.runKernelFunc(function(r) {\n        return r.linspace(t, e, n);\n    }, {});\n}\nfunction Kn(t, e, n, r) {\n    if (void 0 === n && (n = 1), void 0 === r && (r = \"float32\"), 0 === n) throw new Error(\"Cannot have a step of zero\");\n    if (t === e || t < e && n < 0 || e < t && n > 1) return Gn([\n        0\n    ], r);\n    var o = tt(Math.abs(Math.ceil((e - t) / n)), r);\n    e < t && 1 === n && (n = -1), o[0] = t;\n    for(var a = 1; a < o.length; a++)o[a] = o[a - 1] + n;\n    return Mn(o, r);\n}\nvar jn = An({\n    onesLike_: function(t) {\n        var e = mn(t, \"x\", \"onesLike\");\n        if (\"complex64\" === e.dtype) {\n            var n = jn(Tn(e)), r = Xn(Nn(e));\n            return Dn(n, r);\n        }\n        return Lt.runKernelFunc(function(t) {\n            return t.onesLike(e);\n        }, {\n            $x: e\n        }, function(t, e) {\n            return {\n                $x: function() {\n                    return Xn(t);\n                }\n            };\n        });\n    }\n}), Xn = An({\n    zerosLike_: function(t) {\n        var e = mn(t, \"x\", \"zerosLike\");\n        return Lt.runKernelFunc(function(t) {\n            return t.zerosLike(e);\n        }, {\n            $x: e\n        }, function(t, e) {\n            return {\n                $x: function() {\n                    return Xn(t);\n                }\n            };\n        });\n    }\n});\nvar Yn = An({\n    concat_: function(t, e) {\n        void 0 === e && (e = 0), C(t.length >= 1, function() {\n            return \"Pass at least one tensor to concat\";\n        });\n        var n = gn(t, \"tensors\", \"concat\");\n        \"complex64\" === n[0].dtype && n.forEach(function(t) {\n            if (\"complex64\" !== t.dtype) throw new Error(\"Cannot concatenate complex64 tensors with a tensor\\n          with dtype \" + t.dtype + \". \");\n        }), e = O(e, n[0].shape)[0];\n        var r = Sn(n.map(function(t) {\n            return t.shape;\n        }), e);\n        if (0 === k(r)) return Fn([], r);\n        if (1 === (n = n.filter(function(t) {\n            return t.size > 0;\n        })).length) return n[0];\n        var o = n.map(function(t) {\n            return t.shape;\n        });\n        kn(o, e);\n        var a = n, i = {\n            axis: e\n        };\n        return Lt.runKernelFunc(function(t) {\n            return t.concat(n, e);\n        }, a, function(t) {\n            var n = o.map(function(t) {\n                return t[e];\n            });\n            return tr(t, n, e).map(function(t) {\n                return function() {\n                    return t;\n                };\n            });\n        }, \"Concat\", i);\n    }\n}), $n = An({\n    concat1d_: function(t) {\n        return Yn(t, 0);\n    }\n}), Qn = An({\n    concat2d_: function(t, e) {\n        return Yn(t, e);\n    }\n}), Jn = An({\n    concat3d_: function(t, e) {\n        return Yn(t, e);\n    }\n}), Zn = An({\n    concat4d_: function(t, e) {\n        return Yn(t, e);\n    }\n}), tr = An({\n    split_: function(t, e, n) {\n        void 0 === n && (n = 0);\n        var r, o = mn(t, \"x\", \"split\");\n        return n = O(n, o.shape)[0], \"number\" == typeof e ? (C(o.shape[n] % e == 0, function() {\n            return \"Number of splits must evenly divide the axis.\";\n        }), r = new Array(e).fill(o.shape[n] / e)) : (C(o.shape[n] === e.reduce(function(t, e) {\n            return t + e;\n        }), function() {\n            return \"The sum of sizes must match the size of the axis dimension.\";\n        }), r = e), Lt.runKernelFunc(function(t) {\n            return t.split(o, r, n);\n        }, {\n            $x: o\n        }, function(t) {\n            return {\n                $x: function() {\n                    return Yn(t, n);\n                }\n            };\n        });\n    }\n});\n\"undefined\" != typeof globalThis ? globalThis :  false ? 0 : \"undefined\" != typeof global ? global : \"undefined\" != typeof self && self;\nfunction er(t, e) {\n    return t(e = {\n        exports: {}\n    }, e.exports), e.exports;\n}\nvar nr = er(function(t) {\n    !function(t, e, n) {\n        function r(t) {\n            var e, n = this, r = (e = 4022871197, function(t) {\n                t = t.toString();\n                for(var n = 0; n < t.length; n++){\n                    var r = .02519603282416938 * (e += t.charCodeAt(n));\n                    r -= e = r >>> 0, e = (r *= e) >>> 0, e += 4294967296 * (r -= e);\n                }\n                return 2.3283064365386963e-10 * (e >>> 0);\n            });\n            n.next = function() {\n                var t = 2091639 * n.s0 + 2.3283064365386963e-10 * n.c;\n                return n.s0 = n.s1, n.s1 = n.s2, n.s2 = t - (n.c = 0 | t);\n            }, n.c = 1, n.s0 = r(\" \"), n.s1 = r(\" \"), n.s2 = r(\" \"), n.s0 -= r(t), n.s0 < 0 && (n.s0 += 1), n.s1 -= r(t), n.s1 < 0 && (n.s1 += 1), n.s2 -= r(t), n.s2 < 0 && (n.s2 += 1), r = null;\n        }\n        function o(t, e) {\n            return e.c = t.c, e.s0 = t.s0, e.s1 = t.s1, e.s2 = t.s2, e;\n        }\n        function a(t, e) {\n            var n = new r(t), a = e && e.state, i = n.next;\n            return i.int32 = function() {\n                return 4294967296 * n.next() | 0;\n            }, i.double = function() {\n                return i() + 11102230246251565e-32 * (2097152 * i() | 0);\n            }, i.quick = i, a && (\"object\" == typeof a && o(a, n), i.state = function() {\n                return o(n, {});\n            }), i;\n        }\n        e && e.exports ? e.exports = a : n && n.amd ? n(function() {\n            return a;\n        }) : this.alea = a;\n    }(0, t, !1);\n}), rr = er(function(t) {\n    !function(t, e, n) {\n        function r(t) {\n            var e = this, n = \"\";\n            e.x = 0, e.y = 0, e.z = 0, e.w = 0, e.next = function() {\n                var t = e.x ^ e.x << 11;\n                return e.x = e.y, e.y = e.z, e.z = e.w, e.w ^= e.w >>> 19 ^ t ^ t >>> 8;\n            }, t === (0 | t) ? e.x = t : n += t;\n            for(var r = 0; r < n.length + 64; r++)e.x ^= 0 | n.charCodeAt(r), e.next();\n        }\n        function o(t, e) {\n            return e.x = t.x, e.y = t.y, e.z = t.z, e.w = t.w, e;\n        }\n        function a(t, e) {\n            var n = new r(t), a = e && e.state, i = function() {\n                return (n.next() >>> 0) / 4294967296;\n            };\n            return i.double = function() {\n                do {\n                    var t = ((n.next() >>> 11) + (n.next() >>> 0) / 4294967296) / (1 << 21);\n                }while (0 === t);\n                return t;\n            }, i.int32 = n.next, i.quick = i, a && (\"object\" == typeof a && o(a, n), i.state = function() {\n                return o(n, {});\n            }), i;\n        }\n        e && e.exports ? e.exports = a : n && n.amd ? n(function() {\n            return a;\n        }) : this.xor128 = a;\n    }(0, t, !1);\n}), or = er(function(t) {\n    !function(t, e, n) {\n        function r(t) {\n            var e = this, n = \"\";\n            e.next = function() {\n                var t = e.x ^ e.x >>> 2;\n                return e.x = e.y, e.y = e.z, e.z = e.w, e.w = e.v, (e.d = e.d + 362437 | 0) + (e.v = e.v ^ e.v << 4 ^ t ^ t << 1) | 0;\n            }, e.x = 0, e.y = 0, e.z = 0, e.w = 0, e.v = 0, t === (0 | t) ? e.x = t : n += t;\n            for(var r = 0; r < n.length + 64; r++)e.x ^= 0 | n.charCodeAt(r), r == n.length && (e.d = e.x << 10 ^ e.x >>> 4), e.next();\n        }\n        function o(t, e) {\n            return e.x = t.x, e.y = t.y, e.z = t.z, e.w = t.w, e.v = t.v, e.d = t.d, e;\n        }\n        function a(t, e) {\n            var n = new r(t), a = e && e.state, i = function() {\n                return (n.next() >>> 0) / 4294967296;\n            };\n            return i.double = function() {\n                do {\n                    var t = ((n.next() >>> 11) + (n.next() >>> 0) / 4294967296) / (1 << 21);\n                }while (0 === t);\n                return t;\n            }, i.int32 = n.next, i.quick = i, a && (\"object\" == typeof a && o(a, n), i.state = function() {\n                return o(n, {});\n            }), i;\n        }\n        e && e.exports ? e.exports = a : n && n.amd ? n(function() {\n            return a;\n        }) : this.xorwow = a;\n    }(0, t, !1);\n}), ar = er(function(t) {\n    !function(t, e, n) {\n        function r(t) {\n            var e = this;\n            e.next = function() {\n                var t, n, r = e.x, o = e.i;\n                return t = r[o], n = (t ^= t >>> 7) ^ t << 24, n ^= (t = r[o + 1 & 7]) ^ t >>> 10, n ^= (t = r[o + 3 & 7]) ^ t >>> 3, n ^= (t = r[o + 4 & 7]) ^ t << 7, t = r[o + 7 & 7], n ^= (t ^= t << 13) ^ t << 9, r[o] = n, e.i = o + 1 & 7, n;\n            }, function(t, e) {\n                var n, r = [];\n                if (e === (0 | e)) r[0] = e;\n                else for(e = \"\" + e, n = 0; n < e.length; ++n)r[7 & n] = r[7 & n] << 15 ^ e.charCodeAt(n) + r[n + 1 & 7] << 13;\n                for(; r.length < 8;)r.push(0);\n                for(n = 0; n < 8 && 0 === r[n]; ++n);\n                for(8 == n ? r[7] = -1 : r[n], t.x = r, t.i = 0, n = 256; n > 0; --n)t.next();\n            }(e, t);\n        }\n        function o(t, e) {\n            return e.x = t.x.slice(), e.i = t.i, e;\n        }\n        function a(t, e) {\n            null == t && (t = +new Date);\n            var n = new r(t), a = e && e.state, i = function() {\n                return (n.next() >>> 0) / 4294967296;\n            };\n            return i.double = function() {\n                do {\n                    var t = ((n.next() >>> 11) + (n.next() >>> 0) / 4294967296) / (1 << 21);\n                }while (0 === t);\n                return t;\n            }, i.int32 = n.next, i.quick = i, a && (a.x && o(a, n), i.state = function() {\n                return o(n, {});\n            }), i;\n        }\n        e && e.exports ? e.exports = a : n && n.amd ? n(function() {\n            return a;\n        }) : this.xorshift7 = a;\n    }(0, t, !1);\n}), ir = er(function(t) {\n    !function(t, e, n) {\n        function r(t) {\n            var e = this;\n            e.next = function() {\n                var t, n, r = e.w, o = e.X, a = e.i;\n                return e.w = r = r + 1640531527 | 0, n = o[a + 34 & 127], t = o[a = a + 1 & 127], n ^= n << 13, t ^= t << 17, n ^= n >>> 15, t ^= t >>> 12, n = o[a] = n ^ t, e.i = a, n + (r ^ r >>> 16) | 0;\n            }, function(t, e) {\n                var n, r, o, a, i, s = [], u = 128;\n                for(e === (0 | e) ? (r = e, e = null) : (e += \"\\x00\", r = 0, u = Math.max(u, e.length)), o = 0, a = -32; a < u; ++a)e && (r ^= e.charCodeAt((a + 32) % e.length)), 0 === a && (i = r), r ^= r << 10, r ^= r >>> 15, r ^= r << 4, r ^= r >>> 13, a >= 0 && (i = i + 1640531527 | 0, o = 0 == (n = s[127 & a] ^= r + i) ? o + 1 : 0);\n                for(o >= 128 && (s[127 & (e && e.length || 0)] = -1), o = 127, a = 512; a > 0; --a)r = s[o + 34 & 127], n = s[o = o + 1 & 127], r ^= r << 13, n ^= n << 17, r ^= r >>> 15, n ^= n >>> 12, s[o] = r ^ n;\n                t.w = i, t.X = s, t.i = o;\n            }(e, t);\n        }\n        function o(t, e) {\n            return e.i = t.i, e.w = t.w, e.X = t.X.slice(), e;\n        }\n        function a(t, e) {\n            null == t && (t = +new Date);\n            var n = new r(t), a = e && e.state, i = function() {\n                return (n.next() >>> 0) / 4294967296;\n            };\n            return i.double = function() {\n                do {\n                    var t = ((n.next() >>> 11) + (n.next() >>> 0) / 4294967296) / (1 << 21);\n                }while (0 === t);\n                return t;\n            }, i.int32 = n.next, i.quick = i, a && (a.X && o(a, n), i.state = function() {\n                return o(n, {});\n            }), i;\n        }\n        e && e.exports ? e.exports = a : n && n.amd ? n(function() {\n            return a;\n        }) : this.xor4096 = a;\n    }(0, t, !1);\n}), sr = er(function(t) {\n    !function(t, e, n) {\n        function r(t) {\n            var e = this, n = \"\";\n            e.next = function() {\n                var t = e.b, n = e.c, r = e.d, o = e.a;\n                return t = t << 25 ^ t >>> 7 ^ n, n = n - r | 0, r = r << 24 ^ r >>> 8 ^ o, o = o - t | 0, e.b = t = t << 20 ^ t >>> 12 ^ n, e.c = n = n - r | 0, e.d = r << 16 ^ n >>> 16 ^ o, e.a = o - t | 0;\n            }, e.a = 0, e.b = 0, e.c = -1640531527, e.d = 1367130551, t === Math.floor(t) ? (e.a = t / 4294967296 | 0, e.b = 0 | t) : n += t;\n            for(var r = 0; r < n.length + 20; r++)e.b ^= 0 | n.charCodeAt(r), e.next();\n        }\n        function o(t, e) {\n            return e.a = t.a, e.b = t.b, e.c = t.c, e.d = t.d, e;\n        }\n        function a(t, e) {\n            var n = new r(t), a = e && e.state, i = function() {\n                return (n.next() >>> 0) / 4294967296;\n            };\n            return i.double = function() {\n                do {\n                    var t = ((n.next() >>> 11) + (n.next() >>> 0) / 4294967296) / (1 << 21);\n                }while (0 === t);\n                return t;\n            }, i.int32 = n.next, i.quick = i, a && (\"object\" == typeof a && o(a, n), i.state = function() {\n                return o(n, {});\n            }), i;\n        }\n        e && e.exports ? e.exports = a : n && n.amd ? n(function() {\n            return a;\n        }) : this.tychei = a;\n    }(0, t, !1);\n}), ur = er(function(t) {\n    !function(e, n) {\n        var r, o = this, a = 256, i = 6, s = \"random\", u = n.pow(a, i), c = n.pow(2, 52), l = 2 * c, h = a - 1;\n        function f(t, h, f) {\n            var g = [], y = v(function t(e, n) {\n                var r, o = [], a = typeof e;\n                if (n && \"object\" == a) for(r in e)try {\n                    o.push(t(e[r], n - 1));\n                } catch (t) {}\n                return o.length ? o : \"string\" == a ? e : e + \"\\x00\";\n            }((h = 1 == h ? {\n                entropy: !0\n            } : h || {}).entropy ? [\n                t,\n                m(e)\n            ] : null == t ? function() {\n                try {\n                    var t;\n                    return r && (t = r.randomBytes) ? t = t(a) : (t = new Uint8Array(a), (o.crypto || o.msCrypto).getRandomValues(t)), m(t);\n                } catch (t) {\n                    var n = o.navigator, i = n && n.plugins;\n                    return [\n                        +new Date,\n                        o,\n                        i,\n                        o.screen,\n                        m(e)\n                    ];\n                }\n            }() : t, 3), g), x = new d(g), b = function() {\n                for(var t = x.g(i), e = u, n = 0; t < c;)t = (t + n) * a, e *= a, n = x.g(1);\n                for(; t >= l;)t /= 2, e /= 2, n >>>= 1;\n                return (t + n) / e;\n            };\n            return b.int32 = function() {\n                return 0 | x.g(4);\n            }, b.quick = function() {\n                return x.g(4) / 4294967296;\n            }, b.double = b, v(m(x.S), e), (h.pass || f || function(t, e, r, o) {\n                return o && (o.S && p(o, x), t.state = function() {\n                    return p(x, {});\n                }), r ? (n[s] = t, e) : t;\n            })(b, y, \"global\" in h ? h.global : this == n, h.state);\n        }\n        function d(t) {\n            var e, n = t.length, r = this, o = 0, i = r.i = r.j = 0, s = r.S = [];\n            for(n || (t = [\n                n++\n            ]); o < a;)s[o] = o++;\n            for(o = 0; o < a; o++)s[o] = s[i = h & i + t[o % n] + (e = s[o])], s[i] = e;\n            (r.g = function(t) {\n                for(var e, n = 0, o = r.i, i = r.j, s = r.S; t--;)e = s[o = h & o + 1], n = n * a + s[h & (s[o] = s[i = h & i + e]) + (s[i] = e)];\n                return r.i = o, r.j = i, n;\n            })(a);\n        }\n        function p(t, e) {\n            return e.i = t.i, e.j = t.j, e.S = t.S.slice(), e;\n        }\n        function v(t, e) {\n            for(var n, r = t + \"\", o = 0; o < r.length;)e[h & o] = h & (n ^= 19 * e[h & o]) + r.charCodeAt(o++);\n            return m(e);\n        }\n        function m(t) {\n            return String.fromCharCode.apply(0, t);\n        }\n        if (n[\"seed\" + s] = f, v(n.random(), e), t.exports) {\n            t.exports = f;\n            try {\n                r = __webpack_require__(/*! crypto */ \"crypto\");\n            } catch (t) {}\n        }\n    }([], Math);\n});\nur.alea = nr, ur.xor128 = rr, ur.xorwow = or, ur.xorshift7 = ar, ur.xor4096 = ir, ur.tychei = sr;\nvar cr = ur.alea, lr = function() {\n    function t(t, e, n, r, o) {\n        this.mean = t, this.stdDev = e, this.dtype = n, this.nextVal = NaN, this.truncated = r, this.truncated && (this.upper = this.mean + 2 * this.stdDev, this.lower = this.mean - 2 * this.stdDev);\n        var a = o || Math.random();\n        this.random = cr(a.toString());\n    }\n    return t.prototype.nextValue = function() {\n        if (!isNaN(this.nextVal)) {\n            var t = this.nextVal;\n            return this.nextVal = NaN, t;\n        }\n        for(var e, n, r = !1; !r;){\n            var o = void 0, a = void 0, i = void 0;\n            do {\n                i = (o = 2 * this.random() - 1) * o + (a = 2 * this.random() - 1) * a;\n            }while (i >= 1 || 0 === i);\n            var s = Math.sqrt(-2 * Math.log(i) / i);\n            e = this.mean + this.stdDev * o * s, n = this.mean + this.stdDev * a * s, this.truncated && !this.isValidTruncated(e) || (r = !0);\n        }\n        return this.truncated && !this.isValidTruncated(n) || (this.nextVal = this.convertValue(n)), this.convertValue(e);\n    }, t.prototype.convertValue = function(t) {\n        return null == this.dtype || \"float32\" === this.dtype ? t : Math.round(t);\n    }, t.prototype.isValidTruncated = function(t) {\n        return t <= this.upper && t >= this.lower;\n    }, t;\n}(), hr = function() {\n    function t(t, e, n, r) {\n        this.alpha = t, this.beta = 1 / e, this.dtype = n;\n        var o = r || Math.random();\n        this.randu = cr(o.toString()), this.randn = new lr(0, 1, n, !1, this.randu()), this.d = t < 1 ? t + 2 / 3 : t - 1 / 3, this.c = 1 / Math.sqrt(9 * this.d);\n    }\n    return t.prototype.nextValue = function() {\n        for(var t, e, n, r, o, a;;){\n            do {\n                r = this.randn.nextValue(), a = 1 + this.c * r;\n            }while (a <= 0);\n            if (a *= a * a, e = 1 - .331 * (t = r * r) * t, n = .5 * t + this.d * (1 - a + Math.log(a)), (o = this.randu()) < e || Math.log(o) < n) break;\n        }\n        return a = 1 / this.beta * this.d * a, this.alpha < 1 && (a *= Math.pow(this.randu(), 1 / this.alpha)), this.convertValue(a);\n    }, t.prototype.convertValue = function(t) {\n        return \"float32\" === this.dtype ? t : Math.round(t);\n    }, t;\n}(), fr = function() {\n    function t(t, e, n, r) {\n        var o = this;\n        if (void 0 === t && (t = 0), void 0 === e && (e = 1), this.canReturnFloat = function() {\n            return null == o.dtype || \"float32\" === o.dtype;\n        }, this.min = t, this.range = e - t, this.dtype = n, null == r && (r = Math.random()), \"number\" == typeof r && (r = r.toString()), !this.canReturnFloat() && this.range <= 1) throw new Error(\"The difference between \" + t + \" - \" + e + \" <= 1 and dtype is not float\");\n        this.random = cr(r);\n    }\n    return t.prototype.convertValue = function(t) {\n        return this.canReturnFloat() ? t : Math.round(t);\n    }, t.prototype.nextValue = function() {\n        return this.convertValue(this.min + this.range * this.random());\n    }, t;\n}();\nfunction dr(t, e, n) {\n    return void 0 === e && (e = \"float32\"), e = e || \"float32\", nt(t), new gt(t, e, n);\n}\nfunction pr(t, e) {\n    void 0 === e && (e = !1), console.log(t.toString(e));\n}\nvar vr = An({\n    batchToSpaceND_: function(t, e, n) {\n        var r = mn(t, \"x\", \"batchToSpaceND\"), o = e.reduce(function(t, e) {\n            return t * e;\n        });\n        return C(r.rank >= 1 + e.length, function() {\n            return \"input rank is \" + r.rank + \" but should be > than blockShape.length \" + e.length;\n        }), C(n.length === e.length, function() {\n            return \"crops.length is \" + n.length + \" but should be equal to blockShape.length  \" + e.length;\n        }), C(r.shape[0] % o == 0, function() {\n            return \"input tensor batch is \" + r.shape[0] + \" but is not divisible by the product of the elements of blockShape \" + e.join(\" * \") + \" === \" + o;\n        }), Lt.runKernelFunc(function(t) {\n            return t.batchToSpaceND(r, e, n);\n        }, {\n            $x: r\n        }, function(t) {\n            return {\n                $x: function() {\n                    return t.spaceToBatchND(e, n);\n                }\n            };\n        });\n    }\n}), mr = An({\n    broadcastTo_: function(t, e) {\n        var n = mn(t, \"broadcastTo\", \"x\"), r = n.shape;\n        if (e.some(function(t) {\n            return !(t > 0) || t % 1 != 0;\n        })) throw new Error(\"broadcastTo(): Invalid broadcast shape [\" + e + \"].\");\n        if (e.length < n.rank) throw new Error(\"broadcastTo(): shape.length=\" + e.length + \" < input.rank=\" + n.rank + \".\");\n        if (e.length > n.rank) {\n            for(var o = n.shape.slice(); o.length < e.length;)o.unshift(1);\n            n = n.reshape(o);\n        }\n        for(var a = Array.from(e), i = e.length - 1; i >= 0; i--)if (n.shape[i] === e[i]) a[i] = 1;\n        else if (1 !== n.shape[i]) throw new Error(\"broadcastTo(): [\" + r + \"] cannot be broadcast to [\" + e + \"].\");\n        var s = a.map(function(t, e) {\n            return t > 1 ? e : -1;\n        }).filter(function(t) {\n            return t >= 0;\n        });\n        return 0 === s.length ? n.clone() : Lt.runKernelFunc(function(t) {\n            return t.tile(n, a);\n        }, {\n            input: n\n        }, function(t) {\n            return {\n                input: function() {\n                    return t.sum(s, !0);\n                }\n            };\n        });\n    }\n}), gr = An({\n    cast_: function(t, e) {\n        var n = mn(t, \"x\", \"cast\");\n        if (!W(e)) throw new Error(\"Failed to cast to unknown dtype \" + e);\n        if (\"string\" === e && \"string\" !== n.dtype || \"string\" !== e && \"string\" === n.dtype) throw new Error(\"Only strings can be casted to strings\");\n        var r = {\n            dtype: e\n        };\n        return Lt.runKernelFunc(function(t) {\n            return t.cast(n, e);\n        }, {\n            x: n\n        }, function(t) {\n            return {\n                x: function() {\n                    return t.clone();\n                }\n            };\n        }, \"Cast\", r);\n    }\n}), yr = An({\n    clone_: function(t) {\n        var e = mn(t, \"x\", \"clone\", null);\n        return Lt.runKernelFunc(function() {\n            return Lt.makeTensorFromDataId(e.dataId, e.shape, e.dtype);\n        }, {\n            $x: e\n        }, function(t) {\n            return {\n                $x: function() {\n                    return t.toFloat();\n                }\n            };\n        });\n    }\n}), xr = An({\n    cumsum_: function(t, e, n, r) {\n        void 0 === e && (e = 0), void 0 === n && (n = !1), void 0 === r && (r = !1);\n        var o = mn(t, \"x\", \"cumsum\"), a = En([\n            e |= 0\n        ], o.rank), i = o;\n        null != a && (i = o.transpose(a));\n        var s = In(1, o.rank)[0], u = Lt.runKernelFunc(function(t) {\n            return t.cumsum(i, s, n, r);\n        }, {\n            permutedX: i\n        }, function(t) {\n            return {\n                permutedX: function() {\n                    return t.cumsum(e, n, !r);\n                }\n            };\n        });\n        return null != a && (u = u.transpose(a)), u;\n    }\n}), br = An({\n    depthToSpace_: function(t, e, n) {\n        void 0 === n && (n = \"NHWC\");\n        var r = mn(t, \"x\", \"depthToSpace\"), o = \"NHWC\" === n ? r.shape[1] : r.shape[2], a = \"NHWC\" === n ? r.shape[2] : r.shape[3], i = \"NHWC\" === n ? r.shape[3] : r.shape[1];\n        return C(o * e >= 0, function() {\n            return \"Negative dimension size caused by overflow when multiplying\\n      \" + o + \" and \" + e + \"  for depthToSpace with input shape\\n      \" + r.shape;\n        }), C(a * e >= 0, function() {\n            return \"Negative dimension size caused by overflow when multiplying\\n      \" + a + \" and \" + e + \" for depthToSpace with input shape\\n          \" + r.shape;\n        }), C(i % (e * e) == 0, function() {\n            return \"Dimension size must be evenly divisible by \" + e * e + \" but is \" + i + \" for depthToSpace with input shape \" + r.shape;\n        }), Lt.runKernelFunc(function(t) {\n            return t.depthToSpace(r, e, n);\n        }, {\n            $x: r\n        });\n    }\n}), wr = An({\n    expandDims_: function(t, e) {\n        void 0 === e && (e = 0);\n        var n = mn(t, \"x\", \"expandDims\", null);\n        C(e <= n.rank, function() {\n            return \"Axis must be <= rank of the tensor\";\n        });\n        var r = n.shape.slice();\n        return e < 0 && (C(-(n.rank + 1) <= e, function() {\n            return \"Axis must be in the interval [\" + -(n.rank + 1) + \", \" + n.rank + \"]\";\n        }), e = n.rank + e + 1), r.splice(e, 0, 1), Or(n, r);\n    }\n}), Cr = An({\n    eye_: function(t, e, n, r) {\n        void 0 === r && (r = \"float32\"), null == e && (e = t);\n        for(var o = dr([\n            t,\n            e\n        ], r), a = t <= e ? t : e, i = 0; i < a; ++i)o.set(1, i, i);\n        var s = o.toTensor().as2D(t, e);\n        if (null == n) return s;\n        if (1 === n.length) return Lr(wr(s, 0), [\n            n[0],\n            1,\n            1\n        ]);\n        if (2 === n.length) return Lr(wr(wr(s, 0), 0), [\n            n[0],\n            n[1],\n            1,\n            1\n        ]);\n        if (3 === n.length) return Lr(wr(wr(wr(s, 0), 0), 0), [\n            n[0],\n            n[1],\n            n[2],\n            1,\n            1\n        ]);\n        throw new Error(\"eye() currently supports only 1D and 2D batchShapes, but received \" + n.length + \"D.\");\n    }\n}), Er = An({\n    multinomial_: function(t, e, n, r) {\n        void 0 === r && (r = !1);\n        var o = mn(t, \"logits\", \"multinomial\"), a = o.size, i = o.rank;\n        if (a < 2) throw new Error(\"Error in multinomial: you need at least 2 outcomes, but got \" + a + \".\");\n        if (i > 2) throw new Error(\"Rank of probabilities must be 1 or 2, but is \" + i);\n        n = n || Math.random();\n        var s = 1 === i ? o.as2D(1, -1) : o, u = Lt.runKernelFunc(function(t) {\n            return t.multinomial(s, r, e, n);\n        }, {\n            logits2D: s\n        });\n        return 1 === i ? u.as1D() : u;\n    }\n}), Rr = An({\n    oneHot_: function(t, e, n, r) {\n        if (void 0 === n && (n = 1), void 0 === r && (r = 0), e < 2) throw new Error(\"Error in oneHot: depth must be >=2, but it is \" + e);\n        var o = mn(t, \"indices\", \"oneHot\", \"int32\"), a = o.shape.concat([\n            e\n        ]);\n        return o = o.flatten(), Lt.runKernelFunc(function(t) {\n            return t.oneHot(o, e, n, r);\n        }, {\n            $indices: o\n        }, function(t) {\n            return {\n                $indices: function() {\n                    return Gn(o.shape, \"float32\");\n                }\n            };\n        }).reshape(a);\n    }\n}), Ir = An({\n    pad_: function(t, e, n) {\n        void 0 === n && (n = 0);\n        var r = mn(t, \"x\", \"pad\");\n        if (0 === r.rank) throw new Error(\"pad(scalar) is not defined. Pass non-scalar to pad\");\n        var o = {\n            paddings: e,\n            constantValue: n\n        };\n        return Lt.runKernelFunc(function(t) {\n            return t.pad(r, e, n);\n        }, {\n            x: r\n        }, function(t) {\n            var n = e.map(function(t) {\n                return t[0];\n            });\n            return {\n                x: function() {\n                    return t.slice(n, r.shape);\n                }\n            };\n        }, \"PadV2\", o);\n    }\n}), kr = An({\n    pad1d_: function(t, e, n) {\n        return void 0 === n && (n = 0), C(2 === e.length, function() {\n            return \"Invalid number of paddings. Must be length of 2.\";\n        }), Ir(t, [\n            e\n        ], n);\n    }\n}), Sr = An({\n    pad2d_: function(t, e, n) {\n        return void 0 === n && (n = 0), C(2 === e.length && 2 === e[0].length && 2 === e[1].length, function() {\n            return \"Invalid number of paddings. Must be length of 2 each.\";\n        }), Ir(t, e, n);\n    }\n}), Ar = An({\n    pad3d_: function(t, e, n) {\n        return void 0 === n && (n = 0), C(3 === e.length && 2 === e[0].length && 2 === e[1].length && 2 === e[2].length, function() {\n            return \"Invalid number of paddings. Must be length of 2 each.\";\n        }), Ir(t, e, n);\n    }\n}), Dr = An({\n    pad4d_: function(t, e, n) {\n        return void 0 === n && (n = 0), C(4 === e.length && 2 === e[0].length && 2 === e[1].length && 2 === e[2].length && 2 === e[3].length, function() {\n            return \"Invalid number of paddings. Must be length of 2 each.\";\n        }), Ir(t, e, n);\n    }\n}), Tr = An({\n    rand_: function(t, e, n) {\n        var r = k(t), o = null;\n        if (null == n || \"float32\" === n) o = new Float32Array(r);\n        else if (\"int32\" === n) o = new Int32Array(r);\n        else {\n            if (\"bool\" !== n) throw new Error(\"Unknown data type \" + n);\n            o = new Uint8Array(r);\n        }\n        for(var a = 0; a < r; a++)o[a] = e();\n        return Lt.makeTensor(o, t, n);\n    }\n}), Nr = An({\n    randomNormal_: function(t, e, n, r, o) {\n        if (void 0 === e && (e = 0), void 0 === n && (n = 1), null != r && \"bool\" === r) throw new Error(\"Unsupported data type \" + r);\n        for(var a = new lr(e, n, r, !1, o), i = dr(t, r), s = 0; s < i.values.length; s++)i.values[s] = a.nextValue();\n        return i.toTensor();\n    }\n}), Fr = An({\n    randomGamma_: function(t, e, n, r, o) {\n        if (void 0 === n && (n = 1), void 0 === r && (r = \"float32\"), null == n && (n = 1), null == r && (r = \"float32\"), \"float32\" !== r && \"int32\" !== r) throw new Error(\"Unsupported data type \" + r);\n        for(var a = new hr(e, n, r, o), i = dr(t, r), s = 0; s < i.values.length; s++)i.values[s] = a.nextValue();\n        return i.toTensor();\n    }\n}), _r = An({\n    randomUniform_: function(t, e, n, r, o) {\n        void 0 === e && (e = 0), void 0 === n && (n = 1), void 0 === r && (r = \"float32\");\n        for(var a = dr(t, r), i = new fr(e, n, null, o), s = 0; s < a.values.length; s++)a.values[s] = i.nextValue();\n        return a.toTensor();\n    }\n}), Or = An({\n    reshape_: function(t, e) {\n        var n = mn(t, \"x\", \"reshape\", null);\n        e = _(e, n.size), C(n.size === k(e), function() {\n            return \"new shape and old shape must have the same number of elements.\";\n        });\n        var r = {\n            shape: e\n        };\n        return Lt.runKernelFunc(function(t) {\n            return t.reshape(n, e);\n        }, {\n            x: n\n        }, function(t) {\n            return {\n                x: function() {\n                    return t.reshape(n.shape);\n                }\n            };\n        }, \"Reshape\", r);\n    }\n}), Mr = An({\n    spaceToBatchND_: function(t, e, n) {\n        var r = mn(t, \"x\", \"spaceToBatchND\");\n        return C(r.rank >= 1 + e.length, function() {\n            return \"input rank \" + r.rank + \" should be > than [blockShape] \" + e.length;\n        }), C(n.length === e.length, function() {\n            return \"paddings.shape[0] \" + n.length + \" must be equal to [blockShape] \" + e.length;\n        }), C(r.shape.reduce(function(t, r, o) {\n            return o > 0 && o <= e.length ? t && (r + n[o - 1][0] + n[o - 1][1]) % e[o - 1] == 0 : t;\n        }, !0), function() {\n            return \"input spatial dimensions \" + r.shape.slice(1) + \" with paddings \" + n.toString() + \" must be divisible by blockShapes \" + e.toString();\n        }), Lt.runKernelFunc(function(t) {\n            return t.spaceToBatchND(r, e, n);\n        }, {\n            $x: r\n        }, function(t) {\n            return {\n                $x: function() {\n                    return t.batchToSpaceND(e, n);\n                }\n            };\n        });\n    }\n}), Br = An({\n    squeeze_: function(t, e) {\n        var n = mn(t, \"x\", \"squeeze\");\n        return Or(n, M(n.shape, e).newShape);\n    }\n}), Pr = An({\n    stack_: function(t, e) {\n        void 0 === e && (e = 0);\n        var n = gn(t, \"tensors\", \"stack\");\n        if (C(n.length >= 1, function() {\n            return \"Pass at least one tensor to tf.stack\";\n        }), 1 === n.length) return n[0].expandDims(e);\n        var r = n[0].rank, o = n[0].shape, a = n[0].dtype;\n        C(e <= r, function() {\n            return \"Axis must be <= rank of the tensor\";\n        }), n.forEach(function(t) {\n            E(o, t.shape, \"All tensors passed to stack must have matching shapes\");\n        }), n.forEach(function(t) {\n            C(a === t.dtype, function() {\n                return \"All tensors passed to stack must have matching dtypes\";\n            });\n        });\n        var i = n.map(function(t) {\n            return t.expandDims(e);\n        });\n        return Yn(i, e);\n    }\n}), Lr = An({\n    tile_: function(t, e) {\n        var n = mn(t, \"x\", \"tile\", null);\n        C(n.rank === e.length, function() {\n            return \"Error in transpose: rank of input \" + n.rank + \" must match length of reps \" + e + \".\";\n        });\n        var r = [\n            n\n        ], o = {\n            reps: e\n        };\n        return Lt.runKernelFunc(function(t, r) {\n            var o = t.tile(n, e);\n            return r([\n                n\n            ]), o;\n        }, {\n            x: n\n        }, function(t, n) {\n            var r = n[0];\n            return {\n                x: function() {\n                    var n = Xn(r);\n                    if (1 === r.rank) for(var o = 0; o < e[0]; ++o)n = n.add(t.slice([\n                        o * r.shape[0]\n                    ], [\n                        r.shape[0]\n                    ]));\n                    else if (2 === r.rank) for(o = 0; o < e[0]; ++o)for(var a = 0; a < e[1]; ++a)n = n.add(t.slice([\n                        o * r.shape[0],\n                        a * r.shape[1]\n                    ], [\n                        r.shape[0],\n                        r.shape[1]\n                    ]));\n                    else if (3 === r.rank) for(o = 0; o < e[0]; ++o)for(a = 0; a < e[1]; ++a)for(var i = 0; i < e[2]; ++i)n = n.add(t.slice([\n                        o * r.shape[0],\n                        a * r.shape[1],\n                        i * r.shape[2]\n                    ], [\n                        r.shape[0],\n                        r.shape[1],\n                        r.shape[2]\n                    ]));\n                    else {\n                        if (4 !== r.rank) throw new Error(\"Gradient for tile operation is not implemented for rank-\" + r.rank + \" tensors yet.\");\n                        for(o = 0; o < e[0]; ++o)for(a = 0; a < e[1]; ++a)for(i = 0; i < e[2]; ++i)for(var s = 0; s < e[3]; ++s)n = n.add(t.slice([\n                            o * r.shape[0],\n                            a * r.shape[1],\n                            i * r.shape[2],\n                            s * r.shape[3]\n                        ], [\n                            r.shape[0],\n                            r.shape[1],\n                            r.shape[2],\n                            r.shape[3]\n                        ]));\n                    }\n                    return n;\n                }\n            };\n        }, \"Tile\", o, r);\n    }\n}), Wr = An({\n    truncatedNormal_: function(t, e, n, r, o) {\n        if (void 0 === e && (e = 0), void 0 === n && (n = 1), null != r && \"bool\" === r) throw new Error(\"Unsupported data type \" + r);\n        for(var a = new lr(e, n, r, !0, o), i = dr(t, r), s = 0; s < i.values.length; s++)i.values[s] = a.nextValue();\n        return i.toTensor();\n    }\n}), Ur = An({\n    unstack_: function(t, e) {\n        void 0 === e && (e = 0), e = e || 0;\n        var n = mn(t, \"x\", \"unstack\");\n        C(e >= -n.shape.length && e < n.shape.length, function() {\n            return \"Axis = \" + e + \" is not in [-\" + n.shape.length + \", \" + n.shape.length + \")\";\n        }), e < 0 && (e += n.shape.length);\n        var r = {\n            axis: e\n        };\n        return Lt.runKernelFunc(function(t) {\n            return t.unstack(n, e);\n        }, {\n            x: n\n        }, function(t) {\n            return {\n                x: function() {\n                    return Pr(t, e);\n                }\n            };\n        }, \"Unpack\", r);\n    }\n}), Vr = function(t, e) {\n    return n(this, void 0, void 0, function() {\n        var n, o, a, i, s, u, c, l, h, f;\n        return r(this, function(r) {\n            switch(r.label){\n                case 0:\n                    return n = mn(t, \"x\", \"setdiff1d\"), o = mn(e, \"y\", \"setdiff1d\"), C(n.dtype === o.dtype, function() {\n                        return \"x and y should have the same dtype, but got x (\" + n.dtype + \") and y (\" + o.dtype + \").\";\n                    }), C(1 === n.rank, function() {\n                        return \"x should be 1D tensor, but got x (\" + n.shape + \").\";\n                    }), C(1 === o.rank, function() {\n                        return \"y should be 1D tensor, but got y (\" + o.shape + \").\";\n                    }), [\n                        4,\n                        n.data()\n                    ];\n                case 1:\n                    return a = r.sent(), [\n                        4,\n                        o.data()\n                    ];\n                case 2:\n                    for(i = r.sent(), s = new Set(i), u = 0, h = 0; h < a.length; h++)s.has(a[h]) || u++;\n                    for(c = new gt([\n                        u\n                    ], n.dtype), l = new gt([\n                        u\n                    ], \"int32\"), h = 0, f = 0; h < a.length; h++)s.has(a[h]) || (c.values[f] = a[h], l.values[f] = h, f++);\n                    return [\n                        2,\n                        [\n                            c.toTensor(),\n                            l.toTensor()\n                        ]\n                    ];\n            }\n        });\n    });\n};\nfunction zr(t, e, n, r) {\n    void 0 === r && (r = !0);\n    var o = [];\n    if (r) (o = o.concat(e.slice(0))).push(t[0] / n), o = o.concat(t.slice(1));\n    else {\n        o = o.concat(t[0]);\n        for(var a = e.length, i = 0; i < a; ++i)o = o.concat([\n            t[i + 1] / e[i],\n            e[i]\n        ]);\n        o = o.concat(t.slice(a + 1));\n    }\n    return o;\n}\nfunction Gr(t, e, n) {\n    void 0 === n && (n = !0);\n    var r = [];\n    if (n) {\n        r.push(e);\n        for(var o = e + 1; o < t; ++o)o <= 2 * e ? (r.push(o), r.push(o - (e + 1))) : r.push(o);\n    } else {\n        var a = [], i = [];\n        for(o = 1; o < t; ++o)o >= 2 * e + 1 || o % 2 == 1 ? i.push(o) : a.push(o);\n        r.push.apply(r, a), r.push(0), r.push.apply(r, i);\n    }\n    return r;\n}\nfunction Hr(t, e, n, r) {\n    void 0 === r && (r = !0);\n    var o = [];\n    r ? o.push(t[0] / n) : o.push(t[0] * n);\n    for(var a = 1; a < t.length; ++a)a <= e.length ? r ? o.push(e[a - 1] * t[a]) : o.push(t[a] / e[a - 1]) : o.push(t[a]);\n    return o;\n}\nfunction qr(t, e) {\n    for(var n = [\n        0\n    ], r = 0; r < e; ++r)n.push(t[r][0]);\n    return n;\n}\nfunction Kr(t, e, n) {\n    for(var r = t.slice(0, 1), o = 0; o < n; ++o)r.push(t[o + 1] - e[o][0] - e[o][1]);\n    return r;\n}\nfunction jr(t, e) {\n    if (t.rank < 1) throw new Error(\"tf.gatherND() expects the input to be rank 1 or higher, but the rank was \" + t.rank + \".\");\n    if (e.rank < 1) throw new Error(\"tf.gatherND() expects the indices to be rank 1 or higher, but the rank was \" + e.rank + \".\");\n    if (\"int32\" !== e.dtype) throw new Error(\"tf.gatherND() expects the indices to be int32 type, but the dtype was \" + e.dtype + \".\");\n    if (e.shape[e.rank - 1] > t.rank) throw new Error(\"index innermost dimension length must be <= tensor rank; saw: \" + e.shape[e.rank - 1] + \" vs. \" + t.rank);\n    if (0 === t.size) throw new Error(\"Requested more than 0 entries, but input is empty. Input shape: \" + t.shape + \".\");\n    for(var n = e.shape, r = n[n.length - 1], o = 1, a = 0; a < n.length - 1; ++a)o *= n[a];\n    var i = t.shape, s = n.slice();\n    s.pop();\n    var u = 1;\n    for(a = r; a < t.rank; ++a)u *= i[a], s.push(i[a]);\n    var c = $(t.shape).map(function(t) {\n        return t / u;\n    }).concat([\n        1\n    ]).slice(0, r);\n    return [\n        s,\n        o,\n        u,\n        c\n    ];\n}\nvar Xr = Object.freeze({\n    prepareAndValidate: jr\n}), Yr = 30;\nfunction $r(t) {\n    return t <= Yr ? t : Y(t, Math.floor(Math.sqrt(t)));\n}\nfunction Qr(t, e, n) {\n    var r = e.rank > 1 ? e.shape[e.rank - 1] : 1, o = e.rank > 1 ? e.rank - 1 : 1, a = \"Must have updates.shape = indices.shape[:batchDim] + shape[sliceDim:], got updates.shape: \" + n.shape + \", indices.shape: \" + e.shape + \", shape: \" + t + \", sliceDim: \" + r + \", and batchDim: \" + o + \".\";\n    if (n.rank < o) throw new Error(a + \" update.rank < \" + o + \". \");\n    if (t.length < r + (n.rank - o)) throw new Error(a + \" Output shape length < \" + (r + (n.rank - o)));\n    if (n.rank !== o + t.length - r) throw new Error(a + \" update.rank != \" + (o + t.length - r));\n    for(var i = 0; i < o; ++i)if (n.shape[i] !== e.shape[i]) throw new Error(a + \" updates.shape[\" + i + \"] (\" + n.shape[i] + \") != indices.shape[\" + i + \"] (\" + e.shape[i] + \").\");\n    for(i = 0; i < n.rank - o; ++i)if (n.shape[i + o] !== t[i + r]) throw new Error(a + \" updates.shape[\" + (i + o) + \"] (\" + n.shape[i + o] + \") != shape[\" + (i + o) + \"] (\" + t[i + o] + \")\");\n}\nfunction Jr(t, e, n) {\n    if (e.rank < 1) throw new Error(\"tf.scatterND() expects the indices to be rank 1 or higher, but the rank was \" + e.rank + \".\");\n    if (t.rank < 1) throw new Error(\"tf.scatterND() expects the updates to be rank 1 or higher, but the rank was \" + t.rank + \".\");\n    if (\"int32\" !== e.dtype) throw new Error(\"The dtype of 'indices' should be int32, but got dtype: \" + e.dtype);\n    if (n.length < 1) throw new Error(\"Output rank must be greater or equal to 1, but got shape: \" + n);\n    if (0 === n.length) {\n        if (0 === e.size) throw new Error(\"Indices specified for empty output. indices shape: \" + e.shape);\n        if (0 === t.size) throw new Error(\"Updates specified for empty output. updates shape: \" + t.shape);\n    }\n    Qr(n, e, t);\n}\nfunction Zr(t, e, n) {\n    for(var r = e.shape.length, o = r > 1 ? e.shape[r - 1] : 1, a = n.length, i = 1, s = o; s < a; ++s)i *= n[s];\n    var u = o < 1 ? 1 : o;\n    return {\n        sliceRank: o,\n        numUpdates: k(e.shape) / u,\n        sliceSize: i,\n        strides: $(n.slice(0, o)).concat([\n            1\n        ]),\n        outputSize: k(n)\n    };\n}\nvar to = Object.freeze({\n    validateUpdateShape: Qr,\n    validateInput: Jr,\n    calculateShapes: Zr\n});\nfunction eo(t, e, n) {\n    C(t.rank === e.length, function() {\n        return \"Error in slice\" + t.rank + \"D: Length of begin \" + e + \" must match the rank of the array (\" + t.rank + \").\";\n    }), C(t.rank === n.length, function() {\n        return \"Error in slice\" + t.rank + \"D: Length of size \" + n + \" must match the rank of the array (\" + t.rank + \").\";\n    });\n    for(var r = function(r) {\n        C(e[r] + n[r] <= t.shape[r], function() {\n            return \"Error in slice\" + t.rank + \"D: begin[\" + r + \"] + size[\" + r + \"] (\" + (e[r] + n[r]) + \") would overflow input.shape[\" + r + \"] (\" + t.shape[r] + \")\";\n        });\n    }, o = 0; o < t.rank; ++o)r(o);\n}\nfunction no(t) {\n    for(var e = [], n = 0; t > 0;)1 & t && e.push(n), t /= 2, n++;\n    return e;\n}\nfunction ro(t, e, n) {\n    for(var r = [], o = 0; o < t.length; o++)r[o] = Math.ceil((e[o] - t[o]) / n[o]);\n    return r;\n}\nfunction oo(t, e, n, r, o) {\n    var a = e[o], i = n[o] || 1;\n    (t & 1 << o || null == a) && (a = i > 0 ? Number.MIN_SAFE_INTEGER : Number.MAX_SAFE_INTEGER);\n    var s = r[o];\n    return a < 0 && (a += s), a = x(0, a, s - 1);\n}\nfunction ao(t, e, n, r, o) {\n    var a = e[o], i = n[o] || 1;\n    (t & 1 << o || null == a) && (a = i > 0 ? Number.MAX_SAFE_INTEGER : Number.MIN_SAFE_INTEGER);\n    var s = r[o];\n    return a < 0 && (a += s), a = i > 0 ? x(0, a, s) : x(-1, a, s - 1);\n}\nfunction io(t, e, n) {\n    for(var r = n.length, o = 0; o < n.length; o++)if (n[o] > 1) {\n        r = o;\n        break;\n    }\n    for(o = r + 1; o < n.length; o++)if (e[o] > 0 || n[o] !== t[o]) return !1;\n    return !0;\n}\nfunction so(t, e) {\n    for(var n = t.length > 0 ? t[t.length - 1] : 1, r = 0; r < t.length - 1; r++)n += t[r] * e[r];\n    return n;\n}\nvar uo = Object.freeze({\n    assertParamsValid: eo,\n    maskToAxes: no,\n    computeOutShape: ro,\n    startForAxis: oo,\n    stopForAxis: ao,\n    isSliceContinous: io,\n    computeFlatOffset: so\n});\nfunction co(t) {\n    return C(X(t), function() {\n        return \"The f passed in grad(f) must be a function\";\n    }), function(e, n) {\n        var r = mn(e, \"x\", \"tf.grad\", null), o = null != n ? mn(n, \"dy\", \"tf.grad\") : null;\n        return Lt.tidy(function() {\n            var e = Lt.gradients(function() {\n                return t(r);\n            }, [\n                r\n            ], o), n = e.value, a = e.grads;\n            return null != o && E(n.shape, o.shape, \"The shape of dy passed in grad(f)(x, dy) must match the shape returned by f(x)\"), mo(a), a[0];\n        });\n    };\n}\nfunction lo(t) {\n    return C(X(t), function() {\n        return \"The f passed in grads(f) must be a function\";\n    }), function(e, n) {\n        C(Array.isArray(e), function() {\n            return \"The args passed in grads(f)(args) must be an array of `Tensor`s or `TensorLike`s\";\n        });\n        var r = gn(e, \"args\", \"tf.grads\", null), o = null != n ? mn(n, \"dy\", \"tf.grads\") : null;\n        return Lt.tidy(function() {\n            var e = Lt.gradients(function() {\n                return t.apply(void 0, r);\n            }, r, o), n = e.value, a = e.grads;\n            return null != o && E(n.shape, o.shape, \"The shape of dy passed in grads(f)([x1,...], dy) must match the shape returned by f([x1,...])\"), mo(a), a;\n        });\n    };\n}\nfunction ho(t) {\n    return C(X(t), function() {\n        return \"The f passed in valueAndGrad(f) must be a function\";\n    }), function(e, n) {\n        C(e instanceof wt, function() {\n            return \"The x passed in valueAndGrad(f)(x) must be a tensor\";\n        }), C(null == n || n instanceof wt, function() {\n            return \"The dy passed in valueAndGrad(f)(x, dy) must be a tensor\";\n        });\n        var r = Lt.gradients(function() {\n            return t(e);\n        }, [\n            e\n        ], n), o = r.grads, a = r.value;\n        return mo(o), {\n            grad: o[0],\n            value: a\n        };\n    };\n}\nfunction fo(t) {\n    return C(X(t), function() {\n        return \"The f passed in valueAndGrads(f) must be a function\";\n    }), function(e, n) {\n        C(Array.isArray(e) && e.every(function(t) {\n            return t instanceof wt;\n        }), function() {\n            return \"The args passed in valueAndGrads(f)(args) must be array of tensors\";\n        }), C(null == n || n instanceof wt, function() {\n            return \"The dy passed in valueAndGrads(f)(args, dy) must be a tensor\";\n        });\n        var r = Lt.gradients(function() {\n            return t.apply(void 0, e);\n        }, e, n);\n        return null != n && E(r.value.shape, n.shape, \"The shape of dy passed in valueAndGrads(f)([x1,...], dy) must match the shape returned by f([x1,...])\"), mo(r.grads), r;\n    };\n}\nfunction po(t, e) {\n    C(X(t), function() {\n        return \"The f passed in variableGrads(f) must be a function\";\n    }), C(null == e || Array.isArray(e) && e.every(function(t) {\n        return t instanceof St;\n    }), function() {\n        return \"The varList passed in variableGrads(f, varList) must be an array of variables\";\n    });\n    var n = null != e;\n    if (!n) for(var r in e = [], Lt.registeredVariables)e.push(Lt.registeredVariables[r]);\n    var o = n ? e.filter(function(t) {\n        return !t.trainable;\n    }) : null, a = e.length;\n    C((e = e.filter(function(t) {\n        return t.trainable;\n    })).length > 0, function() {\n        return \"variableGrads() expects at least one of the input variables to be trainable, but none of the \" + a + \" variables is trainable.\";\n    });\n    var i = Lt.gradients(t, e, null, !0), s = i.value, u = i.grads;\n    C(u.some(function(t) {\n        return null != t;\n    }), function() {\n        return \"Cannot find a connection between any variable and the result of the loss function y=f(x). Please make sure the operations that use variables are inside the function f passed to minimize().\";\n    }), C(0 === s.rank, function() {\n        return \"The f passed in variableGrads(f) must return a scalar, but it returned a rank-\" + s.rank + \" tensor\";\n    });\n    var c = {};\n    return e.forEach(function(t, e) {\n        null != u[e] && (c[t.name] = u[e]);\n    }), null != o && o.forEach(function(t) {\n        return c[t.name] = null;\n    }), {\n        value: s,\n        grads: c\n    };\n}\nfunction vo(t) {\n    return Lt.customGrad(t);\n}\nfunction mo(t) {\n    if (t.filter(function(t) {\n        return null == t;\n    }).length > 0) throw new Error(\"Cannot compute gradient of y=f(x) with respect to x. Make sure that\\n    the f you passed encloses all operations that lead from x to y.\");\n}\nvar go = An({\n    softmax_: function(t, e) {\n        void 0 === e && (e = -1);\n        var n = mn(t, \"logits\", \"softmax\", \"float32\");\n        if (-1 === e && (e = n.rank - 1), e !== n.rank - 1) throw Error(\"Softmax along a non-last dimension is not yet supported. Logits was rank \" + n.rank + \" and dim was \" + e);\n        return Lt.runKernelFunc(function(t, r) {\n            var o = t.softmax(n, e);\n            return r([\n                o\n            ]), o;\n        }, {\n            logits: n\n        }, function(t, n) {\n            var r = n[0], o = t.mul(r);\n            return {\n                logits: function() {\n                    return o.sub(o.sum([\n                        e\n                    ], !0).mul(r));\n                }\n            };\n        }, \"Softmax\", {\n            dim: e\n        }, [], [\n            !0\n        ]);\n    }\n}), yo = An({\n    logSoftmax_: function(t, e) {\n        void 0 === e && (e = -1);\n        var n = mn(t, \"logits\", \"logSoftmax\");\n        if (-1 === e && (e = n.rank - 1), e !== n.rank - 1) throw Error(\"Log Softmax along a non-last dimension is not yet supported. Logits was rank \" + n.rank + \" and axis was \" + e);\n        return vo(function(t, n) {\n            var r = t.max(e, !0), o = t.sub(r), a = o.toFloat().sub(o.exp().sum(e, !0).log());\n            n([\n                a\n            ]);\n            return {\n                value: a,\n                gradFunc: function(t, n) {\n                    var r = n[0].exp();\n                    return t.sub(t.sum(e, !0).mul(r));\n                }\n            };\n        })(n);\n    }\n}), xo = function() {\n    function t(t, e) {\n        this.backend = t, this.dataMover = e, this.data = new WeakMap, this.dataIdsCount = 0;\n    }\n    return t.prototype.get = function(t) {\n        return this.data.has(t) || this.dataMover.moveData(this.backend, t), this.data.get(t);\n    }, t.prototype.set = function(t, e) {\n        this.dataIdsCount++, this.data.set(t, e);\n    }, t.prototype.has = function(t) {\n        return this.data.has(t);\n    }, t.prototype.delete = function(t) {\n        return this.dataIdsCount--, this.data.delete(t);\n    }, t.prototype.numDataIds = function() {\n        return this.dataIdsCount;\n    }, t;\n}(), bo = function() {\n    function t() {}\n    return t.prototype.time = function(t) {\n        return wo(\"time\");\n    }, t.prototype.read = function(t) {\n        return wo(\"read\");\n    }, t.prototype.readSync = function(t) {\n        return wo(\"readSync\");\n    }, t.prototype.numDataIds = function() {\n        return wo(\"numDataIds\");\n    }, t.prototype.disposeData = function(t) {\n        return wo(\"disposeData\");\n    }, t.prototype.write = function(t, e, n) {\n        return wo(\"write\");\n    }, t.prototype.move = function(t, e, n, r) {\n        return wo(\"move\");\n    }, t.prototype.memory = function() {\n        return wo(\"memory\");\n    }, t.prototype.floatPrecision = function() {\n        return wo(\"floatPrecision\");\n    }, t.prototype.epsilon = function() {\n        return 32 === this.floatPrecision() ? 1e-7 : 1e-4;\n    }, t.prototype.batchMatMul = function(t, e, n, r) {\n        return wo(\"batchMatMul\");\n    }, t.prototype.fusedBatchMatMul = function(t) {\n        t.a, t.b, t.transposeA, t.transposeB, t.bias, t.activation, t.preluActivationWeights;\n        return wo(\"fusedBatchMatMul\");\n    }, t.prototype.slice = function(t, e, n) {\n        return wo(\"slice\");\n    }, t.prototype.stridedSlice = function(t, e, n, r) {\n        return wo(\"stridedSlice\");\n    }, t.prototype.unstack = function(t, e) {\n        return wo(\"unstack\");\n    }, t.prototype.reverse = function(t, e) {\n        return wo(\"reverse\");\n    }, t.prototype.concat = function(t, e) {\n        return wo(\"concat\");\n    }, t.prototype.neg = function(t) {\n        return wo(\"neg\");\n    }, t.prototype.add = function(t, e) {\n        return wo(\"add\");\n    }, t.prototype.addN = function(t) {\n        return wo(\"addN\");\n    }, t.prototype.subtract = function(t, e) {\n        return wo(\"subtract\");\n    }, t.prototype.multiply = function(t, e) {\n        return wo(\"multiply\");\n    }, t.prototype.realDivide = function(t, e) {\n        return wo(\"realDivide\");\n    }, t.prototype.floorDiv = function(t, e) {\n        return wo(\"floorDiv\");\n    }, t.prototype.sum = function(t, e) {\n        return wo(\"sum\");\n    }, t.prototype.prod = function(t, e) {\n        return wo(\"prod\");\n    }, t.prototype.unsortedSegmentSum = function(t, e, n) {\n        return wo(\"unsortedSegmentSum\");\n    }, t.prototype.argMin = function(t, e) {\n        return wo(\"argMin\");\n    }, t.prototype.argMax = function(t, e) {\n        return wo(\"argMax\");\n    }, t.prototype.equal = function(t, e) {\n        return wo(\"equal\");\n    }, t.prototype.notEqual = function(t, e) {\n        return wo(\"notEqual\");\n    }, t.prototype.less = function(t, e) {\n        return wo(\"less\");\n    }, t.prototype.lessEqual = function(t, e) {\n        return wo(\"lessEqual\");\n    }, t.prototype.greater = function(t, e) {\n        return wo(\"greater\");\n    }, t.prototype.greaterEqual = function(t, e) {\n        return wo(\"greaterEqual\");\n    }, t.prototype.logicalNot = function(t) {\n        return wo(\"logicalNot\");\n    }, t.prototype.logicalAnd = function(t, e) {\n        return wo(\"logicalAnd\");\n    }, t.prototype.logicalOr = function(t, e) {\n        return wo(\"logicalOr\");\n    }, t.prototype.where = function(t) {\n        return wo(\"where\");\n    }, t.prototype.select = function(t, e, n) {\n        return wo(\"select\");\n    }, t.prototype.topk = function(t, e, n) {\n        return wo(\"topk\");\n    }, t.prototype.min = function(t, e) {\n        return wo(\"min\");\n    }, t.prototype.minimum = function(t, e) {\n        return wo(\"minimum\");\n    }, t.prototype.mod = function(t, e) {\n        return wo(\"mod\");\n    }, t.prototype.max = function(t, e) {\n        return wo(\"max\");\n    }, t.prototype.maximum = function(t, e) {\n        return wo(\"maximum\");\n    }, t.prototype.all = function(t, e) {\n        return wo(\"all\");\n    }, t.prototype.any = function(t, e) {\n        return wo(\"any\");\n    }, t.prototype.squaredDifference = function(t, e) {\n        return wo(\"squaredDifference\");\n    }, t.prototype.ceil = function(t) {\n        return wo(\"ceil\");\n    }, t.prototype.floor = function(t) {\n        return wo(\"floor\");\n    }, t.prototype.round = function(t) {\n        return wo(\"round\");\n    }, t.prototype.sign = function(t) {\n        return wo(\"sign\");\n    }, t.prototype.isNaN = function(t) {\n        return wo(\"isNaN\");\n    }, t.prototype.isInf = function(t) {\n        return wo(\"isInf\");\n    }, t.prototype.isFinite = function(t) {\n        return wo(\"isFinite\");\n    }, t.prototype.pow = function(t, e) {\n        return wo(\"pow\");\n    }, t.prototype.exp = function(t) {\n        return wo(\"exp\");\n    }, t.prototype.expm1 = function(t) {\n        return wo(\"expm1\");\n    }, t.prototype.softmax = function(t, e) {\n        return wo(\"softmax\");\n    }, t.prototype.log = function(t) {\n        return wo(\"log\");\n    }, t.prototype.log1p = function(t) {\n        return wo(\"log1p\");\n    }, t.prototype.sqrt = function(t) {\n        return wo(\"sqrt\");\n    }, t.prototype.rsqrt = function(t) {\n        return wo(\"rsqrt\");\n    }, t.prototype.square = function(t) {\n        return wo(\"square\");\n    }, t.prototype.reciprocal = function(t) {\n        return wo(\"reciprocal\");\n    }, t.prototype.relu = function(t) {\n        return wo(\"relu\");\n    }, t.prototype.relu6 = function(t) {\n        return wo(\"relu6\");\n    }, t.prototype.prelu = function(t, e) {\n        return wo(\"prelu\");\n    }, t.prototype.elu = function(t) {\n        return wo(\"elu\");\n    }, t.prototype.eluDer = function(t, e) {\n        return wo(\"eluDer\");\n    }, t.prototype.selu = function(t) {\n        return wo(\"selu\");\n    }, t.prototype.int = function(t) {\n        return wo(\"int\");\n    }, t.prototype.clip = function(t, e, n) {\n        return wo(\"clip\");\n    }, t.prototype.abs = function(t) {\n        return wo(\"abs\");\n    }, t.prototype.complexAbs = function(t) {\n        return wo(\"complexAbs\");\n    }, t.prototype.sigmoid = function(t) {\n        return wo(\"sigmoid\");\n    }, t.prototype.softplus = function(t) {\n        return wo(\"softplus\");\n    }, t.prototype.sin = function(t) {\n        return wo(\"sin\");\n    }, t.prototype.cos = function(t) {\n        return wo(\"cos\");\n    }, t.prototype.tan = function(t) {\n        return wo(\"tan\");\n    }, t.prototype.asin = function(t) {\n        return wo(\"asin\");\n    }, t.prototype.acos = function(t) {\n        return wo(\"acos\");\n    }, t.prototype.atan = function(t) {\n        return wo(\"atan\");\n    }, t.prototype.atan2 = function(t, e) {\n        return wo(\"atan2\");\n    }, t.prototype.sinh = function(t) {\n        return wo(\"sinh\");\n    }, t.prototype.cosh = function(t) {\n        return wo(\"cosh\");\n    }, t.prototype.tanh = function(t) {\n        return wo(\"tanh\");\n    }, t.prototype.asinh = function(t) {\n        return wo(\"asinh\");\n    }, t.prototype.acosh = function(t) {\n        return wo(\"acosh\");\n    }, t.prototype.atanh = function(t) {\n        return wo(\"atanh\");\n    }, t.prototype.erf = function(t) {\n        return wo(\"erf\");\n    }, t.prototype.step = function(t, e) {\n        return wo(\"step\");\n    }, t.prototype.fusedConv2d = function(t) {\n        t.input, t.filter, t.convInfo, t.bias, t.activation, t.preluActivationWeights;\n        return wo(\"fusedConv2d\");\n    }, t.prototype.conv2d = function(t, e, n) {\n        return wo(\"conv2d\");\n    }, t.prototype.conv2dDerInput = function(t, e, n) {\n        return wo(\"conv2dDerInput\");\n    }, t.prototype.conv2dDerFilter = function(t, e, n) {\n        return wo(\"conv2dDerFilter\");\n    }, t.prototype.fusedDepthwiseConv2D = function(t) {\n        t.input, t.filter, t.convInfo, t.bias, t.activation, t.preluActivationWeights;\n        return wo(\"fusedDepthwiseConv2D\");\n    }, t.prototype.depthwiseConv2D = function(t, e, n) {\n        return wo(\"depthwiseConv2D\");\n    }, t.prototype.depthwiseConv2DDerInput = function(t, e, n) {\n        return wo(\"depthwiseConv2DDerInput\");\n    }, t.prototype.depthwiseConv2DDerFilter = function(t, e, n) {\n        return wo(\"depthwiseConv2DDerFilter\");\n    }, t.prototype.conv3d = function(t, e, n) {\n        return wo(\"conv3d\");\n    }, t.prototype.conv3dDerInput = function(t, e, n) {\n        return wo(\"conv3dDerInput\");\n    }, t.prototype.conv3dDerFilter = function(t, e, n) {\n        return wo(\"conv3dDerFilter\");\n    }, t.prototype.maxPool = function(t, e) {\n        return wo(\"maxPool\");\n    }, t.prototype.maxPoolBackprop = function(t, e, n, r) {\n        return wo(\"maxPoolBackprop\");\n    }, t.prototype.avgPool = function(t, e) {\n        return wo(\"avgPool\");\n    }, t.prototype.avgPoolBackprop = function(t, e, n) {\n        return wo(\"avgPoolBackprop\");\n    }, t.prototype.avgPool3d = function(t, e) {\n        return wo(\"avgPool3d\");\n    }, t.prototype.avgPool3dBackprop = function(t, e, n) {\n        return wo(\"avgPool3dBackprop\");\n    }, t.prototype.maxPool3d = function(t, e) {\n        return wo(\"maxPool3d\");\n    }, t.prototype.maxPool3dBackprop = function(t, e, n, r) {\n        return wo(\"maxPool3dBackprop\");\n    }, t.prototype.reshape = function(t, e) {\n        return wo(\"reshape\");\n    }, t.prototype.cast = function(t, e) {\n        return wo(\"cast\");\n    }, t.prototype.tile = function(t, e) {\n        return wo(\"tile\");\n    }, t.prototype.pad = function(t, e, n) {\n        return wo(\"pad\");\n    }, t.prototype.transpose = function(t, e) {\n        return wo(\"transpose\");\n    }, t.prototype.gather = function(t, e, n) {\n        return wo(\"gather\");\n    }, t.prototype.gatherND = function(t, e) {\n        return wo(\"gatherND\");\n    }, t.prototype.scatterND = function(t, e, n) {\n        return wo(\"scatterND\");\n    }, t.prototype.batchToSpaceND = function(t, e, n) {\n        return wo(\"batchToSpaceND\");\n    }, t.prototype.spaceToBatchND = function(t, e, n) {\n        return wo(\"spaceToBatchND\");\n    }, t.prototype.resizeBilinear = function(t, e, n, r) {\n        return wo(\"resizeBilinear\");\n    }, t.prototype.resizeBilinearBackprop = function(t, e, n) {\n        return wo(\"resizeBilinearBackprop\");\n    }, t.prototype.resizeNearestNeighbor = function(t, e, n, r) {\n        return wo(\"resizeNearestNeighbor\");\n    }, t.prototype.resizeNearestNeighborBackprop = function(t, e, n) {\n        return wo(\"resizeNearestNeighborBackprop\");\n    }, t.prototype.batchNormalization = function(t, e, n, r, o, a) {\n        return wo(\"batchNormalization\");\n    }, t.prototype.localResponseNormalization4D = function(t, e, n, r, o) {\n        return wo(\"localResponseNormalization4D\");\n    }, t.prototype.LRNGrad = function(t, e, n, r, o, a, i) {\n        return wo(\"LRNGrad\");\n    }, t.prototype.multinomial = function(t, e, n, r) {\n        return wo(\"multinomial\");\n    }, t.prototype.oneHot = function(t, e, n, r) {\n        return wo(\"oneHot\");\n    }, t.prototype.cumsum = function(t, e, n, r) {\n        return wo(\"cumsum\");\n    }, t.prototype.nonMaxSuppression = function(t, e, n, r, o) {\n        return wo(\"nonMaxSuppression\");\n    }, t.prototype.fft = function(t) {\n        return wo(\"fft\");\n    }, t.prototype.ifft = function(t) {\n        return wo(\"ifft\");\n    }, t.prototype.complex = function(t, e) {\n        return wo(\"complex\");\n    }, t.prototype.real = function(t) {\n        return wo(\"real\");\n    }, t.prototype.imag = function(t) {\n        return wo(\"imag\");\n    }, t.prototype.cropAndResize = function(t, e, n, r, o, a) {\n        return wo(\"cropAndResize\");\n    }, t.prototype.depthToSpace = function(t, e, n) {\n        return wo(\"depthToSpace\");\n    }, t.prototype.split = function(t, e, n) {\n        return wo(\"split\");\n    }, t.prototype.sparseToDense = function(t, e, n, r) {\n        return wo(\"sparseToDense\");\n    }, t.prototype.diag = function(t) {\n        return wo(\"diag\");\n    }, t.prototype.fill = function(t, e, n) {\n        return wo(\"fill\");\n    }, t.prototype.onesLike = function(t) {\n        return wo(\"onesLike\");\n    }, t.prototype.zerosLike = function(t) {\n        return wo(\"zerosLike\");\n    }, t.prototype.linspace = function(t, e, n) {\n        return wo(\"linspace\");\n    }, t.prototype.dispose = function() {\n        return wo(\"dispose\");\n    }, t;\n}();\nfunction wo(t) {\n    throw new Error(\"'\" + t + \"' not yet implemented or not found in the registry. Did you forget to import the kernel?\");\n}\nfunction Co(t, e) {\n    for(var n = t.length, r = [], o = 0; o < n; o++){\n        var a = n - 1 - o, i = t[a] || 1;\n        (e[e.length - 1 - o] || 1) > 1 && 1 === i && r.unshift(a);\n    }\n    return r;\n}\nfunction Eo(t, e) {\n    for(var n = [], r = 0; r < e.length; r++){\n        var o = t[t.length - r - 1], a = e.length - r - 1, i = e[a];\n        (null == o || 1 === o && i > 1) && n.unshift(a);\n    }\n    return n;\n}\nfunction Ro(t, e) {\n    for(var n = [], r = Math.max(t.length, e.length), o = 0; o < r; o++){\n        var a = t[t.length - o - 1];\n        null == a && (a = 1);\n        var i = e[e.length - o - 1];\n        if (null == i && (i = 1), 1 === a) n.unshift(i);\n        else if (1 === i) n.unshift(a);\n        else {\n            if (a !== i) throw Error(\"Operands could not be broadcast together with shapes \" + t + \" and \" + e + \".\");\n            n.unshift(a);\n        }\n    }\n    return n;\n}\nfunction Io(t, e, n, r, o, a, i) {\n    void 0 === i && (i = \"channelsLast\");\n    var s, u = To(e), c = u[0], l = u[1];\n    if (\"channelsLast\" === i) s = [\n        c,\n        l,\n        t[3],\n        t[3]\n    ];\n    else {\n        if (\"channelsFirst\" !== i) throw new Error(\"Unknown dataFormat \" + i);\n        s = [\n            c,\n            l,\n            t[1],\n            t[1]\n        ];\n    }\n    return So(t, s, n, r, o, a, !1, i);\n}\nfunction ko(t, e, n, r, o, a, i) {\n    void 0 === i && (i = \"NDHWC\");\n    var s, u, c = No(e), l = c[0], h = c[1], f = c[2];\n    if (\"NDHWC\" === i) u = \"channelsLast\", s = [\n        l,\n        h,\n        f,\n        t[4],\n        t[4]\n    ];\n    else {\n        if (\"NCDHW\" !== i) throw new Error(\"Unknown dataFormat \" + i);\n        u = \"channelsFirst\", s = [\n            l,\n            h,\n            f,\n            t[1],\n            t[1]\n        ];\n    }\n    return Ao(t, s, n, r, o, !1, u, a);\n}\nfunction So(t, e, n, r, o, a, i, s) {\n    void 0 === i && (i = !1), void 0 === s && (s = \"channelsLast\");\n    var u = [\n        -1,\n        -1,\n        -1,\n        -1\n    ], c = u[0], l = u[1], h = u[2], f = u[3];\n    if (\"channelsLast\" === s) c = t[0], l = t[1], h = t[2], f = t[3];\n    else {\n        if (\"channelsFirst\" !== s) throw new Error(\"Unknown dataFormat \" + s);\n        c = t[0], f = t[1], l = t[2], h = t[3];\n    }\n    var d, p = e[0], v = e[1], m = e[3], g = To(n), y = g[0], x = g[1], b = To(r), w = b[0], E = b[1], R = Fo(p, w), I = Fo(v, E), k = function(t, e, n, r, o, a, i, s) {\n        var u, c, l;\n        if (\"number\" == typeof t) {\n            u = {\n                top: t,\n                bottom: t,\n                left: t,\n                right: t,\n                type: 0 === t ? \"VALID\" : \"NUMBER\"\n            };\n            var h = function(t, e, n, r, o) {\n                null == r && (r = Do(t, e, n));\n                var a = t[0], i = t[1], s = _o((a - e + 2 * r) / n + 1, o);\n                C(A(s), function() {\n                    return \"The output # of rows (\" + s + \") must be an integer. Change the stride and/or zero pad parameters\";\n                });\n                var u = _o((i - e + 2 * r) / n + 1, o);\n                return C(A(u), function() {\n                    return \"The output # of columns (\" + u + \") must be an integer. Change the stride and/or zero pad parameters\";\n                }), [\n                    s,\n                    u\n                ];\n            }([\n                e,\n                n\n            ], a, r, t, s);\n            c = h[0], l = h[1];\n        } else if (\"same\" === t) {\n            c = Math.ceil(e / r), l = Math.ceil(n / o);\n            var f = Math.max(0, (c - 1) * r + a - e), d = Math.max(0, (l - 1) * o + i - n), p = Math.floor(f / 2), v = f - p, m = Math.floor(d / 2);\n            u = {\n                top: p,\n                bottom: v,\n                left: m,\n                right: d - m,\n                type: \"SAME\"\n            };\n        } else {\n            if (\"valid\" !== t) throw Error(\"Unknown padding parameter: \" + t);\n            u = {\n                top: 0,\n                bottom: 0,\n                left: 0,\n                right: 0,\n                type: \"VALID\"\n            }, c = Math.ceil((e - a + 1) / r), l = Math.ceil((n - i + 1) / o);\n        }\n        return {\n            padInfo: u,\n            outHeight: c,\n            outWidth: l\n        };\n    }(o, l, h, y, x, R, I, a), S = k.padInfo, D = k.outHeight, T = k.outWidth, N = i ? m * f : m;\n    return \"channelsFirst\" === s ? d = [\n        c,\n        N,\n        D,\n        T\n    ] : \"channelsLast\" === s && (d = [\n        c,\n        D,\n        T,\n        N\n    ]), {\n        batchSize: c,\n        dataFormat: s,\n        inHeight: l,\n        inWidth: h,\n        inChannels: f,\n        outHeight: D,\n        outWidth: T,\n        outChannels: N,\n        padInfo: S,\n        strideHeight: y,\n        strideWidth: x,\n        filterHeight: p,\n        filterWidth: v,\n        effectiveFilterHeight: R,\n        effectiveFilterWidth: I,\n        dilationHeight: w,\n        dilationWidth: E,\n        inShape: t,\n        outShape: d,\n        filterShape: e\n    };\n}\nfunction Ao(t, e, n, r, o, a, i, s) {\n    void 0 === a && (a = !1), void 0 === i && (i = \"channelsLast\");\n    var u = [\n        -1,\n        -1,\n        -1,\n        -1,\n        -1\n    ], c = u[0], l = u[1], h = u[2], f = u[3], d = u[4];\n    if (\"channelsLast\" === i) c = t[0], l = t[1], h = t[2], f = t[3], d = t[4];\n    else {\n        if (\"channelsFirst\" !== i) throw new Error(\"Unknown dataFormat \" + i);\n        c = t[0], d = t[1], l = t[2], h = t[3], f = t[4];\n    }\n    var p, v = e[0], m = e[1], g = e[2], y = e[4], x = No(n), b = x[0], w = x[1], E = x[2], R = No(r), I = R[0], k = R[1], S = R[2], D = Fo(v, I), T = Fo(m, k), N = Fo(g, S), F = function(t, e, n, r, o, a, i, s, u, c, l) {\n        var h, f, d, p;\n        if (\"number\" == typeof t) {\n            h = {\n                top: t,\n                bottom: t,\n                left: t,\n                right: t,\n                front: t,\n                back: t,\n                type: 0 === t ? \"VALID\" : \"NUMBER\"\n            };\n            var v = function(t, e, n, r, o, a) {\n                null == o && (o = Do(t, e, r));\n                var i = t[0], s = t[1], u = t[2], c = _o((i - e + 2 * o) / r + 1, a);\n                C(A(c), function() {\n                    return \"The output # of depths (\" + c + \") must be an integer. Change the stride and/or zero pad parameters\";\n                });\n                var l = _o((s - e + 2 * o) / r + 1, a);\n                C(A(l), function() {\n                    return \"The output # of rows (\" + l + \") must be an integer. Change the stride and/or zero pad parameters\";\n                });\n                var h = _o((u - e + 2 * o) / r + 1, a);\n                return C(A(h), function() {\n                    return \"The output # of columns (\" + h + \") must be an integer. Change the stride and/or zero pad parameters\";\n                }), [\n                    c,\n                    l,\n                    h,\n                    n\n                ];\n            }([\n                e,\n                n,\n                r,\n                1\n            ], s, 1, o, t, l);\n            f = v[0], d = v[1], p = v[2];\n        } else if (\"same\" === t) {\n            f = Math.ceil(e / o), d = Math.ceil(n / a), p = Math.ceil(r / i);\n            var m = (f - 1) * o + s - e, g = (d - 1) * a + u - n, y = (p - 1) * i + c - r, x = Math.floor(m / 2), b = m - x, w = Math.floor(g / 2), E = g - w, R = Math.floor(y / 2);\n            h = {\n                top: w,\n                bottom: E,\n                left: R,\n                right: y - R,\n                front: x,\n                back: b,\n                type: \"SAME\"\n            };\n        } else {\n            if (\"valid\" !== t) throw Error(\"Unknown padding parameter: \" + t);\n            h = {\n                top: 0,\n                bottom: 0,\n                left: 0,\n                right: 0,\n                front: 0,\n                back: 0,\n                type: \"VALID\"\n            }, f = Math.ceil((e - s + 1) / o), d = Math.ceil((n - u + 1) / a), p = Math.ceil((r - c + 1) / i);\n        }\n        return {\n            padInfo: h,\n            outDepth: f,\n            outHeight: d,\n            outWidth: p\n        };\n    }(o, l, h, f, b, w, E, D, T, N, s), _ = F.padInfo, O = F.outDepth, M = F.outHeight, B = F.outWidth, P = a ? y * d : y;\n    return \"channelsFirst\" === i ? p = [\n        c,\n        P,\n        O,\n        M,\n        B\n    ] : \"channelsLast\" === i && (p = [\n        c,\n        O,\n        M,\n        B,\n        P\n    ]), {\n        batchSize: c,\n        dataFormat: i,\n        inDepth: l,\n        inHeight: h,\n        inWidth: f,\n        inChannels: d,\n        outDepth: O,\n        outHeight: M,\n        outWidth: B,\n        outChannels: P,\n        padInfo: _,\n        strideDepth: b,\n        strideHeight: w,\n        strideWidth: E,\n        filterDepth: v,\n        filterHeight: m,\n        filterWidth: g,\n        effectiveFilterDepth: D,\n        effectiveFilterHeight: T,\n        effectiveFilterWidth: N,\n        dilationDepth: I,\n        dilationHeight: k,\n        dilationWidth: S,\n        inShape: t,\n        outShape: p,\n        filterShape: e\n    };\n}\nfunction Do(t, e, n, r) {\n    void 0 === r && (r = 1);\n    var o = Fo(e, r);\n    return Math.floor((t[0] * (n - 1) - n + o) / 2);\n}\nfunction To(t) {\n    return \"number\" == typeof t ? [\n        t,\n        t,\n        t\n    ] : 2 === t.length ? [\n        t[0],\n        t[1],\n        1\n    ] : t;\n}\nfunction No(t) {\n    return \"number\" == typeof t ? [\n        t,\n        t,\n        t\n    ] : t;\n}\nfunction Fo(t, e) {\n    return e <= 1 ? t : t + (t - 1) * (e - 1);\n}\nfunction _o(t, e) {\n    if (!e) return t;\n    switch(e){\n        case \"round\":\n            return Math.round(t);\n        case \"ceil\":\n            return Math.ceil(t);\n        case \"floor\":\n            return Math.floor(t);\n        default:\n            throw new Error(\"Unknown roundingMode \" + e);\n    }\n}\nfunction Oo(t) {\n    var e = To(t), n = e[0], r = e[1], o = e[2];\n    return 1 === n && 1 === r && 1 === o;\n}\nfunction Mo(t, e) {\n    return Oo(t) || Oo(e);\n}\nfunction Bo(t) {\n    if (\"NHWC\" === t) return \"channelsLast\";\n    if (\"NCHW\" === t) return \"channelsFirst\";\n    throw new Error(\"Unknown dataFormat \" + t);\n}\nfunction Po(t, e, n) {\n    if (\"complex64\" === e) {\n        if (\"complex64\" === t.dtype) return t.clone();\n        var r = Gn(t.shape), o = t.toFloat(), a = n.complex(o, r);\n        return r.dispose(), o.dispose(), a;\n    }\n    if (!U(t.dtype, e)) return Lt.makeTensorFromDataId(t.dataId, t.shape, e);\n    if (\"complex64\" === t.dtype) {\n        var i = n.real(t);\n        a = i.cast(e);\n        return i.dispose(), a;\n    }\n    if (\"int32\" === e) return n.int(t);\n    if (\"bool\" === e) {\n        var s = On(0, t.dtype);\n        a = n.notEqual(t, s);\n        return s.dispose(), a;\n    }\n    throw new Error(\"Error in Cast: failed to cast \" + t.dtype + \" to \" + e);\n}\nfunction Lo(t, e) {\n    return Lt.makeTensorFromDataId(t.dataId, e, t.dtype);\n}\nfunction Wo(t, e, n) {\n    var r = (e - t) / (n - 1), o = tt(n, \"float32\");\n    o[0] = t;\n    for(var a = 1; a < o.length; a++)o[a] = o[a - 1] + r;\n    return Mn(o, \"float32\");\n}\nvar Uo = Object.freeze({\n    castTensor: Po,\n    reshapeTensor: Lo,\n    linspaceImpl: Wo,\n    upcastType: Dt,\n    axesAreInnerMostDims: yn,\n    combineLocations: xn,\n    computeOutAndReduceShapes: bn,\n    expandShapeToKeepDim: wn,\n    assertAxesAreInnerMostDims: Cn,\n    getAxesPermutation: En,\n    getUndoAxesPermutation: Rn,\n    getInnerMostAxes: In,\n    getBroadcastDims: Co,\n    getReductionAxes: Eo,\n    assertAndGetBroadcastShape: Ro,\n    assertParamsConsistent: kn,\n    computeOutShape: Sn,\n    computePool2DInfo: Io,\n    computePool3DInfo: ko,\n    computeConv2DInfo: So,\n    computeConv3DInfo: Ao,\n    computeDefaultPad: Do,\n    tupleValuesAreOne: Oo,\n    eitherStridesOrDilationsAreOne: Mo,\n    convertConv2DDataFormat: Bo,\n    PARALLELIZE_THRESHOLD: Yr,\n    computeOptimalWindowSize: $r\n});\nfunction Vo(t, e) {\n    if (t.length !== e.length) throw new Error(\"Cannot merge real and imag arrays of different lengths. real:\" + t.length + \", imag: \" + e.length + \".\");\n    for(var n = new Float32Array(2 * t.length), r = 0; r < n.length; r += 2)n[r] = t[r / 2], n[r + 1] = e[r / 2];\n    return n;\n}\nfunction zo(t, e) {\n    return {\n        real: t[2 * e],\n        imag: t[2 * e + 1]\n    };\n}\nfunction Go(t, e, n, r) {\n    t[2 * r] = e, t[2 * r + 1] = n;\n}\nfunction Ho(t, e, n) {\n    var r = (n ? 2 : -2) * Math.PI * (t / e);\n    return {\n        real: Math.cos(r),\n        imag: Math.sin(r)\n    };\n}\nfunction qo(t, e, n) {\n    var r = function(t, e, n) {\n        return function(t, e, n) {\n            var r = 0, o = t.length, a = 0, i = !1;\n            for(; r < o;){\n                var s = n(e, t[a = r + (o - r >>> 1)]);\n                s > 0 ? r = a + 1 : (o = a, i = !s);\n            }\n            return i ? r : -r - 1;\n        }(t, e, n || Ko);\n    }(t, e, n), o = r < 0 ? -(r + 1) : r;\n    t.splice(o, 0, e);\n}\nfunction Ko(t, e) {\n    return t > e ? 1 : t < e ? -1 : 0;\n}\nfunction jo(t, e, n, r, o) {\n    return Yo(t, e, n, r, o, 0).selectedIndices;\n}\nfunction Xo(t, e, n, r, o, a) {\n    var i = Yo(t, e, n, r, o, a, !0);\n    return i.numValidOutputs.dispose(), {\n        selectedIndices: i.selectedIndices,\n        selectedScores: i.selectedScores\n    };\n}\nfunction Yo(t, e, n, r, o, a, i, s) {\n    void 0 === i && (i = !1), void 0 === s && (s = !1);\n    for(var u = Array.from(e).map(function(t, e) {\n        return {\n            score: t,\n            boxIndex: e,\n            suppressBeginIndex: 0\n        };\n    }).filter(function(t) {\n        return t.score > o;\n    }).sort(Jo), c = a > 0 ? -.5 / a : 0, l = [], h = []; l.length < n && u.length > 0;){\n        var f = u.pop(), d = f.score, p = f.boxIndex, v = f.suppressBeginIndex;\n        if (d < o) break;\n        for(var m = !1, g = l.length - 1; g >= v; --g){\n            var y = $o(t, p, l[g]);\n            if (y >= r) {\n                m = !0;\n                break;\n            }\n            if (f.score = f.score * Qo(r, c, y), f.score <= o) break;\n        }\n        f.suppressBeginIndex = l.length, m || (f.score === d ? (l.push(p), h.push(f.score)) : f.score > o && qo(u, f, Jo));\n    }\n    var x = l.length;\n    return s && (l.fill(0, x), h.fill(0, x)), {\n        selectedIndices: Mn(l, \"int32\"),\n        selectedScores: Mn(h, \"float32\"),\n        numValidOutputs: On(x, \"int32\")\n    };\n}\nfunction $o(t, e, n) {\n    var r = t.subarray(4 * e, 4 * e + 4), o = t.subarray(4 * n, 4 * n + 4), a = Math.min(r[0], r[2]), i = Math.min(r[1], r[3]), s = Math.max(r[0], r[2]), u = Math.max(r[1], r[3]), c = Math.min(o[0], o[2]), l = Math.min(o[1], o[3]), h = Math.max(o[0], o[2]), f = Math.max(o[1], o[3]), d = (s - a) * (u - i), p = (h - c) * (f - l);\n    if (d <= 0 || p <= 0) return 0;\n    var v = Math.max(a, c), m = Math.max(i, l), g = Math.min(s, h), y = Math.min(u, f), x = Math.max(g - v, 0) * Math.max(y - m, 0);\n    return x / (d + p - x);\n}\nfunction Qo(t, e, n) {\n    var r = Math.exp(e * n * n);\n    return n <= t ? r : 0;\n}\nfunction Jo(t, e) {\n    return t.score - e.score || t.score === e.score && e.boxIndex - t.boxIndex;\n}\nfunction Zo(t, e, n) {\n    var r = new Array(t.rank).fill(0), o = t.shape.slice();\n    return e.map(function(e) {\n        o[n] = e;\n        var a = t.slice(r, o);\n        return r[n] += e, a;\n    });\n}\nfunction ta(t, e) {\n    for(var n = new Array(t.rank), r = 0; r < n.length; r++)n[r] = t.shape[r] * e[r];\n    var o = dr(n, t.dtype);\n    for(r = 0; r < o.values.length; ++r){\n        for(var a = o.indexToLoc(r), i = new Array(t.rank), s = 0; s < i.length; s++)i[s] = a[s] % t.shape[s];\n        var u = t.locToIndex(i);\n        o.values[r] = t.values[u];\n    }\n    return o.toTensor();\n}\nfunction ea(t, e, n, r, o) {\n    for(var a = e[e.length - 1], i = [\n        t.length / a,\n        a\n    ], s = i[0], u = i[1], c = B(n, s * r), l = B(\"int32\", s * r), h = 0; h < s; h++){\n        for(var f = h * u, d = t.subarray(f, f + u), p = [], v = 0; v < d.length; v++)p.push({\n            value: d[v],\n            index: v\n        });\n        p.sort(function(t, e) {\n            return e.value - t.value;\n        });\n        var m = h * r, g = c.subarray(m, m + r), y = l.subarray(m, m + r);\n        for(v = 0; v < r; v++)g[v] = p[v].value, y[v] = p[v].index;\n    }\n    var x = e.slice();\n    return x[x.length - 1] = r, [\n        Fn(c, x, n),\n        Fn(l, x, \"int32\")\n    ];\n}\nfunction na(t, e) {\n    for(var n = [], r = 0; r < e.length; r++)e[r] && n.push(r);\n    var o = dr(t, \"int32\"), a = dr([\n        n.length,\n        t.length\n    ], \"int32\");\n    for(r = 0; r < n.length; r++){\n        var i = o.indexToLoc(n[r]), s = r * t.length;\n        a.values.set(i, s);\n    }\n    return a.toTensor();\n}\nvar ra = function(t, e) {\n    this.outputShape = [], this.outputShape = t, this.variableNames = e.map(function(t, e) {\n        return \"T\" + e;\n    });\n    var n = [];\n    this.variableNames.forEach(function(t) {\n        n.push(\"float v\" + t + \" = get\" + t + \"AtOutCoords();\");\n    });\n    var r = this.variableNames.map(function(t) {\n        return \"v\" + t;\n    }).join(\" + \");\n    this.userCode = \"\\n      void main() {\\n        \" + n.join(\"\\n        \") + \"\\n\\n        float result = \" + r + \";\\n        setOutput(result);\\n      }\\n    \";\n}, oa = function(t, e) {\n    this.outputShape = [], this.packedInputs = !0, this.packedOutput = !0, this.outputShape = t, this.variableNames = e.map(function(t, e) {\n        return \"T\" + e;\n    });\n    var n = [];\n    this.variableNames.forEach(function(t) {\n        n.push(\"vec4 v\" + t + \" = get\" + t + \"AtOutCoords();\");\n    });\n    var r = this.variableNames.map(function(t) {\n        return \"v\" + t;\n    }).join(\" + \");\n    this.userCode = \"\\n      void main() {\\n        \" + n.join(\"\\n        \") + \"\\n\\n        vec4 result = \" + r + \";\\n        setOutput(result);\\n      }\\n    \";\n}, aa = function(t, e, n) {\n    this.variableNames = [\n        \"A\"\n    ];\n    var r = t.windowSize, o = t.batchSize, a = t.inSize, i = Math.ceil(a / r);\n    n || this.variableNames.push(\"bestIndicesA\"), this.outputShape = [\n        o,\n        i\n    ];\n    var s = \"max\" === e ? \">\" : \"<\", u = n ? \"inOffset + i;\" : \"round(getBestIndicesA(batch, inOffset + i));\";\n    this.userCode = \"\\n      void main() {\\n        ivec2 coords = getOutputCoords();\\n        int batch = coords[0];\\n        int outIdx = coords[1];\\n        int inOffset = outIdx * \" + r + \";\\n\\n        int bestIndex = inOffset;\\n        float bestValue = getA(batch, bestIndex);\\n\\n        for (int i = 0; i < \" + r + \"; i++) {\\n          int inIdx = \" + u + \";\\n          float candidate = getA(batch, inIdx);\\n          if (candidate \" + s + \" bestValue) {\\n            bestValue = candidate;\\n            bestIndex = inIdx;\\n          }\\n        }\\n        setOutput(float(bestIndex));\\n      }\\n    \";\n};\nfunction ia(t, e) {\n    return [\n        \"x\",\n        \"y\",\n        \"z\",\n        \"w\",\n        \"u\",\n        \"v\"\n    ].slice(0, e).map(function(e) {\n        return t + \".\" + e;\n    });\n}\nfunction sa(t, e) {\n    return 1 === e ? [\n        t\n    ] : ia(t, e);\n}\nfunction ua() {\n    var t, e, n, r, o, a, s, u, c, l;\n    return 2 === i().getNumber(\"WEBGL_VERSION\") ? (t = \"#version 300 es\", e = \"in\", n = \"out\", r = \"in\", o = \"texture\", a = \"outputColor\", s = \"out vec4 outputColor;\", u = \"\\n      bool isnan_custom(float val) {\\n        return (val > 0.0 || val < 0.0) ? false : val != 0.0;\\n      }\\n\\n      bvec4 isnan_custom(vec4 val) {\\n        return bvec4(isnan_custom(val.x),\\n          isnan_custom(val.y), isnan_custom(val.z), isnan_custom(val.w));\\n      }\\n\\n      #define isnan(value) isnan_custom(value)\\n    \", c = \"\", l = \"\\n      #define round(value) newRound(value)\\n      int newRound(float value) {\\n        return int(floor(value + 0.5));\\n      }\\n\\n      ivec4 newRound(vec4 value) {\\n        return ivec4(floor(value + vec4(0.5)));\\n      }\\n    \") : (t = \"\", e = \"attribute\", n = \"varying\", r = \"varying\", o = \"texture2D\", a = \"gl_FragColor\", s = \"\", u = \"\\n      #define isnan(value) isnan_custom(value)\\n      bool isnan_custom(float val) {\\n        return (val > 0. || val < 1. || val == 0.) ? false : true;\\n      }\\n      bvec4 isnan_custom(vec4 val) {\\n        return bvec4(isnan(val.x), isnan(val.y), isnan(val.z), isnan(val.w));\\n      }\\n    \", c = \"\\n      uniform float INFINITY;\\n\\n      bool isinf(float val) {\\n        return abs(val) == INFINITY;\\n      }\\n      bvec4 isinf(vec4 val) {\\n        return equal(abs(val), vec4(INFINITY));\\n      }\\n    \", l = \"\\n      int round(float value) {\\n        return int(floor(value + 0.5));\\n      }\\n\\n      ivec4 round(vec4 value) {\\n        return ivec4(floor(value + vec4(0.5)));\\n      }\\n    \"), {\n        version: t,\n        attribute: e,\n        varyingVs: n,\n        varyingFs: r,\n        texture2D: o,\n        output: a,\n        defineOutput: s,\n        defineSpecialNaN: u,\n        defineSpecialInf: c,\n        defineRound: l\n    };\n}\nfunction ca(t, e, n) {\n    void 0 === n && (n = \"index\");\n    var r = $(e);\n    return r.map(function(e, o) {\n        return \"int \" + t[o] + \" = \" + n + \" / \" + e + \"; \" + (o === r.length - 1 ? \"int \" + t[o + 1] + \" = \" + n + \" - \" + t[o] + \" * \" + e : \"index -= \" + t[o] + \" * \" + e) + \";\";\n    }).join(\"\");\n}\nfunction la(t) {\n    var e = $(t).map(function(t) {\n        return t.toString();\n    });\n    return \"\\n  int getFlatIndex(ivec3 coords) {\\n    return coords.x * \" + e[0] + \" + coords.y * \" + e[1] + \" + coords.z;\\n  }\\n\";\n}\nvar ha = \"\\n  const float FLOAT_MAX = 1.70141184e38;\\n  const float FLOAT_MIN = 1.17549435e-38;\\n\\n  lowp vec4 encode_float(highp float v) {\\n    if (isnan(v)) {\\n      return vec4(255, 255, 255, 255);\\n    }\\n\\n    highp float av = abs(v);\\n\\n    if(av < FLOAT_MIN) {\\n      return vec4(0.0, 0.0, 0.0, 0.0);\\n    } else if(v > FLOAT_MAX) {\\n      return vec4(0.0, 0.0, 128.0, 127.0) / 255.0;\\n    } else if(v < -FLOAT_MAX) {\\n      return vec4(0.0, 0.0,  128.0, 255.0) / 255.0;\\n    }\\n\\n    highp vec4 c = vec4(0,0,0,0);\\n\\n    highp float e = floor(log2(av));\\n    highp float m = exp2(fract(log2(av))) - 1.0;\\n\\n    c[2] = floor(128.0 * m);\\n    m -= c[2] / 128.0;\\n    c[1] = floor(32768.0 * m);\\n    m -= c[1] / 32768.0;\\n    c[0] = floor(8388608.0 * m);\\n\\n    highp float ebias = e + 127.0;\\n    c[3] = floor(ebias / 2.0);\\n    ebias -= c[3] * 2.0;\\n    c[2] += floor(ebias) * 128.0;\\n\\n    c[3] += 128.0 * step(0.0, -v);\\n\\n    return c / 255.0;\\n  }\\n\";\nfunction fa(t, e, n, r) {\n    var o = [];\n    t.forEach(function(t) {\n        var e = k(t.shapeInfo.logicalShape);\n        t.shapeInfo.isUniform ? o.push(\"uniform float \" + t.name + (e > 1 ? \"[\" + e + \"]\" : \"\") + \";\") : (o.push(\"uniform sampler2D \" + t.name + \";\"), o.push(\"uniform int offset\" + t.name + \";\"));\n    });\n    var a, i, s = o.join(\"\\n\"), u = t.map(function(t) {\n        return function(t, e, n) {\n            void 0 === n && (n = !1);\n            var r = \"\";\n            r += n ? pa(t) : da(t);\n            var o = t.shapeInfo.logicalShape, a = e.logicalShape;\n            o.length <= a.length && (r += n ? function(t, e) {\n                var n, r = t.name, o = r.charAt(0).toUpperCase() + r.slice(1), a = \"get\" + o + \"AtOutCoords\", i = t.shapeInfo.logicalShape.length, s = e.logicalShape.length, u = Co(t.shapeInfo.logicalShape, e.logicalShape), c = wa(s), l = s - i, h = [\n                    \"x\",\n                    \"y\",\n                    \"z\",\n                    \"w\",\n                    \"u\",\n                    \"v\"\n                ];\n                n = 0 === i ? \"\" : s < 2 && u.length >= 1 ? \"coords = 0;\" : u.map(function(t) {\n                    return \"coords.\" + h[t + l] + \" = 0;\";\n                }).join(\"\\n\");\n                var f = \"\";\n                f = s < 2 && i > 0 ? \"coords\" : t.shapeInfo.logicalShape.map(function(t, e) {\n                    return \"coords.\" + h[e + l];\n                }).join(\", \");\n                var d = \"return outputValue;\", p = 1 === k(t.shapeInfo.logicalShape), v = 1 === k(e.logicalShape);\n                if (1 !== i || p || v) {\n                    if (p && !v) d = 1 === s ? \"\\n        return vec4(outputValue.x, outputValue.x, 0., 0.);\\n      \" : \"\\n        return vec4(outputValue.x);\\n      \";\n                    else if (u.length) {\n                        var m = i - 2, g = i - 1;\n                        u.indexOf(m) > -1 && u.indexOf(g) > -1 ? d = \"return vec4(outputValue.x);\" : u.indexOf(m) > -1 ? d = \"return vec4(outputValue.x, outputValue.y, outputValue.x, outputValue.y);\" : u.indexOf(g) > -1 && (d = \"return vec4(outputValue.xx, outputValue.zz);\");\n                    }\n                } else d = \"\\n      return vec4(outputValue.xy, outputValue.xy);\\n    \";\n                return \"\\n    vec4 \" + a + \"() {\\n      \" + c + \" coords = getOutputCoords();\\n      \" + n + \"\\n      vec4 outputValue = get\" + o + \"(\" + f + \");\\n      \" + d + \"\\n    }\\n  \";\n            }(t, e) : function(t, e) {\n                var n = t.name, r = n.charAt(0).toUpperCase() + n.slice(1), o = \"get\" + r + \"AtOutCoords\", a = e.texShape, i = t.shapeInfo.texShape, s = t.shapeInfo.logicalShape.length, u = e.logicalShape.length;\n                if (!t.shapeInfo.isUniform && s === u && null == t.shapeInfo.flatOffset && S(i, a)) return \"\\n      float \" + o + \"() {\\n        return sampleTexture(\" + n + \", resultUV);\\n      }\\n    \";\n                var c, l = wa(u), h = Co(t.shapeInfo.logicalShape, e.logicalShape), f = u - s, d = [\n                    \"x\",\n                    \"y\",\n                    \"z\",\n                    \"w\",\n                    \"u\",\n                    \"v\"\n                ];\n                c = 0 === s ? \"\" : u < 2 && h.length >= 1 ? \"coords = 0;\" : h.map(function(t) {\n                    return \"coords.\" + d[t + f] + \" = 0;\";\n                }).join(\"\\n\");\n                var p = \"\";\n                p = u < 2 && s > 0 ? \"coords\" : t.shapeInfo.logicalShape.map(function(t, e) {\n                    return \"coords.\" + d[e + f];\n                }).join(\", \");\n                return \"\\n    float \" + o + \"() {\\n      \" + l + \" coords = getOutputCoords();\\n      \" + c + \"\\n      return get\" + r + \"(\" + p + \");\\n    }\\n  \";\n            }(t, e));\n            return r;\n        }(t, e, r);\n    }).join(\"\\n\"), c = e.texShape, l = ua(), h = function(t) {\n        return \"\\n    float sampleTexture(sampler2D textureSampler, vec2 uv) {\\n      return \" + t.texture2D + \"(textureSampler, uv).r;\\n    }\\n  \";\n    }(l), f = function(t) {\n        return t.version + \"\\n    precision highp float;\\n    precision highp int;\\n    precision highp sampler2D;\\n    \" + t.varyingFs + \" vec2 resultUV;\\n    \" + t.defineOutput + \"\\n    const vec2 halfCR = vec2(0.5, 0.5);\\n\\n    struct ivec5\\n    {\\n      int x;\\n      int y;\\n      int z;\\n      int w;\\n      int u;\\n    };\\n\\n    struct ivec6\\n    {\\n      int x;\\n      int y;\\n      int z;\\n      int w;\\n      int u;\\n      int v;\\n    };\\n\\n    uniform float NAN;\\n    \" + t.defineSpecialNaN + \"\\n    \" + t.defineSpecialInf + \"\\n    \" + t.defineRound + \"\\n\\n    int imod(int x, int y) {\\n      return x - y * (x / y);\\n    }\\n\\n    int idiv(int a, int b, float sign) {\\n      int res = a / b;\\n      int mod = imod(a, b);\\n      if (sign < 0. && mod != 0) {\\n        res -= 1;\\n      }\\n      return res;\\n    }\\n\\n    //Based on the work of Dave Hoskins\\n    //https://www.shadertoy.com/view/4djSRW\\n    #define HASHSCALE1 443.8975\\n    float random(float seed){\\n      vec2 p = resultUV * seed;\\n      vec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);\\n      p3 += dot(p3, p3.yzx + 19.19);\\n      return fract((p3.x + p3.y) * p3.z);\\n    }\\n\\n    \" + va + \"\\n    \" + ma + \"\\n    \" + ga + \"\\n  \";\n    }(l);\n    return e.isPacked ? (a = function(t, e) {\n        switch(t.length){\n            case 0:\n                return \"\\n    int getOutputCoords() {\\n      return 0;\\n    }\\n  \";\n            case 1:\n                return function(t, e) {\n                    var n = [\n                        Math.ceil(e[0] / 2),\n                        Math.ceil(e[1] / 2)\n                    ];\n                    if (1 === n[0]) return \"\\n      int getOutputCoords() {\\n        return 2 * int(resultUV.x * \" + n[1] + \".0);\\n      }\\n    \";\n                    if (1 === n[1]) return \"\\n      int getOutputCoords() {\\n        return 2 * int(resultUV.y * \" + n[0] + \".0);\\n      }\\n    \";\n                    return \"\\n    int getOutputCoords() {\\n      ivec2 resTexRC = ivec2(resultUV.yx *\\n                             vec2(\" + n[0] + \", \" + n[1] + \"));\\n      return 2 * (resTexRC.x * \" + n[1] + \" + resTexRC.y);\\n    }\\n  \";\n                }(0, e);\n            case 2:\n                return function(t, e) {\n                    var n = [\n                        Math.ceil(e[0] / 2),\n                        Math.ceil(e[1] / 2)\n                    ];\n                    if (S(t, e)) return \"\\n      ivec2 getOutputCoords() {\\n        return 2 * ivec2(resultUV.yx * vec2(\" + n[0] + \", \" + n[1] + \"));\\n      }\\n    \";\n                    var r = Math.ceil(t[1] / 2);\n                    return \"\\n    ivec2 getOutputCoords() {\\n      ivec2 resTexRC = ivec2(resultUV.yx *\\n                             vec2(\" + n[0] + \", \" + n[1] + \"));\\n\\n      int index = resTexRC.x * \" + n[1] + \" + resTexRC.y;\\n      int r = 2 * (index / \" + r + \");\\n      int c = imod(index, \" + r + \") * 2;\\n\\n      return ivec2(r, c);\\n    }\\n  \";\n                }(t, e);\n            case 3:\n                return n = t, r = e, o = [\n                    Math.ceil(r[0] / 2),\n                    Math.ceil(r[1] / 2)\n                ], a = Math.ceil(n[2] / 2), i = a * Math.ceil(n[1] / 2), \"\\n    ivec3 getOutputCoords() {\\n      ivec2 resTexRC = ivec2(resultUV.yx *\\n                             vec2(\" + o[0] + \", \" + o[1] + \"));\\n      int index = resTexRC.x * \" + o[1] + \" + resTexRC.y;\\n\\n      int b = index / \" + i + \";\\n      index -= b * \" + i + \";\\n\\n      int r = 2 * (index / \" + a + \");\\n      int c = imod(index, \" + a + \") * 2;\\n\\n      return ivec3(b, r, c);\\n    }\\n  \";\n            default:\n                return function(t, e) {\n                    for(var n = [\n                        Math.ceil(e[0] / 2),\n                        Math.ceil(e[1] / 2)\n                    ], r = Math.ceil(t[t.length - 1] / 2), o = r * Math.ceil(t[t.length - 2] / 2), a = o, i = \"\", s = \"b, r, c\", u = 2; u < t.length - 1; u++)a *= t[t.length - u - 1], i = \"\\n      int b\" + u + \" = index / \" + a + \";\\n      index -= b\" + u + \" * \" + a + \";\\n    \" + i, s = \"b\" + u + \", \" + s;\n                    return \"\\n    ivec\" + t.length + \" getOutputCoords() {\\n      ivec2 resTexRC = ivec2(resultUV.yx *\\n                             vec2(\" + n[0] + \", \" + n[1] + \"));\\n      int index = resTexRC.x * \" + n[1] + \" + resTexRC.y;\\n\\n      \" + i + \"\\n\\n      int b = index / \" + o + \";\\n      index -= b * \" + o + \";\\n\\n      int r = 2 * (index / \" + r + \");\\n      int c = imod(index, \" + r + \") * 2;\\n\\n      return ivec\" + t.length + \"(\" + s + \");\\n    }\\n  \";\n                }(t, e);\n        }\n        var n, r, o, a, i;\n    }(e.logicalShape, c), i = function(t) {\n        return \"\\n    void setOutput(vec4 val) {\\n      \" + t.output + \" = val;\\n    }\\n  \";\n    }(l)) : (a = function(t, e) {\n        switch(t.length){\n            case 0:\n                return \"\\n    int getOutputCoords() {\\n      return 0;\\n    }\\n  \";\n            case 1:\n                return function(t, e) {\n                    if (1 === e[0]) return \"\\n      int getOutputCoords() {\\n        return int(resultUV.x * \" + e[1] + \".0);\\n      }\\n    \";\n                    if (1 === e[1]) return \"\\n      int getOutputCoords() {\\n        return int(resultUV.y * \" + e[0] + \".0);\\n      }\\n    \";\n                    return \"\\n    int getOutputCoords() {\\n      ivec2 resTexRC = ivec2(resultUV.yx *\\n                             vec2(\" + e[0] + \", \" + e[1] + \"));\\n      return resTexRC.x * \" + e[1] + \" + resTexRC.y;\\n    }\\n  \";\n                }(0, e);\n            case 2:\n                return function(t, e) {\n                    if (S(t, e)) return \"\\n      ivec2 getOutputCoords() {\\n        return ivec2(resultUV.yx * vec2(\" + e[0] + \", \" + e[1] + \"));\\n      }\\n    \";\n                    if (1 === t[1]) return \"\\n      ivec2 getOutputCoords() {\\n        ivec2 resTexRC = ivec2(resultUV.yx *\\n                               vec2(\" + e[0] + \", \" + e[1] + \"));\\n        int index = resTexRC.x * \" + e[1] + \" + resTexRC.y;\\n        return ivec2(index, 0);\\n      }\\n    \";\n                    if (1 === t[0]) return \"\\n      ivec2 getOutputCoords() {\\n        ivec2 resTexRC = ivec2(resultUV.yx *\\n                               vec2(\" + e[0] + \", \" + e[1] + \"));\\n        int index = resTexRC.x * \" + e[1] + \" + resTexRC.y;\\n        return ivec2(0, index);\\n      }\\n    \";\n                    return \"\\n    ivec2 getOutputCoords() {\\n      ivec2 resTexRC = ivec2(resultUV.yx *\\n                             vec2(\" + e[0] + \", \" + e[1] + \"));\\n      int index = resTexRC.x * \" + e[1] + \" + resTexRC.y;\\n      int r = index / \" + t[1] + \";\\n      int c = index - r * \" + t[1] + \";\\n      return ivec2(r, c);\\n    }\\n  \";\n                }(t, e);\n            case 3:\n                return n = e, r = ca([\n                    \"r\",\n                    \"c\",\n                    \"d\"\n                ], t), \"\\n    ivec3 getOutputCoords() {\\n      ivec2 resTexRC = ivec2(resultUV.yx *\\n                             vec2(\" + n[0] + \", \" + n[1] + \"));\\n      int index = resTexRC.x * \" + n[1] + \" + resTexRC.y;\\n      \" + r + \"\\n      return ivec3(r, c, d);\\n    }\\n  \";\n            case 4:\n                return function(t, e) {\n                    var n = ca([\n                        \"r\",\n                        \"c\",\n                        \"d\",\n                        \"d2\"\n                    ], t);\n                    return \"\\n    ivec4 getOutputCoords() {\\n      ivec2 resTexRC = ivec2(resultUV.yx *\\n        vec2(\" + e[0] + \", \" + e[1] + \"));\\n      int index = resTexRC.x * \" + e[1] + \" + resTexRC.y;\\n      \" + n + \"\\n      return ivec4(r, c, d, d2);\\n    }\\n  \";\n                }(t, e);\n            case 5:\n                return function(t, e) {\n                    var n = ca([\n                        \"r\",\n                        \"c\",\n                        \"d\",\n                        \"d2\",\n                        \"d3\"\n                    ], t);\n                    return \"\\n    ivec5 getOutputCoords() {\\n      ivec2 resTexRC = ivec2(resultUV.yx * vec2(\" + e[0] + \",\\n                             \" + e[1] + \"));\\n\\n      int index = resTexRC.x * \" + e[1] + \" + resTexRC.y;\\n\\n      \" + n + \"\\n\\n      ivec5 outShape = ivec5(r, c, d, d2, d3);\\n      return outShape;\\n    }\\n  \";\n                }(t, e);\n            case 6:\n                return function(t, e) {\n                    var n = ca([\n                        \"r\",\n                        \"c\",\n                        \"d\",\n                        \"d2\",\n                        \"d3\",\n                        \"d4\"\n                    ], t);\n                    return \"\\n    ivec6 getOutputCoords() {\\n      ivec2 resTexRC = ivec2(resultUV.yx *\\n        vec2(\" + e[0] + \", \" + e[1] + \"));\\n      int index = resTexRC.x * \" + e[1] + \" + resTexRC.y;\\n\\n      \" + n + \"\\n\\n      ivec6 result = ivec6(r, c, d, d2, d3, d4);\\n      return result;\\n    }\\n  \";\n                }(t, e);\n            default:\n                throw new Error(t.length + \"-D output sampling is not yet supported\");\n        }\n        var n, r;\n    }(e.logicalShape, c), i = function(t) {\n        return \"\\n    void setOutput(float val) {\\n      \" + t.output + \" = vec4(val, 0, 0, 0);\\n    }\\n  \";\n    }(l)), r && (f += ya), [\n        f,\n        h,\n        i,\n        s,\n        a,\n        u,\n        n\n    ].join(\"\\n\");\n}\nfunction da(t) {\n    var e = t.shapeInfo.logicalShape;\n    switch(e.length){\n        case 0:\n            return function(t) {\n                var e = t.name, n = \"get\" + e.charAt(0).toUpperCase() + e.slice(1);\n                if (t.shapeInfo.isUniform) return \"float \" + n + \"() {return \" + e + \";}\";\n                var r = t.shapeInfo.texShape, o = r[0], a = r[1];\n                if (1 === o && 1 === a) return \"\\n      float \" + n + \"() {\\n        return sampleTexture(\" + e + \", halfCR);\\n      }\\n    \";\n                var i = t.shapeInfo.texShape, s = i[0], u = i[1], c = xa(e);\n                return \"\\n    float \" + n + \"() {\\n      vec2 uv = uvFromFlat(\" + s + \", \" + u + \", \" + c + \");\\n      return sampleTexture(\" + e + \", uv);\\n    }\\n  \";\n            }(t);\n        case 1:\n            return function(t) {\n                var e = t.name, n = \"get\" + e.charAt(0).toUpperCase() + e.slice(1);\n                if (t.shapeInfo.isUniform) return \"\\n      float \" + n + \"(int index) {\\n        \" + ba(t) + \"\\n      }\\n    \";\n                var r = t.shapeInfo.texShape, o = r[0], a = r[1];\n                if (1 === a && 1 === o) return \"\\n      float \" + n + \"(int index) {\\n        return sampleTexture(\" + e + \", halfCR);\\n      }\\n    \";\n                var i = xa(e);\n                if (1 === a) return \"\\n      float \" + n + \"(int index) {\\n        vec2 uv = vec2(0.5, (float(index + \" + i + \") + 0.5) / \" + o + \".0);\\n        return sampleTexture(\" + e + \", uv);\\n      }\\n    \";\n                if (1 === o) return \"\\n      float \" + n + \"(int index) {\\n        vec2 uv = vec2((float(index + \" + i + \") + 0.5) / \" + a + \".0, 0.5);\\n        return sampleTexture(\" + e + \", uv);\\n      }\\n    \";\n                return \"\\n    float \" + n + \"(int index) {\\n      vec2 uv = uvFromFlat(\" + o + \", \" + a + \", index + \" + i + \");\\n      return sampleTexture(\" + e + \", uv);\\n    }\\n  \";\n            }(t);\n        case 2:\n            return function(t) {\n                var e = t.shapeInfo.logicalShape, n = t.name, r = \"get\" + n.charAt(0).toUpperCase() + n.slice(1), o = t.shapeInfo.texShape;\n                if (null != o && S(e, o)) {\n                    var a = o[0], i = o[1];\n                    return \"\\n    float \" + r + \"(int row, int col) {\\n      vec2 uv = (vec2(col, row) + halfCR) / vec2(\" + i + \".0, \" + a + \".0);\\n      return sampleTexture(\" + n + \", uv);\\n    }\\n  \";\n                }\n                var s = M(e), u = s.newShape, c = s.keptDims, l = u;\n                if (l.length < e.length) {\n                    var h = Ca(t, l);\n                    return \"\\n      \" + da(h) + \"\\n      float \" + r + \"(int row, int col) {\\n        return \" + r + \"(\" + Ea([\n                        \"row\",\n                        \"col\"\n                    ], c) + \");\\n      }\\n    \";\n                }\n                if (t.shapeInfo.isUniform) return \"\\n      float \" + r + \"(int row, int col) {\\n        int index = round(dot(vec2(row, col), vec2(\" + e[1] + \", 1)));\\n        \" + ba(t) + \"\\n      }\\n    \";\n                var f = o[0], d = o[1], p = xa(n);\n                if (1 === d) return \"\\n    float \" + r + \"(int row, int col) {\\n      float index = dot(vec3(row, col, \" + p + \"), vec3(\" + e[1] + \", 1, 1));\\n      vec2 uv = vec2(0.5, (index + 0.5) / \" + f + \".0);\\n      return sampleTexture(\" + n + \", uv);\\n    }\\n  \";\n                if (1 === f) return \"\\n    float \" + r + \"(int row, int col) {\\n      float index = dot(vec3(row, col, \" + p + \"), vec3(\" + e[1] + \", 1, 1));\\n      vec2 uv = vec2((index + 0.5) / \" + d + \".0, 0.5);\\n      return sampleTexture(\" + n + \", uv);\\n    }\\n  \";\n                return \"\\n  float \" + r + \"(int row, int col) {\\n    // Explicitly use integer operations as dot() only works on floats.\\n    int index = row * \" + e[1] + \" + col + \" + p + \";\\n    vec2 uv = uvFromFlat(\" + f + \", \" + d + \", index);\\n    return sampleTexture(\" + n + \", uv);\\n  }\\n\";\n            }(t);\n        case 3:\n            return function(t) {\n                var e = t.shapeInfo.logicalShape, n = t.name, r = \"get\" + n.charAt(0).toUpperCase() + n.slice(1), o = e[1] * e[2], a = e[2], i = M(e), s = i.newShape, u = i.keptDims, c = s;\n                if (c.length < e.length) {\n                    var l = Ca(t, c);\n                    return \"\\n        \" + da(l) + \"\\n        float \" + r + \"(int row, int col, int depth) {\\n          return \" + r + \"(\" + Ea([\n                        \"row\",\n                        \"col\",\n                        \"depth\"\n                    ], u) + \");\\n        }\\n      \";\n                }\n                if (t.shapeInfo.isUniform) return \"\\n      float \" + r + \"(int row, int col, int depth) {\\n        int index = round(dot(vec3(row, col, depth),\\n                          vec3(\" + o + \", \" + a + \", 1)));\\n        \" + ba(t) + \"\\n      }\\n    \";\n                var h = t.shapeInfo.texShape, f = h[0], d = h[1], p = t.shapeInfo.flatOffset;\n                if (d === o && null == p) return \"\\n        float \" + r + \"(int row, int col, int depth) {\\n          float texR = float(row);\\n          float texC = dot(vec2(col, depth), vec2(\" + a + \", 1));\\n          vec2 uv = (vec2(texC, texR) + halfCR) /\\n                     vec2(\" + d + \".0, \" + f + \".0);\\n          return sampleTexture(\" + n + \", uv);\\n        }\\n      \";\n                if (d === a && null == p) return \"\\n    float \" + r + \"(int row, int col, int depth) {\\n      float texR = dot(vec2(row, col), vec2(\" + e[1] + \", 1));\\n      float texC = float(depth);\\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(\" + d + \".0, \" + f + \".0);\\n      return sampleTexture(\" + n + \", uv);\\n    }\\n  \";\n                var v = xa(n);\n                return \"\\n      float \" + r + \"(int row, int col, int depth) {\\n        // Explicitly use integer operations as dot() only works on floats.\\n        int index = row * \" + o + \" + col * \" + a + \" + depth + \" + v + \";\\n        vec2 uv = uvFromFlat(\" + f + \", \" + d + \", index);\\n        return sampleTexture(\" + n + \", uv);\\n      }\\n  \";\n            }(t);\n        case 4:\n            return function(t) {\n                var e = t.shapeInfo.logicalShape, n = t.name, r = \"get\" + n.charAt(0).toUpperCase() + n.slice(1), o = e[3], a = e[2] * o, i = e[1] * a, s = M(e), u = s.newShape, c = s.keptDims;\n                if (u.length < e.length) {\n                    var l = Ca(t, u);\n                    return \"\\n      \" + da(l) + \"\\n      float \" + r + \"(int row, int col, int depth, int depth2) {\\n        return \" + r + \"(\" + Ea([\n                        \"row\",\n                        \"col\",\n                        \"depth\",\n                        \"depth2\"\n                    ], c) + \");\\n      }\\n    \";\n                }\n                if (t.shapeInfo.isUniform) return \"\\n      float \" + r + \"(int row, int col, int depth, int depth2) {\\n        int index = round(dot(vec4(row, col, depth, depth2),\\n                          vec4(\" + i + \", \" + a + \", \" + o + \", 1)));\\n        \" + ba(t) + \"\\n      }\\n    \";\n                var h = t.shapeInfo.flatOffset, f = t.shapeInfo.texShape, d = f[0], p = f[1];\n                if (p === i && null == h) return \"\\n      float \" + r + \"(int row, int col, int depth, int depth2) {\\n        float texR = float(row);\\n        float texC =\\n            dot(vec3(col, depth, depth2),\\n                vec3(\" + a + \", \" + o + \", 1));\\n        vec2 uv = (vec2(texC, texR) + halfCR) /\\n                   vec2(\" + p + \".0, \" + d + \".0);\\n        return sampleTexture(\" + n + \", uv);\\n      }\\n    \";\n                if (p === o && null == h) return \"\\n      float \" + r + \"(int row, int col, int depth, int depth2) {\\n        float texR = dot(vec3(row, col, depth),\\n                         vec3(\" + e[1] * e[2] + \", \" + e[2] + \", 1));\\n        float texC = float(depth2);\\n        vec2 uv = (vec2(texC, texR) + halfCR) /\\n                  vec2(\" + p + \".0, \" + d + \".0);\\n        return sampleTexture(\" + n + \", uv);\\n      }\\n    \";\n                var v = xa(n);\n                return \"\\n    float \" + r + \"(int row, int col, int depth, int depth2) {\\n      // Explicitly use integer operations as dot() only works on floats.\\n      int index = row * \" + i + \" + col * \" + a + \" +\\n          depth * \" + o + \" + depth2;\\n      vec2 uv = uvFromFlat(\" + d + \", \" + p + \", index + \" + v + \");\\n      return sampleTexture(\" + n + \", uv);\\n    }\\n  \";\n            }(t);\n        case 5:\n            return function(t) {\n                var e = t.shapeInfo.logicalShape, n = t.name, r = \"get\" + n.charAt(0).toUpperCase() + n.slice(1), o = e[4], a = e[3] * o, i = e[2] * a, s = e[1] * i, u = M(e), c = u.newShape, l = u.keptDims;\n                if (c.length < e.length) {\n                    var h = Ca(t, c);\n                    return \"\\n      \" + da(h) + \"\\n      float \" + r + \"(int row, int col, int depth, int depth2, int depth3) {\\n        return \" + r + \"(\" + Ea([\n                        \"row\",\n                        \"col\",\n                        \"depth\",\n                        \"depth2\",\n                        \"depth3\"\n                    ], l) + \");\\n      }\\n    \";\n                }\n                if (t.shapeInfo.isUniform) return \"\\n      float \" + r + \"(int row, int col, int depth, int depth2, int depth3) {\\n        float index = dot(\\n          vec4(row, col, depth, depth2),\\n          vec4(\" + s + \", \" + i + \", \" + a + \", \" + o + \")) +\\n          depth3;\\n        \" + ba(t) + \"\\n      }\\n    \";\n                var f = t.shapeInfo.flatOffset, d = t.shapeInfo.texShape, p = d[0], v = d[1];\n                if (v === s && null == f) return \"\\n      float \" + r + \"(int row, int col, int depth, int depth2, int depth3) {\\n        int texR = row;\\n        float texC = dot(vec4(col, depth, depth2, depth3),\\n                         vec4(\" + i + \", \" + a + \", \" + o + \", 1));\\n        vec2 uv = (vec2(texC, texR) + halfCR) /\\n                   vec2(\" + v + \".0, \" + p + \".0);\\n        return sampleTexture(\" + n + \", uv);\\n      }\\n    \";\n                if (v === o && null == f) return \"\\n      float \" + r + \"(int row, int col, int depth, int depth2, int depth3) {\\n        float texR = dot(\\n          vec4(row, col, depth, depth2),\\n          vec4(\" + e[1] * e[2] * e[3] + \",\\n               \" + e[2] * e[3] + \", \" + e[3] + \", 1));\\n        int texC = depth3;\\n        vec2 uv = (vec2(texC, texR) + halfCR) /\\n                  vec2(\" + v + \".0, \" + p + \".0);\\n        return sampleTexture(\" + n + \", uv);\\n      }\\n    \";\n                var m = xa(n);\n                return \"\\n    float \" + r + \"(int row, int col, int depth, int depth2, int depth3) {\\n      // Explicitly use integer operations as dot() only works on floats.\\n      int index = row * \" + s + \" + col * \" + i + \" + depth * \" + a + \" +\\n          depth2 * \" + o + \" + depth3 + \" + m + \";\\n      vec2 uv = uvFromFlat(\" + p + \", \" + v + \", index);\\n      return sampleTexture(\" + n + \", uv);\\n    }\\n  \";\n            }(t);\n        case 6:\n            return function(t) {\n                var e = t.shapeInfo.logicalShape, n = t.name, r = \"get\" + n.charAt(0).toUpperCase() + n.slice(1), o = M(e), a = o.newShape, i = o.keptDims;\n                if (a.length < e.length) {\n                    var s = Ca(t, a);\n                    return \"\\n      \" + da(s) + \"\\n      float \" + r + \"(int row, int col, int depth,\\n                    int depth2, int depth3, int depth4) {\\n        return \" + r + \"(\" + Ea([\n                        \"row\",\n                        \"col\",\n                        \"depth\",\n                        \"depth2\",\n                        \"depth3\",\n                        \"depth4\"\n                    ], i) + \");\\n      }\\n    \";\n                }\n                var u = e[5], c = e[4] * u, l = e[3] * c, h = e[2] * l, f = e[1] * h;\n                if (t.shapeInfo.isUniform) return \"\\n      float \" + r + \"(int row, int col, int depth,\\n                  int depth2, int depth3, int depth4) {\\n        int index = round(dot(\\n          vec4(row, col, depth, depth2),\\n          vec4(\" + f + \", \" + h + \", \" + l + \", \" + c + \")) +\\n          dot(\\n            vec2(depth3, depth4),\\n            vec2(\" + u + \", 1)));\\n        \" + ba(t) + \"\\n      }\\n    \";\n                var d = t.shapeInfo.flatOffset, p = t.shapeInfo.texShape, v = p[0], m = p[1];\n                if (m === f && null == d) return \"\\n      float \" + r + \"(int row, int col, int depth,\\n                    int depth2, int depth3, int depth4) {\\n        int texR = row;\\n        float texC = dot(vec4(col, depth, depth2, depth3),\\n          vec4(\" + h + \", \" + l + \", \" + c + \", \" + u + \")) +\\n               float(depth4);\\n        vec2 uv = (vec2(texC, texR) + halfCR) /\\n                   vec2(\" + m + \".0, \" + v + \".0);\\n        return sampleTexture(\" + n + \", uv);\\n      }\\n    \";\n                if (m === u && null == d) return \"\\n      float \" + r + \"(int row, int col, int depth,\\n                    int depth2, int depth3, int depth4) {\\n        float texR = dot(vec4(row, col, depth, depth2),\\n          vec4(\" + e[1] * e[2] * e[3] * e[4] + \",\\n               \" + e[2] * e[3] * e[4] + \",\\n               \" + e[3] * e[4] + \",\\n               \" + e[4] + \")) + float(depth3);\\n        int texC = depth4;\\n        vec2 uv = (vec2(texC, texR) + halfCR) /\\n                  vec2(\" + m + \".0, \" + v + \".0);\\n        return sampleTexture(\" + n + \", uv);\\n      }\\n    \";\n                var g = xa(n);\n                return \"\\n    float \" + r + \"(int row, int col, int depth,\\n                  int depth2, int depth3, int depth4) {\\n      // Explicitly use integer operations as dot() only works on floats.\\n      int index = row * \" + f + \" + col * \" + h + \" + depth * \" + l + \" +\\n          depth2 * \" + c + \" + depth3 * \" + u + \" + depth4 + \" + g + \";\\n      vec2 uv = uvFromFlat(\" + v + \", \" + m + \", index);\\n      return sampleTexture(\" + n + \", uv);\\n    }\\n  \";\n            }(t);\n        default:\n            throw new Error(e.length + \"-D input sampling is not yet supported\");\n    }\n}\nfunction pa(t) {\n    var e, n, r;\n    switch(t.shapeInfo.logicalShape.length){\n        case 0:\n            return e = t.name, n = \"get\" + e.charAt(0).toUpperCase() + e.slice(1), r = ua(), \"\\n    vec4 \" + n + \"() {\\n      return \" + r.texture2D + \"(\" + e + \", halfCR);\\n    }\\n  \";\n        case 1:\n            return function(t) {\n                var e = t.name, n = \"get\" + e.charAt(0).toUpperCase() + e.slice(1), r = t.shapeInfo.texShape, o = [\n                    Math.ceil(r[0] / 2),\n                    Math.ceil(r[1] / 2)\n                ], a = ua();\n                return \"\\n    vec4 \" + n + \"(int index) {\\n      vec2 uv = packedUVfrom1D(\\n        \" + o[0] + \", \" + o[1] + \", index);\\n      return \" + a.texture2D + \"(\" + e + \", uv);\\n    }\\n  \";\n            }(t);\n        case 2:\n            return function(t) {\n                var e = t.shapeInfo.logicalShape, n = t.name, r = \"get\" + n.charAt(0).toUpperCase() + n.slice(1), o = t.shapeInfo.texShape, a = o[0], i = o[1], s = ua();\n                if (null != o && S(e, o)) return \"\\n      vec4 \" + r + \"(int row, int col) {\\n        vec2 uv = (vec2(col, row) + halfCR) / vec2(\" + i + \".0, \" + a + \".0);\\n\\n        return \" + s.texture2D + \"(\" + n + \", uv);\\n      }\\n    \";\n                var u = [\n                    Math.ceil(o[0] / 2),\n                    Math.ceil(o[1] / 2)\n                ], c = Math.ceil(e[1] / 2);\n                return \"\\n    vec4 \" + r + \"(int row, int col) {\\n      vec2 uv = packedUVfrom2D(\" + c + \", \" + u[0] + \", \" + u[1] + \", row, col);\\n      return \" + s.texture2D + \"(\" + n + \", uv);\\n    }\\n  \";\n            }(t);\n        case 3:\n            return function(t) {\n                var e = t.shapeInfo.logicalShape, n = t.name, r = \"get\" + n.charAt(0).toUpperCase() + n.slice(1), o = t.shapeInfo.texShape, a = [\n                    Math.ceil(o[0] / 2),\n                    Math.ceil(o[1] / 2)\n                ];\n                if (1 === e[0]) {\n                    var i = e.slice(1), s = Ca(t, i);\n                    return \"\\n        \" + pa(s) + \"\\n        vec4 \" + r + \"(int b, int row, int col) {\\n          return \" + r + \"(\" + Ea([\n                        \"b\",\n                        \"row\",\n                        \"col\"\n                    ], [\n                        1,\n                        2\n                    ]) + \");\\n        }\\n      \";\n                }\n                var u = a[0], c = a[1], l = Math.ceil(e[2] / 2), h = l * Math.ceil(e[1] / 2), f = ua();\n                return \"\\n    vec4 \" + r + \"(int b, int row, int col) {\\n      vec2 uv = packedUVfrom3D(\\n        \" + u + \", \" + c + \", \" + h + \", \" + l + \", b, row, col);\\n      return \" + f.texture2D + \"(\" + n + \", uv);\\n    }\\n  \";\n            }(t);\n        default:\n            return function(t) {\n                for(var e = t.shapeInfo.logicalShape, n = e.length, r = t.name, o = \"get\" + r.charAt(0).toUpperCase() + r.slice(1), a = t.shapeInfo.texShape, i = [\n                    Math.ceil(a[0] / 2),\n                    Math.ceil(a[1] / 2)\n                ], s = i[0], u = i[1], c = Math.ceil(e[n - 1] / 2), l = c * Math.ceil(e[n - 2] / 2), h = \"int b, int row, int col\", f = \"b * \" + l + \" + (row / 2) * \" + c + \" + (col / 2)\", d = 2; d < n - 1; d++)h = \"int b\" + d + \", \" + h, l *= e[n - d - 1], f = \"b\" + d + \" * \" + l + \" + \" + f;\n                var p = ua();\n                return \"\\n    vec4 \" + o + \"(\" + h + \") {\\n      int index = \" + f + \";\\n      int texR = index / \" + u + \";\\n      int texC = index - texR * \" + u + \";\\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(\" + u + \", \" + s + \");\\n      return \" + p.texture2D + \"(\" + r + \", uv);\\n    }\\n  \";\n            }(t);\n    }\n}\nvar va = \"\\nvec2 uvFromFlat(int texNumR, int texNumC, int index) {\\n  int texR = index / texNumC;\\n  int texC = index - texR * texNumC;\\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\\n}\\nvec2 packedUVfrom1D(int texNumR, int texNumC, int index) {\\n  int texelIndex = index / 2;\\n  int texR = texelIndex / texNumC;\\n  int texC = texelIndex - texR * texNumC;\\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\\n}\\n\", ma = \"\\nvec2 packedUVfrom2D(int texelsInLogicalRow, int texNumR,\\n  int texNumC, int row, int col) {\\n  int texelIndex = (row / 2) * texelsInLogicalRow + (col / 2);\\n  int texR = texelIndex / texNumC;\\n  int texC = texelIndex - texR * texNumC;\\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\\n}\\n\", ga = \"\\nvec2 packedUVfrom3D(int texNumR, int texNumC,\\n    int texelsInBatch, int texelsInLogicalRow, int b,\\n    int row, int col) {\\n  int index = b * texelsInBatch + (row / 2) * texelsInLogicalRow + (col / 2);\\n  int texR = index / texNumC;\\n  int texC = index - texR * texNumC;\\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\\n}\\n\", ya = \"\\n  float getChannel(vec4 frag, vec2 innerDims) {\\n    vec2 modCoord = mod(innerDims, 2.);\\n    return modCoord.x == 0. ?\\n      (modCoord.y == 0. ? frag.r : frag.g) :\\n      (modCoord.y == 0. ? frag.b : frag.a);\\n  }\\n  float getChannel(vec4 frag, int dim) {\\n    float modCoord = mod(float(dim), 2.);\\n    return modCoord == 0. ? frag.r : frag.g;\\n  }\\n\";\nfunction xa(t) {\n    return \"offset\" + t;\n}\nfunction ba(t) {\n    var e = t.name, n = k(t.shapeInfo.logicalShape);\n    return n < 2 ? \"return \" + e + \";\" : \"\\n    for (int i = 0; i < \" + n + \"; i++) {\\n      if (i == index) {\\n        return \" + e + \"[i];\\n      }\\n    }\\n  \";\n}\nfunction wa(t) {\n    if (t <= 1) return \"int\";\n    if (2 === t) return \"ivec2\";\n    if (3 === t) return \"ivec3\";\n    if (4 === t) return \"ivec4\";\n    if (5 === t) return \"ivec5\";\n    if (6 === t) return \"ivec6\";\n    throw Error(\"GPU for rank \" + t + \" is not yet supported\");\n}\nfunction Ca(t, e) {\n    var n = JSON.parse(JSON.stringify(t));\n    return n.shapeInfo.logicalShape = e, n;\n}\nfunction Ea(t, e) {\n    return e.map(function(e) {\n        return t[e];\n    }).join(\", \");\n}\nvar Ra = function(t, e, n, r) {\n    this.variableNames = [\n        \"A\"\n    ], this.packedInputs = !0, this.packedOutput = !0, C(t.length > 2, function() {\n        return \"Packed arg\" + (n.charAt(0).toUpperCase() + n.slice(1)) + \" supports only inputs with rank above 2.\";\n    });\n    var o = t[t.length - 1], a = Math.ceil(o / e);\n    this.outputShape = t.slice(0, -1), a > 1 && this.outputShape.push(a), r || this.variableNames.push(\"bestIndicesA\");\n    var i, s, u = this.outputShape, c = u.length, l = wa(c), h = sa(\"coords\", c);\n    if (1 === a) {\n        var f = wa(s = c + 1);\n        i = \"\\n        \" + f + \" sourceLocR = \" + f + \"(\" + h.join() + \", 0);\\n        ++\" + h[c - 1] + \";\\n        \" + f + \" sourceLocG = \" + f + \"(\" + h.join() + \", 0);\\n        ++\" + h[c - 2] + \";\\n        \" + f + \" sourceLocA = \" + f + \"(\" + h.join() + \", 0);\\n        --\" + h[c - 1] + \";\\n        \" + f + \" sourceLocB = \" + f + \"(\" + h.join() + \", 0);\\n        --\" + h[c - 2] + \";\";\n    } else s = c, i = \"\\n        \" + l + \" sourceLocR = coords;\\n        ++\" + h[c - 1] + \";\\n        \" + l + \" sourceLocG = coords;\\n        ++\" + h[c - 2] + \";\\n        \" + l + \" sourceLocA = coords;\\n        --\" + h[c - 1] + \";\\n        \" + l + \" sourceLocB = coords;\\n        --\" + h[c - 2] + \";\";\n    var d = [\n        \"x\",\n        \"y\",\n        \"z\",\n        \"w\",\n        \"u\",\n        \"v\"\n    ].slice(0, s), p = \".\" + d[s - 1], v = d.map(function(t) {\n        return \"int \" + t;\n    }), m = sa(\"sourceLocR\", s - 1).concat(\"inIdx.r\"), g = sa(\"sourceLocG\", s - 1).concat(\"inIdx.g\"), y = sa(\"sourceLocB\", s - 1).concat(\"inIdx.b\"), x = sa(\"sourceLocA\", s - 1).concat(\"inIdx.a\"), b = \"max\" === n ? \"greaterThan\" : \"lessThan\", w = r ? \"\" : \"\\n          inIdx = round(vec4(getBestIndicesAChannel(\" + m.join() + \"),\\n                             getBestIndicesAChannel(\" + g.join() + \"),\\n                             getBestIndicesAChannel(\" + y.join() + \"),\\n                             getBestIndicesAChannel(\" + x.join() + \")));\", E = \"vec4(\\n            getAChannel(\" + m.join() + \"),\\n            hasNextCol ? getAChannel(\" + g.join() + \") : 0.,\\n            hasNextRow ? getAChannel(\" + y.join() + \") : 0.,\\n            hasNextRow && hasNextCol ? getAChannel(\" + x.join() + \") : 0.)\", R = r ? \"\" : \"\\n      float getBestIndicesAChannel(\" + v.join() + \") {\\n        return getChannel(getBestIndicesA(\" + d.join() + \"),\\n                                          vec2(\" + d.slice(-2).join() + \"));\\n      }\";\n    this.userCode = \"\\n      float getAChannel(\" + v.join() + \") {\\n        return getChannel(getA(\" + d.join() + \"),\\n                               vec2(\" + d.slice(-2).join() + \"));\\n      }\\n      \" + R + \"\\n      void main() {\\n        \" + l + \" coords = getOutputCoords();\\n        bool hasNextCol = \" + h[c - 1] + \" < \" + (u[c - 1] - 1) + \";\\n        bool hasNextRow = \" + h[c - 2] + \" < \" + (u[c - 2] - 1) + \";\\n        \" + i + \"\\n        ivec4 srcIdx = ivec4(sourceLocR\" + p + \", sourceLocG\" + p + \",\\n          sourceLocB\" + p + \", sourceLocA\" + p + \") * \" + e + \";\\n        ivec4 inIdx = srcIdx;\\n        vec4 bestIndex = vec4(inIdx);\\n        vec4 bestValue = \" + E + \";\\n\\n        for (int i = 0; i < \" + e + \"; i++) {\\n          inIdx = srcIdx;\\n          \" + w + \"\\n          vec4 candidate = \" + E + \";\\n          bvec4 nan = isnan(candidate);\\n          bvec4 replace = bvec4(\\n            vec4(\" + b + \"(candidate, bestValue)) * (vec4(1.0) - vec4(nan)));\\n\\n          bestValue = vec4(replace.x  ? candidate.x : bestValue.x,\\n                           replace.y  ? candidate.y : bestValue.y,\\n                           replace.z  ? candidate.z : bestValue.z,\\n                           replace.w  ? candidate.w : bestValue.w);\\n          bestIndex = mix(bestIndex, vec4(inIdx), vec4(replace));\\n          srcIdx++;\\n        }\\n        setOutput(bestIndex);\\n      }\\n    \";\n}, Ia = function(t) {\n    this.variableNames = [\n        \"dy\"\n    ], this.outputShape = t.inShape;\n    var e = t.filterHeight, n = t.filterWidth, r = t.strideHeight, o = t.strideWidth, a = t.dilationHeight, i = t.dilationWidth, s = t.effectiveFilterHeight, u = t.effectiveFilterWidth, c = s - 1 - t.padInfo.top, l = u - 1 - t.padInfo.left, h = 1 / (e * n);\n    this.userCode = \"\\n      const ivec2 pads = ivec2(\" + c + \", \" + l + \");\\n      const float avgMultiplier = float(\" + h + \");\\n\\n      void main() {\\n        ivec4 coords = getOutputCoords();\\n        int b = coords[0];\\n        int d = coords[3];\\n\\n        ivec2 dyRCCorner = coords.yz - pads;\\n        int dyRCorner = dyRCCorner.x;\\n        int dyCCorner = dyRCCorner.y;\\n\\n        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).\\n        // ? = to be determined. : = across all values in that axis.\\n        float dotProd = 0.0;\\n        for (int wR = 0; wR < \" + s + \";\\n            wR += \" + a + \") {\\n          float dyR = float(dyRCorner + wR) / \" + r + \".0;\\n\\n          if (dyR < 0.0 || dyR >= \" + t.outHeight + \".0 || fract(dyR) > 0.0) {\\n            continue;\\n          }\\n          int idyR = int(dyR);\\n\\n          for (int wC = 0; wC < \" + u + \";\\n            wC+= \" + i + \") {\\n            float dyC = float(dyCCorner + wC) / \" + o + \".0;\\n\\n            if (dyC < 0.0 || dyC >= \" + t.outWidth + \".0 ||\\n                fract(dyC) > 0.0) {\\n              continue;\\n            }\\n            int idyC = int(dyC);\\n\\n            float dyValue = getDy(b, idyR, idyC, d);\\n\\n            dotProd += dyValue * avgMultiplier;\\n          }\\n        }\\n        setOutput(dotProd);\\n      }\\n    \";\n}, ka = function(t) {\n    this.variableNames = [\n        \"dy\"\n    ], this.outputShape = t.inShape;\n    var e = t.filterDepth, n = t.filterHeight, r = t.filterWidth, o = t.strideDepth, a = t.strideHeight, i = t.strideWidth, s = t.dilationDepth, u = t.dilationHeight, c = t.dilationWidth, l = t.effectiveFilterDepth, h = t.effectiveFilterHeight, f = t.effectiveFilterWidth, d = l - 1 - t.padInfo.front, p = h - 1 - t.padInfo.top, v = f - 1 - t.padInfo.left, m = 1 / (e * n * r);\n    this.userCode = \"\\n      const ivec3 pads = ivec3(\" + d + \", \" + p + \", \" + v + \");\\n      const float avgMultiplier = float(\" + m + \");\\n\\n      void main() {\\n        ivec5 coords = getOutputCoords();\\n        int batch = coords.x;\\n        int ch = coords.u;\\n\\n        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;\\n        int dyDCorner = dyCorner.x;\\n        int dyRCorner = dyCorner.y;\\n        int dyCCorner = dyCorner.z;\\n\\n        // Convolve dy(?, ?, ?, d) with pos mask(:, :, :, ch) to get\\n        // dx(xD, xR, xC, ch).\\n        // ? = to be determined. : = across all values in that axis.\\n        float dotProd = 0.0;\\n\\n        for (int wD = 0; wD < \" + l + \";\\n            wD += \" + s + \") {\\n          float dyD = float(dyDCorner + wD) / \" + o + \".0;\\n\\n          if (dyD < 0.0 || dyD >= \" + t.outDepth + \".0 || fract(dyD) > 0.0) {\\n            continue;\\n          }\\n          int idyD = int(dyD);\\n\\n          for (int wR = 0; wR < \" + h + \";\\n              wR += \" + u + \") {\\n            float dyR = float(dyRCorner + wR) / \" + a + \".0;\\n\\n            if (dyR < 0.0 || dyR >= \" + t.outHeight + \".0 ||\\n                fract(dyR) > 0.0) {\\n              continue;\\n            }\\n            int idyR = int(dyR);\\n\\n            for (int wC = 0; wC < \" + f + \";\\n                wC += \" + c + \") {\\n              float dyC = float(dyCCorner + wC) / \" + i + \".0;\\n\\n              if (dyC < 0.0 || dyC >= \" + t.outWidth + \".0 ||\\n                  fract(dyC) > 0.0) {\\n                continue;\\n              }\\n              int idyC = int(dyC);\\n\\n              float dyValue = getDy(batch, idyD, idyR, idyC, ch);\\n\\n              dotProd += dyValue * avgMultiplier;\\n            }\\n          }\\n        }\\n        setOutput(dotProd);\\n      }\\n    \";\n}, Sa = function(t, e, n, r, o, a) {\n    this.outputShape = [], this.variableNames = [\n        \"x\",\n        \"mean\",\n        \"variance\"\n    ], Ro(t, e), Ro(t, n);\n    var i = \"0.0\";\n    null != r && (Ro(t, r), this.variableNames.push(\"offset\"), i = \"getOffsetAtOutCoords()\");\n    var s = \"1.0\";\n    null != o && (Ro(t, o), this.variableNames.push(\"scale\"), s = \"getScaleAtOutCoords()\"), this.outputShape = t, this.userCode = \"\\n      void main() {\\n        float x = getXAtOutCoords();\\n        float mean = getMeanAtOutCoords();\\n        float variance = getVarianceAtOutCoords();\\n        float offset = \" + i + \";\\n        float scale = \" + s + \";\\n        float inv = scale * inversesqrt(variance + float(\" + a + \"));\\n        setOutput(dot(vec3(x, -mean, offset), vec3(inv, inv, 1)));\\n      }\\n    \";\n}, Aa = function(t, e, n, r, o, a) {\n    this.packedInputs = !0, this.packedOutput = !0, this.variableNames = [\n        \"x\",\n        \"mean\",\n        \"variance\"\n    ], Ro(t, e), Ro(t, n);\n    var i = \"vec4(0.0)\";\n    null != r && (Ro(t, r), this.variableNames.push(\"offset\"), i = \"getOffsetAtOutCoords()\");\n    var s = \"vec4(1.0)\";\n    null != o && (Ro(t, o), this.variableNames.push(\"scale\"), s = \"getScaleAtOutCoords()\"), this.outputShape = t, this.userCode = \"\\n      void main() {\\n        vec4 offset = \" + i + \";\\n        vec4 scale = \" + s + \";\\n\\n        vec4 x = getXAtOutCoords();\\n        vec4 mean = getMeanAtOutCoords();\\n        vec4 variance = getVarianceAtOutCoords();\\n\\n        vec4 inv = scale * inversesqrt(variance + vec4(\" + a + \"));\\n\\n        setOutput((x - mean) * inv + offset);\\n      }\\n    \";\n}, Da = \"return areal * breal - aimag * bimag;\", Ta = \"return areal * bimag + aimag * breal;\", Na = function(t, e, n) {\n    this.variableNames = [\n        \"AReal\",\n        \"AImag\",\n        \"BReal\",\n        \"BImag\"\n    ], this.outputShape = Ro(e, n), this.userCode = \"\\n      float binaryOpComplex(\\n          float areal, float aimag, float breal, float bimag) {\\n        \" + t + \"\\n      }\\n\\n      void main() {\\n        float areal = getARealAtOutCoords();\\n        float aimag = getAImagAtOutCoords();\\n        float breal = getBRealAtOutCoords();\\n        float bimag = getBImagAtOutCoords();\\n        setOutput(binaryOpComplex(areal, aimag, breal, bimag));\\n      }\\n    \";\n}, Fa = \"return a + b;\", _a = \"return a - b;\", Oa = \"return a * b;\", Ma = \"return (a < 0.) ? b * a : a;\", Ba = function(t, e, n) {\n    this.variableNames = [\n        \"A\",\n        \"B\"\n    ], this.outputShape = Ro(e, n), this.userCode = \"\\n      float binaryOperation(float a, float b) {\\n        \" + t + \"\\n      }\\n\\n      void main() {\\n        float a = getAAtOutCoords();\\n        float b = getBAtOutCoords();\\n        setOutput(binaryOperation(a, b));\\n      }\\n    \";\n}, Pa = \"\\n  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));\\n  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);\\n\", La = function(t, e, n, r) {\n    void 0 === r && (r = !1), this.variableNames = [\n        \"A\",\n        \"B\"\n    ], this.supportsBroadcasting = !0, this.packedInputs = !0, this.packedOutput = !0, this.outputShape = Ro(e, n);\n    var o = this.outputShape.length, a = \"\";\n    if (r) if (0 === o || 1 === k(this.outputShape)) a = \"\\n          result.y = 0.;\\n          result.z = 0.;\\n          result.w = 0.;\\n        \";\n    else if (a = \"\\n          \" + wa(o) + \" coords = getOutputCoords();\\n        \", 1 === o) a += \"\\n            result.y = (coords + 1) >= \" + this.outputShape[0] + \" ? 0. : result.y;\\n            result.z = 0.;\\n            result.w = 0.;\\n          \";\n    else {\n        var i = sa(\"coords\", o);\n        a += \"\\n            bool nextRowOutOfBounds =\\n              (\" + i[o - 2] + \" + 1) >= \" + this.outputShape[o - 2] + \";\\n            bool nextColOutOfBounds =\\n              (\" + i[o - 1] + \" + 1) >= \" + this.outputShape[o - 1] + \";\\n            result.y = nextColOutOfBounds ? 0. : result.y;\\n            result.z = nextRowOutOfBounds ? 0. : result.z;\\n            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;\\n          \";\n    }\n    this.userCode = \"\\n      vec4 binaryOperation(vec4 a, vec4 b) {\\n        \" + t + \"\\n      }\\n\\n      void main() {\\n        vec4 a = getAAtOutCoords();\\n        vec4 b = getBAtOutCoords();\\n\\n        vec4 result = binaryOperation(a, b);\\n        \" + a + \"\\n\\n        setOutput(result);\\n      }\\n    \";\n}, Wa = function() {\n    function t(t) {\n        this.variableNames = [\n            \"A\"\n        ], this.outputShape = t, this.userCode = \"\\n      uniform float minVal;\\n      uniform float maxVal;\\n\\n      void main() {\\n        float value = getAAtOutCoords();\\n        if (isnan(value)) {\\n          setOutput(value);\\n          return;\\n        }\\n\\n        setOutput(clamp(value, minVal, maxVal));\\n      }\\n    \";\n    }\n    return t.prototype.getCustomSetupFunc = function(t, e) {\n        var n = this;\n        return function(r, o) {\n            null == n.minLoc && (n.minLoc = r.getUniformLocationNoThrow(o, \"minVal\"), n.maxLoc = r.getUniformLocationNoThrow(o, \"maxVal\")), r.gl.uniform1f(n.minLoc, t), r.gl.uniform1f(n.maxLoc, e);\n        };\n    }, t;\n}(), Ua = function() {\n    function t(t) {\n        this.variableNames = [\n            \"A\"\n        ], this.packedInputs = !0, this.packedOutput = !0, this.outputShape = t, this.userCode = \"\\n      uniform float minVal;\\n      uniform float maxVal;\\n\\n      void main() {\\n        vec4 value = getAAtOutCoords();\\n\\n        if (any(isnan(value))) {\\n          setOutput(value);\\n          return;\\n        }\\n\\n        setOutput(clamp(value, vec4(minVal), vec4(maxVal)));\\n      }\\n    \";\n    }\n    return t.prototype.getCustomSetupFunc = function(t, e) {\n        var n = this;\n        return function(r, o) {\n            null == n.minLoc && (n.minLoc = r.getUniformLocationNoThrow(o, \"minVal\"), n.maxLoc = r.getUniformLocationNoThrow(o, \"maxVal\")), r.gl.uniform1f(n.minLoc, t), r.gl.uniform1f(n.maxLoc, e);\n        };\n    }, t;\n}(), Va = function(t) {\n    this.variableNames = [\n        \"real\",\n        \"imag\"\n    ], this.outputShape = t, this.userCode = \"\\n      void main() {\\n        float re = abs(getRealAtOutCoords());\\n        float im = abs(getImagAtOutCoords());\\n        float mx = max(re, im);\\n\\n        // sadly the length function in glsl is not underflow-safe\\n        // (at least not on Intel GPUs). So the safe solution is\\n        // to ensure underflow-safety in all cases.\\n        setOutput(\\n          mx == 0.0 ? 0.0 : mx * length(vec2(1, min(re, im)/mx))\\n        );\\n      }\\n    \";\n}, za = function(t) {\n    this.outputShape = [], this.outputShape = Sn(t, 1), this.variableNames = t.map(function(t, e) {\n        return \"T\" + e;\n    });\n    var e = new Array(t.length - 1);\n    e[0] = t[0][1];\n    for(var n = 1; n < e.length; n++)e[n] = e[n - 1] + t[n][1];\n    var r = [\n        \"if (yC < \" + e[0] + \") setOutput(getT0(yR, yC));\"\n    ];\n    for(n = 1; n < e.length; n++){\n        var o = e[n - 1];\n        r.push(\"else if (yC < \" + e[n] + \") setOutput(getT\" + n + \"(yR, yC-\" + o + \"));\");\n    }\n    var a = e.length, i = e[e.length - 1];\n    r.push(\"else setOutput(getT\" + a + \"(yR, yC-\" + i + \"));\"), this.userCode = \"\\n      void main() {\\n        ivec2 coords = getOutputCoords();\\n        int yR = coords.x;\\n        int yC = coords.y;\\n\\n        \" + r.join(\"\\n        \") + \"\\n      }\\n    \";\n}, Ga = function(t, e) {\n    this.packedInputs = !0, this.packedOutput = !0, this.outputShape = [], this.outputShape = Sn(t, e);\n    var n = this.outputShape, r = n.length, o = wa(r), a = sa(\"coords\", r), i = [\n        \"x\",\n        \"y\",\n        \"z\",\n        \"w\",\n        \"u\",\n        \"v\"\n    ].slice(0, r);\n    this.variableNames = t.map(function(t, e) {\n        return \"T\" + e;\n    });\n    var s = new Array(t.length - 1);\n    s[0] = t[0][e];\n    for(var u = 1; u < s.length; u++)s[u] = s[u - 1] + t[u][e];\n    var c = i[e], l = i.slice(-2), h = i.join(), f = \"if (\" + c + \" < \" + s[0] + \") {\\n        return getChannel(\\n            getT0(\" + h + \"), vec2(\" + l.join() + \"));\\n        }\";\n    for(u = 1; u < s.length; u++){\n        var d = s[u - 1];\n        f += \"\\n        if (\" + c + \" < \" + s[u] + \"  && \" + c + \" >= \" + s[u - 1] + \") {\\n          return getChannel(\\n            getT\" + u + \"(\" + Ha(i, c, d) + \"),\\n            vec2(\" + Ha(l, c, d) + \"));\\n        }\";\n    }\n    var p = s.length, v = s[s.length - 1];\n    f += \"\\n        return getChannel(\\n          getT\" + p + \"(\" + Ha(i, c, v) + \"),\\n          vec2(\" + Ha(l, c, v) + \"));\", this.userCode = \"\\n      float getValue(\" + i.map(function(t) {\n        return \"int \" + t;\n    }) + \") {\\n        \" + f + \"\\n      }\\n\\n      void main() {\\n        \" + o + \" coords = getOutputCoords();\\n        vec4 result = vec4(getValue(\" + a + \"), 0., 0., 0.);\\n\\n        \" + a[r - 1] + \" = \" + a[r - 1] + \" + 1;\\n        if (\" + a[r - 1] + \" < \" + n[r - 1] + \") {\\n          result.g = getValue(\" + a + \");\\n        }\\n\\n        \" + a[r - 2] + \" = \" + a[r - 2] + \" + 1;\\n        if (\" + a[r - 2] + \" < \" + n[r - 2] + \") {\\n          result.a = getValue(\" + a + \");\\n        }\\n\\n        \" + a[r - 1] + \" = \" + a[r - 1] + \" - 1;\\n        if (\" + a[r - 2] + \" < \" + n[r - 2] + \" &&\\n            \" + a[r - 1] + \" < \" + n[r - 1] + \") {\\n          result.b = getValue(\" + a + \");\\n        }\\n        setOutput(result);\\n      }\\n    \";\n};\nfunction Ha(t, e, n) {\n    var r = t.indexOf(e);\n    return t.map(function(t, e) {\n        return e === r ? t + \" - \" + n : t;\n    }).join();\n}\nvar qa = function(t) {\n    this.variableNames = [\n        \"x\",\n        \"dy\"\n    ], this.outputShape = t.filterShape;\n    var e = t.strideHeight, n = t.strideWidth, r = t.padInfo.top, o = t.padInfo.left, a = \"channelsLast\" === t.dataFormat;\n    this.userCode = \"\\n      void main() {\\n        ivec4 coords = getOutputCoords();\\n        int wR = coords.x;\\n        int wC = coords.y;\\n        int d1 = coords.z;\\n        int d2 = coords.w;\\n\\n        // Convolve x(?, ?, d1) with dy(:, :, d2) to get dw(wR, wC, d1, d2).\\n        // ? = to be determined. : = across all values in that axis.\\n        float dotProd = 0.0;\\n\\n        for (int b = 0; b < \" + t.batchSize + \"; b++) {\\n          for (int yR = 0; yR < \" + t.outHeight + \"; yR++) {\\n            int xR = wR + yR * \" + e + \" - \" + r + \";\\n\\n            if (xR < 0 || xR >= \" + t.inHeight + \") {\\n              continue;\\n            }\\n\\n            for (int yC = 0; yC < \" + t.outWidth + \"; yC++) {\\n              int xC = wC + yC * \" + n + \" - \" + o + \";\\n\\n              if (xC < 0 || xC >= \" + t.inWidth + \") {\\n                continue;\\n              }\\n\\n              if (\" + a + \") {\\n                float dyValue = getDy(b, yR, yC, d2);\\n                float xValue = getX(b, xR, xC, d1);\\n                dotProd += (xValue * dyValue);\\n              } else {\\n                float dyValue = getDy(b, d2, yR, yC);\\n                float xValue = getX(b, d1, xR, xC);\\n                dotProd += (xValue * dyValue);\\n              }\\n\\n            }\\n          }\\n        }\\n        setOutput(dotProd);\\n      }\\n    \";\n}, Ka = function(t) {\n    this.variableNames = [\n        \"dy\",\n        \"W\"\n    ], this.outputShape = t.inShape;\n    var e = t.filterHeight, n = t.filterWidth, r = t.strideHeight, o = t.strideWidth, a = \"channelsLast\" === t.dataFormat, i = e - 1 - t.padInfo.top, s = n - 1 - t.padInfo.left, u = a ? 1 : 2, c = a ? 2 : 3, l = a ? 3 : 1;\n    this.userCode = \"\\n      const ivec2 pads = ivec2(\" + i + \", \" + s + \");\\n\\n      void main() {\\n        ivec4 coords = getOutputCoords();\\n        int batch = coords[0];\\n        int d1 = coords[\" + l + \"];\\n\\n        ivec2 dyCorner = ivec2(coords[\" + u + \"], coords[\" + c + \"]) - pads;\\n        int dyRCorner = dyCorner.x;\\n        int dyCCorner = dyCorner.y;\\n\\n        // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).\\n        // ? = to be determined. : = across all values in that axis.\\n        float dotProd = 0.0;\\n        for (int wR = 0; wR < \" + e + \"; wR++) {\\n          float dyR = float(dyRCorner + wR) / \" + r + \".0;\\n\\n          if (dyR < 0.0 || dyR >= \" + t.outHeight + \".0 || fract(dyR) > 0.0) {\\n            continue;\\n          }\\n          int idyR = int(dyR);\\n\\n          int wRPerm = \" + e + \" - 1 - wR;\\n\\n          for (int wC = 0; wC < \" + n + \"; wC++) {\\n            float dyC = float(dyCCorner + wC) / \" + o + \".0;\\n\\n            if (dyC < 0.0 || dyC >= \" + t.outWidth + \".0 ||\\n                fract(dyC) > 0.0) {\\n              continue;\\n            }\\n            int idyC = int(dyC);\\n\\n            int wCPerm = \" + n + \" - 1 - wC;\\n\\n            for (int d2 = 0; d2 < \" + t.outChannels + \"; d2++) {\\n\\n              if (\" + a + \") {\\n                float xValue = getDy(batch, idyR, idyC, d2);\\n                float wValue = getW(wRPerm, wCPerm, d1, d2);\\n                dotProd += xValue * wValue;\\n              } else {\\n                float xValue = getDy(batch, d2, idyR, idyC);\\n                float wValue = getW(wRPerm, wCPerm, d1, d2);\\n                dotProd += xValue * wValue;\\n              }\\n\\n            }\\n          }\\n        }\\n        setOutput(dotProd);\\n      }\\n    \";\n}, ja = function(t) {\n    this.variableNames = [\n        \"x\",\n        \"dy\"\n    ], this.outputShape = t.filterShape;\n    var e = t.strideDepth, n = t.strideHeight, r = t.strideWidth, o = t.padInfo.front, a = t.padInfo.top, i = t.padInfo.left;\n    this.userCode = \"\\n      void main() {\\n        ivec5 coords = getOutputCoords();\\n        int wF = coords.x;\\n        int wR = coords.y;\\n        int wC = coords.z;\\n        int d1 = coords.w;\\n        int d2 = coords.u;\\n\\n        float dotProd = 0.0;\\n\\n        for (int b = 0; b < \" + t.batchSize + \"; b++) {\\n          for (int yF = 0; yF < \" + t.outDepth + \"; yF++) {\\n            int xF = wF + yF * \" + e + \" - \" + o + \";\\n\\n            if (xF < 0 || xF >= \" + t.inDepth + \") {\\n              continue;\\n            }\\n\\n            for (int yR = 0; yR < \" + t.outHeight + \"; yR++) {\\n              int xR = wR + yR * \" + n + \" - \" + a + \";\\n\\n              if (xR < 0 || xR >= \" + t.inHeight + \") {\\n                continue;\\n              }\\n\\n              for (int yC = 0; yC < \" + t.outWidth + \"; yC++) {\\n                int xC = wC + yC * \" + r + \" - \" + i + \";\\n\\n                if (xC < 0 || xC >= \" + t.inWidth + \") {\\n                  continue;\\n                }\\n\\n                float dyValue = getDy(b, yF, yR, yC, d2);\\n                float xValue = getX(b, xF, xR, xC, d1);\\n                dotProd += (xValue * dyValue);\\n              }\\n            }\\n          }\\n        }\\n        setOutput(dotProd);\\n      }\\n    \";\n}, Xa = function(t) {\n    this.variableNames = [\n        \"dy\",\n        \"W\"\n    ], this.outputShape = t.inShape;\n    var e = t.filterDepth, n = t.filterHeight, r = t.filterWidth, o = t.strideDepth, a = t.strideHeight, i = t.strideWidth, s = e - 1 - t.padInfo.front, u = n - 1 - t.padInfo.top, c = r - 1 - t.padInfo.left;\n    this.userCode = \"\\n      const ivec3 pads = ivec3(\" + s + \", \" + u + \", \" + c + \");\\n\\n      void main() {\\n        ivec5 coords = getOutputCoords();\\n        int batch = coords.x;\\n        int d1 = coords.u;\\n\\n\\n        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;\\n        int dyFCorner = dyCorner.x;\\n        int dyRCorner = dyCorner.y;\\n        int dyCCorner = dyCorner.z;\\n\\n        float dotProd = 0.0;\\n        for (int wF = 0; wF < \" + e + \"; wF++) {\\n          float dyF = float(dyFCorner + wF) / \" + o + \".0;\\n\\n          if (dyF < 0.0 || dyF >= \" + t.outDepth + \".0 || fract(dyF) > 0.0) {\\n            continue;\\n          }\\n          int idyF = int(dyF);\\n\\n          int wFPerm = \" + e + \" - 1 - wF;\\n\\n          for (int wR = 0; wR < \" + n + \"; wR++) {\\n            float dyR = float(dyRCorner + wR) / \" + a + \".0;\\n\\n            if (dyR < 0.0 || dyR >= \" + t.outHeight + \".0 ||\\n              fract(dyR) > 0.0) {\\n              continue;\\n            }\\n            int idyR = int(dyR);\\n\\n            int wRPerm = \" + n + \" - 1 - wR;\\n\\n            for (int wC = 0; wC < \" + r + \"; wC++) {\\n              float dyC = float(dyCCorner + wC) / \" + i + \".0;\\n\\n              if (dyC < 0.0 || dyC >= \" + t.outWidth + \".0 ||\\n                  fract(dyC) > 0.0) {\\n                continue;\\n              }\\n              int idyC = int(dyC);\\n\\n              int wCPerm = \" + r + \" - 1 - wC;\\n\\n              for (int d2 = 0; d2 < \" + t.outChannels + \"; d2++) {\\n                float xValue = getDy(batch, idyF, idyR, idyC, d2);\\n                float wValue = getW(wFPerm, wRPerm, wCPerm, d1, d2);\\n                dotProd += xValue * wValue;\\n              }\\n            }\\n          }\\n        }\\n        setOutput(dotProd);\\n      }\\n    \";\n}, Ya = function(t) {\n    this.variableNames = [\n        \"x\",\n        \"dy\"\n    ], this.outputShape = t.filterShape;\n    var e = t.strideHeight, n = t.strideWidth, r = t.padInfo.top, o = t.padInfo.left, a = t.outChannels / t.inChannels;\n    this.userCode = \"\\n      void main() {\\n        ivec4 coords = getOutputCoords();\\n        int wR = coords.x;\\n        int wC = coords.y;\\n        int d1 = coords.z;\\n        int dm = coords.w;\\n        int d2 = d1 * \" + a + \" + dm;\\n\\n        float dotProd = 0.0;\\n\\n        // TO DO: Vec4 over the batch size\\n        for (int b = 0; b < \" + t.batchSize + \"; b++) {\\n          for (int yR = 0; yR < \" + t.outHeight + \"; yR++) {\\n            int xR = wR + yR * \" + e + \" - \" + r + \";\\n\\n            if (xR < 0 || xR >= \" + t.inHeight + \") {\\n              continue;\\n            }\\n\\n            for (int yC = 0; yC < \" + t.outWidth + \"; yC++) {\\n              int xC = wC + yC * \" + n + \" - \" + o + \";\\n\\n              if (xC < 0 || xC >= \" + t.inWidth + \") {\\n                continue;\\n              }\\n\\n              float dyValue = getDy(b, yR, yC, d2);\\n              float xValue = getX(b, xR, xC, d1);\\n              dotProd += (xValue * dyValue);\\n            }\\n          }\\n        }\\n        setOutput(dotProd);\\n      }\\n    \";\n}, $a = function(t) {\n    this.variableNames = [\n        \"dy\",\n        \"W\"\n    ], this.outputShape = t.inShape;\n    var e = t.filterHeight, n = t.filterWidth, r = t.strideHeight, o = t.strideWidth, a = e - 1 - t.padInfo.top, i = n - 1 - t.padInfo.left, s = t.outChannels / t.inChannels;\n    this.userCode = \"\\n      const ivec2 pads = ivec2(\" + a + \", \" + i + \");\\n\\n      void main() {\\n        ivec4 coords = getOutputCoords();\\n        int batch = coords[0];\\n        int d1 = coords[3];\\n        ivec2 dyCorner = coords.yz - pads;\\n        int dyRCorner = dyCorner.x;\\n        int dyCCorner = dyCorner.y;\\n\\n        float dotProd = 0.0;\\n\\n        for (int wR = 0; wR < \" + e + \"; wR++) {\\n          float dyR = float(dyRCorner + wR) / \" + r + \".0;\\n\\n          if (dyR < 0.0 || dyR >= \" + t.outHeight + \".0 || fract(dyR) > 0.0) {\\n            continue;\\n          }\\n          int idyR = int(dyR);\\n\\n          int wRPerm = \" + e + \" - 1 - wR;\\n\\n          for (int wC = 0; wC < \" + n + \"; wC++) {\\n            float dyC = float(dyCCorner + wC) / \" + o + \".0;\\n\\n            if (dyC < 0.0 || dyC >= \" + t.outWidth + \".0 ||\\n                fract(dyC) > 0.0) {\\n              continue;\\n            }\\n            int idyC = int(dyC);\\n\\n            int wCPerm = \" + n + \" - 1 - wC;\\n\\n            // TO DO: Vec4 over the channelMul\\n            for (int dm = 0; dm < \" + s + \"; dm++) {\\n              int d2 = d1 * \" + s + \" + dm;\\n              float xValue = getDy(batch, idyR, idyC, d2);\\n              float wValue = getW(wRPerm, wCPerm, d1, dm);\\n              dotProd += xValue * wValue;\\n            }\\n          }\\n        }\\n        setOutput(dotProd);\\n      }\\n    \";\n}, Qa = function(t, e, n, r) {\n    void 0 === e && (e = !1), void 0 === n && (n = null), void 0 === r && (r = !1), this.variableNames = [\n        \"x\",\n        \"W\"\n    ], this.outputShape = t.outShape;\n    var o = t.padInfo.top, a = t.padInfo.left, i = t.strideHeight, s = t.strideWidth, u = t.dilationHeight, c = t.dilationWidth, l = t.filterHeight, h = t.filterWidth, f = 4 * Math.floor(t.inChannels / 4), d = t.inChannels % 4, p = \"channelsLast\" === t.dataFormat, v = p ? 1 : 2, m = p ? 2 : 3, g = p ? 3 : 1, y = \"\", x = \"\";\n    n && (y = r ? \"float activation(float a) {\\n          float b = getPreluActivationWeightsAtOutCoords();\\n          \" + n + \"\\n        }\" : \"\\n          float activation(float x) {\\n            \" + n + \"\\n          }\\n        \", x = \"result = activation(result);\");\n    var b = e ? \"result += getBiasAtOutCoords();\" : \"\";\n    e && this.variableNames.push(\"bias\"), r && this.variableNames.push(\"preluActivationWeights\"), this.userCode = \"\\n      \" + y + \"\\n\\n      const ivec2 strides = ivec2(\" + i + \", \" + s + \");\\n      const ivec2 pads = ivec2(\" + o + \", \" + a + \");\\n\\n      void main() {\\n        ivec4 coords = getOutputCoords();\\n        int batch = coords[0];\\n        int d2 = coords[\" + g + \"];\\n\\n        ivec2 xRCCorner =\\n            ivec2(coords[\" + v + \"], coords[\" + m + \"]) * strides - pads;\\n        int xRCorner = xRCCorner.x;\\n        int xCCorner = xRCCorner.y;\\n\\n        // Convolve x(?, ?, d1) with w(:, :, d1, d2) to get y(yR, yC, d2).\\n        // ? = to be determined. : = across all values in that axis.\\n        float dotProd = 0.0;\\n        for (int wR = 0; wR < \" + l + \"; wR++) {\\n          int xR = xRCorner + wR * \" + u + \";\\n\\n          if (xR < 0 || xR >= \" + t.inHeight + \") {\\n            continue;\\n          }\\n\\n          for (int wC = 0; wC < \" + h + \"; wC++) {\\n            int xC = xCCorner + wC * \" + c + \";\\n\\n            if (xC < 0 || xC >= \" + t.inWidth + \") {\\n              continue;\\n            }\\n\\n            for (int d1 = 0; d1 < \" + f + \"; d1 += 4) {\\n              vec4 wValues = vec4(\\n                getW(wR, wC, d1, d2),\\n                getW(wR, wC, d1 + 1, d2),\\n                getW(wR, wC, d1 + 2, d2),\\n                getW(wR, wC, d1 + 3, d2)\\n              );\\n\\n              if (\" + p + \") {\\n                vec4 xValues = vec4(\\n                  getX(batch, xR, xC, d1),\\n                  getX(batch, xR, xC, d1 + 1),\\n                  getX(batch, xR, xC, d1 + 2),\\n                  getX(batch, xR, xC, d1 + 3)\\n                );\\n                dotProd += dot(xValues, wValues);\\n              } else {\\n                vec4 xValues = vec4(\\n                  getX(batch, d1, xR, xC),\\n                  getX(batch, d1 + 1, xR, xC),\\n                  getX(batch, d1 + 2, xR, xC),\\n                  getX(batch, d1 + 3, xR, xC)\\n                );\\n                dotProd += dot(xValues, wValues);\\n              }\\n            }\\n\\n            if (\" + (1 === d) + \") {\\n\\n              if (\" + p + \") {\\n                dotProd +=\\n                    getX(batch, xR, xC, \" + f + \") *\\n                    getW(wR, wC, \" + f + \", d2);\\n              } else {\\n                dotProd +=\\n                    getX(batch, \" + f + \", xR, xC) *\\n                    getW(wR, wC, \" + f + \", d2);\\n              }\\n\\n            } else if (\" + (2 === d) + \") {\\n              vec2 wValues = vec2(\\n                getW(wR, wC, \" + f + \", d2),\\n                getW(wR, wC, \" + f + \" + 1, d2)\\n              );\\n\\n              if (\" + p + \") {\\n                vec2 xValues = vec2(\\n                  getX(batch, xR, xC, \" + f + \"),\\n                  getX(batch, xR, xC, \" + f + \" + 1)\\n                );\\n                dotProd += dot(xValues, wValues);\\n              } else {\\n                vec2 xValues = vec2(\\n                  getX(batch, \" + f + \", xR, xC),\\n                  getX(batch, \" + f + \" + 1, xR, xC)\\n                );\\n                dotProd += dot(xValues, wValues);\\n              }\\n\\n            } else if (\" + (3 === d) + \") {\\n              vec3 wValues = vec3(\\n                getW(wR, wC, \" + f + \", d2),\\n                getW(wR, wC, \" + f + \" + 1, d2),\\n                getW(wR, wC, \" + f + \" + 2, d2)\\n              );\\n\\n              if (\" + p + \") {\\n                vec3 xValues = vec3(\\n                  getX(batch, xR, xC, \" + f + \"),\\n                  getX(batch, xR, xC, \" + f + \" + 1),\\n                  getX(batch, xR, xC, \" + f + \" + 2)\\n                );\\n                dotProd += dot(xValues, wValues);\\n              } else {\\n                vec3 xValues = vec3(\\n                  getX(batch, \" + f + \", xR, xC),\\n                  getX(batch, \" + f + \" + 1, xR, xC),\\n                  getX(batch, \" + f + \" + 2, xR, xC)\\n                );\\n                dotProd += dot(xValues, wValues);\\n              }\\n\\n            }\\n          }\\n        }\\n\\n        float result = dotProd;\\n        \" + b + \"\\n        \" + x + \"\\n        setOutput(result);\\n      }\\n    \";\n}, Ja = function(t) {\n    this.variableNames = [\n        \"x\",\n        \"W\"\n    ], this.outputShape = t.outShape;\n    var e = t.padInfo.front, n = t.padInfo.top, r = t.padInfo.left, o = t.strideDepth, a = t.strideHeight, i = t.strideWidth, s = t.dilationDepth, u = t.dilationHeight, c = t.dilationWidth, l = t.filterDepth, h = t.filterHeight, f = t.filterWidth, d = 4 * Math.floor(t.inChannels / 4), p = t.inChannels % 4;\n    this.userCode = \"\\n      const ivec3 strides = ivec3(\" + o + \", \" + a + \", \" + i + \");\\n      const ivec3 pads = ivec3(\" + e + \", \" + n + \", \" + r + \");\\n\\n      void main() {\\n        ivec5 coords = getOutputCoords();\\n        int batch = coords.x;\\n        int d2 = coords.u;\\n\\n        ivec3 xFRCCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\\n        int xFCorner = xFRCCorner.x;\\n        int xRCorner = xFRCCorner.y;\\n        int xCCorner = xFRCCorner.z;\\n\\n        // Convolve x(?, ?, ?, d1) with w(:, :, :, d1, d2) to get\\n        // y(yF, yR, yC, d2). ? = to be determined. : = across all\\n        // values in that axis.\\n        float dotProd = 0.0;\\n        for (int wF = 0; wF < \" + l + \"; wF++) {\\n          int xF = xFCorner + wF * \" + s + \";\\n\\n          if (xF < 0 || xF >= \" + t.inDepth + \") {\\n            continue;\\n          }\\n\\n          for (int wR = 0; wR < \" + h + \"; wR++) {\\n            int xR = xRCorner + wR * \" + u + \";\\n\\n            if (xR < 0 || xR >= \" + t.inHeight + \") {\\n              continue;\\n            }\\n\\n            for (int wC = 0; wC < \" + f + \"; wC++) {\\n              int xC = xCCorner + wC * \" + c + \";\\n\\n              if (xC < 0 || xC >= \" + t.inWidth + \") {\\n                continue;\\n              }\\n\\n              for (int d1 = 0; d1 < \" + d + \"; d1 += 4) {\\n                vec4 xValues = vec4(\\n                  getX(batch, xF, xR, xC, d1),\\n                  getX(batch, xF, xR, xC, d1 + 1),\\n                  getX(batch, xF, xR, xC, d1 + 2),\\n                  getX(batch, xF, xR, xC, d1 + 3)\\n                );\\n                vec4 wValues = vec4(\\n                  getW(wF, wR, wC, d1, d2),\\n                  getW(wF, wR, wC, d1 + 1, d2),\\n                  getW(wF, wR, wC, d1 + 2, d2),\\n                  getW(wF, wR, wC, d1 + 3, d2)\\n                );\\n\\n                dotProd += dot(xValues, wValues);\\n              }\\n\\n              if (\" + (1 === p) + \") {\\n                dotProd +=\\n                  getX(batch, xF, xR, xC, \" + d + \") *\\n                  getW(wF, wR, wC, \" + d + \", d2);\\n              } else if (\" + (2 === p) + \") {\\n                vec2 xValues = vec2(\\n                  getX(batch, xF, xR, xC, \" + d + \"),\\n                  getX(batch, xF, xR, xC, \" + d + \" + 1)\\n                );\\n                vec2 wValues = vec2(\\n                  getW(wF, wR, wC, \" + d + \", d2),\\n                  getW(wF, wR, wC, \" + d + \" + 1, d2)\\n                );\\n                dotProd += dot(xValues, wValues);\\n              } else if (\" + (3 === p) + \") {\\n                vec3 xValues = vec3(\\n                  getX(batch, xF, xR, xC, \" + d + \"),\\n                  getX(batch, xF, xR, xC, \" + d + \" + 1),\\n                  getX(batch, xF, xR, xC, \" + d + \" + 2)\\n                );\\n                vec3 wValues = vec3(\\n                  getW(wF, wR, wC, \" + d + \", d2),\\n                  getW(wF, wR, wC, \" + d + \" + 1, d2),\\n                  getW(wF, wR, wC, \" + d + \" + 2, d2)\\n                );\\n                dotProd += dot(xValues, wValues);\\n              }\\n            }\\n          }\\n        }\\n        setOutput(dotProd);\\n      }\\n    \";\n}, Za = function(t, e, n, r) {\n    void 0 === e && (e = !1), void 0 === n && (n = null), void 0 === r && (r = !1), this.variableNames = [\n        \"x\",\n        \"W\"\n    ], this.outputShape = t.outShape;\n    var o = t.inHeight, a = t.inWidth, i = t.padInfo.top, s = t.padInfo.left, u = t.strideHeight, c = t.strideWidth, l = t.dilationHeight, h = t.dilationWidth, f = t.filterHeight, d = t.filterWidth, p = t.outChannels / t.inChannels, v = \"\", m = \"\";\n    n && (v = r ? \"float activation(float a) {\\n          float b = getPreluActivationWeightsAtOutCoords();\\n          \" + n + \"\\n        }\" : \"\\n          float activation(float x) {\\n            \" + n + \"\\n          }\\n        \", m = \"result = activation(result);\");\n    var g = e ? \"result += getBiasAtOutCoords();\" : \"\";\n    e && this.variableNames.push(\"bias\"), r && this.variableNames.push(\"preluActivationWeights\"), this.userCode = \"\\n      \" + v + \"\\n\\n      const ivec2 strides = ivec2(\" + u + \", \" + c + \");\\n      const ivec2 pads = ivec2(\" + i + \", \" + s + \");\\n\\n      void main() {\\n        ivec4 coords = getOutputCoords();\\n        int batch = coords.x;\\n        ivec2 xRCCorner = coords.yz * strides - pads;\\n        int d2 = coords.w;\\n        int d1 = d2 / \" + p + \";\\n        int q = d2 - d1 * \" + p + \";\\n\\n        int xRCorner = xRCCorner.x;\\n        int xCCorner = xRCCorner.y;\\n\\n        // Convolve x(?, ?, d1) with w(:, :, d1, q) to get y(yR, yC, d2).\\n        // ? = to be determined. : = across all values in that axis.\\n        float dotProd = 0.0;\\n        // TO DO(dsmilkov): Flatten the two for loops and vec4 the operations.\\n        for (int wR = 0; wR < \" + f + \"; wR++) {\\n          int xR = xRCorner + wR * \" + l + \";\\n\\n          if (xR < 0 || xR >= \" + o + \") {\\n            continue;\\n          }\\n\\n          for (int wC = 0; wC < \" + d + \"; wC++) {\\n            int xC = xCCorner + wC * \" + h + \";\\n\\n            if (xC < 0 || xC >= \" + a + \") {\\n              continue;\\n            }\\n\\n            float xVal = getX(batch, xR, xC, d1);\\n            float wVal = getW(wR, wC, d1, q);\\n            dotProd += xVal * wVal;\\n          }\\n        }\\n\\n        float result = dotProd;\\n        \" + g + \"\\n        \" + m + \"\\n        setOutput(result);\\n      }\\n    \";\n}, ti = function(t, e, n, r) {\n    void 0 === e && (e = !1), void 0 === n && (n = null), void 0 === r && (r = !1), this.variableNames = [\n        \"x\",\n        \"W\"\n    ], this.packedInputs = !0, this.packedOutput = !0, this.outputShape = t.outShape;\n    for(var o = t.inHeight, a = t.inWidth, i = t.padInfo.top, s = t.padInfo.left, u = t.strideHeight, c = t.strideWidth, l = t.dilationHeight, h = t.dilationWidth, f = t.filterHeight, d = t.filterWidth, p = d, v = \"int xR; int xC; int xCOffset;\", m = 0; m < f; m++)for(var g = 0; g < d; g++)v += \"\\n          vec4 xTexelR\" + m + \"C\" + 2 * g + \" = vec4(0.);\\n          vec4 wR\" + m + \"C\" + g + \" = vec4(0.);\\n          vec4 xR\" + m + \"C\" + g + \" = vec4(0.);\";\n    for(m = 0; m < f; m++)for(var y = 0; y < p; y++){\n        if (v += \"\\n          xR = xRCorner + \" + m * l + \";\\n          xC = xCCorner + \" + (g = 2 * y) * h + \";\\n        \", 1 === c) {\n            if (g < d && (v += s % 2 == 1 ? \"\\n                xCOffset = xC + 1;\\n                if(xR >= 0 && xR < \" + o + \" && xCOffset >= 0 && xCOffset < \" + a + \") {\\n                  xTexelR\" + m + \"C\" + g + \" = getX(batch, xR, xCOffset, d1);\\n\\n                  // Need to manually clear unused channels in case\\n                  // we're reading from recycled texture.\\n                  if(xCOffset + 1 >= \" + a + \") {\\n                    xTexelR\" + m + \"C\" + g + \".zw = vec2(0.);\\n                  }\\n                } else {\\n                  xTexelR\" + m + \"C\" + g + \" = vec4(0.);\\n                }\\n\\n                xCOffset = xC + 1 - 2;\\n                if(xR >= 0 && xR < \" + o + \" && xCOffset >= 0 && xCOffset < \" + a + \") {\\n                  vec4 previous = getX(batch, xR, xCOffset, d1);\\n\\n                  // Need to manually clear unused channels in case\\n                  // we're reading from recycled texture.\\n                  if(xCOffset + 1 >= \" + a + \") {\\n                    previous.zw = vec2(0.);\\n                  }\\n\\n                  xR\" + m + \"C\" + g + \" = vec4(previous.zw, xTexelR\" + m + \"C\" + g + \".xy);\\n                } else {\\n                  xR\" + m + \"C\" + g + \" = vec4(0, 0, xTexelR\" + m + \"C\" + g + \".xy);\\n                }\\n              \" : \"\\n                if(xR >= 0 && xR < \" + o + \" && xC >= 0 && xC < \" + a + \") {\\n                  xTexelR\" + m + \"C\" + g + \" = getX(batch, xR, xC, d1);\\n                } else {\\n                  xTexelR\" + m + \"C\" + g + \" = vec4(0.);\\n                }\\n\\n                xR\" + m + \"C\" + g + \" = xTexelR\" + m + \"C\" + g + \";\\n              \", g + 1 < d)) {\n                var x = s % 2 == 0 ? b(h) : h;\n                h % 2 == 0 && s % 2 == 1 || h % 2 != 0 && s % 2 != 1 ? (v += \"\\n                  xCOffset = xC + \" + s % 2 + \" + \" + x + \";\\n\\n                  if(xR >= 0 && xR < \" + o + \" &&\\n                    xCOffset >= 0 && xCOffset < \" + a + \") {\\n                    xTexelR\" + m + \"C\" + (g + 2) + \" = getX(batch, xR, xCOffset, d1);\\n                  }\\n                \", h > 1 && (v += \"\\n                    xCOffset -= 2;\\n                    if(xR >= 0 && xR < \" + o + \" &&\\n                      xCOffset >= 0 && xCOffset < \" + a + \") {\\n                      xTexelR\" + m + \"C\" + g + \" = getX(batch, xR, xCOffset, d1);\\n                    } else {\\n                      xTexelR\" + m + \"C\" + g + \" = vec4(0.);\\n                    }\\n                  \"), v += \"\\n                  xR\" + m + \"C\" + (g + 1) + \" = vec4(\\n                    xTexelR\" + m + \"C\" + g + \".zw, xTexelR\" + m + \"C\" + (g + 2) + \".xy);\\n                \") : v += \"\\n                  xCOffset = xC + \" + x + \";\\n\\n                  if(xR >= 0 && xR < \" + o + \" &&\\n                    xCOffset >= 0 && xCOffset < \" + a + \") {\\n                    xTexelR\" + m + \"C\" + (g + 2) + \" = getX(batch, xR, xCOffset, d1);\\n                  }\\n\\n                  xR\" + m + \"C\" + (g + 1) + \" = xTexelR\" + m + \"C\" + (g + 2) + \";\\n                \";\n            }\n        } else g < d && (v += \"\\n              if(xR >= 0 && xR < \" + o + \") {\\n            \", s % 2 == 1 ? (v += \"\\n                xCOffset = xC + 1 - \" + c + \";\\n                if(xCOffset >= 0 && xCOffset < \" + a + \") {\\n                  xTexelR\" + m + \"C\" + g + \" = getX(batch, xR, xCOffset, d1);\\n                } else {\\n                  xTexelR\" + m + \"C\" + g + \" = vec4(0.);\\n                }\\n\\n                if(xC + 1 >= 0 && xC + 1 < \" + a + \") {\\n                  xTexelR\" + m + \"C\" + (g + 2) + \" = getX(batch, xR, xC + 1, d1);\\n                } else {\\n                  xTexelR\" + m + \"C\" + (g + 2) + \" = vec4(0.);\\n                }\\n\\n                xR\" + m + \"C\" + g + \" = vec4(\\n                  xTexelR\" + m + \"C\" + g + \".zw, xTexelR\" + m + \"C\" + (g + 2) + \".zw);\\n              \", g + 1 < d && (v += \"\\n                  vec4 final = vec4(0.);\\n                  xCOffset = xC + 1 + \" + c + \";\\n                  if(xCOffset >= 0 && xCOffset < \" + a + \") {\\n                    final = getX(batch, xR, xCOffset, d1);\\n                  }\\n                  xR\" + m + \"C\" + (g + 1) + \" = vec4(xTexelR\" + m + \"C\" + (g + 2) + \".xy, final.xy);\\n                \")) : (v += \"\\n                if(xC >= 0 && xC < \" + a + \") {\\n                  xTexelR\" + m + \"C\" + g + \" = getX(batch, xR, xC, d1);\\n                } else {\\n                  xTexelR\" + m + \"C\" + g + \" = vec4(0.);\\n                }\\n\\n                xCOffset = xC + \" + c + \";\\n                if(xCOffset >= 0 && xCOffset < \" + a + \") {\\n                  xTexelR\" + m + \"C\" + (g + 2) + \" = getX(batch, xR, xCOffset, d1);\\n                } else {\\n                  xTexelR\" + m + \"C\" + (g + 2) + \" = vec4(0.);\\n                }\\n\\n                xR\" + m + \"C\" + g + \" = vec4(\\n                  xTexelR\" + m + \"C\" + g + \".xy, xTexelR\" + m + \"C\" + (g + 2) + \".xy);\\n              \", g + 1 < d && (v += \"\\n                  xR\" + m + \"C\" + (g + 1) + \" = vec4(\\n                    xTexelR\" + m + \"C\" + g + \".zw, xTexelR\" + m + \"C\" + (g + 2) + \".zw);\\n                \")), v += \"}\");\n        g < d && (v += \"\\n            vec4 wTexelR\" + m + \"C\" + g + \" = getW(\" + m + \", \" + g + \", d1, q);\\n            wR\" + m + \"C\" + g + \" = vec4(wTexelR\" + m + \"C\" + g + \".xz, wTexelR\" + m + \"C\" + g + \".xz);\\n          \", g + 1 < d && (v += \"\\n              vec4 wTexelR\" + m + \"C\" + (g + 1) + \" = getW(\" + m + \", \" + (g + 1) + \", d1, q);\\n              wR\" + m + \"C\" + (g + 1) + \" =\\n                vec4(wTexelR\" + m + \"C\" + (g + 1) + \".xz, wTexelR\" + m + \"C\" + (g + 1) + \".xz);\"));\n    }\n    for(m = 0; m < f; m++)for(g = 0; g < d; g++)v += \"dotProd += xR\" + m + \"C\" + g + \" * wR\" + m + \"C\" + g + \";\";\n    var w = \"\", C = \"\";\n    n && (w = r ? \"vec4 activation(vec4 a) {\\n          vec4 b = getPreluActivationWeightsAtOutCoords();\\n          \" + n + \"\\n        }\" : \"vec4 activation(vec4 x) {\\n          \" + n + \"\\n        }\", C = \"result = activation(result);\");\n    var E = e ? \"result += getBiasAtOutCoords();\" : \"\";\n    e && this.variableNames.push(\"bias\"), r && this.variableNames.push(\"preluActivationWeights\"), this.userCode = \"\\n      \" + w + \"\\n\\n      const ivec2 strides = ivec2(\" + u + \", \" + c + \");\\n      const ivec2 pads = ivec2(\" + i + \", \" + s + \");\\n\\n      void main() {\\n\\n        ivec4 coords = getOutputCoords();\\n        int batch = coords.x;\\n        ivec2 xRCCorner = coords.yz * strides - pads;\\n        int d2 = coords.w;\\n        int d1 = d2;\\n        int q = 0;\\n        int xRCorner = xRCCorner.x;\\n        int xCCorner = xRCCorner.y;\\n\\n        vec4 dotProd = vec4(0.);\\n\\n        \" + v + \"\\n\\n        vec4 result = dotProd;\\n        \" + E + \"\\n        \" + C + \"\\n        setOutput(result);\\n      }\\n    \";\n}, ei = function(t, e, n, r, o) {\n    this.variableNames = [\n        \"Image\",\n        \"Boxes\",\n        \"BoxInd\"\n    ], this.outputShape = [];\n    var a = t[0], i = t[1], s = t[2], u = t[3], c = e[0], l = n[0], h = n[1];\n    this.outputShape = [\n        c,\n        l,\n        h,\n        u\n    ];\n    var f = \"bilinear\" === r ? 1 : 0, d = [\n        i - 1 + \".0\",\n        s - 1 + \".0\"\n    ], p = d[0], v = d[1], m = l > 1 ? [\n        \"\" + (i - 1) / (l - 1),\n        \"(y2-y1) * height_ratio\",\n        \"y1*\" + p + \" + float(y)*(height_scale)\"\n    ] : [\n        \"0.0\",\n        \"0.0\",\n        \"0.5 * (y1+y2) * \" + p\n    ], g = m[0], y = m[1], x = m[2], b = h > 1 ? [\n        \"\" + (s - 1) / (h - 1),\n        \"(x2-x1) * width_ratio\",\n        \"x1*\" + v + \" + float(x)*(width_scale)\"\n    ] : [\n        \"0.0\",\n        \"0.0\",\n        \"0.5 * (x1+x2) * \" + v\n    ], w = b[0], C = b[1], E = b[2];\n    this.userCode = \"\\n      const float height_ratio = float(\" + g + \");\\n      const float width_ratio = float(\" + w + \");\\n      void main() {\\n        ivec4 coords = getOutputCoords();\\n        int b = coords[0];\\n        int y = coords[1];\\n        int x = coords[2];\\n        int d = coords[3];\\n\\n        // get box vals\\n        float y1 = getBoxes(b,0);\\n        float x1 = getBoxes(b,1);\\n        float y2 = getBoxes(b,2);\\n        float x2 = getBoxes(b,3);\\n\\n        // get image in batch index\\n        int bInd = round(getBoxInd(b));\\n        if(bInd < 0 || bInd >= \" + a + \") {\\n          return;\\n        }\\n\\n        float height_scale = \" + y + \";\\n        float width_scale = \" + C + \";\\n\\n        float in_y = \" + x + \";\\n        if( in_y < 0.0 || in_y > \" + p + \" ) {\\n          setOutput(float(\" + o + \"));\\n          return;\\n        }\\n        float in_x = \" + E + \";\\n        if( in_x < 0.0 || in_x > \" + v + \" ) {\\n          setOutput(float(\" + o + \"));\\n          return;\\n        }\\n\\n        vec2 sourceFracIndexCR = vec2(in_x,in_y);\\n        if(\" + f + \" == 1) {\\n          // Compute the four integer indices.\\n          ivec2 sourceFloorCR = ivec2(sourceFracIndexCR);\\n          ivec2 sourceCeilCR = ivec2(ceil(sourceFracIndexCR));\\n\\n          float topLeft = getImage(b, sourceFloorCR.y, sourceFloorCR.x, d);\\n          float bottomLeft = getImage(b, sourceCeilCR.y, sourceFloorCR.x, d);\\n          float topRight = getImage(b, sourceFloorCR.y, sourceCeilCR.x, d);\\n          float bottomRight = getImage(b, sourceCeilCR.y, sourceCeilCR.x, d);\\n\\n          vec2 fracCR = sourceFracIndexCR - vec2(sourceFloorCR);\\n\\n          float top = topLeft + (topRight - topLeft) * fracCR.x;\\n          float bottom = bottomLeft + (bottomRight - bottomLeft) * fracCR.x;\\n          float newValue = top + (bottom - top) * fracCR.y;\\n          setOutput(newValue);\\n        } else {\\n          // Compute the coordinators of nearest neighbor point.\\n          ivec2 sourceNearestCR = ivec2(floor(\\n            sourceFracIndexCR + vec2(0.5,0.5)));\\n          float newValue = getImage(b, sourceNearestCR.y, sourceNearestCR.x, d);\\n          setOutput(newValue);\\n        }\\n      }\\n    \";\n}, ni = function(t, e, n) {\n    this.variableNames = [\n        \"x\"\n    ], this.outputShape = t;\n    var r = t.length, o = t[t.length - 1], a = n ? \"<\" : \">\";\n    this.userCode = \"\\n      int getIndex(int i) {\\n        \" + (n ? \"return \" + o + \" -i - 1;\" : \"return i;\") + \"\\n      }\\n\\n      void main() {\\n        \" + wa(r) + \" coords = getOutputCoords();\\n        int end = \" + ri(r, \"coords\") + \";\\n        float val = 0.0;\\n        for (int i = \" + o + \" - 1; i >= 0; i -= 1) {\\n          int idx = getIndex(i);\\n          if (idx \" + a + \" end) {\\n            continue;\\n          }\\n          if (idx == end && \" + e + \") {\\n            continue;\\n          }\\n          \" + ri(r, \"coords\") + \" = idx;\\n          val += getX(\" + function(t, e) {\n        if (1 === t) return \"\" + e;\n        if (2 === t) return e + \".x, \" + e + \".y\";\n        if (3 === t) return e + \".x, \" + e + \".y, \" + e + \".z\";\n        if (4 === t) return e + \".x, \" + e + \".y, \" + e + \".z, \" + e + \".w\";\n        throw Error(\"Cumulative sum for rank \" + t + \" is not yet supported\");\n    }(r, \"coords\") + \");\\n        }\\n        setOutput(val);\\n      }\\n    \";\n};\nfunction ri(t, e) {\n    if (1 === t) return \"\" + e;\n    if (2 === t) return e + \".y\";\n    if (3 === t) return e + \".z\";\n    if (4 === t) return e + \".w\";\n    throw Error(\"Cumulative sum for rank \" + t + \" is not yet supported\");\n}\nvar oi = function(t) {\n    this.variableNames = [\n        \"A\"\n    ], this.packedInputs = !1, this.packedOutput = !0, this.outPackingScheme = Vt.DENSE;\n    var e = Yt(t), n = ua();\n    this.outputShape = t, this.userCode = \"\\n      ivec3 outCoordsFromFlatIndex(int index) {\\n        \" + ca([\n        \"r\",\n        \"c\",\n        \"d\"\n    ], t) + \"\\n        return ivec3(r, c, d);\\n      }\\n\\n      void main() {\\n        ivec2 resTexRC = ivec2(resultUV.yx *\\n          vec2(\" + e[0] + \", \" + e[1] + \"));\\n        int index = 4 * (resTexRC.x * \" + e[1] + \" + resTexRC.y);\\n\\n        vec4 result = vec4(0.);\\n\\n        for (int i=0; i<4; i++) {\\n          int flatIndex = index + i;\\n          ivec3 rc = outCoordsFromFlatIndex(flatIndex);\\n          result[i] = getA(rc.x, rc.y, rc.z);\\n        }\\n\\n        \" + n.output + \" = result;\\n      }\\n    \";\n}, ai = function(t) {\n    this.variableNames = [\n        \"A\"\n    ], this.packedInputs = !0, this.packedOutput = !0, this.outPackingScheme = Vt.DENSE;\n    var e = Yt(t), n = ua();\n    this.outputShape = t, this.userCode = \"\\n      ivec3 outCoordsFromFlatIndex(int index) {\\n        \" + ca([\n        \"r\",\n        \"c\",\n        \"d\"\n    ], t) + \"\\n        return ivec3(r, c, d);\\n      }\\n\\n      void main() {\\n        ivec2 resTexRC = ivec2(resultUV.yx *\\n          vec2(\" + e[0] + \", \" + e[1] + \"));\\n        int index = 4 * (resTexRC.x * \" + e[1] + \" + resTexRC.y);\\n\\n        vec4 result = vec4(0.);\\n\\n        for (int i=0; i<4; i++) {\\n          int flatIndex = index + i;\\n          ivec3 rc = outCoordsFromFlatIndex(flatIndex);\\n          result[i] = getChannel(getA(rc.x, rc.y, rc.z), vec2(rc.y, rc.z));\\n        }\\n\\n        \" + n.output + \" = result;\\n      }\\n    \";\n}, ii = function() {\n    function t(t, e, n) {\n        this.variableNames = [\n            \"x\"\n        ], this.outputShape = [], this.outputShape = t, this.blockSize = e, this.dataFormat = n, this.userCode = \"\\n    void main() {\\n      ivec4 coords = getOutputCoords();\\n      int b = coords[0];\\n      int h = \" + this.getHeightCoordString() + \";\\n      int w = \" + this.getWidthCoordString() + \";\\n      int d = \" + this.getDepthCoordString() + \";\\n\\n      int in_h = h / \" + e + \";\\n      int offset_h = imod(h, \" + e + \");\\n      int in_w = w / \" + e + \";\\n      int offset_w = imod(w, \" + e + \");\\n      int offset_d = (offset_h * \" + e + \" + offset_w) *\\n        \" + this.getOutputDepthSize() + \";\\n      int in_d = d + offset_d;\\n\\n      float result = \" + this.getInputSamplingString() + \";\\n      setOutput(result);\\n    }\\n  \";\n    }\n    return t.prototype.getHeightCoordString = function() {\n        return \"NHWC\" === this.dataFormat ? \"coords[1]\" : \"coords[2]\";\n    }, t.prototype.getWidthCoordString = function() {\n        return \"NHWC\" === this.dataFormat ? \"coords[2]\" : \"coords[3]\";\n    }, t.prototype.getDepthCoordString = function() {\n        return \"NHWC\" === this.dataFormat ? \"coords[3]\" : \"coords[1]\";\n    }, t.prototype.getOutputDepthSize = function() {\n        return \"NHWC\" === this.dataFormat ? this.outputShape[3] : this.outputShape[1];\n    }, t.prototype.getInputSamplingString = function() {\n        return \"NHWC\" === this.dataFormat ? \"getX(b, in_h, in_w, in_d)\" : \"getX(b, in_d, in_h, in_w)\";\n    }, t;\n}(), si = function(t) {\n    this.variableNames = [\n        \"X\"\n    ], this.outputShape = [\n        t,\n        t\n    ], this.userCode = \"\\n      void main() {\\n          ivec2 coords = getOutputCoords();\\n          float val = coords[0] == coords[1] ? getX(coords[0]) : 0.0;\\n          setOutput(val);\\n      }\\n    \";\n}, ui = function(t) {\n    this.variableNames = [\n        \"A\"\n    ], this.outTexUsage = zt.DOWNLOAD;\n    var e = ua();\n    this.outputShape = t, this.userCode = \"\\n      \" + ha + \"\\n\\n      void main() {\\n        float x = getAAtOutCoords();\\n        \" + e.output + \" = encode_float(x);\\n      }\\n    \";\n}, ci = function(t) {\n    this.variableNames = [\n        \"A\"\n    ], this.packedInputs = !0, this.packedOutput = !1, this.outTexUsage = zt.DOWNLOAD;\n    var e = ua();\n    this.outputShape = t, this.userCode = \"\\n      \" + ha + \"\\n\\n      void main() {\\n        ivec3 coords = getOutputCoords();\\n        float x = getChannel(getAAtOutCoords(), vec2(coords.y, coords.z));\\n        \" + e.output + \" = encode_float(x);\\n      }\\n    \";\n}, li = function(t, e, n) {\n    void 0 === n && (n = !1), this.variableNames = [\n        \"A\"\n    ];\n    var r = ua(), o = e[0], a = e[1];\n    this.outputShape = t;\n    var i = \"result\";\n    n && (i = \"floor(result * 255. + 0.5)\"), this.userCode = \"\\n      \" + la(t) + \"\\n\\n      void main() {\\n        ivec3 coords = getOutputCoords();\\n\\n        int flatIndex = getFlatIndex(coords);\\n        int offset = imod(flatIndex, 4);\\n\\n        flatIndex = idiv(flatIndex, 4, 1.);\\n        \\n        int r = flatIndex / \" + a + \";\\n        int c = imod(flatIndex, \" + a + \");\\n        vec2 uv = (vec2(c, r) + halfCR) / vec2(\" + a + \".0, \" + o + \".0);\\n        vec4 values = \" + r.texture2D + \"(A, uv);\\n\\n        float result;\\n\\n        if(offset == 0) {\\n          result = values[0];\\n        } else if(offset == 1) {\\n          result = values[1];\\n        } else if(offset == 2) {\\n          result = values[2];\\n        } else {\\n          result = values[3];\\n        }\\n\\n        \" + r.output + \" = vec4(\" + i + \", 0., 0., 0.);\\n      }\\n    \";\n}, hi = function(t, e, n) {\n    void 0 === n && (n = !1), this.variableNames = [\n        \"A\"\n    ], this.packedInputs = !1, this.packedOutput = !0;\n    var r = ua(), o = e[0], a = e[1];\n    this.outputShape = t;\n    var i = \"\", s = \"result\";\n    n && (s = \"floor(result * 255. + 0.5)\");\n    for(var u = 0; u <= 1; u++)for(var c = 0; c <= 1; c++){\n        var l = 2 * u + c;\n        i += \"\\n          localCoords = coords;\\n          if(localCoords[2] + \" + c + \" < \" + t[2] + \") {\\n            localCoords[2] += \" + c + \";\\n            if(localCoords[1] + \" + u + \" < \" + t[1] + \") {\\n              localCoords[1] += \" + u + \";\\n\\n              flatIndex = getFlatIndex(localCoords);\\n              offset = imod(flatIndex, 4);\\n\\n              flatIndex = idiv(flatIndex, 4, 1.);\\n\\n              r = flatIndex / \" + a + \";\\n              c = imod(flatIndex, \" + a + \");\\n              uv = (vec2(c, r) + halfCR) / vec2(\" + a + \".0, \" + o + \".0);\\n              values = \" + r.texture2D + \"(A, uv);\\n\\n              if(offset == 0) {\\n                result[\" + l + \"] = values[0];\\n              } else if(offset == 1) {\\n                result[\" + l + \"] = values[1];\\n              } else if(offset == 2) {\\n                result[\" + l + \"] = values[2];\\n              } else {\\n                result[\" + l + \"] = values[3];\\n              }\\n            }\\n          }\\n        \";\n    }\n    this.userCode = \"\\n      \" + la(t) + \"\\n\\n      void main() {\\n        ivec3 coords = getOutputCoords();\\n\\n        vec4 result = vec4(0.);\\n        int flatIndex, r, c, offset;\\n        ivec3 localCoords;\\n        vec2 uv;\\n        vec4 values;\\n\\n        \" + i + \"\\n\\n        \" + r.output + \" = \" + s + \";\\n      }\\n    \";\n}, fi = \"return real * expR - imag * expI;\", di = \"return real * expI + imag * expR;\", pi = function(t, e, n) {\n    this.variableNames = [\n        \"real\",\n        \"imag\"\n    ];\n    var r = e[1];\n    this.outputShape = e;\n    var o = n ? \"2.0 * \" + Math.PI : \"-2.0 * \" + Math.PI, a = n ? r + \".0\" : \"1.0\";\n    this.userCode = \"\\n      const float exponentMultiplier = \" + o + \";\\n\\n      float unaryOpComplex(float real, float expR, float imag, float expI) {\\n        \" + t + \"\\n      }\\n\\n      float mulMatDFT(int batch, int index) {\\n        float indexRatio = float(index) / float(\" + r + \");\\n        float exponentMultiplierTimesIndexRatio =\\n            exponentMultiplier * indexRatio;\\n\\n        float result = 0.0;\\n\\n        for (int i = 0; i < \" + r + \"; i++) {\\n          // x = (-2|2 * PI / N) * index * i;\\n          float x = exponentMultiplierTimesIndexRatio * float(i);\\n          float expR = cos(x);\\n          float expI = sin(x);\\n          float real = getReal(batch, i);\\n          float imag = getImag(batch, i);\\n\\n          result +=\\n              unaryOpComplex(real, expR, imag, expI) / \" + a + \";\\n        }\\n\\n        return result;\\n      }\\n\\n      void main() {\\n        ivec2 coords = getOutputCoords();\\n        setOutput(mulMatDFT(coords[0], coords[1]));\\n      }\\n    \";\n}, vi = function() {\n    function t(t, e) {\n        this.outputShape = [], this.variableNames = [\n            \"x\"\n        ], this.outputShape = t, this.userCode = \"\\n      uniform float value;\\n      void main() {\\n        // Input can be obtained from uniform value.\\n        setOutput(value);\\n      }\\n    \";\n    }\n    return t.prototype.getCustomSetupFunc = function(t) {\n        var e = this;\n        return function(n, r) {\n            null == e.valueLoc && (e.valueLoc = n.getUniformLocationNoThrow(r, \"value\")), n.gl.uniform1f(e.valueLoc, t);\n        };\n    }, t;\n}(), mi = function(t, e, n) {\n    this.variableNames = [\n        \"A\",\n        \"indices\"\n    ];\n    var r = t.slice();\n    r[n] = e, this.outputShape = r, this.rank = r.length;\n    var o = wa(this.rank), a = function(t, e) {\n        var n = t.length;\n        if (n > 4) throw Error(\"Gather for rank \" + n + \" is not yet supported\");\n        if (1 === n) return \"int(getIndices(resRC))\";\n        for(var r = [\n            \"resRC.x\",\n            \"resRC.y\",\n            \"resRC.z\",\n            \"resRC.w\"\n        ], o = [], a = 0; a < t.length; a++)a === e ? o.push(\"int(getIndices(\" + r[a] + \"))\") : o.push(\"\" + r[a]);\n        return o.join();\n    }(t, n);\n    this.userCode = \"\\n      void main() {\\n        \" + o + \" resRC = getOutputCoords();\\n        setOutput(getA(\" + a + \"));\\n      }\\n    \";\n};\nvar gi = function(t, e, n) {\n    this.sliceDim = t, this.strides = e, this.variableNames = [\n        \"x\",\n        \"indices\"\n    ], this.outputShape = n;\n    var r = wa(e.length), o = wa(n.length), a = this.sliceDim > 1 ? \"strides[j]\" : \"strides\";\n    this.userCode = \"\\n        \" + r + \" strides = \" + r + \"(\" + this.strides + \");\\n         void main() {\\n          \" + o + \" coords = getOutputCoords();\\n          int flattenIndex = 0;\\n          for (int j = 0; j < \" + this.sliceDim + \"; j++) {\\n            int index = round(getIndices(coords[0], j));\\n            flattenIndex += index * \" + a + \";\\n          }\\n          setOutput(getX(flattenIndex, coords[1]));\\n        }\\n      \";\n};\nfunction yi(t, e) {\n    var n = ua();\n    return oe(t, e, n.version + \"\\n    precision highp float;\\n    \" + n.attribute + \" vec3 clipSpacePos;\\n    \" + n.attribute + \" vec2 uv;\\n    \" + n.varyingVs + \" vec2 resultUV;\\n\\n    void main() {\\n      gl_Position = vec4(clipSpacePos, 1);\\n      resultUV = uv;\\n    }\");\n}\nfunction xi(t, e) {\n    return fe(t, e, new Float32Array([\n        -1,\n        1,\n        0,\n        0,\n        1,\n        -1,\n        -1,\n        0,\n        0,\n        0,\n        1,\n        1,\n        0,\n        1,\n        1,\n        1,\n        -1,\n        0,\n        1,\n        0\n    ]));\n}\nfunction bi(t, e) {\n    return de(t, e, new Uint16Array([\n        0,\n        1,\n        2,\n        2,\n        1,\n        3\n    ]));\n}\nfunction wi(t, e, n, r, o, a, i) {\n    ve(n, r);\n    var s = pe(t, e), u = t.TEXTURE_2D;\n    return Jt(t, e, function() {\n        return t.bindTexture(u, s);\n    }), Jt(t, e, function() {\n        return t.texParameteri(u, t.TEXTURE_WRAP_S, t.CLAMP_TO_EDGE);\n    }), Jt(t, e, function() {\n        return t.texParameteri(u, t.TEXTURE_WRAP_T, t.CLAMP_TO_EDGE);\n    }), Jt(t, e, function() {\n        return t.texParameteri(u, t.TEXTURE_MIN_FILTER, t.NEAREST);\n    }), Jt(t, e, function() {\n        return t.texParameteri(u, t.TEXTURE_MAG_FILTER, t.NEAREST);\n    }), Jt(t, e, function() {\n        return t.texImage2D(u, 0, o, n, r, 0, a, i, null);\n    }), Jt(t, e, function() {\n        return t.bindTexture(t.TEXTURE_2D, null);\n    }), s;\n}\nfunction Ci(t, e, n, r, o) {\n    var a = Xt(n, r);\n    return wi(t, e, a[0], a[1], o.internalFormatFloat, o.textureFormatFloat, t.FLOAT);\n}\nfunction Ei(t, e, n, r, o) {\n    var a = Xt(n, r);\n    return wi(t, e, a[0], a[1], o.internalFormatHalfFloat, o.textureFormatFloat, o.textureTypeHalfFloat);\n}\nfunction Ri(t, e, n, r, o) {\n    var a = Xt(n, r);\n    return wi(t, e, a[0], a[1], t.RGBA, t.RGBA, t.UNSIGNED_BYTE);\n}\nfunction Ii(t, e, n, r, o) {\n    var a = $t(n, r);\n    return wi(t, e, a[0], a[1], o.internalFormatPackedFloat, t.RGBA, t.FLOAT);\n}\nfunction ki(t, e, n, r, o) {\n    var a = $t(n, r);\n    return wi(t, e, a[0], a[1], o.internalFormatPackedHalfFloat, t.RGBA, o.textureTypeHalfFloat);\n}\nfunction Si(t, e, n, r) {\n    return Jt(t, e, function() {\n        return t.bindBuffer(t.ARRAY_BUFFER, r);\n    }), ge(t, e, n, \"clipSpacePos\", r, 3, 20, 0) && ge(t, e, n, \"uv\", r, 2, 20, 12);\n}\nfunction Ai(t, e, n, r, o, a, i) {\n    var s, u, c;\n    Jt(t, e, function() {\n        return t.bindTexture(t.TEXTURE_2D, n);\n    }), a instanceof Uint8Array ? (s = new Uint8Array(r * o * 4), u = t.UNSIGNED_BYTE, c = t.RGBA) : (s = new Float32Array(r * o * 4), u = t.FLOAT, c = i.internalFormatPackedFloat), s.set(a), Jt(t, e, function() {\n        return t.texImage2D(t.TEXTURE_2D, 0, c, r, o, 0, t.RGBA, u, s);\n    }), Jt(t, e, function() {\n        return t.bindTexture(t.TEXTURE_2D, null);\n    });\n}\nfunction Di(t, e, n, r) {\n    Jt(t, e, function() {\n        return t.bindTexture(t.TEXTURE_2D, n);\n    }), r.data instanceof Uint8Array ? Jt(t, e, function() {\n        return t.texImage2D(t.TEXTURE_2D, 0, t.RGBA, r.width, r.height, 0, t.RGBA, t.UNSIGNED_BYTE, r.data);\n    }) : Jt(t, e, function() {\n        return t.texImage2D(t.TEXTURE_2D, 0, t.RGBA, t.RGBA, t.UNSIGNED_BYTE, r);\n    }), Jt(t, e, function() {\n        return t.bindTexture(t.TEXTURE_2D, null);\n    });\n}\nfunction Ti(t, e, n, r, o) {\n    var a = t.createBuffer();\n    Jt(t, e, function() {\n        return t.bindBuffer(t.PIXEL_PACK_BUFFER, a);\n    });\n    var i = 16 * n * r;\n    return Jt(t, e, function() {\n        return t.bufferData(t.PIXEL_PACK_BUFFER, i, t.STREAM_READ);\n    }), Jt(t, e, function() {\n        return t.readPixels(0, 0, r, n, t.RGBA, t.FLOAT, 0);\n    }), Jt(t, e, function() {\n        return t.bindBuffer(t.PIXEL_PACK_BUFFER, null);\n    }), a;\n}\nfunction Ni(t, e, n) {\n    var r = t, o = new Float32Array(n);\n    return r.bindBuffer(r.PIXEL_PACK_BUFFER, e), r.getBufferSubData(r.PIXEL_PACK_BUFFER, 0, o), r.bindBuffer(r.PIXEL_PACK_BUFFER, null), o;\n}\nfunction Fi(t, e, n, r, o) {\n    var a = Xt(n, r), i = a[0], s = a[1], u = new Uint8Array(n * r * 4);\n    return Jt(t, e, function() {\n        return t.readPixels(0, 0, i, s, o.downloadTextureFormat, t.UNSIGNED_BYTE, u);\n    }), new Float32Array(u.buffer);\n}\nfunction _i(t, e, n, r, o, a, i, s) {\n    var u = t, c = new Float32Array(function(t, e) {\n        var n = $t(t, e);\n        return n[0] * n[1] * 4;\n    }(a, i));\n    return u.bindBuffer(u.PIXEL_PACK_BUFFER, e), u.getBufferSubData(u.PIXEL_PACK_BUFFER, 0, c), u.bindBuffer(u.PIXEL_PACK_BUFFER, null), c;\n}\nfunction Oi(t, e, n, r) {\n    var o = new Float32Array(n * r * 4);\n    return Jt(t, e, function() {\n        return t.readPixels(0, 0, r, n, t.RGBA, t.FLOAT, o);\n    }), o;\n}\nvar Mi = Object.freeze({\n    createVertexShader: yi,\n    createVertexBuffer: xi,\n    createIndexBuffer: bi,\n    createFloat32MatrixTexture: Ci,\n    createFloat16MatrixTexture: Ei,\n    createUnsignedBytesMatrixTexture: Ri,\n    createPackedMatrixTexture: Ii,\n    createFloat16PackedMatrixTexture: ki,\n    bindVertexProgramAttributeStreams: Si,\n    uploadDenseMatrixToTexture: Ai,\n    uploadPixelDataToTexture: Di,\n    createBufferFromOutputTexture: Ti,\n    downloadFloat32MatrixFromBuffer: Ni,\n    downloadByteEncodedFloatMatrixFromOutputTexture: Fi,\n    downloadPackedMatrixFromBuffer: _i,\n    downloadMatrixFromPackedOutputTexture: Oi\n}), Bi = function() {\n    function t(t) {\n        this.outputTexture = null, this.program = null, this.disposed = !1, this.vertexAttrsAreBound = !1, this.itemsToPoll = [];\n        var e = i().getNumber(\"WEBGL_VERSION\");\n        null != t ? (this.gl = t, Kt(e, t)) : this.gl = jt(e);\n        var n = \"WEBGL_color_buffer_float\";\n        if (1 === i().getNumber(\"WEBGL_VERSION\")) {\n            if (this.textureFloatExtension = re(this.gl, this.debug, \"OES_texture_float\"), Pe(this.gl, \"OES_texture_half_float\")) this.textureHalfFloatExtension = re(this.gl, this.debug, \"OES_texture_half_float\");\n            else if (i().get(\"WEBGL_FORCE_F16_TEXTURES\")) throw new Error(\"GL context does not support half float textures, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.\");\n            if (this.colorBufferFloatExtension = this.gl.getExtension(n), Pe(this.gl, \"EXT_color_buffer_half_float\")) this.colorBufferHalfFloatExtension = re(this.gl, this.debug, \"EXT_color_buffer_half_float\");\n            else if (i().get(\"WEBGL_FORCE_F16_TEXTURES\")) throw new Error(\"GL context does not support color renderable half floats, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.\");\n        } else if (n = \"EXT_color_buffer_float\", Pe(this.gl, n)) this.colorBufferFloatExtension = this.gl.getExtension(n);\n        else {\n            if (!Pe(this.gl, \"EXT_color_buffer_half_float\")) throw new Error(\"GL context does not support color renderable floats\");\n            this.colorBufferHalfFloatExtension = this.gl.getExtension(\"EXT_color_buffer_half_float\");\n        }\n        this.vertexBuffer = xi(this.gl, this.debug), this.indexBuffer = bi(this.gl, this.debug), this.framebuffer = me(this.gl, this.debug), this.textureConfig = Qt(this.gl, this.textureHalfFloatExtension);\n    }\n    return Object.defineProperty(t.prototype, \"debug\", {\n        get: function() {\n            return i().getBool(\"DEBUG\");\n        },\n        enumerable: !0,\n        configurable: !0\n    }), t.prototype.dispose = function() {\n        var t = this;\n        if (!this.disposed) {\n            null != this.program && console.warn(\"Disposing a GPGPUContext that still has a bound WebGLProgram. This is probably a resource leak, delete the program with GPGPUContext.deleteProgram before disposing.\"), null != this.outputTexture && console.warn(\"Disposing a GPGPUContext that still has a bound output matrix texture.  This is probably a resource leak, delete the output matrix texture with GPGPUContext.deleteMatrixTexture before disposing.\");\n            var e = this.gl;\n            Jt(e, this.debug, function() {\n                return e.finish();\n            }), Jt(e, this.debug, function() {\n                return e.bindFramebuffer(e.FRAMEBUFFER, null);\n            }), Jt(e, this.debug, function() {\n                return e.deleteFramebuffer(t.framebuffer);\n            }), Jt(e, this.debug, function() {\n                return e.bindBuffer(e.ARRAY_BUFFER, null);\n            }), Jt(e, this.debug, function() {\n                return e.bindBuffer(e.ELEMENT_ARRAY_BUFFER, null);\n            }), Jt(e, this.debug, function() {\n                return e.deleteBuffer(t.indexBuffer);\n            }), this.disposed = !0;\n        }\n    }, t.prototype.createFloat32MatrixTexture = function(t, e) {\n        return this.throwIfDisposed(), Ci(this.gl, this.debug, t, e, this.textureConfig);\n    }, t.prototype.createFloat16MatrixTexture = function(t, e) {\n        return this.throwIfDisposed(), Ei(this.gl, this.debug, t, e, this.textureConfig);\n    }, t.prototype.createUnsignedBytesMatrixTexture = function(t, e) {\n        return this.throwIfDisposed(), Ri(this.gl, this.debug, t, e, this.textureConfig);\n    }, t.prototype.uploadPixelDataToTexture = function(t, e) {\n        this.throwIfDisposed(), Di(this.gl, this.debug, t, e);\n    }, t.prototype.uploadDenseMatrixToTexture = function(t, e, n, r) {\n        this.throwIfDisposed(), Ai(this.gl, this.debug, t, e, n, r, this.textureConfig);\n    }, t.prototype.createFloat16PackedMatrixTexture = function(t, e) {\n        return this.throwIfDisposed(), ki(this.gl, this.debug, t, e, this.textureConfig);\n    }, t.prototype.createPackedMatrixTexture = function(t, e) {\n        return this.throwIfDisposed(), Ii(this.gl, this.debug, t, e, this.textureConfig);\n    }, t.prototype.deleteMatrixTexture = function(t) {\n        var e = this;\n        this.throwIfDisposed(), this.outputTexture === t && (Ee(this.gl, this.debug, this.framebuffer), this.outputTexture = null), Jt(this.gl, this.debug, function() {\n            return e.gl.deleteTexture(t);\n        });\n    }, t.prototype.downloadByteEncodedFloatMatrixFromOutputTexture = function(t, e, n) {\n        var r = this;\n        return this.downloadMatrixDriver(t, function() {\n            return Fi(r.gl, r.debug, e, n, r.textureConfig);\n        });\n    }, t.prototype.downloadPackedMatrixFromBuffer = function(t, e, n, r, o, a) {\n        return _i(this.gl, t, 0, 0, 0, o, a, this.textureConfig);\n    }, t.prototype.downloadFloat32MatrixFromBuffer = function(t, e) {\n        return Ni(this.gl, t, e);\n    }, t.prototype.createBufferFromTexture = function(t, e, n) {\n        this.bindTextureToFrameBuffer(t);\n        var r = Ti(this.gl, this.debug, e, n, this.textureConfig);\n        return this.unbindTextureToFrameBuffer(), r;\n    }, t.prototype.createAndWaitForFence = function() {\n        var t = this.createFence(this.gl);\n        return this.pollFence(t);\n    }, t.prototype.createFence = function(t) {\n        var e, n, r = this;\n        if (i().getBool(\"WEBGL_FENCE_API_ENABLED\")) {\n            var o = t, a = o.fenceSync(o.SYNC_GPU_COMMANDS_COMPLETE, 0);\n            t.flush(), n = function() {\n                var t = o.clientWaitSync(a, 0, 0);\n                return t === o.ALREADY_SIGNALED || t === o.CONDITION_SATISFIED;\n            }, e = a;\n        } else i().getNumber(\"WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION\") > 0 ? (e = this.beginQuery(), this.endQuery(), n = function() {\n            return r.isQueryAvailable(e, i().getNumber(\"WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION\"));\n        }) : n = function() {\n            return !0;\n        };\n        return {\n            query: e,\n            isFencePassed: n\n        };\n    }, t.prototype.downloadMatrixFromPackedTexture = function(t, e, n) {\n        var r = this;\n        return this.downloadMatrixDriver(t, function() {\n            return Oi(r.gl, r.debug, e, n);\n        });\n    }, t.prototype.createProgram = function(t) {\n        this.throwIfDisposed();\n        var e = this.gl, n = ae(e, this.debug, t), r = yi(e, this.debug), o = ce(e, this.debug);\n        return Jt(e, this.debug, function() {\n            return e.attachShader(o, r);\n        }), Jt(e, this.debug, function() {\n            return e.attachShader(o, n);\n        }), le(e, this.debug, o), this.debug && he(e, this.debug, o), this.vertexAttrsAreBound || (this.setProgram(o), this.vertexAttrsAreBound = Si(e, this.debug, this.program, this.vertexBuffer)), o;\n    }, t.prototype.deleteProgram = function(t) {\n        var e = this;\n        this.throwIfDisposed(), t === this.program && (this.program = null), null != t && Jt(this.gl, this.debug, function() {\n            return e.gl.deleteProgram(t);\n        });\n    }, t.prototype.setProgram = function(t) {\n        var e = this;\n        this.throwIfDisposed(), this.program = t, null != this.program && this.debug && he(this.gl, this.debug, this.program), Jt(this.gl, this.debug, function() {\n            return e.gl.useProgram(t);\n        });\n    }, t.prototype.getUniformLocation = function(t, e, n) {\n        return void 0 === n && (n = !0), this.throwIfDisposed(), n ? xe(this.gl, this.debug, t, e) : be(this.gl, t, e);\n    }, t.prototype.getAttributeLocation = function(t, e) {\n        var n = this;\n        return this.throwIfDisposed(), Jt(this.gl, this.debug, function() {\n            return n.gl.getAttribLocation(t, e);\n        });\n    }, t.prototype.getUniformLocationNoThrow = function(t, e) {\n        return this.throwIfDisposed(), this.gl.getUniformLocation(t, e);\n    }, t.prototype.setInputMatrixTexture = function(t, e, n) {\n        this.throwIfDisposed(), this.throwIfNoProgram(), we(this.gl, this.debug, this.program, t, e, n);\n    }, t.prototype.setOutputMatrixTexture = function(t, e, n) {\n        this.setOutputMatrixTextureDriver(t, n, e);\n    }, t.prototype.setOutputPackedMatrixTexture = function(t, e, n) {\n        this.throwIfDisposed();\n        var r = $t(e, n), o = r[0], a = r[1];\n        this.setOutputMatrixTextureDriver(t, o, a);\n    }, t.prototype.setOutputMatrixWriteRegion = function(t, e, n, r) {\n        this.setOutputMatrixWriteRegionDriver(n, t, r, e);\n    }, t.prototype.setOutputPackedMatrixWriteRegion = function(t, e, n, r) {\n        throw new Error(\"setOutputPackedMatrixWriteRegion not implemented.\");\n    }, t.prototype.debugValidate = function() {\n        null != this.program && he(this.gl, this.debug, this.program), Re(this.gl);\n    }, t.prototype.executeProgram = function() {\n        this.throwIfDisposed(), this.throwIfNoProgram();\n        var t = this.gl;\n        this.debug && this.debugValidate(), Jt(t, this.debug, function() {\n            return t.drawElements(t.TRIANGLES, 6, t.UNSIGNED_SHORT, 0);\n        });\n    }, t.prototype.blockUntilAllProgramsCompleted = function() {\n        var t = this;\n        this.throwIfDisposed(), Jt(this.gl, this.debug, function() {\n            return t.gl.finish();\n        });\n    }, t.prototype.getQueryTimerExtension = function() {\n        return null == this.disjointQueryTimerExtension && (this.disjointQueryTimerExtension = re(this.gl, this.debug, 2 === i().getNumber(\"WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION\") ? \"EXT_disjoint_timer_query_webgl2\" : \"EXT_disjoint_timer_query\")), this.disjointQueryTimerExtension;\n    }, t.prototype.getQueryTimerExtensionWebGL2 = function() {\n        return this.getQueryTimerExtension();\n    }, t.prototype.getQueryTimerExtensionWebGL1 = function() {\n        return this.getQueryTimerExtension();\n    }, t.prototype.beginQuery = function() {\n        if (2 === i().getNumber(\"WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION\")) {\n            var t = this.gl, e = this.getQueryTimerExtensionWebGL2(), n = t.createQuery();\n            return t.beginQuery(e.TIME_ELAPSED_EXT, n), n;\n        }\n        var r = this.getQueryTimerExtensionWebGL1(), o = r.createQueryEXT();\n        return r.beginQueryEXT(r.TIME_ELAPSED_EXT, o), o;\n    }, t.prototype.endQuery = function() {\n        if (2 !== i().getNumber(\"WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION\")) {\n            var t = this.getQueryTimerExtensionWebGL1();\n            t.endQueryEXT(t.TIME_ELAPSED_EXT);\n        } else {\n            var e = this.gl, n = this.getQueryTimerExtensionWebGL2();\n            e.endQuery(n.TIME_ELAPSED_EXT);\n        }\n    }, t.prototype.waitForQueryAndGetTime = function(t) {\n        return n(this, void 0, void 0, function() {\n            var e = this;\n            return r(this, function(n) {\n                switch(n.label){\n                    case 0:\n                        return [\n                            4,\n                            F(function() {\n                                return e.disposed || e.isQueryAvailable(t, i().getNumber(\"WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION\"));\n                            })\n                        ];\n                    case 1:\n                        return n.sent(), [\n                            2,\n                            this.getQueryTime(t, i().getNumber(\"WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION\"))\n                        ];\n                }\n            });\n        });\n    }, t.prototype.getQueryTime = function(t, e) {\n        if (0 === e) return null;\n        if (2 === e) {\n            var n = this.gl;\n            return n.getQueryParameter(t, n.QUERY_RESULT) / 1e6;\n        }\n        var r = this.getQueryTimerExtensionWebGL1();\n        return r.getQueryObjectEXT(t, r.QUERY_RESULT_EXT) / 1e6;\n    }, t.prototype.isQueryAvailable = function(t, e) {\n        if (0 === e) return !0;\n        if (2 === e) {\n            var n = this.gl, r = this.getQueryTimerExtensionWebGL2(), o = n.getQueryParameter(t, n.QUERY_RESULT_AVAILABLE);\n            return null == this.disjoint && (this.disjoint = this.gl.getParameter(r.GPU_DISJOINT_EXT)), o && !this.disjoint;\n        }\n        o = (r = this.getQueryTimerExtensionWebGL1()).getQueryObjectEXT(t, r.QUERY_RESULT_AVAILABLE_EXT);\n        return null == this.disjoint && (this.disjoint = this.gl.getParameter(r.GPU_DISJOINT_EXT)), o && !this.disjoint;\n    }, t.prototype.pollFence = function(t) {\n        var e = this;\n        return new Promise(function(n) {\n            e.addItemToPoll(function() {\n                return t.isFencePassed();\n            }, function() {\n                return n();\n            });\n        });\n    }, t.prototype.pollItems = function() {\n        for(var t = function(t) {\n            for(var e = 0; e < t.length; ++e){\n                if (!t[e]()) break;\n            }\n            return e - 1;\n        }(this.itemsToPoll.map(function(t) {\n            return t.isDoneFn;\n        })), e = 0; e <= t; ++e){\n            (0, this.itemsToPoll[e].resolveFn)();\n        }\n        this.itemsToPoll = this.itemsToPoll.slice(t + 1);\n    }, t.prototype.addItemToPoll = function(t, e) {\n        var n = this;\n        this.itemsToPoll.push({\n            isDoneFn: t,\n            resolveFn: e\n        }), this.itemsToPoll.length > 1 || F(function() {\n            return n.pollItems(), 0 === n.itemsToPoll.length;\n        });\n    }, t.prototype.bindTextureToFrameBuffer = function(t) {\n        this.throwIfDisposed(), Ce(this.gl, this.debug, t, this.framebuffer), this.debug && Re(this.gl);\n    }, t.prototype.unbindTextureToFrameBuffer = function() {\n        null != this.outputTexture ? (Ce(this.gl, this.debug, this.outputTexture, this.framebuffer), this.debug && Re(this.gl)) : Ee(this.gl, this.debug, this.framebuffer);\n    }, t.prototype.downloadMatrixDriver = function(t, e) {\n        this.bindTextureToFrameBuffer(t);\n        var n = e();\n        return this.unbindTextureToFrameBuffer(), n;\n    }, t.prototype.setOutputMatrixTextureDriver = function(t, e, n) {\n        this.throwIfDisposed();\n        var r = this.gl;\n        Ce(r, this.debug, t, this.framebuffer), this.debug && Re(r), this.outputTexture = t, Jt(r, this.debug, function() {\n            return r.viewport(0, 0, e, n);\n        }), Jt(r, this.debug, function() {\n            return r.scissor(0, 0, e, n);\n        });\n    }, t.prototype.setOutputMatrixWriteRegionDriver = function(t, e, n, r) {\n        var o = this;\n        this.throwIfDisposed(), Jt(this.gl, this.debug, function() {\n            return o.gl.scissor(t, e, n, r);\n        });\n    }, t.prototype.throwIfDisposed = function() {\n        if (this.disposed) throw new Error(\"Attempted to use disposed GPGPUContext.\");\n    }, t.prototype.throwIfNoProgram = function() {\n        if (null == this.program) throw new Error(\"No GPU program is currently set.\");\n    }, t;\n}();\nfunction Pi(t, e) {\n    if (t.length !== e.length) throw Error(\"Binary was compiled with \" + t.length + \" inputs, but was executed with \" + e.length + \" inputs\");\n    t.forEach(function(t, n) {\n        var r = t.logicalShape, o = e[n], a = o.shape;\n        if (!S(r, a)) throw Error(\"Binary was compiled with different shapes than the current args. Shapes \" + r + \" and \" + a + \" must match\");\n        if (!t.isUniform || !o.isUniform) {\n            var i = t.texShape, s = o.isUniform ? null : o.texData.texShape;\n            if (!S(i, s)) throw Error(\"Binary was compiled with different texture shapes than the current args. Shape \" + i + \" and \" + s + \" must match\");\n        }\n    });\n}\nvar Li = function(t, e, n) {\n    this.variableNames = [\n        \"A\"\n    ], this.packedInputs = !0, this.packedOutput = !0, this.outputShape = t;\n    for(var r = n.filterWidth, o = n.inChannels, a = n.strideWidth, i = n.strideHeight, s = n.padInfo, u = n.outWidth, c = n.dilationWidth, l = n.dilationHeight, h = n.dataFormat, f = s.left, d = s.top, p = o * r, v = ua(), m = \"channelsLast\" === h, g = m ? 0 : 1, y = m ? 1 : 2, x = \"\", b = 0; b <= 1; b++)for(var w = 0; w <= 1; w++)x += \"\\n          blockIndex = rc.y + \" + w + \";\\n          pos = rc.x + \" + b + \";\\n\\n          if(blockIndex < \" + t[1] + \" && pos < \" + t[0] + \") {\\n            offsetY = int(blockIndex / (\" + u + \")) * \" + i + \" - \" + d + \";\\n            d0 = offsetY + \" + l + \" * (pos / \" + p + \");\\n\\n            if(d0 < \" + e[g] + \" && d0 >= 0) {\\n\\n              offsetX = int(mod(float(blockIndex), \" + u + \".) * \" + a + \". - \" + f + \".);\\n              d1 = offsetX + \" + c + \" * (int(mod(float(pos), \" + p + \".) / \" + o + \".));\\n\\n              if(d1 < \" + e[y] + \" && d1 >= 0) {\\n\\n                ch = int(mod(float(pos), \" + o + \".));\\n\\n                if (\" + m + \") {\\n                  innerDims = vec2(d1, ch);\\n                  result[\" + (2 * b + w) + \"] = getChannel(\\n                    getA(d0, int(innerDims.x),\\n                    int(innerDims.y)), innerDims);\\n                } else {\\n                  innerDims = vec2(d0, d1);\\n                  result[\" + (2 * b + w) + \"] = getChannel(\\n                    getA(ch, int(innerDims.x),\\n                    int(innerDims.y)), innerDims);\\n                }\\n              }\\n            }\\n          }\\n        \";\n    this.userCode = \"\\n      void main() {\\n        ivec2 rc = getOutputCoords();\\n\\n        vec4 result = vec4(0);\\n\\n        int blockIndex, pos, offsetY, d0, offsetX, d1, ch;\\n        vec2 innerDims;\\n\\n        \" + x + \"\\n\\n        \" + v.output + \" = result;\\n      }\\n    \";\n}, Wi = function(t, e, n, r, o) {\n    this.variableNames = [\n        \"x\"\n    ], this.outputShape = [];\n    var a, i = e, s = t[3] - 1;\n    this.outputShape = t;\n    var u = \"float(\" + n + \") + float(\" + r + \") * sum\";\n    a = .5 === o ? \"inversesqrt(\" + u + \")\" : 1 === o ? \"1.0/(\" + u + \")\" : \"exp(log(\" + u + \") * float(-\" + o + \"));\", this.userCode = \"\\n      void main() {\\n        ivec4 coords = getOutputCoords();\\n        int b = coords[0];\\n        int r = coords[1];\\n        int c = coords[2];\\n        int d = coords[3];\\n        float x = getX(b, r, c, d);\\n        float sum = 0.0;\\n        for (int j = -\" + i + \"; j <= \" + i + \"; j++) {\\n          int idx = d + j;\\n          if (idx >= 0 && idx <=  \" + s + \") {\\n            float z = getX(b, r, c, idx);\\n            sum += z * z;\\n          }\\n        }\\n        float val = x * \" + a + \";\\n        setOutput(val);\\n      }\\n    \";\n}, Ui = function(t, e, n, r, o) {\n    this.variableNames = [\n        \"inputImage\",\n        \"outputImage\",\n        \"dy\"\n    ], this.outputShape = [], this.outputShape = t, this.depth = t[3], this.depthRadius = e, this.bias = n, this.alpha = r, this.beta = o, this.userCode = \"\\n      void main() {\\n        ivec4 coords = getOutputCoords();\\n        int b = coords[0];\\n        int r = coords[1];\\n        int c = coords[2];\\n\\n        float result = 0.0;\\n        for (int d = 0; d < \" + this.depth + \"; ++d) {\\n          int depthBegin = int(max(0.0, float(d - \" + e + \")));\\n          int depthEnd = int(min(float(\" + this.depth + \"),\\n              float(d + \" + e + \" + 1)));\\n\\n          const int MIN_DEPTH_BEGIN = 0;\\n          const int MAX_DEPTH_END = \" + this.depth + \";\\n\\n          float norm = 0.0;\\n          for (int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k) {\\n            if (k < depthBegin){\\n              continue;\\n            }\\n            else if (k >= depthBegin && k < depthEnd) {\\n              norm += getInputImage(b, r, c, k) * getInputImage(b, r, c, k);\\n            }\\n            else {\\n              break;\\n            }\\n          }\\n\\n          norm = float(\" + r + \") * norm + float(\" + n + \");\\n\\n          for(int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k){\\n            if (k < depthBegin){\\n              continue;\\n            }\\n            else if (k >= depthBegin && k < depthEnd){\\n              float dyi = -2.0 * float(\" + r + \")\\n                * float(\" + o + \")\\n                * getInputImage(b ,r ,c, k) * getOutputImage(b, r, c, d)\\n                / norm;\\n              if (k == d) {\\n                dyi += pow(norm, -1.0 * \" + o + \");\\n              }\\n              if (k == coords[3]) {\\n                dyi *= getDy(b, r, c, d);\\n                result += dyi;\\n              }\\n            }\\n            else {\\n              break;\\n            }\\n          }\\n      }\\n      setOutput(result);\\n      }\\n    \";\n}, Vi = function(t, e, n, r, o) {\n    this.variableNames = [\n        \"x\"\n    ], this.outputShape = [], this.packedInputs = !0, this.packedOutput = !0;\n    var a, i = e, s = t[3] - 1;\n    this.outputShape = t;\n    var u = \"float(\" + n + \") + float(\" + r + \") * sum\";\n    a = .5 === o ? \"inversesqrt(\" + u + \")\" : 1 === o ? \"1.0/(\" + u + \")\" : \"exp(log(\" + u + \") * float(-\" + o + \"));\", this.userCode = \"\\n      void main() {\\n        ivec4 coords = getOutputCoords();\\n        int b = coords.x;\\n        int r = coords.y;\\n        int c = coords.z;\\n        int d = coords.w;\\n\\n        bool hasNextCol = d < \" + this.outputShape[3] + \";\\n        bool hasNextRow = c < \" + this.outputShape[2] + \";\\n\\n        vec4 sum = vec4(0.);\\n        vec4 xFragAtOutputCoords = getX(b, r, c, d);\\n\\n        vec4 xAtOutputCoords = vec4(\\n          getChannel(xFragAtOutputCoords, vec2(c, d)),\\n          hasNextCol ?\\n            getChannel(xFragAtOutputCoords, vec2(c, d + 1)) : 0.0,\\n          hasNextRow ?\\n            getChannel(xFragAtOutputCoords , vec2(c + 1, d)) : 0.0,\\n          (hasNextRow && hasNextCol) ?\\n            getChannel(xFragAtOutputCoords, vec2(c + 1, d + 1)) : 0.0\\n        );\\n\\n        int firstChannel = d - \" + i + \";\\n        vec2 cache = vec2(0.);\\n        if(firstChannel >= 0){\\n          vec4 firstChannelFrag = getX(b, r, c, firstChannel);\\n          cache.x = getChannel(firstChannelFrag, vec2(c, firstChannel));\\n            if(hasNextRow){\\n              cache.y = getChannel(firstChannelFrag, vec2(c + 1, firstChannel));\\n            }\\n        }\\n\\n        ivec2 depth = ivec2(d, d + 1);\\n        for (int j = - \" + i + \"; j <= \" + i + \"; j++) {\\n          ivec2 idx = depth + j;\\n          bvec2 aboveLowerBound = greaterThanEqual(idx, ivec2(0));\\n          bvec2 belowUpperBound = lessThanEqual(idx, ivec2(\" + s + \"));\\n\\n          bool depthInRange = aboveLowerBound.x && belowUpperBound.x;\\n          bool depthPlusOneInRange = aboveLowerBound.y && belowUpperBound.y;\\n\\n          if(depthInRange || depthPlusOneInRange){\\n            vec4 z = vec4(0.);\\n            vec4 xFragAtCurrentDepth;\\n            z.xz = cache.xy;\\n            if(depthPlusOneInRange && hasNextCol){\\n              xFragAtCurrentDepth = idx.y != d ?\\n                getX(b, r, c, idx.y) : xFragAtOutputCoords;\\n              z.y = getChannel(xFragAtCurrentDepth, vec2(c, idx.y));\\n              if(hasNextRow){\\n                z.w = getChannel(xFragAtCurrentDepth, vec2(c + 1, idx.y));\\n              }\\n            }\\n            cache.xy = z.yw;\\n            sum += z * z;\\n          }\\n        }\\n        vec4 result = xAtOutputCoords * \" + a + \";\\n        setOutput(result);\\n      }\\n    \";\n}, zi = function(t) {\n    this.variableNames = [\n        \"dy\",\n        \"maxPos\"\n    ], this.outputShape = t.inShape;\n    var e = t.strideHeight, n = t.strideWidth, r = t.dilationHeight, o = t.effectiveFilterHeight, a = t.effectiveFilterWidth, i = o - 1 - t.padInfo.top, s = a - 1 - t.padInfo.left, u = o * a - 1;\n    this.userCode = \"\\n      const ivec2 pads = ivec2(\" + i + \", \" + s + \");\\n\\n      void main() {\\n        ivec4 coords = getOutputCoords();\\n        int b = coords[0];\\n        int d = coords[3];\\n\\n        ivec2 dyRCCorner = coords.yz - pads;\\n        int dyRCorner = dyRCCorner.x;\\n        int dyCCorner = dyRCCorner.y;\\n\\n        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).\\n        // ? = to be determined. : = across all values in that axis.\\n        float dotProd = 0.0;\\n        for (int wR = 0; wR < \" + o + \";\\n          wR += \" + r + \") {\\n          float dyR = float(dyRCorner + wR) / \" + e + \".0;\\n\\n          if (dyR < 0.0 || dyR >= \" + t.outHeight + \".0 || fract(dyR) > 0.0) {\\n            continue;\\n          }\\n          int idyR = int(dyR);\\n\\n          for (int wC = 0; wC < \" + a + \"; wC++) {\\n            float dyC = float(dyCCorner + wC) / \" + n + \".0;\\n\\n            if (dyC < 0.0 || dyC >= \" + t.outWidth + \".0 ||\\n                fract(dyC) > 0.0) {\\n              continue;\\n            }\\n            int idyC = int(dyC);\\n\\n            float dyValue = getDy(b, idyR, idyC, d);\\n            int maxPosValue = \" + u + \" - int(getMaxPos(b, idyR, idyC, d));\\n\\n            // Get the current value, check it against the value from the\\n            // position matrix.\\n            int curPosValue = wR * \" + a + \" + wC;\\n            float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);\\n\\n            dotProd += dyValue * mask;\\n          }\\n        }\\n        setOutput(dotProd);\\n      }\\n    \";\n}, Gi = function(t) {\n    this.variableNames = [\n        \"dy\",\n        \"maxPos\"\n    ], this.outputShape = t.inShape;\n    var e = t.strideDepth, n = t.strideHeight, r = t.strideWidth, o = t.dilationDepth, a = t.dilationHeight, i = t.dilationWidth, s = t.effectiveFilterDepth, u = t.effectiveFilterHeight, c = t.effectiveFilterWidth, l = s - 1 - t.padInfo.front, h = u - 1 - t.padInfo.top, f = c - 1 - t.padInfo.left, d = s * u * c - 1;\n    this.userCode = \"\\n      const ivec3 pads = ivec3(\" + l + \", \" + h + \", \" + f + \");\\n\\n      void main() {\\n        ivec5 coords = getOutputCoords();\\n        int batch = coords.x;\\n        int ch = coords.u;\\n\\n        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;\\n        int dyDCorner = dyCorner.x;\\n        int dyRCorner = dyCorner.y;\\n        int dyCCorner = dyCorner.z;\\n\\n        // Convolve dy(?, ?, ?, ch) with pos mask(:, :, :, d) to get\\n        // dx(xD, xR, xC, ch).\\n        // ? = to be determined. : = across all values in that axis.\\n        float dotProd = 0.0;\\n\\n        for (int wD = 0; wD < \" + s + \";\\n           wD += \" + o + \") {\\n          float dyD = float(dyDCorner + wD) / \" + e + \".0;\\n\\n          if (dyD < 0.0 || dyD >= \" + t.outDepth + \".0 || fract(dyD) > 0.0) {\\n            continue;\\n          }\\n          int idyD = int(dyD);\\n\\n          for (int wR = 0; wR < \" + u + \";\\n              wR += \" + a + \") {\\n            float dyR = float(dyRCorner + wR) / \" + n + \".0;\\n\\n            if (dyR < 0.0 || dyR >= \" + t.outHeight + \".0 ||\\n                fract(dyR) > 0.0) {\\n              continue;\\n            }\\n            int idyR = int(dyR);\\n\\n            for (int wC = 0; wC < \" + c + \";\\n                wC += \" + i + \") {\\n              float dyC = float(dyCCorner + wC) / \" + r + \".0;\\n\\n              if (dyC < 0.0 || dyC >= \" + t.outWidth + \".0 ||\\n                  fract(dyC) > 0.0) {\\n                continue;\\n              }\\n              int idyC = int(dyC);\\n\\n              float dyValue = getDy(batch, idyD, idyR, idyC, ch);\\n              int maxPosValue = \" + d + \" -\\n                  int(getMaxPos(batch, idyD, idyR, idyC, ch));\\n\\n              // Get the current value, check it against the value from the\\n              // position matrix.\\n              int curPosValue =\\n                  wD * \" + u + \" * \" + c + \" +\\n                  wR * \" + c + \" + wC;\\n              float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);\\n\\n              dotProd += dyValue * mask;\\n            }\\n          }\\n        }\\n        setOutput(dotProd);\\n      }\\n    \";\n}, Hi = function(t, e, n, r, o, a, i) {\n    void 0 === n && (n = !1), void 0 === r && (r = !1), void 0 === o && (o = !1), void 0 === a && (a = null), void 0 === i && (i = !1), this.variableNames = [\n        \"matrixA\",\n        \"matrixB\"\n    ], this.packedInputs = !0, this.packedOutput = !0, this.outputShape = e;\n    var s = n ? t[1] : t[2], u = Math.ceil(s / 2), c = n ? \"i * 2, rc.y\" : \"rc.y, i * 2\", l = r ? \"rc.z, i * 2\" : \"i * 2, rc.z\", h = n ? [\n        \"a.xxyy\",\n        \"a.zzww\"\n    ] : [\n        \"a.xxzz\",\n        \"a.yyww\"\n    ], f = r ? [\n        \"b.xzxz\",\n        \"b.ywyw\"\n    ] : [\n        \"b.xyxy\",\n        \"b.zwzw\"\n    ], d = \"\", p = \"\";\n    a && (d = i ? \"vec4 activation(vec4 a) {\\n          vec4 b = getPreluActivationWeightsAtOutCoords();\\n          \" + a + \"\\n        }\" : \"vec4 activation(vec4 x) {\\n          \" + a + \"\\n        }\", p = \"result = activation(result);\");\n    var v = o ? \"result += getBiasAtOutCoords();\" : \"\";\n    o && this.variableNames.push(\"bias\"), i && this.variableNames.push(\"preluActivationWeights\"), this.userCode = \"\\n      \" + d + \"\\n\\n      const float sharedDimension = \" + u + \".0;\\n\\n      vec4 dot2x2ARowBCol(ivec3 rc) {\\n        vec4 result = vec4(0);\\n        for (int i = 0; i < \" + u + \"; i++) {\\n          vec4 a = getMatrixA(rc.x, \" + c + \");\\n          vec4 b = getMatrixB(rc.x, \" + l + \");\\n\\n          // These swizzled products need to be separately added.\\n          // See: https://github.com/tensorflow/tfjs/issues/1735\\n          result += (\" + h[0] + \" * \" + f[0] + \");\\n          result += (\" + h[1] + \" * \" + f[1] + \");\\n        }\\n        return result;\\n      }\\n\\n      void main() {\\n        ivec3 rc = getOutputCoords();\\n        vec4 result = dot2x2ARowBCol(rc);\\n\\n        \" + v + \"\\n\\n        \" + p + \"\\n\\n        setOutput(result);\\n      }\\n    \";\n}, qi = function() {\n    function t(t, e, n) {\n        this.variableNames = [\n            \"probs\"\n        ], this.outputShape = [\n            t,\n            n\n        ], this.userCode = \"\\n      uniform float seed;\\n\\n      void main() {\\n        ivec2 coords = getOutputCoords();\\n        int batch = coords[0];\\n\\n        float r = random(seed);\\n        float cdf = 0.0;\\n\\n        for (int i = 0; i < \" + (e - 1) + \"; i++) {\\n          cdf += getProbs(batch, i);\\n\\n          if (r < cdf) {\\n            setOutput(float(i));\\n            return;\\n          }\\n        }\\n\\n        // If no other event happened, last event happened.\\n        setOutput(float(\" + (e - 1) + \"));\\n      }\\n    \";\n    }\n    return t.prototype.getCustomSetupFunc = function(t) {\n        var e = this;\n        return function(n, r) {\n            null == e.seedLoc && (e.seedLoc = n.getUniformLocation(r, \"seed\")), n.gl.uniform1f(e.seedLoc, t);\n        };\n    }, t;\n}(), Ki = function(t, e, n, r) {\n    this.variableNames = [\n        \"indices\"\n    ], this.outputShape = [\n        t,\n        e\n    ], this.userCode = \"\\n      void main() {\\n        ivec2 coords = getOutputCoords();\\n        int index = round(getIndices(coords.x));\\n        setOutput(mix(float(\" + r + \"), float(\" + n + \"),\\n                      float(index == coords.y)));\\n      }\\n    \";\n}, ji = function(t) {\n    this.variableNames = [\n        \"A\"\n    ], this.packedInputs = !1, this.packedOutput = !0, this.outputShape = t;\n    var e = t.length;\n    if (0 === e) this.userCode = \"\\n        void main() {\\n          setOutput(vec4(getA(), 0., 0., 0.));\\n        }\\n      \";\n    else {\n        var n = sa(\"rc\", e), r = wa(e), o = function(t, e, n) {\n            if (1 === t) return \"rc > \" + e[0];\n            for(var r = \"\", o = t - 2; o < t; o++)r += n[o] + \" >= \" + e[o], o < t - 1 && (r += \"||\");\n            return r;\n        }(e, t, n), a = function(t, e, n, r) {\n            if (1 === t) return \"\";\n            var o = r.slice(-2);\n            return \"\\n    int r = \" + o[0] + \";\\n    int c = \" + o[1] + \";\\n    int rp1 = r + 1;\\n    int cp1 = c + 1;\\n\\n    bool cEdge = cp1 >= \" + e + \";\\n    bool rEdge = rp1 >= \" + n + \";\\n  \";\n        }(e, t[t.length - 1], t[t.length - 2], n), i = function(t, e) {\n            var n = t.length, r = function(t, e) {\n                for(var n = [], r = 0; r <= 1; r++)for(var o = 0; o <= 1; o++){\n                    for(var a = (0 === r ? \"r\" : \"rp1\") + \", \" + (0 === o ? \"c\" : \"cp1\"), i = 2; i < t; i++)a = e[e.length - 1 - i] + \",\" + a;\n                    n.push(a);\n                }\n                return n;\n            }(n, e);\n            return 1 === n ? \"getA(rc),\\n            rc + 1 >= \" + t[0] + \" ? 0. : getA(rc + 1),\\n            0, 0\" : \"getA(\" + r[0] + \"),\\n          cEdge ? 0. : getA(\" + r[1] + \"),\\n          rEdge ? 0. : getA(\" + r[2] + \"),\\n          rEdge || cEdge ? 0. : getA(\" + r[3] + \")\";\n        }(t, n);\n        this.userCode = \"\\n        void main() {\\n          \" + r + \" rc = getOutputCoords();\\n\\n          if(\" + o + \") {\\n            setOutput(vec4(0));\\n          } else {\\n            \" + a + \"\\n\\n            setOutput(vec4(\" + i + \"));\\n          }\\n        }\\n      \";\n    }\n};\nvar Xi = function(t, e, n) {\n    this.variableNames = [\n        \"x\"\n    ], this.outputShape = e.map(function(e, n) {\n        return e[0] + t[n] + e[1];\n    });\n    var r = t.length, o = wa(r), a = e.map(function(t) {\n        return t[0];\n    }).join(\",\"), i = e.map(function(e, n) {\n        return e[0] + t[n];\n    }).join(\",\"), s = [\n        \"coords[0]\",\n        \"coords[1]\",\n        \"coords[2]\",\n        \"coords[3]\"\n    ].slice(0, r);\n    this.userCode = 1 !== r ? \"\\n      \" + o + \" start = \" + o + \"(\" + a + \");\\n      \" + o + \" end = \" + o + \"(\" + i + \");\\n\\n      void main() {\\n        \" + o + \" outC = getOutputCoords();\\n        if (any(lessThan(outC, start)) || any(greaterThanEqual(outC, end))) {\\n          setOutput(float(\" + n + \"));\\n        } else {\\n          \" + o + \" coords = outC - start;\\n          setOutput(getX(\" + s + \"));\\n        }\\n      }\\n    \" : \"\\n        int start = \" + a + \";\\n        int end = \" + i + \";\\n\\n        void main() {\\n          int outC = getOutputCoords();\\n          if (outC < start || outC >= end) {\\n            setOutput(float(\" + n + \"));\\n          } else {\\n            setOutput(getX(outC - start));\\n          }\\n        }\\n      \";\n}, Yi = function(t, e, n) {\n    this.variableNames = [\n        \"x\"\n    ], this.packedInputs = !0, this.packedOutput = !0, this.outputShape = e.map(function(e, n) {\n        return e[0] + t[n] + e[1];\n    });\n    for(var r = t.length, o = wa(r), a = e.map(function(t) {\n        return t[0];\n    }).join(\",\"), i = e.map(function(e, n) {\n        return e[0] + t[n];\n    }).join(\",\"), s = sa(\"rc\", r), u = sa(\"source\", r), c = s[r - 1] + \" < \" + this.outputShape[r - 1], l = 1 === r ? \"source\" : \"vec2(\" + u.slice(-2).join() + \")\", h = [\n        o + \" rc = outputLoc;\",\n        s[r - 1] + \" += 1;\\n       if(\" + c + \") {\\n      \",\n        1 === r ? \"\" : \"}\\n       rc = outputLoc;\\n       \" + s[r - 2] + \" += 1;\\n       if(\" + s[r - 2] + \" < \" + this.outputShape[r - 2] + \") {\",\n        1 === r ? \"\" : \"  \" + s[r - 1] + \" += 1;\\n         if(\" + c + \") {\"\n    ], f = 1 === r ? \"rc < start || rc >= end\" : \"any(lessThan(rc, start)) || any(greaterThanEqual(rc, end))\", d = \"\", p = 0, v = 1 === r ? 2 : 4; p < v; p++)d += \"\\n        \" + h[p] + \"\\n        if (\" + f + \") {\\n          result[\" + p + \"] = float(\" + n + \");\\n        } else {\\n          \" + o + \" source = rc - start;\\n          result[\" + p + \"] = getChannel(getX(\" + u.join() + \"), \" + l + \");\\n        }\\n      \";\n    d += 1 === r ? \"} \" : \"}}\", this.userCode = \"\\n      const \" + o + \" start = \" + o + \"(\" + a + \");\\n      const \" + o + \" end = \" + o + \"(\" + i + \");\\n\\n      void main() {\\n        \" + o + \" outputLoc = getOutputCoords();\\n        vec4 result = vec4(0.);\\n        \" + d + \"\\n        setOutput(result);\\n      }\\n    \";\n}, $i = function(t, e, n) {\n    if (this.variableNames = [\n        \"x\"\n    ], \"avg\" === e && n) throw new Error(\"Cannot compute positions for average pool.\");\n    var r = t.filterWidth, o = t.strideHeight, a = t.strideWidth, i = t.dilationHeight, s = t.dilationWidth, u = t.effectiveFilterHeight, c = t.effectiveFilterWidth, l = t.padInfo.top, h = t.padInfo.left;\n    this.outputShape = t.outShape;\n    var f = \"avg\" === e, d = \"0.0\";\n    if (f || (d = \"-1.0 / 1e-20\"), n) this.userCode = \"\\n        const ivec2 strides = ivec2(\" + o + \", \" + a + \");\\n        const ivec2 pads = ivec2(\" + l + \", \" + h + \");\\n\\n        void main() {\\n          ivec4 coords = getOutputCoords();\\n          int batch = coords[0];\\n          int d = coords[3];\\n\\n          ivec2 xRCCorner = coords.yz * strides - pads;\\n          int xRCorner = xRCCorner.x;\\n          int xCCorner = xRCCorner.y;\\n\\n          // max/min x(?, ?, d) to get y(yR, yC, d).\\n          // ? = to be determined\\n          float minMaxValue = 0.0;\\n          float minMaxValueFound = 0.0;\\n          int minMaxPosition = 0;\\n          float avgValue = 0.0;\\n\\n          for (int wR = 0; wR < \" + u + \";\\n              wR += \" + i + \") {\\n            int xR = xRCorner + wR;\\n\\n            if (xR < 0 || xR >= \" + t.inHeight + \") {\\n              continue;\\n            }\\n\\n            for (int wC = 0; wC < \" + c + \";\\n                wC += \" + s + \") {\\n              int xC = xCCorner + wC;\\n\\n              if (xC < 0 || xC >= \" + t.inWidth + \") {\\n                continue;\\n              }\\n\\n              float value = getX(batch, xR, xC, d);\\n\\n              // If a min / max value has already been found, use it. If not,\\n              // use the current value.\\n              float currMinMaxValue = mix(\\n                  value, minMaxValue, minMaxValueFound);\\n              if (value >= currMinMaxValue) {\\n                minMaxValue = value;\\n                minMaxValueFound = 1.0;\\n                minMaxPosition = wR * \" + c + \" + wC;\\n              }\\n            }\\n          }\\n          setOutput(float(minMaxPosition));\\n        }\\n      \";\n    else {\n        var p = e + \"(\" + e + \"(\" + e + \"(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])\";\n        \"avg\" === e && (p = \"avgValue / count\");\n        var v = 4 * Math.floor(r / 4), m = r % 4, g = \"\\n      if (\" + f + \") {\\n        avgValue += dot(values, ones);\\n      } else {\\n        minMaxValue = max(values, minMaxValue);\\n      }\\n    \";\n        this.userCode = \"\\n      const ivec2 strides = ivec2(\" + o + \", \" + a + \");\\n      const ivec2 pads = ivec2(\" + l + \", \" + h + \");\\n      const float initializationValue = \" + d + \";\\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\\n\\n      float count = 0.0;\\n\\n      float getValue(int batch, int xR, int xC, int d) {\\n        if (xC < 0 || xC >= \" + t.inWidth + \") {\\n          return initializationValue;\\n        }\\n        count += 1.0;\\n        return getX(batch, xR, xC, d);\\n      }\\n\\n      void main() {\\n        ivec4 coords = getOutputCoords();\\n        int batch = coords[0];\\n        int d = coords[3];\\n\\n        ivec2 xRCCorner = coords.yz * strides - pads;\\n        int xRCorner = xRCCorner.x;\\n        int xCCorner = xRCCorner.y;\\n\\n        // max/min x(?, ?, d) to get y(yR, yC, d).\\n        // ? = to be determined\\n        vec4 minMaxValue = vec4(\" + d + \");\\n        float avgValue = 0.0;\\n        count = 0.0;\\n\\n        for (int wR = 0; wR < \" + u + \";\\n            wR += \" + i + \") {\\n          int xR = xRCorner + wR;\\n\\n          if (xR < 0 || xR >= \" + t.inHeight + \") {\\n            continue;\\n          }\\n\\n          for (int wC = 0; wC < \" + v + \"; wC += 4) {\\n            int xC = xCCorner + wC * \" + s + \";\\n\\n            vec4 values = vec4(\\n              getValue(batch, xR, xC, d),\\n              getValue(batch, xR, xC + \" + s + \", d),\\n              getValue(batch, xR, xC + 2 * \" + s + \", d),\\n              getValue(batch, xR, xC + 3 * \" + s + \", d)\\n            );\\n\\n            \" + g + \"\\n          }\\n\\n          int xC = xCCorner + \" + v + \";\\n          if (\" + (1 === m) + \") {\\n            vec4 values = vec4(\\n              getValue(batch, xR, xC, d),\\n              initializationValue,\\n              initializationValue,\\n              initializationValue\\n            );\\n\\n            \" + g + \"\\n          } else if (\" + (2 === m) + \") {\\n            vec4 values = vec4(\\n              getValue(batch, xR, xC, d),\\n              getValue(batch, xR, xC + \" + s + \", d),\\n              initializationValue,\\n              initializationValue\\n            );\\n\\n            \" + g + \"\\n          } else if (\" + (3 === m) + \") {\\n            vec4 values = vec4(\\n              getValue(batch, xR, xC, d),\\n              getValue(batch, xR, xC + \" + s + \", d),\\n              getValue(batch, xR, xC + 2 * \" + s + \", d),\\n              initializationValue\\n            );\\n\\n            \" + g + \"\\n          }\\n        }\\n        setOutput(\" + p + \");\\n      }\\n    \";\n    }\n}, Qi = function(t, e, n) {\n    if (this.variableNames = [\n        \"x\"\n    ], \"avg\" === e && n) throw new Error(\"Cannot compute positions for average pool.\");\n    var r = t.filterWidth, o = t.strideDepth, a = t.strideHeight, i = t.strideWidth, s = t.dilationDepth, u = t.dilationHeight, c = t.dilationWidth, l = t.effectiveFilterDepth, h = t.effectiveFilterHeight, f = t.effectiveFilterWidth, d = t.padInfo.front, p = t.padInfo.top, v = t.padInfo.left;\n    this.outputShape = t.outShape;\n    var m = \"avg\" === e, g = \"0.0\";\n    if (m || (g = \"-1.0 / 1e-20\"), n) this.userCode = \"\\n        const ivec3 strides =\\n            ivec3(\" + o + \", \" + a + \", \" + i + \");\\n        const ivec3 pads = ivec3(\" + d + \", \" + p + \", \" + v + \");\\n\\n        void main() {\\n          ivec5 coords = getOutputCoords();\\n          int batch = coords.x;\\n          int ch = coords.u;\\n\\n          ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\\n          int xDCorner = xCorner.x;\\n          int xRCorner = xCorner.y;\\n          int xCCorner = xCorner.z;\\n\\n          // max/min x(?, ?, ?, ch) to get y(yD, yR, yC, ch).\\n          // ? = to be determined\\n          float minMaxValue = 0.0;\\n          float minMaxValueFound = 0.0;\\n          int minMaxPosition = 0;\\n\\n          for (int wD = 0; wD < \" + l + \";\\n              wD += \" + s + \") {\\n            int xD = xDCorner + wD;\\n\\n            if (xD < 0 || xD >= \" + t.inDepth + \") {\\n              continue;\\n            }\\n\\n            for (int wR = 0; wR < \" + h + \";\\n                wR += \" + u + \") {\\n              int xR = xRCorner + wR;\\n\\n              if (xR < 0 || xR >= \" + t.inHeight + \") {\\n                continue;\\n              }\\n\\n              for (int wC = 0; wC < \" + f + \";\\n                  wC += \" + c + \") {\\n                int xC = xCCorner + wC;\\n\\n                if (xC < 0 || xC >= \" + t.inWidth + \") {\\n                  continue;\\n                }\\n\\n                float value = getX(batch, xD, xR, xC, ch);\\n\\n                // If a min / max value has already been found, use it. If not,\\n                // use the current value.\\n                float currMinMaxValue = mix(\\n                    value, minMaxValue, minMaxValueFound);\\n                if (value >= currMinMaxValue) {\\n                  minMaxValue = value;\\n                  minMaxValueFound = 1.0;\\n                  minMaxPosition =\\n                      wD * \" + h + \" * \" + f + \" +\\n                      wR * \" + f + \" + wC;;\\n                }\\n              }\\n            }\\n          }\\n          setOutput(float(minMaxPosition));\\n        }\\n      \";\n    else {\n        var y = e + \"(\" + e + \"(\" + e + \"(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])\";\n        \"avg\" === e && (y = \"avgValue / count\");\n        var x = 4 * Math.floor(r / 4), b = r % 4, w = \"\\n      if (\" + m + \") {\\n        avgValue += dot(values, ones);\\n      } else {\\n        minMaxValue = max(values, minMaxValue);\\n      }\\n    \";\n        this.userCode = \"\\n      const ivec3 strides =\\n        ivec3(\" + o + \", \" + a + \", \" + i + \");\\n      const ivec3 pads = ivec3(\" + d + \", \" + p + \", \" + v + \");\\n      const float initializationValue = \" + g + \";\\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\\n\\n      float count = 0.0;\\n\\n      float getValue(int batch, int xD, int xR, int xC, int ch) {\\n        if (xC < 0 || xC >= \" + t.inWidth + \") {\\n          return initializationValue;\\n        }\\n        count += 1.0;\\n        return getX(batch, xD, xR, xC, ch);\\n      }\\n\\n      void main() {\\n        ivec5 coords = getOutputCoords();\\n        int batch = coords.x;\\n        int ch = coords.u;\\n\\n        ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\\n        int xDCorner = xCorner.x;\\n        int xRCorner = xCorner.y;\\n        int xCCorner = xCorner.z;\\n\\n        // max/min x(?, ?, ?, d) to get y(yD, yR, yC, ch).\\n        // ? = to be determined\\n        vec4 minMaxValue = vec4(\" + g + \");\\n        float avgValue = 0.0;\\n        count = 0.0;\\n\\n        for (int wD = 0; wD < \" + l + \";\\n            wD += \" + s + \") {\\n          int xD = xDCorner + wD;\\n\\n          if (xD < 0 || xD >= \" + t.inDepth + \") {\\n            continue;\\n          }\\n\\n          for (int wR = 0; wR < \" + h + \";\\n            wR += \" + u + \") {\\n            int xR = xRCorner + wR;\\n\\n            if (xR < 0 || xR >= \" + t.inHeight + \") {\\n              continue;\\n            }\\n\\n            for (int wC = 0; wC < \" + x + \"; wC += 4) {\\n              int xC = xCCorner + wC * \" + c + \";\\n\\n              vec4 values = vec4(\\n                getValue(batch, xD, xR, xC, ch),\\n                getValue(batch, xD, xR, xC + \" + c + \", ch),\\n                getValue(batch, xD, xR, xC + 2 * \" + c + \", ch),\\n                getValue(batch, xD, xR, xC + 3 * \" + c + \", ch)\\n              );\\n\\n              \" + w + \"\\n            }\\n\\n            int xC = xCCorner + \" + x + \";\\n            if (\" + (1 === b) + \") {\\n              vec4 values = vec4(\\n                getValue(batch, xD, xR, xC, ch),\\n                initializationValue,\\n                initializationValue,\\n                initializationValue\\n              );\\n\\n              \" + w + \"\\n            } else if (\" + (2 === b) + \") {\\n              vec4 values = vec4(\\n                getValue(batch, xD, xR, xC, ch),\\n                getValue(batch, xD, xR, xC + \" + c + \", ch),\\n                initializationValue,\\n                initializationValue\\n              );\\n\\n              \" + w + \"\\n            } else if (\" + (3 === b) + \") {\\n              vec4 values = vec4(\\n                getValue(batch, xD, xR, xC, ch),\\n                getValue(batch, xD, xR, xC + \" + c + \", ch),\\n                getValue(batch, xD, xR, xC + 2 * \" + c + \", ch),\\n                initializationValue\\n              );\\n\\n              \" + w + \"\\n            }\\n          }\\n          setOutput(\" + y + \");\\n        }\\n      }\\n    \";\n    }\n}, Ji = function(t, e) {\n    this.variableNames = [\n        \"x\"\n    ];\n    var n = t.windowSize, r = t.batchSize, o = t.inSize, a = Math.ceil(o / n);\n    this.outputShape = [\n        r,\n        a\n    ];\n    var i = \"0.0\", s = \"\";\n    \"prod\" === e ? i = \"1.0\" : \"min\" === e ? (i = \"1.0 / 1e-20\", s = \"min\") : \"max\" === e && (i = \"-1.0 / 1e-20\", s = \"max\");\n    var u = e + \"(\" + e + \"(\" + e + \"(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])\";\n    \"sum\" === e ? u = \"sumValue\" : \"prod\" === e ? u = \"prodValue\" : \"all\" === e ? u = \"allValue\" : \"any\" === e && (u = \"anyValue\");\n    var c = 4 * Math.floor(n / 4), l = n % 4, h = \"\\n      if (\" + (\"sum\" === e) + \") {\\n        sumValue += dot(values, ones);\\n      } else if (\" + (\"prod\" === e) + \") {\\n        vec2 tmp = vec2(values[0], values[1]) * vec2(values[2], values[3]);\\n        prodValue *= tmp[0] * tmp[1];\\n      } else {\\n        minMaxValue = \" + s + \"(values, minMaxValue);\\n      }\\n    \", f = \"vec4\";\n    \"all\" === e ? (i = \"1.0\", h = \"\\n        bool reducedAllValue = all(values);\\n        float floatedReducedAllValue = float(reducedAllValue);\\n        allValue = float(allValue >= 1.0 && floatedReducedAllValue >= 1.0);\\n      \", f = \"bvec4\") : \"any\" === e && (i = \"0.0\", h = \"\\n        bool reducedAnyValue = any(values);\\n        float floatedReducedAnyValue = float(reducedAnyValue);\\n        anyValue = float(anyValue >= 1.0 || floatedReducedAnyValue >= 1.0);\\n      \", f = \"bvec4\");\n    var d = \"\";\n    o % n > 0 && (d = \"\\n        if (inIdx < 0 || inIdx >= \" + o + \") {\\n          return initializationValue;\\n        }\\n      \"), this.userCode = \"\\n      const float initializationValue = \" + i + \";\\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\\n\\n      float getValue(int batch, int inIdx) {\\n        \" + d + \"\\n        return getX(batch, inIdx);\\n      }\\n\\n      void main() {\\n        ivec2 coords = getOutputCoords();\\n        int batch = coords[0];\\n        int outIdx = coords[1];\\n        int inOffset = outIdx * \" + n + \";\\n\\n        vec4 minMaxValue = vec4(\" + i + \");\\n        float prodValue = 1.0;\\n        float sumValue = 0.0;\\n        float allValue = 1.0;\\n        float anyValue = 0.0;\\n\\n        for (int i = 0; i < \" + c + \"; i += 4) {\\n          int inIdx = inOffset + i;\\n          \" + f + \" values = \" + f + \"(\\n            getValue(batch, inIdx),\\n            getValue(batch, inIdx + 1),\\n            getValue(batch, inIdx + 2),\\n            getValue(batch, inIdx + 3)\\n          );\\n\\n          \" + h + \"\\n        }\\n\\n        int inIdx = inOffset + \" + c + \";\\n        if (\" + (1 === l) + \") {\\n          \" + f + \" values = \" + f + \"(\\n            getValue(batch, inIdx),\\n            initializationValue,\\n            initializationValue,\\n            initializationValue\\n          );\\n\\n          \" + h + \"\\n        } else if (\" + (2 === l) + \") {\\n          \" + f + \" values = \" + f + \"(\\n            getValue(batch, inIdx),\\n            getValue(batch, inIdx + 1),\\n            initializationValue,\\n            initializationValue\\n          );\\n\\n          \" + h + \"\\n        } else if (\" + (3 === l) + \") {\\n          \" + f + \" values = \" + f + \"(\\n            getValue(batch, inIdx),\\n            getValue(batch, inIdx + 1),\\n            getValue(batch, inIdx + 2),\\n            initializationValue\\n          );\\n\\n          \" + h + \"\\n        }\\n        setOutput(\" + u + \");\\n      }\\n    \";\n}, Zi = function(t, e) {\n    this.variableNames = [\n        \"A\"\n    ], this.packedInputs = !0, this.packedOutput = !0, this.outputShape = t;\n    for(var n = \"\", r = 0; r < 4; r++){\n        var o = \"thisRC = rc;\";\n        r % 2 == 1 && (o += \"thisRC.z += 1;\"), r > 1 && (o += \"thisRC.y += 1;\"), n += \"\\n        \" + o + \"\\n        \" + (r > 0 ? \"if(thisRC.y < rows && thisRC.z < cols){\" : \"\") + \"\\n          int flatIndex = getFlatIndex(thisRC);\\n\\n          ivec3 inputRC = inputCoordsFromReshapedOutCoords(flatIndex);\\n          vec2 inputRCInnerDims = vec2(float(inputRC.y),float(inputRC.z));\\n\\n          result[\" + r + \"] =\\n            getChannel(getA(inputRC.x, inputRC.y, inputRC.z), inputRCInnerDims);\\n        \" + (r > 0 ? \"}\" : \"\") + \"\\n      \";\n    }\n    this.userCode = \"\\n      \\n    ivec3 inputCoordsFromReshapedOutCoords(int index) {\\n      \" + ca([\n        \"r\",\n        \"c\",\n        \"d\"\n    ], e) + \"\\n      return ivec3(r, c, d);\\n    }\\n  \\n      \" + la(t) + \"\\n\\n      void main() {\\n        ivec3 rc = getOutputCoords();\\n\\n        vec4 result = vec4(0.);\\n\\n        ivec3 thisRC;\\n        int rows = \" + t[1] + \";\\n        int cols = \" + t[2] + \";\\n\\n        \" + n + \"\\n\\n        setOutput(result);\\n      }\\n    \";\n};\nvar ts = function(t, e, n) {\n    this.variableNames = [\n        \"dy\"\n    ], this.outputShape = [], this.outputShape = e.shape;\n    var r = e.shape, o = r[1], a = r[2], i = t.shape, s = i[1], u = i[2], c = [\n        n && s > 1 ? o - 1 : o,\n        n && u > 1 ? a - 1 : a\n    ], l = [\n        n && s > 1 ? s - 1 : s,\n        n && u > 1 ? u - 1 : u\n    ], h = c[0] / l[0], f = c[1] / l[1], d = 1 / h, p = 1 / f, v = 2 * Math.ceil(d) + 2, m = 2 * Math.ceil(p) + 2;\n    this.userCode = \"\\n      void main() {\\n        ivec4 coords = getOutputCoords();\\n        int b = coords[0];\\n        int d = coords[3];\\n        int r = coords[1];\\n        int c = coords[2];\\n\\n        float accumulator = 0.0;\\n\\n        const float heightScale = float(\" + h + \");\\n        const float widthScale = float(\" + f + \");\\n\\n        const float invHeightScale = float(\" + d + \");\\n        const float invWidthScale = float(\" + p + \");\\n\\n        const int winHeight = int(\" + v + \");\\n        const int winWidth = int(\" + m + \");\\n\\n        // Compute bounds for where in dy we will look\\n        float startRLerp = floor(float(r) * invHeightScale);\\n        int startDyR = int(startRLerp - float(winHeight / 2));\\n\\n        float startCLerp = floor(float(c) * invWidthScale);\\n        int startDyC = int(startCLerp - float(winWidth / 2));\\n\\n        // Loop over dy\\n        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {\\n          int dyR = dyROffset + startDyR;\\n\\n          // Guard against the window exceeding the bounds of dy\\n          if (dyR < 0 || dyR >= \" + s + \") {\\n            continue;\\n          }\\n\\n          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {\\n            int dyC = dyCOffset + startDyC;\\n\\n            // Guard against the window exceeding the bounds of dy\\n            if (dyC < 0 || dyC >= \" + u + \") {\\n              continue;\\n            }\\n\\n            float dxR = float(dyR) * heightScale;\\n            int topDxRIndex = int(floor(dxR));\\n            int bottomDxRIndex = int(min(ceil(dxR), \" + (o - 1) + \".0));\\n            float dxRLerp = dxR - float(topDxRIndex);\\n            float inverseDxRLerp = 1.0 - dxRLerp;\\n\\n            float dxC = float(dyC) * widthScale;\\n            int leftDxCIndex = int(floor(dxC));\\n            int rightDxCIndex = int(min(ceil(dxC), \" + (a - 1) + \".0));\\n            float dxCLerp = dxC - float(leftDxCIndex);\\n            float inverseDxCLerp = 1.0 - dxCLerp;\\n\\n            if (r == topDxRIndex && c == leftDxCIndex) {\\n              // topLeft\\n              accumulator +=\\n                getDy(b, dyR, dyC, d) * inverseDxRLerp * inverseDxCLerp;\\n            }\\n\\n            if (r == topDxRIndex && c == rightDxCIndex) {\\n              // topRight\\n              accumulator += getDy(b, dyR, dyC, d) * inverseDxRLerp * dxCLerp;\\n            }\\n\\n            if (r == bottomDxRIndex && c == leftDxCIndex) {\\n              // bottomLeft\\n              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * inverseDxCLerp;\\n            }\\n\\n            if (r == bottomDxRIndex && c == rightDxCIndex) {\\n              // bottomRight\\n              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * dxCLerp;\\n            }\\n          }\\n        }\\n        // End loop over dy\\n\\n        setOutput(accumulator);\\n      }\\n    \";\n}, es = function(t, e, n, r) {\n    this.variableNames = [\n        \"A\"\n    ], this.outputShape = [];\n    var o = t[0], a = t[1], i = t[2], s = t[3];\n    this.outputShape = [\n        o,\n        e,\n        n,\n        s\n    ];\n    var u = [\n        r && e > 1 ? a - 1 : a,\n        r && n > 1 ? i - 1 : i\n    ], c = [\n        r && e > 1 ? e - 1 : e,\n        r && n > 1 ? n - 1 : n\n    ];\n    this.userCode = \"\\n      const vec2 effectiveInputOverOutputRatioRC = vec2(\\n          \" + u[0] / c[0] + \",\\n          \" + u[1] / c[1] + \");\\n      const vec2 inputShapeRC = vec2(\" + a + \".0, \" + i + \".0);\\n\\n      void main() {\\n        ivec4 coords = getOutputCoords();\\n        int b = coords[0];\\n        int d = coords[3];\\n        ivec2 yRC = coords.yz;\\n\\n        // Fractional source index.\\n        vec2 sourceFracIndexRC = vec2(yRC) * effectiveInputOverOutputRatioRC;\\n\\n        // Compute the four integer indices.\\n        ivec2 sourceFloorRC = ivec2(sourceFracIndexRC);\\n        ivec2 sourceCeilRC = ivec2(\\n          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));\\n\\n        float topLeft = getA(b, sourceFloorRC.x, sourceFloorRC.y, d);\\n        float bottomLeft = getA(b, sourceCeilRC.x, sourceFloorRC.y, d);\\n        float topRight = getA(b, sourceFloorRC.x, sourceCeilRC.y, d);\\n        float bottomRight = getA(b, sourceCeilRC.x, sourceCeilRC.y, d);\\n\\n        vec2 fracRC = sourceFracIndexRC - vec2(sourceFloorRC);\\n\\n        float top = topLeft + (topRight - topLeft) * fracRC.y;\\n        float bottom = bottomLeft + (bottomRight - bottomLeft) * fracRC.y;\\n        float newValue = top + (bottom - top) * fracRC.x;\\n\\n        setOutput(newValue);\\n      }\\n    \";\n}, ns = function(t, e, n, r) {\n    this.variableNames = [\n        \"A\"\n    ], this.packedInputs = !0, this.packedOutput = !0, this.outputShape = [];\n    var o = t[0], a = t[1], i = t[2], s = t[3];\n    this.outputShape = [\n        o,\n        e,\n        n,\n        s\n    ];\n    var u = [\n        r && e > 1 ? a - 1 : a,\n        r && n > 1 ? i - 1 : i\n    ], c = [\n        r && e > 1 ? e - 1 : e,\n        r && n > 1 ? n - 1 : n\n    ];\n    this.userCode = \"\\n      const vec3 effectiveInputOverOutputRatioRC = vec3(\\n          \" + u[0] / c[0] + \",\\n          \" + u[1] / c[1] + \",\\n          \" + u[1] / c[1] + \");\\n      const vec3 inputShapeRC = vec3(\" + a + \".0, \" + i + \".0,\\n                                     \" + i + \".0);\\n\\n      float getAValue(int b, int r, int c, int d) {\\n        return getChannel(getA(b, r, c, d), vec2(c, d));\\n      }\\n\\n      void main() {\\n        ivec4 coords = getOutputCoords();\\n        int b = coords[0];\\n        int d = coords[3];\\n        // Calculate values for next column in yRC.z.\\n        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);\\n\\n        // Fractional source index.\\n        vec3 sourceFracIndexRC = vec3(yRC) * effectiveInputOverOutputRatioRC;\\n\\n        // Compute the four integer indices.\\n        ivec3 sourceFloorRC = ivec3(sourceFracIndexRC);\\n        ivec3 sourceCeilRC = ivec3(\\n          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));\\n\\n        // Should we calculate next column and row elements in 2x2 packed cell.\\n        bool hasNextCol = d < \" + (s - 1) + \";\\n        bool hasNextRow = coords.z < \" + (n - 1) + \";\\n\\n        // In parallel, construct four corners for all four components in\\n        // packed 2x2 cell.\\n        vec4 topLeft = vec4(\\n          getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d),\\n          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d + 1)\\n                     : 0.0,\\n          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d)\\n                     : 0.0,\\n          (hasNextRow && hasNextCol) ?\\n            getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d + 1) : 0.0);\\n\\n        vec4 bottomLeft = vec4(\\n          getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d),\\n          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d + 1)\\n                     : 0.0,\\n          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d)\\n                     : 0.0,\\n          (hasNextRow && hasNextCol) ?\\n            getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d + 1) : 0.0);\\n\\n        vec4 topRight = vec4(\\n          getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d),\\n          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d + 1)\\n                     : 0.0,\\n          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d)\\n                     : 0.0,\\n          (hasNextRow && hasNextCol) ?\\n            getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d + 1) : 0.0);\\n\\n        vec4 bottomRight = vec4(\\n          getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d),\\n          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d + 1)\\n                     : 0.0,\\n          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d)\\n                     : 0.0,\\n          (hasNextRow && hasNextCol) ?\\n            getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d + 1) : 0.0);\\n\\n        vec3 fracRC = sourceFracIndexRC - vec3(sourceFloorRC);\\n\\n        vec4 top = mix(topLeft, topRight, fracRC.yyzz);\\n        vec4 bottom = mix(bottomLeft, bottomRight, fracRC.yyzz);\\n        vec4 newValue = mix(top, bottom, fracRC.x);\\n\\n        setOutput(newValue);\\n      }\\n    \";\n}, rs = function(t, e, n) {\n    this.variableNames = [\n        \"dy\"\n    ], this.outputShape = [], this.outputShape = e.shape;\n    var r = e.shape, o = r[1], a = r[2], i = t.shape, s = i[1], u = i[2], c = [\n        n && s > 1 ? o - 1 : o,\n        n && u > 1 ? a - 1 : a\n    ], l = [\n        n && s > 1 ? s - 1 : s,\n        n && u > 1 ? u - 1 : u\n    ], h = c[0] / l[0], f = c[1] / l[1], d = 1 / h, p = 1 / f, v = 2 * Math.ceil(d) + 2, m = 2 * Math.ceil(p) + 2;\n    this.userCode = \"\\n      void main() {\\n        ivec4 coords = getOutputCoords();\\n        int b = coords[0];\\n        int d = coords[3];\\n        int r = coords[1];\\n        int c = coords[2];\\n\\n        float accumulator = 0.0;\\n\\n        const float heightScale = float(\" + h + \");\\n        const float widthScale = float(\" + f + \");\\n\\n        const float invHeightScale = float(\" + d + \");\\n        const float invWidthScale = float(\" + p + \");\\n\\n        const int winHeight = int(\" + v + \");\\n        const int winWidth = int(\" + m + \");\\n\\n        // Compute bounds for where in dy we will look\\n        float startRLerp = floor(float(r) * invHeightScale);\\n        int startDyR = int(floor(startRLerp - float(winHeight / 2)));\\n\\n        float startCLerp = floor(float(c) * invWidthScale);\\n        int startDyC = int(floor(startCLerp - float(winWidth / 2)));\\n\\n        // Loop over dy\\n        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {\\n          int dyR = dyROffset + startDyR;\\n\\n          // Guard against the window exceeding the bounds of dy\\n          if (dyR < 0 || dyR >= \" + s + \") {\\n            continue;\\n          }\\n\\n          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {\\n            int dyC = dyCOffset + startDyC;\\n\\n            // Guard against the window exceeding the bounds of dy\\n            if (dyC < 0 || dyC >= \" + u + \") {\\n              continue;\\n            }\\n\\n            float sourceFracRow =\\n              float(\" + c[0] + \") *\\n                (float(dyR) / float(\" + l[0] + \"));\\n\\n            float sourceFracCol =\\n                float(\" + c[1] + \") *\\n                  (float(dyC) / float(\" + l[1] + \"));\\n\\n            int sourceNearestRow = int(min(\\n                float(int(\" + o + \") - 1),\\n                \" + n + \" ? float(round(sourceFracRow)) :\\n                                  float(floor(sourceFracRow))));\\n\\n            int sourceNearestCol = int(min(\\n                float(int(\" + a + \") - 1),\\n                \" + n + \" ? float(round(sourceFracCol)) :\\n                                  float(floor(sourceFracCol))));\\n\\n            if (r == sourceNearestRow && c == sourceNearestCol) {\\n              accumulator += getDy(b, dyR, dyC, d);\\n            }\\n          }\\n        }\\n        // End loop over dy\\n\\n        setOutput(accumulator);\\n      }\\n    \";\n}, os = function(t, e, n, r) {\n    this.variableNames = [\n        \"A\"\n    ], this.outputShape = [];\n    var o = t[0], a = t[1], i = t[2], s = t[3];\n    this.outputShape = [\n        o,\n        e,\n        n,\n        s\n    ];\n    var u = [\n        r && e > 1 ? a - 1 : a,\n        r && n > 1 ? i - 1 : i\n    ], c = [\n        r && e > 1 ? e - 1 : e,\n        r && n > 1 ? n - 1 : n\n    ], l = r ? \"0.5\" : \"0.0\";\n    this.userCode = \"\\n      const vec2 effectiveInputOverOutputRatioRC = vec2(\\n          \" + u[0] / c[0] + \",\\n          \" + u[1] / c[1] + \");\\n      const vec2 inputShapeRC = vec2(\" + a + \".0, \" + i + \".0);\\n\\n      void main() {\\n        ivec4 coords = getOutputCoords();\\n        int b = coords[0];\\n        int d = coords[3];\\n        ivec2 yRC = coords.yz;\\n\\n        // Fractional source index.\\n        vec2 sourceFracIndexRC = vec2(yRC) * effectiveInputOverOutputRatioRC;\\n\\n        // Compute the coordinators of nearest neighbor point.\\n        ivec2 sourceNearestRC = ivec2(\\n          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + \" + l + \")));\\n\\n        float newValue = getA(b, sourceNearestRC.x, sourceNearestRC.y, d);\\n\\n        setOutput(newValue);\\n      }\\n    \";\n}, as = function(t, e) {\n    this.variableNames = [\n        \"x\"\n    ];\n    var n = t.length;\n    if (n > 4) throw new Error(\"WebGL backend: Reverse of rank-\" + n + \" tensor is not yet supported\");\n    if (this.outputShape = t, 1 !== n) {\n        var r = t.map(function(n, r) {\n            return function(n) {\n                return -1 !== e.indexOf(n) && 1 !== t[n] ? t[n] + \" - coords[\" + n + \"] - 1\" : \"coords[\" + n + \"]\";\n            }(r);\n        }).join(\",\"), o = wa(n);\n        this.userCode = \"\\n      void main() {\\n        \" + o + \" coords = getOutputCoords();\\n        setOutput(getX(\" + r + \"));\\n      }\\n    \";\n    } else this.userCode = \"\\n        void main() {\\n          int coord = getOutputCoords();\\n          setOutput(getX(\" + t[0] + \" - coord - 1));\\n        }\\n      \";\n}, is = function(t, e) {\n    this.variableNames = [\n        \"x\"\n    ], this.packedInputs = !0, this.packedOutput = !0;\n    var n = t.length;\n    if (n > 4) throw new Error(\"WebGL backend: Reverse of rank-\" + n + \" tensor is not yet supported\");\n    this.outputShape = t;\n    var r = sa(\"rc\", n), o = r[n - 1] + \" + 1 < \" + this.outputShape[n - 1], a = r[n - 2] + \" + 1 < \" + this.outputShape[n - 2], i = wa(n);\n    function s(n) {\n        var r = t.map(function(r, o) {\n            return function(n, r) {\n                return -1 !== e.indexOf(n) && 1 !== t[n] ? t[n] + \" - \" + r[n] + \" - 1\" : \"\" + r[n];\n            }(o, n);\n        });\n        return \"getChannel(getX(\" + r.join(\",\") + \"), vec2(\" + r.slice(-2).join(\",\") + \"))\";\n    }\n    this.userCode = 1 === n ? \"\\n        void main(){\\n          int rc = getOutputCoords();\\n          vec4 result = vec4(0.);\\n          result.r = getChannel(getX(\" + t[0] + \" - rc - 1),\\n            \" + t[0] + \" - rc - 1);\\n          if(\" + o + \"){\\n              result.g = getChannel(getX(\" + t[0] + \" - (rc  + 1) - 1),\\n                \" + t[0] + \" - (rc  + 1) - 1);\\n          }\\n          setOutput(result);\\n        }\\n      \" : \"\\n        void main() {\\n          \" + i + \" rc = getOutputCoords();\\n          vec4 result = vec4(0.);\\n          result.r = \" + function(t) {\n        return s(t);\n    }(r.slice()) + \";\\n          if(\" + o + \"){\\n            result.g = \" + function(t) {\n        return t[n - 1] = \"(\" + t[n - 1] + \" + 1)\", s(t);\n    }(r.slice()) + \";\\n          }\\n          if(\" + a + \") {\\n            result.b = \" + function(t) {\n        return t[n - 2] = \"(\" + t[n - 2] + \" + 1)\", s(t);\n    }(r.slice()) + \";\\n            if(\" + o + \") {\\n              result.a = \" + function(t) {\n        return t[n - 1] = \"(\" + t[n - 1] + \" + 1)\", t[n - 2] = \"(\" + t[n - 2] + \" + 1)\", s(t);\n    }(r.slice()) + \";\\n            }\\n          }\\n          setOutput(result);\\n        }\\n    \";\n}, ss = function(t, e, n, r, o, a, i) {\n    void 0 === i && (i = !0), this.variableNames = [\n        \"updates\",\n        \"indices\",\n        \"defaultValue\"\n    ], this.outputShape = a;\n    var s = wa(o.length), u = wa(a.length), c = \"\";\n    1 === n ? c = \"i\" : 2 === n && (c = \"i, j\");\n    var l = \"getIndices(\" + c + \")\", h = \"\";\n    1 === r ? h = \"i\" : 2 === r && (h = \"i, coords[1]\");\n    var f = \"getUpdates(\" + h + \")\", d = e > 1 ? \"strides[j]\" : \"strides\";\n    this.userCode = \"\\n        \" + s + \" strides = \" + s + \"(\" + o + \");\\n\\n        void main() {\\n          \" + u + \" coords = getOutputCoords();\\n          float sum = 0.0;\\n          bool found = false;\\n          for (int i = 0; i < \" + t + \"; i++) {\\n            int flattenedIndex = 0;\\n            for (int j = 0; j < \" + e + \"; j++) {\\n              int index = round(\" + l + \");\\n              flattenedIndex += index * \" + d + \";\\n            }\\n            if (flattenedIndex == coords[0]) {\\n              sum += \" + f + \";\\n              found = true;\\n            }\\n          }\\n          setOutput(mix(getDefaultValue(), sum, float(found)));\\n        }\\n      \";\n}, us = function(t, e) {\n    this.variableNames = [\n        \"x\",\n        \"segmentIds\"\n    ];\n    var n = t.windowSize, r = t.batchSize, o = t.inSize, a = t.numSegments, i = a * Math.ceil(o / n);\n    this.outputShape = [\n        r,\n        i\n    ];\n    var s = 4 * Math.floor(n / 4), u = n % 4, c = \"\\n        sumValue += dot(values, segFilter);\\n    \", l = \"\";\n    o % n > 0 && (l = \"\\n        if (inIdx < 0 || inIdx >= \" + o + \") {\\n          return initializationValue;\\n        }\\n      \");\n    var h = \"\";\n    o % n > 0 && (h = \"\\n        if (inIdx < 0 || inIdx >= \" + o + \") {\\n          return -1.0;\\n        }\\n      \"), this.userCode = \"\\n      const float initializationValue = 0.0;\\n\\n      float getValue(int batch, int inIdx) {\\n        \" + l + \"\\n        return getX(batch, inIdx);\\n      }\\n\\n      float getSegmentIdAtIndex(int inIdx) {\\n        \" + h + \"\\n        return getSegmentIds(inIdx);\\n      }\\n\\n      void main() {\\n        ivec2 coords = getOutputCoords();\\n        int batch = coords[0];\\n        int outIdx = coords[1];\\n        int inOffset = int(floor(float(outIdx) / float(\\n          \" + a + \")) * float(\" + n + \"));\\n        int currentSeg = int(mod(float(outIdx), float(\" + a + \")));\\n\\n        float sumValue = 0.0;\\n\\n        for (int i = 0; i < \" + s + \"; i += 4) {\\n          int inIdx = inOffset + i;\\n          vec4 values = vec4(\\n            getValue(batch, inIdx),\\n            getValue(batch, inIdx + 1),\\n            getValue(batch, inIdx + 2),\\n            getValue(batch, inIdx + 3)\\n          );\\n\\n          vec4 segFilter = vec4(\\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\\n            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,\\n            int(getSegmentIdAtIndex(inIdx + 3)) == currentSeg ? 1 : 0\\n          );\\n\\n          \" + c + \"\\n        }\\n\\n        int inIdx = inOffset + \" + s + \";\\n        if (\" + (1 === u) + \") {\\n          vec4 values = vec4(\\n            getValue(batch, inIdx),\\n            initializationValue,\\n            initializationValue,\\n            initializationValue\\n          );\\n\\n          int inIdxSeg = int(getSegmentIdAtIndex(inIdx));\\n\\n          vec4 segFilter = vec4(\\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\\n            0,\\n            0,\\n            0\\n          );\\n\\n          \" + c + \"\\n        } else if (\" + (2 === u) + \") {\\n          vec4 values = vec4(\\n            getValue(batch, inIdx),\\n            getValue(batch, inIdx + 1),\\n            initializationValue,\\n            initializationValue\\n          );\\n\\n          vec4 segFilter = vec4(\\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\\n              0,\\n              0\\n          );\\n\\n          \" + c + \"\\n        } else if (\" + (3 === u) + \") {\\n          vec4 values = vec4(\\n            getValue(batch, inIdx),\\n            getValue(batch, inIdx + 1),\\n            getValue(batch, inIdx + 2),\\n            initializationValue\\n          );\\n\\n          vec4 segFilter = vec4(\\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\\n            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,\\n            0\\n          );\\n\\n          \" + c + \"\\n        }\\n        setOutput(sumValue);\\n      }\\n    \";\n}, cs = function(t, e, n) {\n    var r, o;\n    if (this.variableNames = [\n        \"c\",\n        \"a\",\n        \"b\"\n    ], this.outputShape = e, n > 4) throw Error(\"Where for rank \" + n + \" is not yet supported\");\n    if (1 === n) o = \"resRC\", r = \"resRC\";\n    else {\n        for(var a = [\n            \"resRC.x\",\n            \"resRC.y\",\n            \"resRC.z\",\n            \"resRC.w\"\n        ], i = [], s = [], u = 0; u < e.length; u++)s.push(\"\" + a[u]), u < t && i.push(\"\" + a[u]);\n        r = i.join(), o = s.join();\n    }\n    var c = wa(n);\n    this.userCode = \"\\n      void main() {\\n        \" + c + \" resRC = getOutputCoords();\\n        float cVal = getC(\" + r + \");\\n        if (cVal >= 1.0) {\\n          setOutput(getA(\" + o + \"));\\n        } else {\\n          setOutput(getB(\" + o + \"));\\n        }\\n      }\\n    \";\n}, ls = function() {\n    function t(t) {\n        this.variableNames = [\n            \"source\"\n        ], this.outputShape = t, this.rank = t.length;\n        var e, n = wa(this.rank), r = \"uniform int start[\" + this.rank + \"];\", o = function(t) {\n            if (1 === t) return \"sourceLoc\";\n            if (t <= 6) return hs.slice(0, t).map(function(t) {\n                return \"sourceLoc.\" + t;\n            }).join(\",\");\n            throw Error(\"Slicing for rank \" + t + \" is not yet supported\");\n        }(this.rank);\n        e = \"\\n        \" + n + \" sourceLoc;\\n        \" + n + \" coords = getOutputCoords();\\n        \" + t.map(function(t, e) {\n            return \"sourceLoc.\" + hs[e] + \" = start[\" + e + \"] + coords.\" + hs[e] + \";\";\n        }).join(\"\\n\") + \"\\n      \", this.userCode = \"\\n      \" + r + \"\\n      void main() {\\n        \" + e + \"\\n        setOutput(getSource(\" + o + \"));\\n      }\\n    \";\n    }\n    return t.prototype.getCustomSetupFunc = function(t) {\n        var e = this;\n        if (t.length !== this.rank) throw Error(\"The rank (\" + this.rank + \") of the program must match the length of start (\" + t.length + \")\");\n        return function(n, r) {\n            null == e.startLoc && (e.startLoc = n.getUniformLocationNoThrow(r, \"start\"), null == e.startLoc) || n.gl.uniform1iv(e.startLoc, t);\n        };\n    }, t;\n}(), hs = [\n    \"x\",\n    \"y\",\n    \"z\",\n    \"w\",\n    \"u\",\n    \"v\"\n];\nvar fs = function() {\n    function t(t) {\n        this.variableNames = [\n            \"source\"\n        ], this.packedInputs = !0, this.packedOutput = !0, this.outputShape = t, this.rank = t.length;\n        var e = wa(this.rank), n = sa(\"coords\", this.rank), r = sa(\"sourceLoc\", this.rank), o = 1 === this.rank ? \"sourceLoc\" : \"vec2(\" + r.slice(-2).join() + \")\", a = \"getChannel(getSource(\" + r.join() + \"), \" + o + \")\", i = \"\\n      result.x = \" + a + \";\\n      if (++\" + n[this.rank - 1] + \" < \" + t[this.rank - 1] + \") {\\n        ++\" + r[this.rank - 1] + \";\\n        result.y = \" + a + \";\\n        --\" + r[this.rank - 1] + \";\\n      }\\n    \", s = 1 === this.rank ? \"\" : \"\\n      --\" + n[this.rank - 1] + \";\\n      if (++\" + n[this.rank - 2] + \" < \" + t[this.rank - 2] + \") {\\n        ++\" + r[this.rank - 2] + \";\\n        result.z = \" + a + \";\\n        if (++\" + n[this.rank - 1] + \" < \" + t[this.rank - 1] + \") {\\n          ++\" + r[this.rank - 1] + \";\\n          result.w = \" + a + \";\\n        }\\n      }\\n    \", u = this.rank <= 4 ? \"sourceLoc = coords +\\n            \" + e + \"(\" + t.map(function(t, e) {\n            return \"start[\" + e + \"]\";\n        }).join() + \");\" : t.map(function(t, e) {\n            return r[e] + \" = \" + n[e] + \" + start[\" + e + \"];\";\n        }).join(\"\\n\");\n        this.userCode = \"\\n      uniform int start[\" + this.rank + \"];\\n      void main() {\\n        \" + e + \" coords = getOutputCoords();\\n        \" + e + \" sourceLoc;\\n        \" + u + \"\\n        vec4 result = vec4(0.);\\n        \" + i + \"\\n        \" + s + \"\\n        setOutput(result);\\n      }\\n    \";\n    }\n    return t.prototype.getCustomSetupFunc = function(t) {\n        var e = this;\n        if (t.length !== this.rank) throw Error(\"The rank (\" + this.rank + \") of the program must match the length of start (\" + t.length + \")\");\n        return function(n, r) {\n            null == e.startLoc && (e.startLoc = n.getUniformLocationNoThrow(r, \"start\"), null == e.startLoc) || n.gl.uniform1iv(e.startLoc, t);\n        };\n    }, t;\n}(), ds = function(t, e, n) {\n    this.variableNames = [\n        \"x\"\n    ], this.outputShape = n;\n    var r = n.length, o = wa(n.length), a = wa(n.length), i = \"\";\n    if (1 === r) i = \"coords * strides + begin\";\n    else {\n        var s = 0;\n        i = n.map(function(t, e) {\n            return s++, 1 === n.length ? \"coords * strides[\" + e + \"] + begin[\" + e + \"]\" : \"coords[\" + (s - 1) + \"] * strides[\" + e + \"] + begin[\" + e + \"]\";\n        }).join(\",\");\n    }\n    this.userCode = \"\\n      \" + o + \" begin = \" + o + \"(\" + t + \");\\n      \" + o + \" strides = \" + o + \"(\" + e + \");\\n\\n      void main() {\\n        \" + a + \" coords = getOutputCoords();\\n        setOutput(getX(\" + i + \"));\\n      }\\n    \";\n}, ps = function() {\n    function t(t) {\n        this.gpgpu = t, this.numUsedTextures = 0, this.numFreeTextures = 0, this.freeTextures = {}, this.logEnabled = !1, this.usedTextures = {};\n    }\n    return t.prototype.acquireTexture = function(t, e, n) {\n        var r, o = vs(e, n), a = ms(t, o, n);\n        if (a in this.freeTextures || (this.freeTextures[a] = []), a in this.usedTextures || (this.usedTextures[a] = []), this.freeTextures[a].length > 0) {\n            this.numFreeTextures--, this.numUsedTextures++, this.log();\n            var i = this.freeTextures[a].shift();\n            return this.usedTextures[a].push(i), i;\n        }\n        return this.numUsedTextures++, this.log(), o === Gt.PACKED_2X2_FLOAT32 ? r = this.gpgpu.createPackedMatrixTexture(t[0], t[1]) : o === Gt.PACKED_2X2_FLOAT16 ? r = this.gpgpu.createFloat16PackedMatrixTexture(t[0], t[1]) : o === Gt.UNPACKED_FLOAT32 ? r = this.gpgpu.createFloat32MatrixTexture(t[0], t[1]) : o === Gt.UNPACKED_FLOAT16 ? r = this.gpgpu.createFloat16MatrixTexture(t[0], t[1]) : o === Gt.PACKED_4X1_UNSIGNED_BYTE && (r = this.gpgpu.createUnsignedBytesMatrixTexture(t[0], t[1])), this.usedTextures[a].push(r), r;\n    }, t.prototype.releaseTexture = function(t, e, n, r) {\n        if (null != this.freeTextures) {\n            var o = ms(e, vs(n, r), r);\n            o in this.freeTextures || (this.freeTextures[o] = []), this.freeTextures[o].push(t), this.numFreeTextures++, this.numUsedTextures--;\n            var a = this.usedTextures[o], i = a.indexOf(t);\n            if (i < 0) throw new Error(\"Cannot release a texture that was never provided by this texture manager\");\n            a.splice(i, 1), this.log();\n        }\n    }, t.prototype.log = function() {\n        if (this.logEnabled) {\n            var t = this.numFreeTextures + this.numUsedTextures;\n            console.log(\"Free/Used\", this.numFreeTextures + \" / \" + this.numUsedTextures, \"(\" + t + \")\");\n        }\n    }, t.prototype.getNumUsedTextures = function() {\n        return this.numUsedTextures;\n    }, t.prototype.getNumFreeTextures = function() {\n        return this.numFreeTextures;\n    }, t.prototype.dispose = function() {\n        var t = this;\n        if (null != this.freeTextures) {\n            for(var e in this.freeTextures)this.freeTextures[e].forEach(function(e) {\n                t.gpgpu.deleteMatrixTexture(e);\n            });\n            for(var e in this.usedTextures)this.usedTextures[e].forEach(function(e) {\n                t.gpgpu.deleteMatrixTexture(e);\n            });\n            this.freeTextures = null, this.usedTextures = null, this.numUsedTextures = 0, this.numFreeTextures = 0;\n        }\n    }, t;\n}();\nfunction vs(t, e) {\n    if (t === zt.UPLOAD) return Gt.PACKED_2X2_FLOAT32;\n    if (t === zt.RENDER || null == t) return function(t) {\n        return i().getBool(\"WEBGL_RENDER_FLOAT32_ENABLED\") ? t ? Gt.PACKED_2X2_FLOAT32 : Gt.UNPACKED_FLOAT32 : t ? Gt.PACKED_2X2_FLOAT16 : Gt.UNPACKED_FLOAT16;\n    }(e);\n    if (t === zt.DOWNLOAD || t === zt.PIXELS) return Gt.PACKED_4X1_UNSIGNED_BYTE;\n    throw new Error(\"Unknown logical texture type \" + t);\n}\nfunction ms(t, e, n) {\n    return t[0] + \"_\" + t[1] + \"_\" + e + \"_\" + n;\n}\nvar gs = function(t, e) {\n    this.variableNames = [\n        \"A\"\n    ];\n    for(var n = new Array(t.length), r = 0; r < n.length; r++)n[r] = t[r] * e[r];\n    this.outputShape = n, this.rank = n.length;\n    var o = wa(this.rank), a = function(t) {\n        var e = t.length;\n        if (e > 5) throw Error(\"Tile for rank \" + e + \" is not yet supported\");\n        if (1 === e) return \"imod(resRC, \" + t[0] + \")\";\n        for(var n = [\n            \"resRC.x\",\n            \"resRC.y\",\n            \"resRC.z\",\n            \"resRC.w\",\n            \"resRC.u\"\n        ], r = [], o = 0; o < t.length; o++)r.push(\"imod(\" + n[o] + \", \" + t[o] + \")\");\n        return r.join();\n    }(t);\n    this.userCode = \"\\n      void main() {\\n        \" + o + \" resRC = getOutputCoords();\\n        setOutput(getA(\" + a + \"));\\n      }\\n    \";\n};\nvar ys = function(t, e) {\n    this.variableNames = [\n        \"A\"\n    ];\n    for(var n = new Array(t.length), r = 0; r < n.length; r++)n[r] = t[e[r]];\n    this.outputShape = n, this.rank = n.length;\n    var o = wa(this.rank), a = function(t) {\n        var e = t.length;\n        if (e > 6) throw Error(\"Transpose for rank \" + e + \" is not yet supported\");\n        for(var n = [\n            \"resRC.x\",\n            \"resRC.y\",\n            \"resRC.z\",\n            \"resRC.w\",\n            \"resRC.u\",\n            \"resRC.v\"\n        ], r = new Array(e), o = 0; o < t.length; o++)r[t[o]] = n[o];\n        return r.join();\n    }(e);\n    this.userCode = \"\\n    void main() {\\n      \" + o + \" resRC = getOutputCoords();\\n      setOutput(getA(\" + a + \"));\\n    }\\n    \";\n};\nvar xs = function(t, e) {\n    this.variableNames = [\n        \"A\"\n    ], this.packedInputs = !0, this.packedOutput = !0;\n    for(var n = new Array(t.length), r = 0; r < n.length; r++)n[r] = t[e[r]];\n    if (this.outputShape = n, this.rank = n.length, this.rank > 6) throw Error(\"Packed transpose for rank \" + this.rank + \" is not yet supported.\");\n    var o = wa(this.rank), a = ia(\"rc\", this.rank), i = new Array(this.rank);\n    for(r = 0; r < e.length; r++)i[e[r]] = a[r];\n    var s = \"vec2(\" + i.slice(-2).join() + \")\", u = \"++\" + a[this.rank - 1] + \" < \" + n[this.rank - 1], c = \"getChannel(getA(\" + i.join() + \"), \" + s + \")\";\n    this.userCode = \"\\n    void main() {\\n      \" + o + \" rc = getOutputCoords();\\n      vec4 result = vec4(0.);\\n      result[0] = \" + c + \";\\n      if(\" + u + \") {\\n        result[1] = \" + c + \";\\n      }\\n      --\" + a[this.rank - 1] + \";\\n      if(++\" + a[this.rank - 2] + \" < \" + n[this.rank - 2] + \") {\\n        result[2] = \" + c + \";\\n        if(\" + u + \") {\\n          result[3] = \" + c + \";\\n        }\\n      }\\n      setOutput(result);\\n    }\\n    \";\n}, bs = 1.7580993408473768, ws = 1.0507009873554805, Cs = function(t, e) {\n    this.variableNames = [\n        \"A\"\n    ], this.outputShape = t, this.userCode = \"\\n      float unaryOperation(float x) {\\n        \" + e + \"\\n      }\\n\\n      void main() {\\n        float x = getAAtOutCoords();\\n        float y = unaryOperation(x);\\n\\n        setOutput(y);\\n      }\\n    \";\n}, Es = \"if (isnan(x)) return x;\", Rs = \"return x;\", Is = \"return abs(x);\", ks = Es + \"\\n  return (x < 0.0) ? 0.0 : x;\\n\", Ss = Es + \"\\n  return (x < 0.0) ? 0.0 : min(6.0, x);\\n\", As = \"return (x >= 0.0) ? x : (exp(x) - 1.0);\", Ds = \"\\n  // Stable and Attracting Fixed Point (0, 1) for Normalized Weights.\\n  // see: https://arxiv.org/abs/1706.02515\\n  float scaleAlpha = \" + bs + \";\\n  float scale = \" + ws + \";\\n  return (x >= 0.0) ? scale * x : scaleAlpha * (exp(x) - 1.0);\\n\";\nvar Ts = \"return -x;\", Ns = \"return ceil(x);\", Fs = \"return floor(x);\", _s = \"return exp(x);\", Os = \"return exp(x) - 1.0;\", Ms = Es + \"\\n  return sin(x);\\n\", Bs = Es + \"\\n  return cos(x);\\n\", Ps = Es + \"\\n  if (abs(x) > 1.) {\\n    return NAN;\\n  }\\n  return asin(x);\\n\", Ls = Es + \"\\n  if (abs(x) > 1.) {\\n    return NAN;\\n  }\\n  return acos(x);\\n\", Ws = Es + \"\\n  return atan(x);\\n\", Us = Es + \"return log(x + sqrt(x * x + 1.0));\", Vs = Es + \"\\n  if (x < 1.0) return NAN;\\n  return log(x + sqrt(x * x - 1.0));\", zs = Es + \"\\n  if ((x < -1.0) || (x > 1.0)) return NAN;\\n  return (log(1.0 + x) - log(1.0 - x)) / 2.0;\", Gs = \"return x;\", Hs = \"return x;\", qs = \"\\n  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));\\n  bvec4 isNaN = isnan(x);\\n\\n  result.r = isNaN.r ? x.r : result.r;\\n  result.g = isNaN.g ? x.g : result.g;\\n  result.b = isNaN.b ? x.b : result.b;\\n  result.a = isNaN.a ? x.a : result.a;\\n\\n  return result;\\n\", Ks = \"\\n  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));\\n  bvec4 isNaN = isnan(x);\\n\\n  result.r = isNaN.r ? x.r : result.r;\\n  result.g = isNaN.g ? x.g : result.g;\\n  result.b = isNaN.b ? x.b : result.b;\\n  result.a = isNaN.a ? x.a : result.a;\\n\\n  return result;\\n\", js = \"\\n  vec4 result;\\n\\n  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);\\n  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);\\n  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);\\n  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);\\n\\n  return result;\\n\", Xs = function(t, e) {\n    this.variableNames = [\n        \"A\"\n    ], this.packedInputs = !0, this.packedOutput = !0, this.outputShape = t, this.userCode = \"\\n      vec4 unaryOperation(vec4 x) {\\n        \" + e + \"\\n      }\\n\\n      void main() {\\n        vec4 x = getAAtOutCoords();\\n        vec4 y = unaryOperation(x);\\n\\n        setOutput(y);\\n      }\\n    \";\n}, Ys = function(t) {\n    this.variableNames = [\n        \"A\"\n    ], this.packedInputs = !0, this.packedOutput = !1, this.outputShape = t;\n    var e = t.length, n = sa(\"rc\", e), r = wa(e), o = function(t, e) {\n        if (1 === t) return \"rc\";\n        for(var n = \"\", r = 0; r < t; r++)n += e[r], r < t - 1 && (n += \",\");\n        return n;\n    }(e, n), a = n.slice(-2), i = e <= 1 ? \"rc\" : \"vec2(\" + a.join(\",\") + \")\";\n    this.userCode = \"\\n      void main() {\\n        \" + r + \" rc = getOutputCoords();\\n        vec4 packedInput = getA(\" + o + \");\\n\\n        setOutput(getChannel(packedInput, \" + i + \"));\\n      }\\n    \";\n}, $s = {};\nfunction Qs(t, e) {\n    if (void 0 === e && (e = !1), \"linear\" === t) return e ? Hs : Rs;\n    if (\"relu\" === t) return e ? qs : ks;\n    if (\"elu\" === t) return e ? js : As;\n    if (\"relu6\" === t) return e ? Ks : Ss;\n    if (\"prelu\" === t) return e ? Pa : Ma;\n    throw new Error(\"Activation \" + t + \" has not been implemented for the WebGL backend.\");\n}\nvar Js = 600;\nvar Zs = function(t) {\n    function o(e) {\n        var n, r = t.call(this) || this;\n        if (r.pendingRead = new WeakMap, r.pendingDisposal = new WeakSet, r.dataRefCount = new WeakMap, r.numBytesInGPU = 0, r.uploadWaitMs = 0, r.downloadWaitMs = 0, r.warnedAboutMemory = !1, r.pendingDeletes = 0, r.disposed = !1, !i().getBool(\"HAS_WEBGL\")) throw new Error(\"WebGL is not supported on this device\");\n        if (null == e) {\n            var o = jt(i().getNumber(\"WEBGL_VERSION\"));\n            r.binaryCache = (n = i().getNumber(\"WEBGL_VERSION\")) in $s ? $s[n] : ($s[n] = {}, $s[n]), r.gpgpu = new Bi(o), r.canvas = o.canvas, r.gpgpuCreatedLocally = !0;\n        } else r.gpgpu = e, r.binaryCache = {}, r.gpgpuCreatedLocally = !1, r.canvas = e.gl.canvas;\n        return r.textureManager = new ps(r.gpgpu), r.numMBBeforeWarning = null == i().global.screen ? 1024 : i().global.screen.height * i().global.screen.width * window.devicePixelRatio * Js / 1024 / 1024, r.texData = new xo(r, Lt), r;\n    }\n    return e(o, t), o.prototype.numDataIds = function() {\n        return this.texData.numDataIds() + (this.cpuBackend ? this.cpuBackend.numDataIds() : 0) - this.pendingDeletes;\n    }, o.prototype.write = function(t, e, n) {\n        if (i().getBool(\"DEBUG\") && this.checkNumericalProblems(t), \"complex64\" === n && null != t) throw new Error(\"Cannot write to a complex64 dtype. Please use tf.complex(real, imag).\");\n        var r = {};\n        return this.texData.set(r, {\n            shape: e,\n            dtype: n,\n            values: t,\n            usage: zt.UPLOAD\n        }), r;\n    }, o.prototype.move = function(t, e, n, r) {\n        if (i().getBool(\"DEBUG\") && this.checkNumericalProblems(e), \"complex64\" === r) throw new Error(\"Cannot write to a complex64 dtype. Please use tf.complex(real, imag).\");\n        this.texData.set(t, {\n            shape: n,\n            dtype: r,\n            values: e,\n            usage: zt.UPLOAD\n        });\n    }, o.prototype.readSync = function(t) {\n        var e = this.texData.get(t), n = e.values, r = e.dtype, o = e.complexTensors, a = e.slice, i = e.shape, s = e.isPacked;\n        if (null != a) {\n            var u = void 0;\n            u = s ? new Xs(i, Gs) : new Cs(i, Gs);\n            var c = this.runWebGLProgram(u, [\n                {\n                    dataId: t,\n                    shape: i,\n                    dtype: r\n                }\n            ], r), l = this.readSync(c.dataId);\n            return this.disposeData(c.dataId), l;\n        }\n        if (null != n) return this.convertAndCacheOnCPU(t);\n        if (\"string\" === r) return n;\n        var h, f, d = null != this.activeTimers;\n        (d && (h = et()), \"complex64\" === r) ? f = Vo(o.real.dataSync(), o.imag.dataSync()) : f = this.getValuesFromTexture(t);\n        return d && (this.downloadWaitMs += et() - h), this.convertAndCacheOnCPU(t, f);\n    }, o.prototype.read = function(t) {\n        return n(this, void 0, void 0, function() {\n            var e, n, o, a, s, u, c, l, h, f, d, p, v, m, g, y, x, b, w, C, E, R;\n            return r(this, function(r) {\n                switch(r.label){\n                    case 0:\n                        if (this.pendingRead.has(t)) return e = this.pendingRead.get(t), [\n                            2,\n                            new Promise(function(t) {\n                                return e.push(t);\n                            })\n                        ];\n                        if (n = this.texData.get(t), o = n.values, a = n.shape, s = n.slice, u = n.dtype, c = n.complexTensors, l = n.isPacked, null != s) return h = void 0, h = l ? new Xs(a, Gs) : new Cs(a, Gs), f = this.runWebGLProgram(h, [\n                            {\n                                dataId: t,\n                                shape: a,\n                                dtype: u\n                            }\n                        ], u), d = this.read(f.dataId), this.disposeData(f.dataId), [\n                            2,\n                            d\n                        ];\n                        if (null != o) return [\n                            2,\n                            this.convertAndCacheOnCPU(t)\n                        ];\n                        if (!i().getBool(\"WEBGL_DOWNLOAD_FLOAT_ENABLED\") && 2 === i().getNumber(\"WEBGL_VERSION\")) throw new Error(\"tensor.data() with WEBGL_DOWNLOAD_FLOAT_ENABLED=false and WEBGL_VERSION=2 not yet supported.\");\n                        return p = null, \"complex64\" !== u && i().get(\"WEBGL_BUFFER_SUPPORTED\") && (v = this.decode(t), m = this.texData.get(v.dataId), p = (R = this.gpgpu).createBufferFromTexture.apply(R, [\n                            m.texture\n                        ].concat(Yt(a)))), this.pendingRead.set(t, []), \"complex64\" === u ? [\n                            3,\n                            2\n                        ] : [\n                            4,\n                            this.gpgpu.createAndWaitForFence()\n                        ];\n                    case 1:\n                        r.sent(), r.label = 2;\n                    case 2:\n                        return \"complex64\" !== u ? [\n                            3,\n                            4\n                        ] : [\n                            4,\n                            Promise.all([\n                                c.real.data(),\n                                c.imag.data()\n                            ])\n                        ];\n                    case 3:\n                        return y = r.sent(), x = y[0], b = y[1], g = Vo(x, b), [\n                            3,\n                            5\n                        ];\n                    case 4:\n                        null == p ? g = this.getValuesFromTexture(t) : (w = k(a), g = this.gpgpu.downloadFloat32MatrixFromBuffer(p, w)), r.label = 5;\n                    case 5:\n                        return null != v && this.disposeData(v.dataId), C = this.convertAndCacheOnCPU(t, g), E = this.pendingRead.get(t), this.pendingRead.delete(t), E.forEach(function(t) {\n                            return t(C);\n                        }), this.pendingDisposal.has(t) && (this.pendingDisposal.delete(t), this.disposeData(t), this.pendingDeletes--), [\n                            2,\n                            C\n                        ];\n                }\n            });\n        });\n    }, o.prototype.checkNumericalProblems = function(t) {\n        if (null != t) for(var e = 0; e < t.length; e++){\n            var n = t[e];\n            if (!ee(n)) {\n                if (i().getBool(\"WEBGL_RENDER_FLOAT32_CAPABLE\")) throw Error(\"The value \" + n + \" cannot be represented with your current settings. Consider enabling float32 rendering: 'tf.env().set('WEBGL_RENDER_FLOAT32_ENABLED', true);'\");\n                throw Error(\"The value \" + n + \" cannot be represented on this device.\");\n            }\n        }\n    }, o.prototype.getValuesFromTexture = function(t) {\n        var e, n = this.texData.get(t), r = n.shape, o = n.dtype, a = n.isPacked, s = k(r);\n        if (i().getBool(\"WEBGL_DOWNLOAD_FLOAT_ENABLED\")) {\n            var u = this.decode(t), c = this.texData.get(u.dataId), l = (e = this.gpgpu).downloadMatrixFromPackedTexture.apply(e, [\n                c.texture\n            ].concat(Yt(r))).subarray(0, s);\n            return this.disposeData(u.dataId), l;\n        }\n        var h = i().getBool(\"WEBGL_PACK\") && !0 === a, f = h ? Te(r) : r, d = h ? new ci(f) : new ui(f), p = this.runWebGLProgram(d, [\n            {\n                shape: f,\n                dtype: o,\n                dataId: t\n            }\n        ], \"float32\"), v = this.texData.get(p.dataId), m = this.gpgpu.downloadByteEncodedFloatMatrixFromOutputTexture(v.texture, v.texShape[0], v.texShape[1]).subarray(0, s);\n        return this.disposeData(p.dataId), m;\n    }, o.prototype.time = function(t) {\n        return n(this, void 0, void 0, function() {\n            var e, n, o, a, s, u, c;\n            return r(this, function(r) {\n                switch(r.label){\n                    case 0:\n                        return e = this.activeTimers, n = [], o = !1, null == this.programTimersStack ? (this.programTimersStack = n, o = !0) : this.activeTimers.push(n), this.activeTimers = n, t(), a = I(this.activeTimers.map(function(t) {\n                            return t.query;\n                        })).filter(function(t) {\n                            return null != t;\n                        }), s = I(this.activeTimers.map(function(t) {\n                            return t.name;\n                        })).filter(function(t) {\n                            return null != t;\n                        }), this.activeTimers = e, o && (this.programTimersStack = null), u = {\n                            uploadWaitMs: this.uploadWaitMs,\n                            downloadWaitMs: this.downloadWaitMs,\n                            kernelMs: null,\n                            wallMs: null\n                        }, i().getNumber(\"WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE\") > 0 ? [\n                            4,\n                            Promise.all(a)\n                        ] : [\n                            3,\n                            2\n                        ];\n                    case 1:\n                        return c = r.sent(), u.kernelMs = w(c), u.getExtraProfileInfo = function() {\n                            return c.map(function(t, e) {\n                                return {\n                                    name: s[e],\n                                    ms: t\n                                };\n                            }).map(function(t) {\n                                return t.name + \": \" + t.ms;\n                            }).join(\", \");\n                        }, [\n                            3,\n                            3\n                        ];\n                    case 2:\n                        u.kernelMs = {\n                            error: \"WebGL query timers are not supported in this environment.\"\n                        }, r.label = 3;\n                    case 3:\n                        return this.uploadWaitMs = 0, this.downloadWaitMs = 0, [\n                            2,\n                            u\n                        ];\n                }\n            });\n        });\n    }, o.prototype.memory = function() {\n        return {\n            unreliable: !1,\n            numBytesInGPU: this.numBytesInGPU\n        };\n    }, o.prototype.startTimer = function() {\n        return i().getNumber(\"WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE\") > 0 ? this.gpgpu.beginQuery() : {\n            startMs: et(),\n            endMs: null\n        };\n    }, o.prototype.endTimer = function(t) {\n        return i().getNumber(\"WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE\") > 0 ? (this.gpgpu.endQuery(), t) : (t.endMs = et(), t);\n    }, o.prototype.getQueryTime = function(t) {\n        return n(this, void 0, void 0, function() {\n            var e;\n            return r(this, function(n) {\n                return i().getNumber(\"WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE\") > 0 ? [\n                    2,\n                    this.gpgpu.waitForQueryAndGetTime(t)\n                ] : [\n                    2,\n                    (e = t).endMs - e.startMs\n                ];\n            });\n        });\n    }, o.prototype.disposeData = function(t) {\n        if (!this.pendingDisposal.has(t)) {\n            if (this.pendingRead.has(t)) return this.pendingDisposal.add(t), void this.pendingDeletes++;\n            if (this.texData.has(t)) {\n                this.releaseGPUData(t);\n                var e = this.texData.get(t).complexTensors;\n                null != e && (e.real.dispose(), e.imag.dispose()), this.texData.delete(t);\n            }\n        }\n    }, o.prototype.releaseGPUData = function(t) {\n        var e = this.texData.get(t), n = e.texture, r = e.dtype, o = e.texShape, a = e.usage, i = e.isPacked, s = e.slice, u = s && s.origDataId || t, c = this.dataRefCount.get(u);\n        c > 1 ? this.dataRefCount.set(u, c - 1) : (this.dataRefCount.delete(u), null != n && (this.numBytesInGPU -= this.computeBytes(o, r), this.textureManager.releaseTexture(n, o, a, i)));\n        var l = this.texData.get(t);\n        l.texture = null, l.texShape = null, l.isPacked = !1, l.slice = null;\n    }, o.prototype.getTexture = function(t) {\n        return this.uploadToGPU(t), this.texData.get(t).texture;\n    }, o.prototype.getDataInfo = function(t) {\n        return this.texData.get(t);\n    }, o.prototype.getCPUBackend = function() {\n        return i().getBool(\"WEBGL_CPU_FORWARD\") ? (null == this.cpuBackend && (this.cpuBackend = Lt.findBackend(\"cpu\")), this.cpuBackend) : null;\n    }, o.prototype.shouldExecuteOnCPU = function(t, e) {\n        var n = this;\n        return void 0 === e && (e = 128), null != this.getCPUBackend() && t.every(function(t) {\n            return null == n.texData.get(t.dataId).texture && t.size < e;\n        });\n    }, o.prototype.getGPGPUContext = function() {\n        return this.gpgpu;\n    }, o.prototype.complex = function(t, e) {\n        var n = this.makeOutput(t.shape, \"complex64\");\n        return this.texData.get(n.dataId).complexTensors = {\n            real: Lt.keep(t.clone()),\n            imag: Lt.keep(e.clone())\n        }, n;\n    }, o.prototype.real = function(t) {\n        return this.texData.get(t.dataId).complexTensors.real.clone();\n    }, o.prototype.imag = function(t) {\n        return this.texData.get(t.dataId).complexTensors.imag.clone();\n    }, o.prototype.slice = function(t, e, n) {\n        if (this.shouldExecuteOnCPU([\n            t\n        ])) return this.cpuBackend.slice(t, e, n);\n        if (0 === k(n)) return Fn([], n, t.dtype);\n        var r = this.texData.get(t.dataId).isPacked, o = io(t.shape, e, n);\n        if (r || !o) {\n            var a = i().getBool(\"WEBGL_PACK_ARRAY_OPERATIONS\") ? new fs(n) : new ls(n), s = a.getCustomSetupFunc(e);\n            return this.compileAndRun(a, [\n                t\n            ], null, s);\n        }\n        return this.uploadToGPU(t.dataId), this.shallowSlice(t, e, n);\n    }, o.prototype.shallowSlice = function(t, e, n) {\n        var r = this.texData.get(t.dataId), o = this.makeOutput(n, t.dtype), a = this.texData.get(o.dataId);\n        Object.assign(a, r), a.shape = n, a.dtype = t.dtype;\n        var i = so(e, t.strides);\n        r.slice && (i += r.slice.flatOffset), a.slice = {\n            flatOffset: i,\n            origDataId: r.slice && r.slice.origDataId || t.dataId\n        };\n        var s = this.dataRefCount.get(a.slice.origDataId) || 1;\n        return this.dataRefCount.set(a.slice.origDataId, s + 1), o;\n    }, o.prototype.stridedSlice = function(t, e, n, r) {\n        if (this.shouldExecuteOnCPU([\n            t\n        ])) return this.cpuBackend.stridedSlice(t, e, n, r);\n        var o = ro(e, n, r);\n        if (o.some(function(t) {\n            return 0 === t;\n        })) return Fn([], o);\n        var a = new ds(e, r, o);\n        return this.compileAndRun(a, [\n            t\n        ]);\n    }, o.prototype.reverse = function(t, e) {\n        var n = i().getBool(\"WEBGL_PACK_ARRAY_OPERATIONS\") ? new is(t.shape, e) : new as(t.shape, e);\n        return this.compileAndRun(n, [\n            t\n        ]);\n    }, o.prototype.concat = function(t, e) {\n        if (\"complex64\" === t[0].dtype) {\n            var n = t.map(function(t) {\n                return Tn(t);\n            }), r = t.map(function(t) {\n                return Nn(t);\n            });\n            return Dn(this.concat(n, e), this.concat(r, e));\n        }\n        if (this.shouldExecuteOnCPU(t)) return this.cpuBackend.concat(t, e);\n        if (1 === t.length) return t[0];\n        if (t.length > i().getNumber(\"WEBGL_MAX_TEXTURES_IN_SHADER\")) {\n            var o = Math.floor(t.length / 2), a = this.concat(t.slice(0, o), e), s = this.concat(t.slice(o), e);\n            return this.concat([\n                a,\n                s\n            ], e);\n        }\n        if (i().getBool(\"WEBGL_PACK_ARRAY_OPERATIONS\") && t[0].rank > 1) {\n            var u = new Ga(t.map(function(t) {\n                return t.shape;\n            }), e);\n            return this.compileAndRun(u, t);\n        }\n        var c = Sn(t.map(function(t) {\n            return t.shape;\n        }), e), l = t.map(function(t) {\n            return t.as2D(-1, k(t.shape.slice(e)));\n        }), h = new za(l.map(function(t) {\n            return t.shape;\n        }));\n        return this.compileAndRun(h, l).reshape(c);\n    }, o.prototype.neg = function(t) {\n        if (this.shouldExecuteOnCPU([\n            t\n        ])) return this.cpuBackend.neg(t);\n        if (i().getBool(\"WEBGL_PACK_UNARY_OPERATIONS\")) return this.packedUnaryOp(t, Ts, t.dtype);\n        var e = new Cs(t.shape, Ts);\n        return this.compileAndRun(e, [\n            t\n        ]);\n    }, o.prototype.batchMatMul = function(t, e, n, r) {\n        var o = n ? t.shape[2] : t.shape[1], a = r ? e.shape[1] : e.shape[2], i = n ? t.shape[1] : t.shape[2], s = t.shape[0];\n        if ((1 === o || 1 === a) && i > 1e3) {\n            n && (t = t.transpose([\n                0,\n                2,\n                1\n            ])), r && (e = e.transpose([\n                0,\n                2,\n                1\n            ]));\n            var u = 1 === a ? t : t.as3D(s, i, 1), c = 1 === a ? 2 : 1, l = 1 === a ? e.as3D(s, 1, i) : e;\n            return this.multiply(u, l).sum(c, !0);\n        }\n        var h = Dt(t.dtype, e.dtype), f = new Hi(t.shape, [\n            s,\n            o,\n            a\n        ], n, r);\n        return this.compileAndRun(f, [\n            t,\n            e\n        ], h);\n    }, o.prototype.fusedBatchMatMul = function(t) {\n        var e = t.a, n = t.b, r = t.transposeA, o = t.transposeB, a = t.bias, i = t.activation, s = t.preluActivationWeights, u = r ? e.shape[2] : e.shape[1], c = o ? n.shape[1] : n.shape[2], l = e.shape[0], h = Dt(e.dtype, n.dtype), f = null != a, d = null != s, p = i ? Qs(i, !0) : null, v = new Hi(e.shape, [\n            l,\n            u,\n            c\n        ], r, o, f, p, d), m = [\n            e,\n            n\n        ];\n        return a && m.push(a), s && m.push(s), this.compileAndRun(v, m, h);\n    }, o.prototype.multiply = function(t, e) {\n        if (\"complex64\" === t.dtype) {\n            var n = this.texData.get(t.dataId), r = this.texData.get(e.dataId), o = new Na(Da, t.shape, e.shape), a = new Na(Ta, t.shape, e.shape), s = [\n                this.makeComplexComponentTensorInfo(t, n.complexTensors.real),\n                this.makeComplexComponentTensorInfo(t, n.complexTensors.imag),\n                this.makeComplexComponentTensorInfo(e, r.complexTensors.real),\n                this.makeComplexComponentTensorInfo(e, r.complexTensors.imag)\n            ], u = this.compileAndRun(o, s), c = this.compileAndRun(a, s), l = this.complex(u, c);\n            return u.dispose(), c.dispose(), l;\n        }\n        if (this.shouldExecuteOnCPU([\n            t,\n            e\n        ])) return this.cpuBackend.multiply(t, e);\n        if (i().getBool(\"WEBGL_PACK_BINARY_OPERATIONS\")) return this.packedBinaryOp(t, e, Oa, t.dtype);\n        var h = new Ba(Oa, t.shape, e.shape);\n        return this.compileAndRun(h, [\n            t,\n            e\n        ], t.dtype);\n    }, o.prototype.batchNormalization = function(t, e, n, r, o, a) {\n        var s = [\n            t,\n            e,\n            n\n        ], u = null;\n        null != a && (u = a.shape, s.push(a));\n        var c = null;\n        if (null != o && (c = o.shape, s.push(o)), i().getBool(\"WEBGL_PACK_NORMALIZATION\")) {\n            var l = new Aa(t.shape, e.shape, n.shape, u, c, r);\n            return this.compileAndRun(l, s);\n        }\n        var h = new Sa(t.shape, e.shape, n.shape, u, c, r);\n        return this.compileAndRun(h, s);\n    }, o.prototype.localResponseNormalization4D = function(t, e, n, r, o) {\n        var a = i().getBool(\"WEBGL_PACK_NORMALIZATION\") ? new Vi(t.shape, e, n, r, o) : new Wi(t.shape, e, n, r, o);\n        return this.compileAndRun(a, [\n            t\n        ]);\n    }, o.prototype.LRNGrad = function(t, e, n, r, o, a, i) {\n        var s = new Ui(e.shape, r, o, a, i);\n        return this.compileAndRun(s, [\n            e,\n            n,\n            t\n        ]);\n    }, o.prototype.tile = function(t, e) {\n        if (\"string\" === t.dtype) {\n            var n = this.readSync(t.dataId).map(function(t) {\n                return ot(t);\n            });\n            return ta(dr(t.shape, t.dtype, n), e);\n        }\n        var r = new gs(t.shape, e);\n        return this.compileAndRun(r, [\n            t\n        ]);\n    }, o.prototype.pad = function(t, e, n) {\n        var r = i().getBool(\"WEBGL_PACK_ARRAY_OPERATIONS\") ? new Yi(t.shape, e, n) : new Xi(t.shape, e, n);\n        return this.compileAndRun(r, [\n            t\n        ]);\n    }, o.prototype.transpose = function(t, e) {\n        if (this.shouldExecuteOnCPU([\n            t\n        ])) return this.cpuBackend.transpose(t, e);\n        var n = i().getBool(\"WEBGL_PACK_ARRAY_OPERATIONS\") ? new xs(t.shape, e) : new ys(t.shape, e);\n        return this.compileAndRun(n, [\n            t\n        ]);\n    }, o.prototype.gather = function(t, e, n) {\n        if (this.shouldExecuteOnCPU([\n            t,\n            e\n        ])) return this.cpuBackend.gather(t, e, n);\n        var r = new mi(t.shape, e.size, n);\n        return this.compileAndRun(r, [\n            t,\n            e\n        ]);\n    }, o.prototype.batchToSpaceND = function(t, e, n) {\n        C(t.rank <= 4, function() {\n            return \"batchToSpaceND for rank > 4 with a WebGL backend not implemented yet\";\n        });\n        var r = e.reduce(function(t, e) {\n            return t * e;\n        }), o = zr(t.shape, e, r), a = Gr(o.length, e.length), i = Hr(t.shape, e, r), s = qr(n, e.length), u = Kr(i, n, e.length);\n        return t.reshape(o).transpose(a).reshape(i).slice(s, u);\n    }, o.prototype.spaceToBatchND = function(t, e, n) {\n        C(t.rank <= 4, function() {\n            return \"spaceToBatchND for rank > 4 with a WebGL backend not implemented yet\";\n        });\n        var r = e.reduce(function(t, e) {\n            return t * e;\n        }), o = [\n            [\n                0,\n                0\n            ]\n        ];\n        o.push.apply(o, n);\n        for(var a = 1 + e.length; a < t.shape.length; ++a)o.push([\n            0,\n            0\n        ]);\n        var i = t.pad(o), s = zr(i.shape, e, r, !1), u = Gr(s.length, e.length, !1), c = Hr(i.shape, e, r, !1);\n        return i.reshape(s).transpose(u).reshape(c);\n    }, o.prototype.reduce = function(t, e, n) {\n        var r = t.shape[0], o = t.shape[1], a = $r(o), i = new Ji({\n            windowSize: a,\n            inSize: o,\n            batchSize: r\n        }, e), s = this.compileAndRun(i, [\n            t\n        ], n);\n        return 1 === s.shape[1] ? s : this.reduce(s, e, n);\n    }, o.prototype.argReduce = function(t, e, n) {\n        void 0 === n && (n = null);\n        var r = t.shape[0], o = t.shape[1];\n        null != n && (r = n.shape[0], o = n.shape[1]);\n        var a = $r(o), i = new aa({\n            windowSize: a,\n            inSize: o,\n            batchSize: r\n        }, e, null == n), s = [\n            t\n        ];\n        null != n && s.push(n);\n        var u = this.compileAndRun(i, s, \"int32\");\n        return 1 === u.shape[1] ? u : this.argReduce(t, e, u);\n    }, o.prototype.argReducePacked = function(t, e, n) {\n        void 0 === n && (n = null);\n        var r = null != n ? n.shape : t.shape, o = $r(r[r.length - 1]), a = new Ra(r, o, e, null == n), i = null == n ? [\n            t\n        ] : [\n            t,\n            n\n        ], s = this.compileAndRun(a, i, \"int32\");\n        return s.rank === t.rank ? this.argReducePacked(t, e, s) : s;\n    }, o.prototype.sum = function(t, e) {\n        Cn(\"sum\", e, t.rank);\n        var n = bn(t.shape, e), r = n[0], o = k(n[1]), a = t.as2D(-1, o), i = Tt(t.dtype);\n        return this.reduce(a, \"sum\", i).reshape(r);\n    }, o.prototype.prod = function(t, e) {\n        if (this.shouldExecuteOnCPU([\n            t\n        ])) return this.cpuBackend.prod(t, e);\n        var n = bn(t.shape, e), r = n[0], o = k(n[1]), a = t.as2D(-1, o), i = Tt(t.dtype);\n        return this.reduce(a, \"prod\", i).reshape(r);\n    }, o.prototype.unsortedSegmentSum = function(t, e, n) {\n        var r = 0, o = En([\n            r\n        ], t.rank), a = t;\n        null != o && (a = t.transpose(o), r = In(1, t.rank)[0]);\n        var i = function(t, e, n) {\n            for(var r = [], o = t.length, a = 0; a < o; a++)a !== e ? r.push(t[a]) : r.push(n);\n            return r;\n        }(a.shape, r, n), s = k([\n            a.shape[r]\n        ]), u = a.as2D(-1, s), c = Tt(t.dtype), l = this.segOpCompute(u, \"unsortedSegmentSum\", e, c, n).reshape(i);\n        return null != o && (l = l.transpose(Rn(o))), l;\n    }, o.prototype.segOpCompute = function(t, e, n, r, o) {\n        var a = t.shape[0], i = t.shape[1], s = function(t, e) {\n            var n, r = !1;\n            for(t <= Yr ? (n = t, r = !0) : n = Y(t, Math.floor(Math.sqrt(t))); !r;)n > e || n === t ? r = !0 : n = Y(t, n + 1);\n            return n;\n        }(i, o), u = new us({\n            windowSize: s,\n            inSize: i,\n            batchSize: a,\n            numSegments: o\n        }, e), c = this.compileAndRun(u, [\n            t,\n            n\n        ], r);\n        return c.shape[1] === o ? c : (n = Kn(0, o).tile([\n            i / s\n        ]), this.segOpCompute(c, e, n, r, o));\n    }, o.prototype.argMinMaxReduce = function(t, e, n) {\n        var r = [\n            e\n        ];\n        if (Cn(\"arg\" + n.charAt(0).toUpperCase() + n.slice(1), r, t.rank), !i().getBool(\"WEBGL_PACK_REDUCE\") || t.rank <= 2) {\n            var o = bn(t.shape, r), a = o[0], s = k(o[1]), u = t.as2D(-1, s);\n            return this.argReduce(u, n).reshape(a);\n        }\n        return this.argReducePacked(t, n);\n    }, o.prototype.argMin = function(t, e) {\n        return this.argMinMaxReduce(t, e, \"min\");\n    }, o.prototype.argMax = function(t, e) {\n        return this.argMinMaxReduce(t, e, \"max\");\n    }, o.prototype.cumsum = function(t, e, n, r) {\n        if (e !== t.rank - 1) throw new Error(\"WebGL cumsum shader expects an inner-most axis=\" + (t.rank - 1) + \" but got axis=\" + e);\n        var o = new ni(t.shape, n, r);\n        return this.compileAndRun(o, [\n            t\n        ]);\n    }, o.prototype.equal = function(t, e) {\n        if (i().getBool(\"WEBGL_PACK_BINARY_OPERATIONS\")) return this.packedBinaryOp(t, e, \"\\n  return vec4(equal(a, b));\\n\", \"bool\");\n        var n = new Ba(\"return float(a == b);\", t.shape, e.shape);\n        return this.compileAndRun(n, [\n            t,\n            e\n        ], \"bool\");\n    }, o.prototype.notEqual = function(t, e) {\n        if (i().getBool(\"WEBGL_PACK_BINARY_OPERATIONS\")) return this.packedBinaryOp(t, e, \"\\n  return vec4(notEqual(a, b));\\n\", \"bool\");\n        var n = new Ba(\"return float(a != b);\", t.shape, e.shape);\n        return this.compileAndRun(n, [\n            t,\n            e\n        ], \"bool\");\n    }, o.prototype.less = function(t, e) {\n        if (this.shouldExecuteOnCPU([\n            t,\n            e\n        ])) return this.cpuBackend.less(t, e);\n        if (i().getBool(\"WEBGL_PACK_BINARY_OPERATIONS\")) return this.packedBinaryOp(t, e, \"\\n  return vec4(lessThan(a, b));\\n\", \"bool\");\n        var n = new Ba(\"return float(a < b);\", t.shape, e.shape);\n        return this.compileAndRun(n, [\n            t,\n            e\n        ], \"bool\");\n    }, o.prototype.lessEqual = function(t, e) {\n        if (i().getBool(\"WEBGL_PACK_BINARY_OPERATIONS\")) return this.packedBinaryOp(t, e, \"\\n  return vec4(lessThanEqual(a, b));\\n\", \"bool\");\n        var n = new Ba(\"return float(a <= b);\", t.shape, e.shape);\n        return this.compileAndRun(n, [\n            t,\n            e\n        ], \"bool\");\n    }, o.prototype.greater = function(t, e) {\n        if (this.shouldExecuteOnCPU([\n            t,\n            e\n        ])) return this.cpuBackend.greater(t, e);\n        if (i().getBool(\"WEBGL_PACK_BINARY_OPERATIONS\")) return this.packedBinaryOp(t, e, \"\\n  return vec4(greaterThan(a, b));\\n\", \"bool\");\n        var n = new Ba(\"return float(a > b);\", t.shape, e.shape);\n        return this.compileAndRun(n, [\n            t,\n            e\n        ], \"bool\");\n    }, o.prototype.greaterEqual = function(t, e) {\n        if (i().getBool(\"WEBGL_PACK_BINARY_OPERATIONS\")) return this.packedBinaryOp(t, e, \"\\n  return vec4(greaterThanEqual(a, b));\\n\", \"bool\");\n        var n = new Ba(\"return float(a >= b);\", t.shape, e.shape);\n        return this.compileAndRun(n, [\n            t,\n            e\n        ], \"bool\");\n    }, o.prototype.logicalNot = function(t) {\n        var e = new Cs(t.shape, \"return float(!(x >= 1.0));\");\n        return this.compileAndRun(e, [\n            t\n        ]);\n    }, o.prototype.logicalAnd = function(t, e) {\n        if (i().getBool(\"WEBGL_PACK_BINARY_OPERATIONS\")) return this.packedBinaryOp(t, e, \"\\n  return vec4(\\n    vec4(greaterThanEqual(a, vec4(1.0))) *\\n    vec4(greaterThanEqual(b, vec4(1.0))));\\n\", \"bool\");\n        var n = new Ba(\"return float(a >= 1.0 && b >= 1.0);\", t.shape, e.shape);\n        return this.compileAndRun(n, [\n            t,\n            e\n        ], \"bool\");\n    }, o.prototype.logicalOr = function(t, e) {\n        if (i().getBool(\"WEBGL_PACK_BINARY_OPERATIONS\")) return this.packedBinaryOp(t, e, \"\\n  return min(\\n    vec4(greaterThanEqual(a, vec4(1.0))) +\\n    vec4(greaterThanEqual(b, vec4(1.0))),\\n    vec4(1.0));\\n\", \"bool\");\n        var n = new Ba(\"return float(a >= 1.0 || b >= 1.0);\", t.shape, e.shape);\n        return this.compileAndRun(n, [\n            t,\n            e\n        ], \"bool\");\n    }, o.prototype.select = function(t, e, n) {\n        var r = new cs(t.rank, e.shape, e.rank);\n        return this.compileAndRun(r, [\n            t,\n            e,\n            n\n        ], Dt(e.dtype, n.dtype));\n    }, o.prototype.where = function(t) {\n        dn(\"tf.where() in webgl locks the UI thread. Call tf.whereAsync() instead\");\n        var e = t.dataSync();\n        return na(t.shape, e);\n    }, o.prototype.topk = function(t, e, n) {\n        return ea(t.dataSync(), t.shape, t.dtype, e);\n    }, o.prototype.min = function(t, e) {\n        Cn(\"min\", e, t.rank);\n        var n = bn(t.shape, e), r = n[0], o = k(n[1]), a = t.as2D(-1, o);\n        return this.reduce(a, \"min\", a.dtype).reshape(r);\n    }, o.prototype.minimum = function(t, e) {\n        if (this.shouldExecuteOnCPU([\n            t,\n            e\n        ])) return this.cpuBackend.minimum(t, e);\n        var n = i().getBool(\"WEBGL_PACK_BINARY_OPERATIONS\") ? new La(\"\\n  vec4 result = vec4(min(a, b));\\n  vec4 isNaN = min(vec4(isnan(a)) + vec4(isnan(b)), vec4(1.0));\\n  \\n  result.r = isNaN.r > 0. ? NAN : result.r;\\n  result.g = isNaN.g > 0. ? NAN : result.g;\\n  result.b = isNaN.b > 0. ? NAN : result.b;\\n  result.a = isNaN.a > 0. ? NAN : result.a;\\n\\n  return result;\\n\", t.shape, e.shape) : new Ba(\"\\n  if (isnan(a)) return a;\\n  if (isnan(b)) return b;\\n\\n  return min(a, b);\\n\", t.shape, e.shape);\n        return this.compileAndRun(n, [\n            t,\n            e\n        ]);\n    }, o.prototype.mod = function(t, e) {\n        var n = i().getBool(\"WEBGL_PACK_BINARY_OPERATIONS\") ? new La(\"\\n  vec4 result = mod(a, b);\\n  vec4 isNaN = vec4(equal(b, vec4(0.0)));\\n  \\n  result.r = isNaN.r > 0. ? NAN : result.r;\\n  result.g = isNaN.g > 0. ? NAN : result.g;\\n  result.b = isNaN.b > 0. ? NAN : result.b;\\n  result.a = isNaN.a > 0. ? NAN : result.a;\\n\\n  return result;\\n\", t.shape, e.shape) : new Ba(\"if (b == 0.0) return NAN;\\n  return mod(a, b);\", t.shape, e.shape);\n        return this.compileAndRun(n, [\n            t,\n            e\n        ]);\n    }, o.prototype.max = function(t, e) {\n        if (this.shouldExecuteOnCPU([\n            t\n        ])) return this.cpuBackend.max(t, e);\n        Cn(\"max\", e, t.rank);\n        var n = bn(t.shape, e), r = n[0], o = k(n[1]), a = t.as2D(-1, o);\n        return this.reduce(a, \"max\", a.dtype).reshape(r);\n    }, o.prototype.maximum = function(t, e) {\n        if (this.shouldExecuteOnCPU([\n            t,\n            e\n        ])) return this.cpuBackend.maximum(t, e);\n        var n = i().getBool(\"WEBGL_PACK_BINARY_OPERATIONS\") ? new La(\"\\n  vec4 result = vec4(max(a, b));\\n  vec4 isNaN = min(vec4(isnan(a)) + vec4(isnan(b)), vec4(1.0));\\n  \\n  result.r = isNaN.r > 0. ? NAN : result.r;\\n  result.g = isNaN.g > 0. ? NAN : result.g;\\n  result.b = isNaN.b > 0. ? NAN : result.b;\\n  result.a = isNaN.a > 0. ? NAN : result.a;\\n\\n  return result;\\n\", t.shape, e.shape) : new Ba(\"\\n  if (isnan(a)) return a;\\n  if (isnan(b)) return b;\\n\\n  return max(a, b);\\n\", t.shape, e.shape);\n        return this.compileAndRun(n, [\n            t,\n            e\n        ]);\n    }, o.prototype.all = function(t, e) {\n        Cn(\"all\", e, t.rank);\n        var n = bn(t.shape, e), r = n[0], o = k(n[1]), a = t.as2D(-1, o);\n        return this.reduce(a, \"all\", a.dtype).reshape(r);\n    }, o.prototype.any = function(t, e) {\n        Cn(\"any\", e, t.rank);\n        var n = bn(t.shape, e), r = n[0], o = k(n[1]), a = t.as2D(-1, o);\n        return this.reduce(a, \"any\", a.dtype).reshape(r);\n    }, o.prototype.realDivide = function(t, e) {\n        if (i().getBool(\"WEBGL_PACK_BINARY_OPERATIONS\")) {\n            return this.packedBinaryOp(t, e, \"\\n  // vec4 one = vec4(equal(a, b));\\n  // return one + (vec4(1.0) - one) * a / b;\\n  vec4 result = a / b;\\n  if(a.x == b.x) {\\n    result.x = 1.;\\n  }\\n  if(a.y == b.y) {\\n    result.y = 1.;\\n  }\\n  if(a.z == b.z) {\\n    result.z = 1.;\\n  }\\n  if(a.w == b.w) {\\n    result.w = 1.;\\n  }\\n\\n  return result;\\n\", \"float32\", !0);\n        }\n        var n = new Ba(\"\\nif (a == b) {\\n  return 1.0;\\n};\\nreturn a / b;\", t.shape, e.shape);\n        return this.compileAndRun(n, [\n            t,\n            e\n        ], \"float32\");\n    }, o.prototype.floorDiv = function(t, e) {\n        if (i().getBool(\"WEBGL_PACK_BINARY_OPERATIONS\")) return this.packedBinaryOp(t, e, \"\\n  ivec4 ia = round(a);\\n  ivec4 ib = round(b);\\n  bvec4 cond = notEqual(ib, ivec4(0));\\n  ivec4 result = ivec4(0);\\n  vec4 s = sign(a) * sign(b);\\n\\n  // Windows (D3D) wants guaranteed non-zero int division at compile-time.\\n  if (cond[0]) {\\n    result[0] = idiv(ia[0], ib[0], s[0]);\\n  }\\n  if (cond[1]) {\\n    result[1] = idiv(ia[1], ib[1], s[1]);\\n  }\\n  if (cond[2]) {\\n    result[2] = idiv(ia[2], ib[2], s[2]);\\n  }\\n  if (cond[3]) {\\n    result[3] = idiv(ia[3], ib[3], s[3]);\\n  }\\n  return vec4(result);\\n\", \"int32\");\n        var n = new Ba(\"\\n  float s = sign(a) * sign(b);\\n  int ia = round(a);\\n  int ib = round(b);\\n  if (ib != 0) {\\n    // Windows (D3D) wants guaranteed non-zero int division at compile-time.\\n    return float(idiv(ia, ib, s));\\n  } else {\\n    return NAN;\\n  }\\n\", t.shape, e.shape);\n        return this.compileAndRun(n, [\n            t,\n            e\n        ], \"int32\");\n    }, o.prototype.add = function(t, e) {\n        if (\"complex64\" === t.dtype && \"complex64\" === e.dtype) return this.complexSeparableBinaryOp(t, e, Fa);\n        if (this.shouldExecuteOnCPU([\n            t,\n            e\n        ])) return this.cpuBackend.add(t, e);\n        var n = Dt(t.dtype, e.dtype);\n        if (i().getBool(\"WEBGL_PACK_BINARY_OPERATIONS\")) return this.packedBinaryOp(t, e, Fa, n);\n        var r = new Ba(Fa, t.shape, e.shape);\n        return this.compileAndRun(r, [\n            t,\n            e\n        ], n);\n    }, o.prototype.packedUnaryOp = function(t, e, n) {\n        var r = new Xs(t.shape, e);\n        return this.compileAndRun(r, [\n            t\n        ], n);\n    }, o.prototype.packedBinaryOp = function(t, e, n, r, o) {\n        void 0 === o && (o = !1);\n        var a = new La(n, t.shape, e.shape, o);\n        return this.compileAndRun(a, [\n            t,\n            e\n        ], r);\n    }, o.prototype.complexSeparableBinaryOp = function(t, e, n) {\n        var r = this, o = this.texData.get(t.dataId), a = this.texData.get(e.dataId), i = [\n            [\n                o.complexTensors.real,\n                a.complexTensors.real\n            ],\n            [\n                o.complexTensors.imag,\n                a.complexTensors.imag\n            ]\n        ].map(function(o) {\n            var a = o[0], i = o[1], s = r.makeComplexComponentTensorInfo(t, a), u = r.makeComplexComponentTensorInfo(e, i), c = new Ba(n, t.shape, e.shape);\n            return r.compileAndRun(c, [\n                s,\n                u\n            ], Dt(a.dtype, i.dtype));\n        }), s = i[0], u = i[1], c = this.complex(s, u);\n        return s.dispose(), u.dispose(), c;\n    }, o.prototype.makeComplexComponentTensorInfo = function(t, e) {\n        return {\n            dataId: e.dataId,\n            dtype: e.dtype,\n            shape: t.shape\n        };\n    }, o.prototype.addN = function(t) {\n        if (1 === t.length) return t[0];\n        if (t.length > i().get(\"WEBGL_MAX_TEXTURES_IN_SHADER\")) {\n            var e = Math.floor(t.length / 2), n = this.addN(t.slice(0, e)), r = this.addN(t.slice(e));\n            return this.addN([\n                n,\n                r\n            ]);\n        }\n        var o = t.map(function(t) {\n            return t.dtype;\n        }).reduce(function(t, e) {\n            return Dt(t, e);\n        }), a = t.map(function(t) {\n            return t.shape;\n        }), s = i().getBool(\"WEBGL_PACK\") ? new oa(t[0].shape, a) : new ra(t[0].shape, a);\n        return this.compileAndRun(s, t, o);\n    }, o.prototype.subtract = function(t, e) {\n        if (\"complex64\" === t.dtype && \"complex64\" === e.dtype) return this.complexSeparableBinaryOp(t, e, _a);\n        if (this.shouldExecuteOnCPU([\n            t,\n            e\n        ])) return this.cpuBackend.subtract(t, e);\n        var n = Dt(t.dtype, e.dtype);\n        if (i().getBool(\"WEBGL_PACK_BINARY_OPERATIONS\")) return this.packedBinaryOp(t, e, _a, t.dtype);\n        var r = new Ba(_a, t.shape, e.shape);\n        return this.compileAndRun(r, [\n            t,\n            e\n        ], n);\n    }, o.prototype.pow = function(t, e) {\n        var n = i().getBool(\"WEBGL_PACK_BINARY_OPERATIONS\") ? new La(\"\\n  // isModRound1 has 1 for components with round(mod(b, 2.0)) == 1, 0 otherwise.\\n  vec4 isModRound1 = vec4(equal(round(mod(b, 2.0)), ivec4(1)));\\n  vec4 multiplier = sign(a) * isModRound1 + (vec4(1.0) - isModRound1);\\n  vec4 result = multiplier * pow(abs(a), b);\\n\\n  // Ensure that a^0 = 1, including 0^0 = 1 as this correspond to TF and JS\\n  bvec4 isExpZero = equal(b, vec4(0.0));\\n  result.r = isExpZero.r ? 1.0 : result.r;\\n  result.g = isExpZero.g ? 1.0 : result.g;\\n  result.b = isExpZero.b ? 1.0 : result.b;\\n  result.a = isExpZero.a ? 1.0 : result.a;\\n\\n  vec4 isNaN = vec4(lessThan(a, vec4(0.0))) * vec4(lessThan(floor(b), b));\\n  \\n  result.r = isNaN.r > 0. ? NAN : result.r;\\n  result.g = isNaN.g > 0. ? NAN : result.g;\\n  result.b = isNaN.b > 0. ? NAN : result.b;\\n  result.a = isNaN.a > 0. ? NAN : result.a;\\n\\n  return result;\\n\", t.shape, e.shape) : new Ba(\"\\nif(a < 0.0 && floor(b) < b){\\n  return NAN;\\n}\\nif (b == 0.0) {\\n  return 1.0;\\n}\\nreturn (round(mod(b, 2.0)) != 1) ?\\n    pow(abs(a), b) : sign(a) * pow(abs(a), b);\\n\", t.shape, e.shape), r = Dt(t.dtype, e.dtype);\n        return this.compileAndRun(n, [\n            t,\n            e\n        ], r);\n    }, o.prototype.ceil = function(t) {\n        if (this.shouldExecuteOnCPU([\n            t\n        ])) return this.cpuBackend.ceil(t);\n        if (i().getBool(\"WEBGL_PACK_UNARY_OPERATIONS\")) return this.packedUnaryOp(t, Ns, t.dtype);\n        var e = new Cs(t.shape, Ns);\n        return this.compileAndRun(e, [\n            t\n        ]);\n    }, o.prototype.floor = function(t) {\n        if (this.shouldExecuteOnCPU([\n            t\n        ])) return this.cpuBackend.floor(t);\n        if (i().getBool(\"WEBGL_PACK_UNARY_OPERATIONS\")) return this.packedUnaryOp(t, Fs, t.dtype);\n        var e = new Cs(t.shape, Fs);\n        return this.compileAndRun(e, [\n            t\n        ]);\n    }, o.prototype.sign = function(t) {\n        var e = new Cs(t.shape, \"\\n  if (isnan(x)) { return 0.0; }\\n  return sign(x);\\n\");\n        return this.compileAndRun(e, [\n            t\n        ]);\n    }, o.prototype.isNaN = function(t) {\n        var e = new Cs(t.shape, \"return float(isnan(x));\");\n        return this.compileAndRun(e, [\n            t\n        ], \"bool\");\n    }, o.prototype.isInf = function(t) {\n        var e = new Cs(t.shape, \"return float(isinf(x));\");\n        return this.compileAndRun(e, [\n            t\n        ], \"bool\");\n    }, o.prototype.isFinite = function(t) {\n        var e = new Cs(t.shape, \"return float(!isnan(x) && !isinf(x));\");\n        return this.compileAndRun(e, [\n            t\n        ], \"bool\");\n    }, o.prototype.round = function(t) {\n        var e = new Cs(t.shape, \"\\n  // OpenGL ES does not support round function.\\n  // The algorithm is based on banker's rounding.\\n  float base = floor(x);\\n  if ((x - base) < 0.5) {\\n    return floor(x);\\n  } else if ((x - base) > 0.5) {\\n    return ceil(x);\\n  } else {\\n    if (mod(base, 2.0) == 0.0) {\\n      return base;\\n    } else {\\n      return base + 1.0;\\n    }\\n  }\\n\");\n        return this.compileAndRun(e, [\n            t\n        ]);\n    }, o.prototype.exp = function(t) {\n        if (this.shouldExecuteOnCPU([\n            t\n        ])) return this.cpuBackend.exp(t);\n        if (i().getBool(\"WEBGL_PACK_UNARY_OPERATIONS\")) return this.packedUnaryOp(t, _s, t.dtype);\n        var e = new Cs(t.shape, _s);\n        return this.compileAndRun(e, [\n            t\n        ]);\n    }, o.prototype.expm1 = function(t) {\n        if (this.shouldExecuteOnCPU([\n            t\n        ])) return this.cpuBackend.expm1(t);\n        if (i().getBool(\"WEBGL_PACK_UNARY_OPERATIONS\")) return this.packedUnaryOp(t, Os, t.dtype);\n        var e = new Cs(t.shape, Os);\n        return this.compileAndRun(e, [\n            t\n        ]);\n    }, o.prototype.softmax = function(t, e) {\n        var n = O([\n            e\n        ], t.shape), r = this.max(t, n), o = wn(r.shape, n), a = this.subtract(t, r.reshape(o)), i = this.exp(a), s = this.sum(i, n).reshape(o);\n        return this.realDivide(i, s);\n    }, o.prototype.log = function(t) {\n        if (this.shouldExecuteOnCPU([\n            t\n        ])) return this.cpuBackend.log(t);\n        if (i().getBool(\"WEBGL_PACK_UNARY_OPERATIONS\")) return this.packedUnaryOp(t, \"\\n  vec4 result = log(x);\\n  vec4 isNaN = vec4(lessThan(x, vec4(0.0)));\\n  result.r = isNaN.r == 1.0 ? NAN : result.r;\\n  result.g = isNaN.g == 1.0 ? NAN : result.g;\\n  result.b = isNaN.b == 1.0 ? NAN : result.b;\\n  result.a = isNaN.a == 1.0 ? NAN : result.a;\\n\\n  return result;\\n\", t.dtype);\n        var e = new Cs(t.shape, \"if (x < 0.0) return NAN;\\n  return log(x);\");\n        return this.compileAndRun(e, [\n            t\n        ]);\n    }, o.prototype.log1p = function(t) {\n        var e = new Cs(t.shape, \"return log(1.0 + x);\");\n        return this.compileAndRun(e, [\n            t\n        ]);\n    }, o.prototype.sqrt = function(t) {\n        var e = new Cs(t.shape, \"return sqrt(x);\");\n        return this.compileAndRun(e, [\n            t\n        ]);\n    }, o.prototype.rsqrt = function(t) {\n        if (this.shouldExecuteOnCPU([\n            t\n        ])) return this.cpuBackend.rsqrt(t);\n        var e = new Cs(t.shape, \"return inversesqrt(x);\");\n        return this.compileAndRun(e, [\n            t\n        ]);\n    }, o.prototype.reciprocal = function(t) {\n        var e = new Cs(t.shape, \"return 1.0 / x;\");\n        return this.compileAndRun(e, [\n            t\n        ]);\n    }, o.prototype.relu = function(t) {\n        var e;\n        return e = i().getBool(\"WEBGL_PACK\") ? new Xs(t.shape, qs) : new Cs(t.shape, ks), this.compileAndRun(e, [\n            t\n        ]);\n    }, o.prototype.relu6 = function(t) {\n        var e;\n        return e = i().getBool(\"WEBGL_PACK\") ? new Xs(t.shape, Ks) : new Cs(t.shape, Ss), this.compileAndRun(e, [\n            t\n        ]);\n    }, o.prototype.prelu = function(t, e) {\n        var n = i().getBool(\"WEBGL_PACK_BINARY_OPERATIONS\") ? new La(Pa, t.shape, e.shape) : new Ba(Ma, t.shape, e.shape);\n        return this.compileAndRun(n, [\n            t,\n            e\n        ]);\n    }, o.prototype.elu = function(t) {\n        if (i().getBool(\"WEBGL_PACK_UNARY_OPERATIONS\")) return this.packedUnaryOp(t, js, t.dtype);\n        var e = new Cs(t.shape, As);\n        return this.compileAndRun(e, [\n            t\n        ]);\n    }, o.prototype.eluDer = function(t, e) {\n        var n = i().getBool(\"WEBGL_PACK_BINARY_OPERATIONS\") ? new La(\"\\n  vec4 bGTEZero = vec4(greaterThanEqual(b, vec4(0.)));\\n  return (bGTEZero * a) + ((vec4(1.0) - bGTEZero) * (a * (b + vec4(1.0))));\\n\", t.shape, e.shape) : new Ba(\"return (b >= 1.0) ? a : a * (b + 1.0);\", t.shape, e.shape);\n        return this.compileAndRun(n, [\n            t,\n            e\n        ]);\n    }, o.prototype.selu = function(t) {\n        var e = new Cs(t.shape, Ds);\n        return this.compileAndRun(e, [\n            t\n        ]);\n    }, o.prototype.int = function(t) {\n        var e = new Cs(t.shape, \"return float(int(x));\");\n        return this.compileAndRun(e, [\n            t\n        ], \"int32\");\n    }, o.prototype.clip = function(t, e, n) {\n        var r, o = (r = i().getBool(\"WEBGL_PACK_CLIP\") ? new Ua(t.shape) : new Wa(t.shape)).getCustomSetupFunc(e, n);\n        return this.compileAndRun(r, [\n            t\n        ], null, o);\n    }, o.prototype.abs = function(t) {\n        if (this.shouldExecuteOnCPU([\n            t\n        ])) return this.cpuBackend.abs(t);\n        if (i().getBool(\"WEBGL_PACK_UNARY_OPERATIONS\")) return this.packedUnaryOp(t, Is, t.dtype);\n        var e = new Cs(t.shape, Is);\n        return this.compileAndRun(e, [\n            t\n        ]);\n    }, o.prototype.complexAbs = function(t) {\n        var e = this.texData.get(t.dataId), n = new Va(t.shape), r = [\n            this.makeComplexComponentTensorInfo(t, e.complexTensors.real),\n            this.makeComplexComponentTensorInfo(t, e.complexTensors.imag)\n        ];\n        return this.compileAndRun(n, r);\n    }, o.prototype.sigmoid = function(t) {\n        var e = new Cs(t.shape, \"return 1.0 / (1.0 + exp(-1.0 * x));\");\n        return this.compileAndRun(e, [\n            t\n        ]);\n    }, o.prototype.softplus = function(t) {\n        var e = new Cs(t.shape, \"\\n  float epsilon = 1.1920928955078125e-7;\\n  float threshold = log(epsilon) + 2.0;\\n\\n  bool too_large = x > -threshold;\\n  bool too_small = x < threshold;\\n\\n  float result;\\n  float exp_x = exp(x);\\n\\n  if (too_large){\\n    result = x;\\n  }\\n  else if (too_small){\\n    result = exp_x;\\n  }\\n  else{\\n    result = log(exp_x + 1.0);\\n  }\\n  return result;\\n\");\n        return this.compileAndRun(e, [\n            t\n        ]);\n    }, o.prototype.sin = function(t) {\n        var e = new Cs(t.shape, Ms);\n        return this.compileAndRun(e, [\n            t\n        ]);\n    }, o.prototype.cos = function(t) {\n        var e = new Cs(t.shape, Bs);\n        return this.compileAndRun(e, [\n            t\n        ]);\n    }, o.prototype.tan = function(t) {\n        var e = new Cs(t.shape, \"return tan(x);\");\n        return this.compileAndRun(e, [\n            t\n        ]);\n    }, o.prototype.asin = function(t) {\n        var e = new Cs(t.shape, Ps);\n        return this.compileAndRun(e, [\n            t\n        ]);\n    }, o.prototype.acos = function(t) {\n        var e = new Cs(t.shape, Ls);\n        return this.compileAndRun(e, [\n            t\n        ]);\n    }, o.prototype.atan = function(t) {\n        var e = new Cs(t.shape, Ws);\n        return this.compileAndRun(e, [\n            t\n        ]);\n    }, o.prototype.atan2 = function(t, e) {\n        var n = i().getBool(\"WEBGL_PACK_BINARY_OPERATIONS\") ? new La(\"\\n  vec4 result = atan(a, b);\\n  vec4 isNaN = min(vec4(isnan(a)) + vec4(isnan(b)), vec4(1.0));\\n  \\n  result.r = isNaN.r > 0. ? NAN : result.r;\\n  result.g = isNaN.g > 0. ? NAN : result.g;\\n  result.b = isNaN.b > 0. ? NAN : result.b;\\n  result.a = isNaN.a > 0. ? NAN : result.a;\\n\\n  return result;\\n\", t.shape, e.shape) : new Ba(\"\\n  if (isnan(a)) return a;\\n  if (isnan(b)) return b;\\n\\n  return atan(a, b);\\n\", t.shape, e.shape);\n        return this.compileAndRun(n, [\n            t,\n            e\n        ]);\n    }, o.prototype.sinh = function(t) {\n        var e = new Cs(t.shape, \"\\n  float e2x = exp(x);\\n  return (e2x - 1.0 / e2x) / 2.0;\\n\");\n        return this.compileAndRun(e, [\n            t\n        ]);\n    }, o.prototype.cosh = function(t) {\n        var e = new Cs(t.shape, \"\\n  float e2x = exp(-x);\\n  return (e2x + 1.0 / e2x) / 2.0;\\n\");\n        return this.compileAndRun(e, [\n            t\n        ]);\n    }, o.prototype.tanh = function(t) {\n        var e = new Cs(t.shape, \"\\n  float e2x = exp(-2.0 * abs(x));\\n  return sign(x) * (1.0 - e2x) / (1.0 + e2x);\\n\");\n        return this.compileAndRun(e, [\n            t\n        ]);\n    }, o.prototype.asinh = function(t) {\n        var e = new Cs(t.shape, Us);\n        return this.compileAndRun(e, [\n            t\n        ]);\n    }, o.prototype.acosh = function(t) {\n        var e = new Cs(t.shape, Vs);\n        return this.compileAndRun(e, [\n            t\n        ]);\n    }, o.prototype.atanh = function(t) {\n        var e = new Cs(t.shape, zs);\n        return this.compileAndRun(e, [\n            t\n        ]);\n    }, o.prototype.erf = function(t) {\n        var e = new Cs(t.shape, '\\n  // Error function is calculated approximately with elementary function.\\n  // See \"Handbook of Mathematical Functions with Formulas,\\n  // Graphs, and Mathematical Tables\", Abramowitz and Stegun.\\n  float p = 0.3275911;\\n  float a1 = 0.254829592;\\n  float a2 = -0.284496736;\\n  float a3 = 1.421413741;\\n  float a4 = -1.453152027;\\n  float a5 = 1.061405429;\\n\\n  float sign = sign(x);\\n  x = abs(x);\\n  float t = 1.0 / (1.0 + p * x);\\n  return sign * (1.0 - (((((a5*t + a4)*t) + a3)*t + a2)*t + a1)*t*exp(-x*x));\\n');\n        return this.compileAndRun(e, [\n            t\n        ]);\n    }, o.prototype.step = function(t, e) {\n        var n = new Cs(t.shape, function(t) {\n            return void 0 === t && (t = 0), Es + \"\\n    return x > 0.0 ? 1.0 : float(\" + t + \");\\n  \";\n        }(e));\n        return this.compileAndRun(n, [\n            t\n        ]);\n    }, o.prototype.conv2dByMatMul = function(t, e, n, r, o, a) {\n        var s = t.shape, u = this.texData.get(t.dataId), c = n.inChannels, l = s[0] * s[1] * s[2], h = n.outChannels, f = \"channelsLast\" === n.dataFormat, d = (1 === l || 1 === h) && c > 1e3, p = s[2] % 2 != 0 && !!u.isPacked;\n        if (d || !i().getBool(\"WEBGL_LAZILY_UNPACK\") || !i().getBool(\"WEBGL_PACK_BINARY_OPERATIONS\") || !p) {\n            var v = f ? s[0] * s[1] * s[2] : s[0] * s[2] * s[3], m = this.reshape(t, [\n                1,\n                v,\n                n.inChannels\n            ]), g = this.reshape(e, [\n                1,\n                n.inChannels,\n                n.outChannels\n            ]);\n            return this.reshape(this.fusedBatchMatMul({\n                a: m,\n                b: g,\n                transposeA: !1,\n                transposeB: !1,\n                bias: r,\n                activation: o,\n                preluActivationWeights: a\n            }), n.outShape);\n        }\n        var y = f ? s[0] * s[1] * (s[2] + 1) : s[0] * s[2] * (s[3] + 1), x = {\n            dataId: t.dataId,\n            shape: [\n                1,\n                y,\n                n.inChannels\n            ],\n            dtype: t.dtype\n        }, b = u.shape;\n        u.shape = u.shape.slice(), u.shape[u.shape.length - 2]++, C(_e(u.shape, x.shape), function() {\n            return \"packed reshape \" + u.shape + \" to \" + x.shape + \" isn't free\";\n        });\n        var w = this.reshape(e, [\n            1,\n            n.inChannels,\n            n.outChannels\n        ]), E = this.fusedBatchMatMul({\n            a: x,\n            b: w,\n            transposeA: !1,\n            transposeB: !1,\n            bias: r,\n            activation: o,\n            preluActivationWeights: a\n        }), R = this.texData.get(E.dataId);\n        return C(R.isPacked, function() {\n            return \"batchMatMul result is expected to be packed\";\n        }), u.shape = b, R.shape = n.outShape, Lt.makeTensorFromDataId(E.dataId, n.outShape, E.dtype);\n    }, o.prototype.conv2dWithIm2Row = function(t, e, n, r, o, a) {\n        var i = n.filterWidth, s = n.filterHeight, u = n.inChannels, c = n.outWidth, l = n.outHeight, h = \"channelsLast\" === n.dataFormat, f = i * s * u, d = l * c, p = [\n            f,\n            d\n        ], v = t.squeeze([\n            0\n        ]), m = e.reshape([\n            1,\n            f,\n            -1\n        ]), g = new Li(p, v.shape, n), y = this.compileAndRun(g, [\n            v\n        ]).reshape([\n            1,\n            p[0],\n            p[1]\n        ]), x = null != r, b = null != a, w = o ? Qs(o, !0) : null, C = new Hi(y.shape, [\n            1,\n            d,\n            n.outChannels\n        ], !0, !1, x, w, b), E = [\n            y,\n            m\n        ];\n        r && E.push(r), b && E.push(a);\n        var R = this.compileAndRun(C, E);\n        return h ? R.reshape([\n            1,\n            l,\n            c,\n            n.outChannels\n        ]) : R.reshape([\n            1,\n            n.outChannels,\n            l,\n            c\n        ]);\n    }, o.prototype.fusedConv2d = function(t) {\n        var e = t.input, n = t.filter, r = t.convInfo, o = t.bias, a = t.activation, s = t.preluActivationWeights;\n        if (1 === r.filterHeight && 1 === r.filterWidth && 1 === r.dilationHeight && 1 === r.dilationWidth && 1 === r.strideHeight && 1 === r.strideWidth && (\"SAME\" === r.padInfo.type || \"VALID\" === r.padInfo.type)) return this.conv2dByMatMul(e, n, r, o, a, s);\n        if (i().getBool(\"WEBGL_CONV_IM2COL\") && 1 === e.shape[0]) return this.conv2dWithIm2Row(e, n, r, o, a, s);\n        var u = null != o, c = null != s, l = a ? Qs(a, !1) : null, h = new Qa(r, u, l, c), f = [\n            e,\n            n\n        ];\n        return o && f.push(o), s && f.push(s), this.compileAndRun(h, f);\n    }, o.prototype.conv2d = function(t, e, n) {\n        if (1 === n.filterHeight && 1 === n.filterWidth && 1 === n.dilationHeight && 1 === n.dilationWidth && 1 === n.strideHeight && 1 === n.strideWidth && (\"SAME\" === n.padInfo.type || \"VALID\" === n.padInfo.type)) return this.conv2dByMatMul(t, e, n);\n        if (i().getBool(\"WEBGL_CONV_IM2COL\") && 1 === t.shape[0]) return this.conv2dWithIm2Row(t, e, n);\n        var r = new Qa(n);\n        return this.compileAndRun(r, [\n            t,\n            e\n        ]);\n    }, o.prototype.conv2dDerInput = function(t, e, n) {\n        var r = new Ka(n);\n        return this.compileAndRun(r, [\n            t,\n            e\n        ]);\n    }, o.prototype.conv2dDerFilter = function(t, e, n) {\n        var r = new qa(n);\n        return this.compileAndRun(r, [\n            t,\n            e\n        ]);\n    }, o.prototype.fusedDepthwiseConv2D = function(t) {\n        var e, n = t.input, r = t.filter, o = t.convInfo, a = t.bias, s = t.activation, u = t.preluActivationWeights, c = i().getBool(\"WEBGL_PACK_DEPTHWISECONV\") && o.strideWidth <= 2 && o.outChannels / o.inChannels == 1, l = s ? Qs(s, c) : null, h = [\n            n,\n            r\n        ], f = null != a, d = null != u;\n        return f && h.push(a), d && h.push(u), c ? (e = new ti(o, f, l, d), this.compileAndRun(e, h)) : (e = new Za(o, f, l, d), this.compileAndRun(e, h));\n    }, o.prototype.depthwiseConv2D = function(t, e, n) {\n        var r;\n        return i().getBool(\"WEBGL_PACK_DEPTHWISECONV\") && n.strideWidth <= 2 && n.outChannels / n.inChannels == 1 ? (r = new ti(n), this.compileAndRun(r, [\n            t,\n            e\n        ])) : (r = new Za(n), this.compileAndRun(r, [\n            t,\n            e\n        ]));\n    }, o.prototype.depthwiseConv2DDerInput = function(t, e, n) {\n        var r = new $a(n);\n        return this.compileAndRun(r, [\n            t,\n            e\n        ]);\n    }, o.prototype.depthwiseConv2DDerFilter = function(t, e, n) {\n        var r = new Ya(n);\n        return this.compileAndRun(r, [\n            t,\n            e\n        ]);\n    }, o.prototype.conv3d = function(t, e, n) {\n        var r = new Ja(n);\n        return this.compileAndRun(r, [\n            t,\n            e\n        ]);\n    }, o.prototype.conv3dDerInput = function(t, e, n) {\n        var r = new Xa(n);\n        return this.compileAndRun(r, [\n            t,\n            e\n        ]);\n    }, o.prototype.conv3dDerFilter = function(t, e, n) {\n        var r = new ja(n);\n        return this.compileAndRun(r, [\n            t,\n            e\n        ]);\n    }, o.prototype.maxPool = function(t, e) {\n        var n = new $i(e, \"max\", !1);\n        return this.compileAndRun(n, [\n            t\n        ]);\n    }, o.prototype.avgPool = function(t, e) {\n        var n = new $i(e, \"avg\", !1);\n        return this.compileAndRun(n, [\n            t\n        ], \"float32\");\n    }, o.prototype.maxPoolBackprop = function(t, e, n, r) {\n        var o = new $i(r, \"max\", !0), a = this.compileAndRun(o, [\n            e\n        ]), i = new zi(r), s = this.compileAndRun(i, [\n            t,\n            a\n        ], e.dtype);\n        return a.dispose(), s;\n    }, o.prototype.avgPoolBackprop = function(t, e, n) {\n        var r = new Ia(n);\n        return this.compileAndRun(r, [\n            t\n        ], e.dtype);\n    }, o.prototype.cast = function(t, e) {\n        return Po(t, e, this);\n    }, o.prototype.unstack = function(t, e) {\n        for(var n = t.shape[e], r = new Array(t.rank - 1), o = 0, a = 0; a < t.rank; a++)a !== e && (r[o++] = t.shape[a]);\n        var i = new Array(t.rank).fill(0), s = t.shape.slice();\n        s[e] = 1;\n        var u = new Array(n);\n        for(a = 0; a < u.length; a++)i[e] = a, u[a] = this.slice(t, i, s).reshape(r);\n        return u;\n    }, o.prototype.avgPool3d = function(t, e) {\n        var n = new Qi(e, \"avg\", !1);\n        return this.compileAndRun(n, [\n            t\n        ], \"float32\");\n    }, o.prototype.avgPool3dBackprop = function(t, e, n) {\n        var r = new ka(n);\n        return this.compileAndRun(r, [\n            t\n        ], e.dtype);\n    }, o.prototype.maxPool3d = function(t, e) {\n        var n = new Qi(e, \"max\", !1);\n        return this.compileAndRun(n, [\n            t\n        ], \"float32\");\n    }, o.prototype.maxPool3dBackprop = function(t, e, n, r) {\n        var o = new Qi(r, \"max\", !0), a = this.compileAndRun(o, [\n            e\n        ]), i = new Gi(r), s = this.compileAndRun(i, [\n            t,\n            a\n        ], e.dtype);\n        return a.dispose(), s;\n    }, o.prototype.reshape = function(t, e) {\n        var n = this.texData.get(t.dataId);\n        if (n.isPacked && !_e(t.shape, e) && (null === n.texture || !_e(n.shape, e))) {\n            var r = this.packedReshape(t, e);\n            return Lt.makeTensorFromDataId(r.dataId, r.shape, r.dtype);\n        }\n        return Lo(t, e);\n    }, o.prototype.resizeBilinear = function(t, e, n, r) {\n        var o = i().getBool(\"WEBGL_PACK_IMAGE_OPERATIONS\") ? new ns(t.shape, e, n, r) : new es(t.shape, e, n, r);\n        return this.compileAndRun(o, [\n            t\n        ], \"float32\");\n    }, o.prototype.resizeBilinearBackprop = function(t, e, n) {\n        var r = new ts(t, e, n);\n        return this.compileAndRun(r, [\n            t\n        ]);\n    }, o.prototype.resizeNearestNeighbor = function(t, e, n, r) {\n        var o = new os(t.shape, e, n, r);\n        return this.compileAndRun(o, [\n            t\n        ]);\n    }, o.prototype.resizeNearestNeighborBackprop = function(t, e, n) {\n        var r = new rs(t, e, n);\n        return this.compileAndRun(r, [\n            t\n        ]);\n    }, o.prototype.multinomial = function(t, e, n, r) {\n        var o = e ? t : go(t), a = o.shape[0], i = o.shape[1], s = new qi(a, i, n), u = s.getCustomSetupFunc(r);\n        return this.compileAndRun(s, [\n            o\n        ], \"int32\", u);\n    }, o.prototype.oneHot = function(t, e, n, r) {\n        var o = new Ki(t.size, e, n, r);\n        return this.compileAndRun(o, [\n            t\n        ]);\n    }, o.prototype.diag = function(t) {\n        var e = new si(t.size);\n        return this.compileAndRun(e, [\n            t\n        ]);\n    }, o.prototype.nonMaxSuppression = function(t, e, n, r, o) {\n        return dn(\"tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead\"), jo(t.dataSync(), e.dataSync(), n, r, o);\n    }, o.prototype.cropAndResize = function(t, e, n, r, o, a) {\n        var i = new ei(t.shape, e.shape, r, o, a);\n        return this.compileAndRun(i, [\n            t,\n            e,\n            n\n        ], \"float32\");\n    }, o.prototype.depthToSpace = function(t, e, n) {\n        C(e > 1, function() {\n            return \"blockSize should be > 1 for depthToSpace, but was: \" + e;\n        });\n        var r = t.shape[0], o = \"NHWC\" === n ? t.shape[1] : t.shape[2], a = \"NHWC\" === n ? t.shape[2] : t.shape[3], i = \"NHWC\" === n ? t.shape[3] : t.shape[1], s = o * e, u = a * e, c = i / (e * e), l = new ii(\"NHWC\" === n ? [\n            r,\n            s,\n            u,\n            c\n        ] : [\n            r,\n            c,\n            s,\n            u\n        ], e, n);\n        return this.compileAndRun(l, [\n            t\n        ]);\n    }, o.prototype.split = function(t, e, n) {\n        return Zo(t, e, n);\n    }, o.prototype.scatterND = function(t, e, n) {\n        var r = Zr(0, t, n), o = r.sliceRank, a = r.numUpdates, i = r.sliceSize, s = r.strides, u = r.outputSize, c = [\n            u / i,\n            i\n        ], l = t.reshape([\n            a,\n            o\n        ]), h = e.reshape([\n            a,\n            i\n        ]);\n        if (0 === u) return Lo(Fn([]), n);\n        var f = On(0), d = new ss(a, o, l.rank, h.rank, s, c);\n        return this.compileAndRun(d, [\n            h,\n            l,\n            f\n        ]).reshape(n);\n    }, o.prototype.sparseToDense = function(t, e, n, r) {\n        var o = Zr(0, t, n), a = o.sliceRank, i = o.numUpdates, s = o.strides, u = o.outputSize, c = new ss(i, a, t.rank, e.rank, s, [\n            u,\n            1\n        ], !1);\n        return this.compileAndRun(c, [\n            e,\n            t,\n            r\n        ]).reshape(n);\n    }, o.prototype.fft = function(t) {\n        return this.fftImpl(t, !1);\n    }, o.prototype.ifft = function(t) {\n        return this.fftImpl(t, !0);\n    }, o.prototype.fftImpl = function(t, e) {\n        var n = this.texData.get(t.dataId), r = new pi(fi, t.shape, e), o = new pi(di, t.shape, e), a = [\n            this.makeComplexComponentTensorInfo(t, n.complexTensors.real),\n            this.makeComplexComponentTensorInfo(t, n.complexTensors.imag)\n        ], i = this.compileAndRun(r, a), s = this.compileAndRun(o, a), u = this.complex(i, s).as2D(t.shape[0], t.shape[1]);\n        return i.dispose(), s.dispose(), u;\n    }, o.prototype.gatherND = function(t, e) {\n        var n = e.shape, r = n[n.length - 1], o = jr(t, e), a = o[0], i = o[1], s = o[2], u = o[3], c = e.reshape([\n            i,\n            r\n        ]), l = t.reshape([\n            t.size / s,\n            s\n        ]), h = new gi(r, u, [\n            i,\n            s\n        ]);\n        return this.compileAndRun(h, [\n            l,\n            c\n        ]).reshape(a);\n    }, o.prototype.fill = function(t, e, n) {\n        if (\"string\" === (n = n || j(e))) {\n            var r = P(n, k(t));\n            return r.fill(e), Lt.makeTensor(r, t, n, this);\n        }\n        var o = new vi(t, e), a = o.getCustomSetupFunc(e);\n        return this.compileAndRun(o, [], n, a);\n    }, o.prototype.onesLike = function(t) {\n        if (\"string\" === t.dtype) throw new Error(\"onesLike is not supported under string dtype\");\n        return this.fill(t.shape, 1, t.dtype);\n    }, o.prototype.zerosLike = function(t) {\n        return this.fill(t.shape, \"string\" === t.dtype ? \"\" : 0, t.dtype);\n    }, o.prototype.linspace = function(t, e, n) {\n        return Wo(t, e, n);\n    }, o.prototype.makeTensorInfo = function(t, e) {\n        var n = this.write(null, t, e);\n        return this.texData.get(n).usage = null, {\n            dataId: n,\n            shape: t,\n            dtype: e\n        };\n    }, o.prototype.makeOutput = function(t, e) {\n        var n = this.makeTensorInfo(t, e).dataId;\n        return Lt.makeTensorFromDataId(n, t, e, this);\n    }, o.prototype.unpackTensor = function(t) {\n        var e = new Ys(t.shape);\n        return this.runWebGLProgram(e, [\n            t\n        ], t.dtype);\n    }, o.prototype.packTensor = function(t) {\n        var e = new ji(t.shape);\n        return this.runWebGLProgram(e, [\n            t\n        ], t.dtype, null, !0);\n    }, o.prototype.packedReshape = function(t, e) {\n        var n = [\n            Ae(t.shape)\n        ].concat(De(t.shape)), r = {\n            dtype: t.dtype,\n            shape: n,\n            dataId: t.dataId\n        }, o = [\n            Ae(e)\n        ].concat(De(e)), a = new Zi(o, n), i = this.runWebGLProgram(a, [\n            r\n        ], t.dtype, null, !0);\n        return {\n            dataId: i.dataId,\n            shape: e,\n            dtype: i.dtype\n        };\n    }, o.prototype.decode = function(t) {\n        var e, n = this.texData.get(t), r = n.isPacked, o = n.shape, a = n.dtype, i = Te(o);\n        e = r ? new ai(i) : new oi(i);\n        return {\n            dtype: a,\n            shape: o,\n            dataId: this.runWebGLProgram(e, [\n                {\n                    shape: i,\n                    dtype: a,\n                    dataId: t\n                }\n            ], a, null, !0).dataId\n        };\n    }, o.prototype.runWebGLProgram = function(t, e, n, r, o) {\n        var a = this;\n        void 0 === o && (o = !1);\n        var s = this.makeTensorInfo(t.outputShape, n), u = this.texData.get(s.dataId);\n        if (t.packedOutput && (u.isPacked = !0), t.outPackingScheme === Vt.DENSE) {\n            var c = Yt(t.outputShape);\n            u.texShape = c.map(function(t) {\n                return 2 * t;\n            });\n        }\n        if (null != t.outTexUsage && (u.usage = t.outTexUsage), 0 === k(s.shape)) return u.values = B(s.dtype, 0), s;\n        var l = [], h = e.map(function(e) {\n            if (\"complex64\" === e.dtype) throw new Error(\"GPGPUProgram does not support complex64 input. For complex64 dtypes, please separate the program into real and imaginary parts.\");\n            var n = a.texData.get(e.dataId);\n            if (null == n.texture) {\n                if (!t.packedInputs && k(e.shape) <= i().getNumber(\"WEBGL_SIZE_UPLOAD_UNIFORM\")) return {\n                    shape: e.shape,\n                    texData: null,\n                    isUniform: !0,\n                    uniformValues: n.values\n                };\n                t.packedInputs && (n.isPacked = !0, n.shape = e.shape);\n            } else if (!!n.isPacked != !!t.packedInputs) e = n.isPacked ? a.unpackTensor(e) : a.packTensor(e), l.push(e), n = a.texData.get(e.dataId);\n            else if (n.isPacked && !_e(n.shape, e.shape)) {\n                var r = e, o = e.shape;\n                e.shape = n.shape, e = a.packedReshape(e, o), l.push(e), n = a.texData.get(e.dataId), r.shape = o;\n            }\n            return a.uploadToGPU(e.dataId), {\n                shape: e.shape,\n                texData: n,\n                isUniform: !1\n            };\n        });\n        this.uploadToGPU(s.dataId);\n        var f, d = {\n            shape: s.shape,\n            texData: u,\n            isUniform: !1\n        }, p = function(t, e, n) {\n            var r = \"\";\n            e.concat(n).forEach(function(t) {\n                var e = null != t.texData && null != t.texData.slice && t.texData.slice.flatOffset > 0, n = t.isUniform ? \"uniform\" : t.texData.texShape;\n                r += t.shape + \"_\" + n + \"_\" + e;\n            });\n            var o = t.userCode, a = t.constructor.name;\n            return a += \"_\" + r + \"_\" + o;\n        }(t, h, d), v = this.getAndSaveBinary(p, function() {\n            return function(t, e, n, r) {\n                var o = e.userCode, a = n.map(function(t, n) {\n                    var r = {\n                        logicalShape: t.shape,\n                        texShape: t.isUniform ? null : t.texData.texShape,\n                        isUniform: t.isUniform,\n                        isPacked: !t.isUniform && t.texData.isPacked,\n                        flatOffset: null\n                    };\n                    return null != t.texData && null != t.texData.slice && t.texData.slice.flatOffset > 0 && (r.flatOffset = t.texData.slice.flatOffset), {\n                        name: e.variableNames[n],\n                        shapeInfo: r\n                    };\n                }), s = a.map(function(t) {\n                    return t.shapeInfo;\n                }), u = {\n                    logicalShape: r.shape,\n                    texShape: r.texData.texShape,\n                    isUniform: !1,\n                    isPacked: r.texData.isPacked,\n                    flatOffset: null\n                }, c = fa(a, u, o, e.packedInputs), l = t.createProgram(c), h = null, f = t.getUniformLocation(l, \"NAN\", !1);\n                1 === i().getNumber(\"WEBGL_VERSION\") && (h = t.getUniformLocation(l, \"INFINITY\", !1));\n                for(var d = {}, p = 0; p < e.variableNames.length; p++){\n                    var v = e.variableNames[p];\n                    d[v] = t.getUniformLocation(l, v, !1), d[\"offset\" + v] = t.getUniformLocation(l, \"offset\" + v, !1);\n                }\n                return {\n                    program: e,\n                    source: c,\n                    webGLProgram: l,\n                    uniformLocations: d,\n                    inShapeInfos: s,\n                    outShapeInfo: u,\n                    infLoc: h,\n                    nanLoc: f\n                };\n            }(a.gpgpu, t, h, d);\n        }), m = null != this.activeTimers;\n        if (m && (f = this.startTimer()), function(t, e, n, r, o) {\n            Pi(e.inShapeInfos, n), Pi([\n                e.outShapeInfo\n            ], [\n                r\n            ]);\n            var a = r.texData.texture, s = r.texData.texShape;\n            r.texData.isPacked ? t.setOutputPackedMatrixTexture(a, s[0], s[1]) : t.setOutputMatrixTexture(a, s[0], s[1]), t.setProgram(e.webGLProgram), 1 === i().getNumber(\"WEBGL_VERSION\") && null !== e.infLoc && t.gl.uniform1f(e.infLoc, 1 / 0), null !== e.nanLoc && t.gl.uniform1f(e.nanLoc, NaN), n.forEach(function(n, r) {\n                var o = e.program.variableNames[r], a = e.uniformLocations[o], i = e.uniformLocations[\"offset\" + o];\n                if (null != a) if (n.isUniform) if (k(n.shape) < 2) t.gl.uniform1f(a, n.uniformValues[0]);\n                else {\n                    var s = n.uniformValues;\n                    s instanceof Float32Array || (s = new Float32Array(s)), t.gl.uniform1fv(a, s);\n                }\n                else null != n.texData.slice && null != i && t.gl.uniform1i(i, n.texData.slice.flatOffset), t.setInputMatrixTexture(n.texData.texture, a, r);\n            }), null != o && o(t, e.webGLProgram), t.executeProgram();\n        }(this.gpgpu, v, h, d, r), l.forEach(function(t) {\n            return a.disposeData(t.dataId);\n        }), m && (f = this.endTimer(f), this.activeTimers.push({\n            name: t.constructor.name,\n            query: this.getQueryTime(f)\n        })), !i().getBool(\"WEBGL_LAZILY_UNPACK\") && u.isPacked && !1 === o) {\n            var g = this.unpackTensor(s);\n            return this.disposeData(s.dataId), g;\n        }\n        return s;\n    }, o.prototype.compileAndRun = function(t, e, n, r, o) {\n        void 0 === o && (o = !1), n = n || e[0].dtype;\n        var a = this.runWebGLProgram(t, e, n, r, o);\n        return Lt.makeTensorFromDataId(a.dataId, a.shape, a.dtype);\n    }, o.prototype.getAndSaveBinary = function(t, e) {\n        return t in this.binaryCache || (this.binaryCache[t] = e()), this.binaryCache[t];\n    }, o.prototype.getTextureManager = function() {\n        return this.textureManager;\n    }, o.prototype.dispose = function() {\n        var t = this;\n        if (!this.disposed) {\n            if (!i().getBool(\"IS_TEST\")) Object.keys(this.binaryCache).forEach(function(e) {\n                t.gpgpu.deleteProgram(t.binaryCache[e].webGLProgram), delete t.binaryCache[e];\n            });\n            this.textureManager.dispose(), null != this.canvas && \"undefined\" != typeof HTMLCanvasElement && this.canvas instanceof HTMLCanvasElement ? this.canvas.remove() : this.canvas = null, this.gpgpuCreatedLocally && (this.gpgpu.program = null, this.gpgpu.dispose()), this.disposed = !0;\n        }\n    }, o.prototype.floatPrecision = function() {\n        var t = this;\n        return null == this.floatPrecisionValue && (this.floatPrecisionValue = Ze(function() {\n            if (!i().get(\"WEBGL_RENDER_FLOAT32_ENABLED\")) {\n                var e = i().getBool(\"DEBUG\");\n                i().set(\"DEBUG\", !1);\n                var n = t.abs(On(1e-8)).dataSync()[0];\n                if (i().set(\"DEBUG\", e), n > 0) return 32;\n            }\n            return 16;\n        })), this.floatPrecisionValue;\n    }, o.prototype.epsilon = function() {\n        return 32 === this.floatPrecision() ? 1e-7 : 1e-4;\n    }, o.prototype.uploadToGPU = function(t) {\n        var e, n = this.texData.get(t), r = n.shape, o = n.dtype, a = n.values, i = n.texture, s = n.usage, u = n.isPacked;\n        if (null == i) {\n            var c, l = null != this.activeTimers;\n            l && (c = et());\n            var h = n.texShape;\n            if (null == h && (h = Ne(r, u), n.texShape = h), null != a) {\n                var f = Te(r), d = void 0, p = h[1], v = h[0], m = a instanceof Uint8Array;\n                u ? (p = (e = $t(h[0], h[1]))[0], v = e[1], d = new hi(f, [\n                    v,\n                    p\n                ], m)) : d = new li(f, [\n                    v,\n                    p\n                ], m);\n                var g = this.makeTensorInfo([\n                    v,\n                    p\n                ], o);\n                this.texData.get(g.dataId).usage = m ? zt.PIXELS : zt.UPLOAD, this.gpgpu.uploadDenseMatrixToTexture(this.getTexture(g.dataId), p, v, a);\n                var y = this.runWebGLProgram(d, [\n                    g\n                ], o, null, !0), x = this.texData.get(y.dataId);\n                n.texture = x.texture, n.texShape = x.texShape, n.isPacked = x.isPacked, n.usage = x.usage, this.disposeData(g.dataId), this.texData.delete(y.dataId), n.values = null, l && (this.uploadWaitMs += et() - c);\n            } else {\n                var b = this.acquireTexture(h, s, o, u);\n                n.texture = b;\n            }\n        }\n    }, o.prototype.convertAndCacheOnCPU = function(t, e) {\n        var n = this.texData.get(t), r = n.dtype;\n        return this.releaseGPUData(t), null != e && (n.values = function(t, e) {\n            if (\"float32\" === e || \"complex64\" === e) return t;\n            if (\"int32\" === e || \"bool\" === e) {\n                for(var n = \"int32\" === e ? new Int32Array(t.length) : new Uint8Array(t.length), r = 0; r < n.length; ++r)n[r] = Math.round(t[r]);\n                return n;\n            }\n            throw new Error(\"Unknown dtype \" + e);\n        }(e, r)), n.values;\n    }, o.prototype.acquireTexture = function(t, e, n, r) {\n        if (this.numBytesInGPU += this.computeBytes(t, n), !this.warnedAboutMemory && this.numBytesInGPU > 1024 * this.numMBBeforeWarning * 1024) {\n            var o = (this.numBytesInGPU / 1024 / 1024).toFixed(2);\n            this.warnedAboutMemory = !0, console.warn(\"High memory usage in GPU: \" + o + \" MB, most likely due to a memory leak\");\n        }\n        return this.textureManager.acquireTexture(t, e, r);\n    }, o.prototype.computeBytes = function(t, e) {\n        return t[0] * t[1] * z(e);\n    }, o;\n}(bo);\nWt() && Lt.registerBackend(\"webgl\", function() {\n    return new Zs;\n}, 2);\nvar tu = An({\n    square_: function(t) {\n        var e = mn(t, \"x\", \"square\"), n = [\n            e\n        ];\n        return Lt.runKernelFunc(function(t, n) {\n            return n([\n                e\n            ]), t.square(e);\n        }, {\n            x: e\n        }, null, \"Square\", {}, n, []);\n    }\n}), eu = \"SquaredDifference\";\nvar nu = An({\n    squaredDifference_: function(t, e) {\n        var n, r = mn(t, \"a\", \"squaredDifference\"), o = mn(e, \"b\", \"squaredDifference\");\n        n = Nt(r, o), r = n[0], o = n[1], Ro(r.shape, o.shape);\n        var a = {\n            a: r,\n            b: o\n        }, i = [\n            r,\n            o\n        ];\n        return Lt.runKernelFunc(function(t, e) {\n            var n = t.squaredDifference(r, o);\n            return e([\n                r,\n                o\n            ]), n;\n        }, a, function(t, e) {\n            var n = e[0], r = e[1], o = On(2);\n            return {\n                a: function() {\n                    return t.mul(n.sub(r).mul(o));\n                },\n                b: function() {\n                    return t.mul(r.sub(n).mul(o));\n                }\n            };\n        }, eu, {}, i, []);\n    }\n});\nvar ru = An({\n    abs_: function(t) {\n        var e = mn(t, \"x\", \"abs\");\n        return \"complex64\" === e.dtype ? Lt.runKernelFunc(function(t) {\n            return t.complexAbs(e);\n        }, {\n            $x: e\n        }) : Lt.runKernelFunc(function(t, n) {\n            var r = t.abs(e);\n            return n([\n                e\n            ]), r;\n        }, {\n            x: e\n        }, function(t, e) {\n            var n = e[0];\n            return {\n                x: function() {\n                    return t.mul(n.toFloat().step(-1));\n                }\n            };\n        }, \"Abs\");\n    }\n}), ou = An({\n    acos_: function(t) {\n        var e = mn(t, \"x\", \"acos\");\n        return Lt.runKernelFunc(function(t, n) {\n            var r = t.acos(e);\n            return n([\n                e\n            ]), r;\n        }, {\n            $x: e\n        }, function(t, e) {\n            var n = e[0];\n            return {\n                $x: function() {\n                    return t.divStrict(On(1).sub(n.toFloat().square()).sqrt()).neg();\n                }\n            };\n        });\n    }\n}), au = An({\n    acosh_: function(t) {\n        var e = mn(t, \"x\", \"acosh\");\n        return Lt.runKernelFunc(function(t, n) {\n            var r = t.acosh(e);\n            return n([\n                e\n            ]), r;\n        }, {\n            $x: e\n        }, function(t, e) {\n            var n = e[0];\n            return {\n                $x: function() {\n                    return t.divStrict(n.toFloat().square().sub(1).sqrt());\n                }\n            };\n        });\n    }\n}), iu = An({\n    asin_: function(t) {\n        var e = mn(t, \"x\", \"asin\");\n        return Lt.runKernelFunc(function(t, n) {\n            var r = t.asin(e);\n            return n([\n                e\n            ]), r;\n        }, {\n            $x: e\n        }, function(t, e) {\n            var n = e[0];\n            return {\n                $x: function() {\n                    return t.divStrict(On(1).sub(n.toFloat().square()).sqrt());\n                }\n            };\n        });\n    }\n}), su = An({\n    asinh_: function(t) {\n        var e = mn(t, \"x\", \"asinh\");\n        return Lt.runKernelFunc(function(t, n) {\n            var r = t.asinh(e);\n            return n([\n                e\n            ]), r;\n        }, {\n            $x: e\n        }, function(t, e) {\n            var n = e[0];\n            return {\n                $x: function() {\n                    return t.divStrict(On(1).add(n.toFloat().square()).sqrt());\n                }\n            };\n        });\n    }\n}), uu = An({\n    atan_: function(t) {\n        var e = mn(t, \"x\", \"atan\");\n        return Lt.runKernelFunc(function(t, n) {\n            var r = t.atan(e);\n            return n([\n                e\n            ]), r;\n        }, {\n            $x: e\n        }, function(t, e) {\n            var n = e[0];\n            return {\n                $x: function() {\n                    return t.div(n.toFloat().square().add(1));\n                }\n            };\n        });\n    }\n}), cu = An({\n    atanh_: function(t) {\n        var e = mn(t, \"x\", \"atanh\");\n        return Lt.runKernelFunc(function(t, n) {\n            var r = t.atanh(e);\n            return n([\n                e\n            ]), r;\n        }, {\n            $x: e\n        }, function(t, e) {\n            var n = e[0];\n            return {\n                $x: function() {\n                    return t.div(On(1).sub(n.toFloat().square()));\n                }\n            };\n        });\n    }\n}), lu = An({\n    ceil_: function(t) {\n        var e = mn(t, \"x\", \"ceil\");\n        return Lt.runKernelFunc(function(t) {\n            return t.ceil(e);\n        }, {\n            $x: e\n        }, function(t) {\n            return {\n                $x: function() {\n                    return Xn(t);\n                }\n            };\n        });\n    }\n}), hu = An({\n    clipByValue_: function(t, e, n) {\n        var r = mn(t, \"x\", \"clipByValue\");\n        C(e <= n, function() {\n            return \"Error in clip: min (\" + e + \") must be less than or equal to max (\" + n + \").\";\n        });\n        var o = [\n            r\n        ], a = {\n            min: e,\n            max: n\n        };\n        return Lt.runKernelFunc(function(t, o) {\n            var a = t.clip(r, e, n);\n            return o([\n                r\n            ]), a;\n        }, {\n            x: r\n        }, function(t, r) {\n            var o = r[0];\n            return {\n                x: function() {\n                    return t.where(o.greaterEqual(e).logicalAnd(o.lessEqual(n)), Xn(t));\n                }\n            };\n        }, \"ClipByValue\", a, o);\n    }\n}), fu = An({\n    cos_: function(t) {\n        var e = mn(t, \"x\", \"cos\"), n = [\n            e\n        ];\n        return Lt.runKernelFunc(function(t, n) {\n            var r = t.cos(e);\n            return n([\n                e\n            ]), r;\n        }, {\n            x: e\n        }, function(t, e) {\n            var n = e[0];\n            return {\n                x: function() {\n                    return n.toFloat().sin().neg().mul(t);\n                }\n            };\n        }, \"Cos\", {}, n);\n    }\n}), du = An({\n    cosh_: function(t) {\n        var e = mn(t, \"x\", \"cosh\");\n        return Lt.runKernelFunc(function(t, n) {\n            var r = t.cosh(e);\n            return n([\n                e\n            ]), r;\n        }, {\n            $x: e\n        }, function(t, e) {\n            var n = e[0];\n            return {\n                $x: function() {\n                    return n.toFloat().sinh().mulStrict(t);\n                }\n            };\n        });\n    }\n}), pu = An({\n    erf_: function(t) {\n        var e = mn(t, \"x\", \"erf\");\n        return C(\"int32\" === e.dtype || \"float32\" === e.dtype, function() {\n            return \"Input dtype must be `int32` or `float32`.\";\n        }), \"int32\" === e.dtype && (e = e.toFloat()), Lt.runKernelFunc(function(t, n) {\n            var r = t.erf(e);\n            return n([\n                e\n            ]), r;\n        }, {\n            $x: e\n        }, function(t, e) {\n            var n = e[0];\n            return {\n                $x: function() {\n                    return t.mul(n.square().neg().exp().mul(2 / Math.sqrt(Math.PI)));\n                }\n            };\n        });\n    }\n}), vu = An({\n    exp_: function(t) {\n        var e = mn(t, \"x\", \"exp\");\n        return Lt.runKernelFunc(function(t, n) {\n            var r = t.exp(e);\n            return n([\n                r\n            ]), r;\n        }, {\n            x: e\n        }, function(t, e) {\n            return {\n                x: function() {\n                    return t.mulStrict(e[0]);\n                }\n            };\n        }, \"Exp\", {}, [], [\n            !0\n        ]);\n    }\n}), mu = An({\n    expm1_: function(t) {\n        var e = mn(t, \"x\", \"expm1\");\n        return Lt.runKernelFunc(function(t, n) {\n            var r = t.expm1(e);\n            return n([\n                e\n            ]), r;\n        }, {\n            $x: e\n        }, function(t, e) {\n            var n = e[0];\n            return {\n                $x: function() {\n                    return t.mul(n.exp());\n                }\n            };\n        });\n    }\n}), gu = An({\n    floor_: function(t) {\n        var e = mn(t, \"x\", \"floor\");\n        return Lt.runKernelFunc(function(t) {\n            return t.floor(e);\n        }, {\n            $x: e\n        }, function(t) {\n            return {\n                $x: function() {\n                    return Xn(t);\n                }\n            };\n        });\n    }\n}), yu = An({\n    log_: function(t) {\n        var e = mn(t, \"x\", \"log\"), n = [\n            e\n        ];\n        return Lt.runKernelFunc(function(t, n) {\n            var r = t.log(e);\n            return n([\n                e\n            ]), r;\n        }, {\n            x: e\n        }, function(t, e) {\n            var n = e[0];\n            return {\n                x: function() {\n                    return t.div(n.toFloat());\n                }\n            };\n        }, \"Log\", {}, n);\n    }\n}), xu = An({\n    log1p_: function(t) {\n        var e = mn(t, \"x\", \"log1p\");\n        return Lt.runKernelFunc(function(t, n) {\n            var r = t.log1p(e);\n            return n([\n                e\n            ]), r;\n        }, {\n            $x: e\n        }, function(t, e) {\n            var n = e[0];\n            return {\n                $x: function() {\n                    return t.div(n.add(1));\n                }\n            };\n        });\n    }\n}), bu = An({\n    logSigmoid_: function(t) {\n        var e = mn(t, \"x\", \"logSigmoid\");\n        return Lt.runKernelFunc(function(t, n) {\n            var r = t.softplus(e.neg()).neg();\n            return n([\n                e\n            ]), r;\n        }, {\n            $x: e\n        }, function(t, e) {\n            var n = e[0];\n            return {\n                $x: function() {\n                    return t.mul(n.neg().sigmoid());\n                }\n            };\n        });\n    }\n}), wu = An({\n    neg_: function(t) {\n        var e = mn(t, \"x\", \"neg\"), n = [\n            e\n        ];\n        return Lt.runKernelFunc(function(t) {\n            return t.neg(e);\n        }, {\n            x: e\n        }, function(t) {\n            return {\n                x: function() {\n                    return t.neg();\n                }\n            };\n        }, \"Neg\", {}, n);\n    }\n}), Cu = An({\n    reciprocal_: function(t) {\n        var e = mn(t, \"x\", \"reciprocal\");\n        return Lt.runKernelFunc(function(t, n) {\n            var r = t.reciprocal(e);\n            return n([\n                e\n            ]), r;\n        }, {\n            $x: e\n        }, function(t, e) {\n            var n = e[0];\n            return {\n                $x: function() {\n                    return t.div(n.square().neg());\n                }\n            };\n        });\n    }\n}), Eu = An({\n    round_: function(t) {\n        var e = mn(t, \"x\", \"round\");\n        return Lt.runKernelFunc(function(t) {\n            return t.round(e);\n        }, {\n            $x: e\n        }, function(t) {\n            return {\n                $x: function() {\n                    return Xn(t);\n                }\n            };\n        });\n    }\n}), Ru = An({\n    rsqrt_: function(t) {\n        var e = mn(t, \"x\", \"rsqrt\"), n = [\n            e\n        ];\n        return Lt.runKernelFunc(function(t, n) {\n            var r = t.rsqrt(e);\n            return n([\n                e\n            ]), r;\n        }, {\n            x: e\n        }, function(t, e) {\n            var n = e[0];\n            return {\n                x: function() {\n                    return t.div(n.pow(1.5).mul(2)).neg();\n                }\n            };\n        }, \"Rsqrt\", {}, n);\n    }\n}), Iu = An({\n    sigmoid_: function(t) {\n        var e = mn(t, \"x\", \"sigmoid\");\n        return Lt.runKernelFunc(function(t, n) {\n            var r = t.sigmoid(e);\n            return n([\n                r\n            ]), r;\n        }, {\n            x: e\n        }, function(t, e) {\n            var n = e[0];\n            return {\n                x: function() {\n                    return t.mul(n.mul(On(1).sub(n)));\n                }\n            };\n        }, \"Sigmoid\");\n    }\n}), ku = An({\n    sign_: function(t) {\n        var e = mn(t, \"x\", \"sign\");\n        return Lt.runKernelFunc(function(t) {\n            return t.sign(e);\n        }, {\n            $x: e\n        }, function(t) {\n            return {\n                $x: function() {\n                    return Xn(t);\n                }\n            };\n        });\n    }\n}), Su = An({\n    isNaN_: function(t) {\n        var e = mn(t, \"x\", \"isNaN\");\n        return Lt.runKernelFunc(function(t) {\n            return t.isNaN(e);\n        }, {\n            $x: e\n        }, function(t) {\n            return {\n                $x: function() {\n                    return Xn(t);\n                }\n            };\n        });\n    }\n}), Au = An({\n    isInf_: function(t) {\n        var e = mn(t, \"x\", \"isInf\");\n        return Lt.runKernelFunc(function(t) {\n            return t.isInf(e);\n        }, {\n            $x: e\n        }, function(t) {\n            return {\n                $x: function() {\n                    return Xn(t);\n                }\n            };\n        });\n    }\n}), Du = An({\n    isFinite_: function(t) {\n        var e = mn(t, \"x\", \"isFinite\");\n        return Lt.runKernelFunc(function(t) {\n            return t.isFinite(e);\n        }, {\n            $x: e\n        }, function(t) {\n            return {\n                $x: function() {\n                    return Xn(t);\n                }\n            };\n        });\n    }\n}), Tu = An({\n    sin_: function(t) {\n        var e = mn(t, \"x\", \"sin\"), n = [\n            e\n        ];\n        return Lt.runKernelFunc(function(t, n) {\n            var r = t.sin(e);\n            return n([\n                e\n            ]), r;\n        }, {\n            x: e\n        }, function(t, e) {\n            var n = e[0];\n            return {\n                x: function() {\n                    return n.toFloat().cos().mul(t);\n                }\n            };\n        }, \"Sin\", {}, n);\n    }\n}), Nu = An({\n    sinh_: function(t) {\n        var e = mn(t, \"x\", \"sinh\");\n        return Lt.runKernelFunc(function(t, n) {\n            var r = t.sinh(e);\n            return n([\n                e\n            ]), r;\n        }, {\n            $x: e\n        }, function(t, e) {\n            var n = e[0];\n            return {\n                $x: function() {\n                    return n.toFloat().cosh().mulStrict(t);\n                }\n            };\n        });\n    }\n}), Fu = An({\n    softplus_: function(t) {\n        var e = mn(t, \"x\", \"softplus\");\n        return Lt.runKernelFunc(function(t, n) {\n            var r = t.softplus(e);\n            return n([\n                e\n            ]), r;\n        }, {\n            $x: e\n        }, function(t, e) {\n            var n = e[0];\n            return {\n                $x: function() {\n                    return t.mul(n.sigmoid());\n                }\n            };\n        });\n    }\n}), _u = An({\n    sqrt_: function(t) {\n        var e = mn(t, \"x\", \"sqrt\");\n        return Lt.runKernelFunc(function(t, n) {\n            var r = t.sqrt(e);\n            return n([\n                e\n            ]), r;\n        }, {\n            $x: e\n        }, function(t, e) {\n            var n = e[0];\n            return {\n                $x: function() {\n                    return t.div(n.toFloat().sqrt().mul(2));\n                }\n            };\n        });\n    }\n}), Ou = An({\n    step_: function(t, e) {\n        void 0 === e && (e = 0);\n        var n = mn(t, \"x\", \"step\");\n        return Lt.runKernelFunc(function(t) {\n            return t.step(n, e);\n        }, {\n            $x: n\n        }, function(t) {\n            return {\n                $x: function() {\n                    return Xn(t);\n                }\n            };\n        });\n    }\n}), Mu = An({\n    tan_: function(t) {\n        var e = mn(t, \"x\", \"tan\");\n        return Lt.runKernelFunc(function(t, n) {\n            var r = t.tan(e);\n            return n([\n                e\n            ]), r;\n        }, {\n            $x: e\n        }, function(t, e) {\n            var n = e[0];\n            return {\n                $x: function() {\n                    return t.div(n.cos().square());\n                }\n            };\n        });\n    }\n}), Bu = An({\n    tanh_: function(t) {\n        var e = mn(t, \"x\", \"tanh\");\n        return Lt.runKernelFunc(function(t, n) {\n            var r = t.tanh(e);\n            return n([\n                r\n            ]), r;\n        }, {\n            x: e\n        }, function(t, e) {\n            var n = e[0];\n            return {\n                x: function() {\n                    return On(1).sub(n.square()).mulStrict(t);\n                }\n            };\n        }, \"Tanh\", {}, null, [\n            !0\n        ]);\n    }\n});\nfunction Pu(t, e, n, r, o, a) {\n    var i, s, u = mn(t, \"x\", \"batchNorm\"), c = mn(e, \"mean\", \"batchNorm\"), l = mn(n, \"variance\", \"batchNorm\");\n    return null != o && (i = mn(o, \"scale\", \"batchNorm\")), null != r && (s = mn(r, \"offset\", \"batchNorm\")), C(2 === u.rank, function() {\n        return \"Error in batchNorm3D: x must be rank 3 but got rank \" + u.rank + \".\";\n    }), C(2 === c.rank || 1 === c.rank, function() {\n        return \"Error in batchNorm2D: mean must be rank 2 or rank 1 but got rank \" + c.rank + \".\";\n    }), C(2 === l.rank || 1 === l.rank, function() {\n        return \"Error in batchNorm2D: variance must be rank 2 or rank 1 but got rank \" + l.rank + \".\";\n    }), null != i && C(2 === i.rank || 1 === i.rank, function() {\n        return \"Error in batchNorm2D: scale must be rank 2 or rank 1 but got rank \" + i.rank + \".\";\n    }), null != s && C(2 === s.rank || 1 === s.rank, function() {\n        return \"Error in batchNorm2D: offset must be rank 2 or rank 1 but got rank \" + s.rank + \".\";\n    }), Uu(u, c, l, s, i, a);\n}\nfunction Lu(t, e, n, r, o, a) {\n    var i, s, u = mn(t, \"x\", \"batchNorm\"), c = mn(e, \"mean\", \"batchNorm\"), l = mn(n, \"variance\", \"batchNorm\");\n    return null != o && (i = mn(o, \"scale\", \"batchNorm\")), null != r && (s = mn(r, \"offset\", \"batchNorm\")), C(3 === u.rank, function() {\n        return \"Error in batchNorm3D: x must be rank 3 but got rank \" + u.rank + \".\";\n    }), C(3 === c.rank || 1 === c.rank, function() {\n        return \"Error in batchNorm3D: mean must be rank 3 or rank 1 but got rank \" + c.rank + \".\";\n    }), C(3 === l.rank || 1 === l.rank, function() {\n        return \"Error in batchNorm3D: variance must be rank 3 or rank 1 but got rank \" + l.rank + \".\";\n    }), null != i && C(3 === i.rank || 1 === i.rank, function() {\n        return \"Error in batchNorm3D: scale must be rank 3 or rank 1 but got rank \" + i.rank + \".\";\n    }), null != s && C(3 === s.rank || 1 === s.rank, function() {\n        return \"Error in batchNorm3D: offset must be rank 3 or rank 1 but got rank \" + s.rank + \".\";\n    }), Uu(u, c, l, s, i, a);\n}\nfunction Wu(t, e, n, r, o, a) {\n    var i, s, u = mn(t, \"x\", \"batchNorm\"), c = mn(e, \"mean\", \"batchNorm\"), l = mn(n, \"variance\", \"batchNorm\");\n    return null != o && (i = mn(o, \"scale\", \"batchNorm\")), null != r && (s = mn(r, \"offset\", \"batchNorm\")), C(4 === u.rank, function() {\n        return \"Error in batchNorm4D: x must be rank 4 but got rank \" + u.rank + \".\";\n    }), C(4 === c.rank || 1 === c.rank, function() {\n        return \"Error in batchNorm4D: mean must be rank 4 or rank 1 but got rank \" + c.rank + \".\";\n    }), C(4 === l.rank || 1 === l.rank, function() {\n        return \"Error in batchNorm4D: variance must be rank 4 or rank 1 but got rank \" + l.rank + \".\";\n    }), null != i && C(4 === i.rank || 1 === i.rank, function() {\n        return \"Error in batchNorm4D: scale must be rank 4 or rank 1 but got rank \" + i.rank + \".\";\n    }), null != s && C(4 === s.rank || 1 === s.rank, function() {\n        return \"Error in batchNorm4D: offset must be rank 4 or rank 1 but got rank \" + s.rank + \".\";\n    }), Uu(u, c, l, s, i, a);\n}\nfunction Uu(t, e, n, r, o, a) {\n    null == a && (a = .001);\n    var i, s, u, c = mn(t, \"x\", \"batchNorm\"), l = mn(e, \"mean\", \"batchNorm\"), h = mn(n, \"variance\", \"batchNorm\");\n    null != o && (i = mn(o, \"scale\", \"batchNorm\")), null != r && (s = mn(r, \"offset\", \"batchNorm\")), C(l.rank === h.rank, function() {\n        return \"Batch normalization gradient requires mean and variance to have equal ranks.\";\n    }), C(null == s || l.rank === s.rank, function() {\n        return \"Batch normalization gradient requires mean and offset to have equal ranks.\";\n    }), C(null == i || l.rank === i.rank, function() {\n        return \"Batch normalization gradient requires mean and scale to have equal ranks.\";\n    }), u = 0 === c.rank || 1 === c.rank ? c.as4D(1, 1, 1, c.size) : 2 === c.rank ? c.as4D(1, 1, c.shape[0], c.shape[1]) : 3 === c.rank ? c.as4D(1, c.shape[0], c.shape[1], c.shape[2]) : c;\n    var f = [\n        c,\n        l,\n        h,\n        i\n    ];\n    return Lt.runKernelFunc(function(t, e) {\n        var n = t.batchNormalization(u, Vu(l), Vu(h), a, Vu(i), Vu(s));\n        return e([\n            c,\n            l,\n            h,\n            i\n        ]), n;\n    }, {\n        x: c,\n        mean: l,\n        variance: h,\n        scale: i,\n        offset: s\n    }, function(t, e) {\n        var n = e, r = n[0], o = n[1], i = n[2], s = n[3], c = null == s ? On(1) : s, l = Eo(o.shape, u.shape), h = [];\n        if (1 === o.rank) {\n            for(var f = 0; f < u.shape.length - 1; ++f)h.push(u.shape[f]);\n            h.push(1);\n        }\n        var d = r.sub(o), p = t.mul(c), v = Ru(i.add(On(a))), m = v.mul(v).mul(v).mul(On(-.5));\n        return {\n            x: function() {\n                return 1 === o.rank ? t.mul(Lr(v.as4D(1, 1, 1, o.shape[0]), h)).mul(c).reshape(r.shape) : t.mul(v).mul(c).reshape(r.shape);\n            },\n            mean: function() {\n                var t = v.mul(On(-1)).mul(p);\n                return 1 === o.rank && (t = t.sum(l)), t.reshape(o.shape);\n            },\n            variance: function() {\n                var t = m.mul(d).mul(p);\n                return 1 === o.rank && (t = t.sum(l)), t.reshape(o.shape);\n            },\n            scale: function() {\n                var e = d.mul(v), n = t.mul(e);\n                return 1 === o.rank && (n = n.sum(l)), n.reshape(o.shape);\n            },\n            offset: function() {\n                var e = t;\n                return 1 === o.rank && (e = e.sum(l)), e.reshape(o.shape);\n            }\n        };\n    }, \"BatchNormalization\", {\n        varianceEpsilon: a\n    }, f).reshape(c.shape);\n}\nfunction Vu(t) {\n    return null == t ? null : 0 === t.rank ? t.as1D() : 1 === t.rank ? t : 2 === t.rank ? t.as4D(1, 1, t.shape[0], t.shape[1]) : 3 === t.rank ? t.as4D(1, t.shape[0], t.shape[1], t.shape[2]) : t;\n}\nfunction zu() {\n    Xe(\"tf.batchNormalization() is going away. Use tf.batchNorm() instead, and note the positional argument change of scale, offset, and varianceEpsilon\");\n}\nvar Gu = An({\n    batchNormalization2d_: function(t, e, n, r, o, a) {\n        return void 0 === r && (r = .001), zu(), Pu(t, e, n, a, o, r);\n    }\n}), Hu = An({\n    batchNormalization3d_: function(t, e, n, r, o, a) {\n        return void 0 === r && (r = .001), zu(), Lu(t, e, n, a, o, r);\n    }\n}), qu = An({\n    batchNormalization4d_: function(t, e, n, r, o, a) {\n        return void 0 === r && (r = .001), zu(), Wu(t, e, n, a, o, r);\n    }\n}), Ku = An({\n    batchNormalization_: function(t, e, n, r, o, a) {\n        return void 0 === r && (r = .001), zu(), Uu(t, e, n, a, o, r);\n    }\n}), ju = An({\n    batchNorm_: Uu\n}), Xu = An({\n    batchNorm2d_: Pu\n}), Yu = An({\n    batchNorm3d_: Lu\n}), $u = An({\n    batchNorm4d_: Wu\n});\nvar Qu = An({\n    logicalAnd_: function(t, e) {\n        var n = mn(t, \"a\", \"logicalAnd\", \"bool\"), r = mn(e, \"b\", \"logicalAnd\", \"bool\");\n        return Ro(n.shape, r.shape), Lt.runKernelFunc(function(t) {\n            return t.logicalAnd(n, r);\n        }, {\n            a: n,\n            b: r\n        }, null, \"LogicalAnd\");\n    }\n}), Ju = An({\n    logicalNot_: function(t) {\n        var e = mn(t, \"x\", \"logicalNot\", \"bool\");\n        return Lt.runKernelFunc(function(t) {\n            return t.logicalNot(e);\n        }, {\n            $x: e\n        });\n    }\n}), Zu = An({\n    logicalOr_: function(t, e) {\n        var n = mn(t, \"a\", \"logicalOr\", \"bool\"), r = mn(e, \"b\", \"logicalOr\", \"bool\");\n        return Ro(n.shape, r.shape), Lt.runKernelFunc(function(t) {\n            return t.logicalOr(n, r);\n        }, {\n            $a: n,\n            $b: r\n        });\n    }\n}), tc = An({\n    logicalXor_: function(t, e) {\n        var n = mn(t, \"a\", \"logicalXor\", \"bool\"), r = mn(e, \"b\", \"logicalXor\", \"bool\");\n        return Ro(n.shape, r.shape), Zu(t, e).logicalAnd(Qu(t, e).logicalNot());\n    }\n}), ec = An({\n    where_: function(t, e, n) {\n        var r = mn(e, \"a\", \"where\"), o = mn(n, \"b\", \"where\"), a = mn(t, \"condition\", \"where\", \"bool\");\n        return E(r.shape, o.shape, \"Error in where: \"), 1 === a.rank ? C(a.shape[0] === r.shape[0], function() {\n            return \"The first dimension of `a` must match the size of `condition`.\";\n        }) : E(a.shape, o.shape, \"Error in where: \"), Lt.runKernelFunc(function(t, e) {\n            var n = t.select(a, r, o);\n            return e([\n                a\n            ]), n;\n        }, {\n            $condition: a,\n            $a: r,\n            $b: o\n        }, function(t, e) {\n            var n = e[0];\n            return {\n                $condition: function() {\n                    return Xn(n).toFloat();\n                },\n                $a: function() {\n                    return t.mul(n.cast(t.dtype));\n                },\n                $b: function() {\n                    return t.mul(n.logicalNot().cast(t.dtype));\n                }\n            };\n        });\n    }\n}), nc = function(t) {\n    return n(this, void 0, void 0, function() {\n        var e, n, o;\n        return r(this, function(r) {\n            switch(r.label){\n                case 0:\n                    return [\n                        4,\n                        (e = mn(t, \"condition\", \"whereAsync\", \"bool\")).data()\n                    ];\n                case 1:\n                    return n = r.sent(), o = na(e.shape, n), t !== e && e.dispose(), [\n                        2,\n                        o\n                    ];\n            }\n        });\n    });\n};\nvar rc = An({\n    add_: function(t, e) {\n        var n, r = mn(t, \"a\", \"add\"), o = mn(e, \"b\", \"add\");\n        n = Nt(r, o), r = n[0], o = n[1];\n        var a = Ro(r.shape, o.shape);\n        return Lt.runKernelFunc(function(t) {\n            return t.add(r, o);\n        }, {\n            a: r,\n            b: o\n        }, function(t) {\n            return {\n                a: function() {\n                    var e = t, n = Eo(r.shape, a);\n                    return n.length > 0 && (e = e.sum(n)), e.reshape(r.shape);\n                },\n                b: function() {\n                    var e = t, n = Eo(o.shape, a);\n                    return n.length > 0 && (e = e.sum(n)), e.reshape(o.shape);\n                }\n            };\n        }, \"Add\");\n    }\n}), oc = An({\n    addN_: function(t) {\n        C(Array.isArray(t), function() {\n            return \"The argument passed to tf.addN() must be a list of tensors\";\n        }), C(t.length >= 1, function() {\n            return \"Must pass at least one tensor to tf.addN(), but got \" + t.length;\n        });\n        var e = t.map(function(t, e) {\n            return mn(t, \"tensors\" + e, \"addN\");\n        }), n = e[0];\n        e.forEach(function(t) {\n            if (t.dtype !== n.dtype) throw new Error(\"All tensors passed to tf.addN() must have the same dtype\");\n        }), e.forEach(function(t) {\n            if (!S(t.shape, n.shape)) throw new Error(\"All tensors passed to tf.addN() must have the same shape\");\n        });\n        var r = e;\n        return Lt.runKernelFunc(function(t) {\n            return t.addN(e);\n        }, r, function(t) {\n            var n = {};\n            return e.forEach(function(e, r) {\n                n[r] = function() {\n                    return t.clone();\n                };\n            }), n;\n        }, \"AddN\");\n    }\n}), ac = An({\n    addStrict_: function(t, e) {\n        var n = mn(t, \"a\", \"addStrict\"), r = mn(e, \"b\", \"addStrict\");\n        return E(n.shape, r.shape, \"Error in addStrict: \"), n.add(r);\n    }\n}), ic = An({\n    atan2_: function(t, e) {\n        var n, r = mn(t, \"a\", \"atan2\"), o = mn(e, \"b\", \"atan2\");\n        n = Nt(r, o), r = n[0], o = n[1];\n        var a = Ro(r.shape, o.shape);\n        return Lt.runKernelFunc(function(t, e) {\n            var n = t.atan2(r, o);\n            return e([\n                r,\n                o\n            ]), n;\n        }, {\n            $a: r,\n            $b: o\n        }, function(t, e) {\n            var n = e[0], r = e[1];\n            return {\n                $a: function() {\n                    var e = rc(n.square(), r.square()), o = t.mul(r.div(e)), i = Eo(n.shape, a);\n                    return i.length > 0 && (o = o.sum(i)), o.reshape(n.shape);\n                },\n                $b: function() {\n                    var e = rc(n.square(), r.square()), o = wu(t.mul(n.div(e))), i = Eo(r.shape, a);\n                    return i.length > 0 && (o = o.sum(i)), o.reshape(r.shape);\n                }\n            };\n        });\n    }\n}), sc = An({\n    div_: function(t, e) {\n        var n, r = mn(t, \"a\", \"div\"), o = mn(e, \"b\", \"div\");\n        if (n = Nt(r, o), r = n[0], o = n[1], \"int32\" === r.dtype && \"int32\" === o.dtype) return lc(r, o);\n        var a = Ro(r.shape, o.shape);\n        return Lt.runKernelFunc(function(t, e) {\n            var n = t.realDivide(r, o);\n            return e([\n                r,\n                o\n            ]), n;\n        }, {\n            a: r,\n            b: o\n        }, function(t, e) {\n            var n = e[0], r = e[1];\n            return {\n                a: function() {\n                    var e = t.div(r.toFloat()), o = Eo(n.shape, a);\n                    return o.length > 0 ? e.sum(o).reshape(n.shape) : e;\n                },\n                b: function() {\n                    var e = t.mul(n.toFloat()), o = Eo(r.shape, a);\n                    o.length > 0 && (e = e.sum(o).reshape(r.shape));\n                    var i = r.square();\n                    return e.div(i.toFloat()).neg();\n                }\n            };\n        }, \"Div\");\n    }\n}), uc = An({\n    divNoNan_: function(t, e) {\n        var n, r = mn(t, \"a\", \"div\"), o = mn(e, \"b\", \"div\");\n        r = (n = Nt(r, o))[0], o = n[1];\n        var a = sc(r, o), i = Xn(a), s = o.equal(i);\n        return ec(s, i, a);\n    }\n}), cc = An({\n    divStrict_: function(t, e) {\n        var n = mn(t, \"a\", \"div\"), r = mn(e, \"b\", \"div\");\n        return E(n.shape, r.shape, \"Error in divideStrict: \"), n.div(r);\n    }\n}), lc = An({\n    floorDiv_: function(t, e) {\n        var n, r = mn(t, \"a\", \"floorDiv\"), o = mn(e, \"b\", \"floorDiv\");\n        n = Nt(r, o), r = n[0], o = n[1];\n        var a = Ro(r.shape, o.shape);\n        return Lt.runKernelFunc(function(t, e) {\n            var n = t.floorDiv(r, o);\n            return e([\n                r,\n                o\n            ]), n;\n        }, {\n            a: r,\n            b: o\n        }, function(t, e) {\n            var n = e[0], r = e[1];\n            return {\n                a: function() {\n                    var e = t.div(r.toFloat()), o = Eo(n.shape, a);\n                    return o.length > 0 ? e.sum(o).reshape(n.shape) : e;\n                },\n                b: function() {\n                    var e = t.mul(n.toFloat()), o = Eo(r.shape, a);\n                    o.length > 0 && (e = e.sum(o).reshape(r.shape));\n                    var i = r.square();\n                    return e.div(i.toFloat()).neg();\n                }\n            };\n        }, \"FloorDiv\");\n    }\n}), hc = An({\n    maximum_: function(t, e) {\n        var n, r = mn(t, \"a\", \"maximum\"), o = mn(e, \"b\", \"maximum\");\n        return n = Nt(r, o), r = n[0], o = n[1], \"bool\" === r.dtype && (r = r.toInt(), o = o.toInt()), Ro(r.shape, o.shape), Lt.runKernelFunc(function(t, e) {\n            var n = t.maximum(r, o);\n            return e([\n                r,\n                o\n            ]), n;\n        }, {\n            a: r,\n            b: o\n        }, function(t, e) {\n            var n = e[0], r = e[1];\n            return {\n                a: function() {\n                    return t.mul(n.greaterEqual(r).toFloat());\n                },\n                b: function() {\n                    return t.mul(n.less(r).toFloat());\n                }\n            };\n        }, \"Maximum\");\n    }\n}), fc = An({\n    maximumStrict_: function(t, e) {\n        var n = mn(t, \"a\", \"maximumStrict\"), r = mn(e, \"b\", \"maximumStrict\");\n        return E(n.shape, r.shape, \"Error in maximumStrict: \"), n.maximum(r);\n    }\n}), dc = An({\n    minimum_: function(t, e) {\n        var n, r = mn(t, \"a\", \"minimum\"), o = mn(e, \"b\", \"minimum\");\n        return n = Nt(r, o), r = n[0], o = n[1], \"bool\" === r.dtype && (r = r.toInt(), o = o.toInt()), Ro(r.shape, o.shape), Lt.runKernelFunc(function(t, e) {\n            var n = t.minimum(r, o);\n            return e([\n                r,\n                o\n            ]), n;\n        }, {\n            a: r,\n            b: o\n        }, function(t, e) {\n            var n = e[0], r = e[1];\n            return {\n                a: function() {\n                    return t.mul(n.lessEqual(r).toFloat());\n                },\n                b: function() {\n                    return t.mul(n.greater(r).toFloat());\n                }\n            };\n        }, \"Minimum\");\n    }\n}), pc = An({\n    minimumStrict_: function(t, e) {\n        var n = mn(t, \"a\", \"minimumStrict\"), r = mn(e, \"b\", \"minimumStrict\");\n        return E(n.shape, r.shape, \"Error in minimumStrict: \"), n.minimum(r);\n    }\n}), vc = An({\n    mod_: function(t, e) {\n        var n, r = mn(t, \"a\", \"mod\"), o = mn(e, \"b\", \"mod\");\n        n = Nt(r, o), r = n[0], o = n[1];\n        var a = Ro(r.shape, o.shape);\n        return Lt.runKernelFunc(function(t, e) {\n            var n = t.mod(r, o);\n            return e([\n                r,\n                o\n            ]), n;\n        }, {\n            $a: r,\n            $b: o\n        }, function(t, e) {\n            var n = e[0], r = e[1];\n            return {\n                $a: function() {\n                    var e = Eo(n.shape, a);\n                    return e.length > 0 ? t.sum(e).reshape(n.shape) : t;\n                },\n                $b: function() {\n                    var e = t.mul(n.div(r).floor().neg()), o = Eo(r.shape, a);\n                    return o.length > 0 ? e.sum(o).reshape(r.shape) : e;\n                }\n            };\n        });\n    }\n}), mc = An({\n    modStrict_: function(t, e) {\n        var n = mn(t, \"a\", \"modStrict\"), r = mn(e, \"b\", \"modStrict\");\n        return E(n.shape, r.shape, \"Error in modStrict: \"), n.mod(r);\n    }\n}), gc = An({\n    mul_: function(t, e) {\n        var n, r = mn(t, \"a\", \"mul\"), o = mn(e, \"b\", \"mul\");\n        n = Nt(r, o), r = n[0], o = n[1];\n        var a = Ro(r.shape, o.shape);\n        return Lt.runKernelFunc(function(t, e) {\n            var n = t.multiply(r, o);\n            return e([\n                r,\n                o\n            ]), n;\n        }, {\n            a: r,\n            b: o\n        }, function(t, e) {\n            var n = e[0], r = e[1];\n            return {\n                a: function() {\n                    var e = t.mul(r.toFloat()), o = Eo(n.shape, a);\n                    return o.length > 0 ? e.sum(o).reshape(n.shape) : e;\n                },\n                b: function() {\n                    var e = t.mul(n.toFloat()), o = Eo(r.shape, a);\n                    return o.length > 0 ? e.sum(o).reshape(r.shape) : e;\n                }\n            };\n        }, \"Mul\");\n    }\n}), yc = An({\n    mulStrict_: function(t, e) {\n        var n = mn(t, \"a\", \"mul\"), r = mn(e, \"b\", \"mul\");\n        return E(n.shape, r.shape, \"Error in multiplyStrict: \"), n.mul(r);\n    }\n}), xc = An({\n    pow_: function(t, e) {\n        var n, r = mn(t, \"base\", \"pow\"), o = mn(e, \"exp\", \"pow\");\n        n = Nt(r, o), r = n[0], o = n[1];\n        var a = Ro(r.shape, o.shape), i = [\n            r,\n            o\n        ];\n        return Lt.runKernelFunc(function(t, e) {\n            var n = t.pow(r, o);\n            return e([\n                r,\n                o,\n                n\n            ]), n;\n        }, {\n            a: r,\n            b: o\n        }, function(t, e) {\n            var n = e[0], r = e[1], o = e[2];\n            return {\n                a: function() {\n                    var e = r.toFloat(), o = t.mul(e.mul(n.pow(e.sub(On(1))))), i = Eo(n.shape, a);\n                    return i.length > 0 && (o = o.sum(i)), o.reshape(n.shape);\n                },\n                b: function() {\n                    var e = n.greater(0), i = n.log().where(e, Xn(n)), s = t.mul(o.mul(i)), u = Eo(r.shape, a);\n                    return u.length > 0 && (s = s.sum(u)), s.reshape(r.shape);\n                }\n            };\n        }, \"Pow\", {}, i, [\n            !0\n        ]);\n    }\n}), bc = An({\n    powStrict_: function(t, e) {\n        return E(t.shape, e.shape, \"Error in powStrict: \"), t.pow(e);\n    }\n}), wc = An({\n    squaredDifferenceStrict_: function(t, e) {\n        var n = mn(t, \"a\", \"squaredDifferenceStrict\"), r = mn(e, \"b\", \"squaredDifferenceStrict\");\n        return E(n.shape, r.shape, \"Error in squaredDifferenceStrict: \"), n.squaredDifference(r);\n    }\n}), Cc = An({\n    sub_: function(t, e) {\n        var n, r = mn(t, \"a\", \"sub\"), o = mn(e, \"b\", \"sub\");\n        n = Nt(r, o), r = n[0], o = n[1];\n        var a = Ro(r.shape, o.shape);\n        return Lt.runKernelFunc(function(t) {\n            return t.subtract(r, o);\n        }, {\n            a: r,\n            b: o\n        }, function(t) {\n            return {\n                a: function() {\n                    var e = t, n = Eo(r.shape, a);\n                    return n.length > 0 && (e = e.sum(n)), e.reshape(r.shape);\n                },\n                b: function() {\n                    var e = t, n = Eo(o.shape, a);\n                    return n.length > 0 && (e = e.sum(n)), e.neg().reshape(o.shape);\n                }\n            };\n        }, \"Sub\");\n    }\n}), Ec = An({\n    subStrict_: function(t, e) {\n        var n = mn(t, \"a\", \"subStrict\"), r = mn(e, \"b\", \"subStrict\");\n        return E(n.shape, r.shape, \"Error in subStrict: \"), n.sub(r);\n    }\n});\nvar Rc = An({\n    equal_: function(t, e) {\n        var n, r = mn(t, \"a\", \"equal\"), o = mn(e, \"b\", \"equal\");\n        return n = Nt(r, o), r = n[0], o = n[1], Ro(r.shape, o.shape), Lt.runKernelFunc(function(t) {\n            return t.equal(r, o);\n        }, {\n            $a: r,\n            $b: o\n        });\n    }\n}), Ic = An({\n    equalStrict_: function(t, e) {\n        var n = mn(t, \"a\", \"equalStrict\"), r = mn(e, \"b\", \"equalStrict\");\n        return E(n.shape, r.shape, \"Error in equalStrict: \"), n.equal(r);\n    }\n}), kc = An({\n    greater_: function(t, e) {\n        var n, r = mn(t, \"a\", \"greater\"), o = mn(e, \"b\", \"greater\");\n        return n = Nt(r, o), r = n[0], o = n[1], Ro(r.shape, o.shape), Lt.runKernelFunc(function(t) {\n            return t.greater(r, o);\n        }, {\n            a: r,\n            b: o\n        }, null, \"Greater\");\n    }\n}), Sc = An({\n    greaterEqual_: function(t, e) {\n        var n, r = mn(t, \"a\", \"greaterEqual\"), o = mn(e, \"b\", \"greaterEqual\");\n        return n = Nt(r, o), r = n[0], o = n[1], Ro(r.shape, o.shape), Lt.runKernelFunc(function(t, e) {\n            var n = t.greaterEqual(r, o);\n            return e([\n                r,\n                o\n            ]), n;\n        }, {\n            a: r,\n            b: o\n        }, function(t, e) {\n            var n = e[0], r = e[1];\n            return {\n                a: function() {\n                    return Xn(n);\n                },\n                b: function() {\n                    return Xn(r);\n                }\n            };\n        }, \"GreaterEqual\");\n    }\n}), Ac = An({\n    greaterEqualStrict_: function(t, e) {\n        var n = mn(t, \"a\", \"greaterEqualStrict\"), r = mn(e, \"b\", \"greaterEqualStrict\");\n        return E(n.shape, r.shape, \"Error in greaterEqualStrict: \"), n.greaterEqual(r);\n    }\n}), Dc = An({\n    greaterStrict_: function(t, e) {\n        var n = mn(t, \"a\", \"greaterStrict\"), r = mn(e, \"b\", \"greaterStrict\");\n        return E(n.shape, r.shape, \"Error in greaterStrict: \"), n.greater(r);\n    }\n}), Tc = An({\n    less_: function(t, e) {\n        var n, r = mn(t, \"a\", \"less\"), o = mn(e, \"b\", \"less\");\n        return n = Nt(r, o), r = n[0], o = n[1], Ro(r.shape, o.shape), Lt.runKernelFunc(function(t) {\n            return t.less(r, o);\n        }, {\n            a: r,\n            b: o\n        }, null, \"Less\");\n    }\n}), Nc = An({\n    lessEqual_: function(t, e) {\n        var n, r = mn(t, \"a\", \"lessEqual\"), o = mn(e, \"b\", \"lessEqual\");\n        return n = Nt(r, o), r = n[0], o = n[1], Ro(r.shape, o.shape), Lt.runKernelFunc(function(t, e) {\n            var n = t.lessEqual(r, o);\n            return e([\n                r,\n                o\n            ]), n;\n        }, {\n            a: r,\n            b: o\n        }, null, \"LessEqual\");\n    }\n}), Fc = An({\n    lessEqualStrict_: function(t, e) {\n        var n = mn(t, \"a\", \"lessEqualStrict\"), r = mn(e, \"b\", \"lessEqualStrict\");\n        return E(n.shape, r.shape, \"Error in lessEqualStrict: \"), n.lessEqual(r);\n    }\n}), _c = An({\n    lessStrict_: function(t, e) {\n        var n = mn(t, \"a\", \"lessStrict\"), r = mn(e, \"b\", \"lessStrict\");\n        return E(n.shape, r.shape, \"Error in lessStrict: \"), n.less(r);\n    }\n}), Oc = An({\n    notEqual_: function(t, e) {\n        var n, r = mn(t, \"a\", \"notEqual\"), o = mn(e, \"b\", \"notEqual\");\n        return n = Nt(r, o), r = n[0], o = n[1], Ro(r.shape, o.shape), Lt.runKernelFunc(function(t) {\n            return t.notEqual(r, o);\n        }, {\n            a: r,\n            b: o\n        }, null, \"NotEqual\");\n    }\n}), Mc = An({\n    notEqualStrict_: function(t, e) {\n        var n = mn(t, \"a\", \"notEqualStrict\"), r = mn(e, \"b\", \"notEqualStrict\");\n        return E(n.shape, r.shape, \"Error in notEqualStrict: \"), n.notEqual(r);\n    }\n});\nfunction Bc(t, e) {\n    for(var n = [], r = t; r < e; ++r)n.push(r);\n    return n;\n}\nfunction Pc(t) {\n    for(var e = [], n = 0; n < t.length; ++n)for(var r = 0; r < t[n].length; ++r)e.push(t[n][r]);\n    return e;\n}\nvar Lc = An({\n    gather_: function(t, e, n) {\n        void 0 === n && (n = 0);\n        var r = mn(t, \"x\", \"gather\"), o = mn(e, \"indices\", \"gather\", \"int32\");\n        n = O(n, r.shape)[0];\n        var a = function(t, e, n) {\n            for(var r = t.shape[n], o = [], a = 1, i = 1, s = 0; s < n; s++)o.push(t.shape[s]), a *= t.shape[s];\n            for(s = 0; s < e.rank; s++)o.push(e.shape[s]);\n            for(s = n + 1; s < t.rank; s++)o.push(t.shape[s]), i *= t.shape[s];\n            return {\n                batchSize: a,\n                sliceSize: i,\n                dimSize: r,\n                outputShape: o\n            };\n        }(r, o, n);\n        return Lt.runKernelFunc(function(t, e) {\n            var a = t.gather(r, o.flatten(), n);\n            return e([\n                o\n            ]), a;\n        }, {\n            x: r,\n            indices: o\n        }, function(t, e) {\n            var o = e[0];\n            return {\n                x: function() {\n                    var e = r.shape, a = o.size, i = e.slice(0, n), s = i.length, u = e.slice(n, e.length).slice(1), c = u.length, l = Bc(0, s), h = Bc(s + 1, s + 1 + c), f = Pc([\n                        i,\n                        [\n                            a\n                        ],\n                        u\n                    ]), d = t.reshape(f), p = o.reshape([\n                        a\n                    ]), v = Pc([\n                        [\n                            s\n                        ],\n                        l,\n                        h\n                    ]), m = d.transpose(v), g = Wc(m, p, r.shape[n]), y = Rn(v);\n                    return g = g.transpose(y);\n                },\n                indices: function() {\n                    return o;\n                }\n            };\n        }, \"Gather\", {\n            axis: n\n        }).reshape(a.outputShape);\n    }\n}), Wc = An({\n    unsortedSegmentSum_: function(t, e, n) {\n        var r = mn(t, \"x\", \"unsortedSegmentSum\"), o = mn(e, \"segmentIds\", \"unsortedSegmentSum\", \"int32\");\n        return C(A(n), function() {\n            return \"numSegments must be of dtype int\";\n        }), Lt.runKernelFunc(function(t, e) {\n            var a = t.unsortedSegmentSum(r, o, n);\n            return e([\n                o\n            ]), a;\n        }, {\n            $x: r\n        }, function(t, e) {\n            var n = e[0];\n            return {\n                $x: function() {\n                    return function(t, e) {\n                        for(var n = hc(e, Xn(e)), r = Lc(t, n), o = Sc(e, On(0, \"int32\")), a = r.rank - o.rank, i = 0; i < a; ++i)o = wr(o, i + 1);\n                        o = Qu(o, zn(r.shape, \"bool\"));\n                        var s = Xn(r);\n                        return ec(o, r, s);\n                    }(t, n);\n                }\n            };\n        });\n    }\n});\nvar Uc = function(t, e, o) {\n    return n(this, void 0, void 0, function() {\n        var n, a, i, s, u, c, l, h, f, d, p, v, m;\n        return r(this, function(r) {\n            switch(r.label){\n                case 0:\n                    for(n = mn(t, \"tensor\", \"boolMask\"), a = mn(e, \"mask\", \"boolMask\", \"bool\"), i = null == o ? 0 : o, s = a.rank, u = n.shape, C(s > 0, function() {\n                        return \"mask cannot be scalar\";\n                    }), E(u.slice(i, i + s), a.shape, \"mask's shape must match the first K dimensions of tensor's shape,\"), c = 1, l = i; l < i + s; l++)c *= u[l];\n                    return h = u.slice(0, i).concat([\n                        c\n                    ], u.slice(i + s)), f = n.reshape(h), d = a.reshape([\n                        -1\n                    ]), [\n                        4,\n                        nc(d)\n                    ];\n                case 1:\n                    return p = r.sent(), v = p.squeeze([\n                        1\n                    ]), m = Lc(f, v, i), t !== n && n.dispose(), e !== a && a.dispose(), v.dispose(), f.dispose(), d.dispose(), p.dispose(), [\n                        2,\n                        m\n                    ];\n            }\n        });\n    });\n};\nfunction Vc(t, e, n, r, o, a, i) {\n    void 0 === a && (a = \"NHWC\"), C(t.length === e.rank, function() {\n        return \"Length of inShape (\" + t.length + \") and rank of dy (\" + e.rank + \") must match\";\n    });\n    var s = t, u = e, c = !1;\n    3 === e.rank && (c = !0, u = e.as4D(1, e.shape[0], e.shape[1], e.shape[2]), s = [\n        1,\n        t[0],\n        t[1],\n        t[2]\n    ]), C(4 === s.length, function() {\n        return \"Error in conv2dDerInput: inShape must be length 4, but got length \" + s.length + \".\";\n    }), C(4 === u.rank, function() {\n        return \"Error in conv2dDerInput: dy must be rank 4, but got rank \" + u.rank;\n    }), C(4 === n.rank, function() {\n        return \"Error in conv2dDerInput: filter must be rank 4, but got rank \" + n.rank;\n    });\n    var l = \"NHWC\" === a ? s[3] : s[1], h = \"NHWC\" === a ? u.shape[3] : u.shape[1];\n    C(l === n.shape[2], function() {\n        return \"Error in conv2dDerInput: depth of input (\" + l + \") must match input depth for filter \" + n.shape[2] + \".\";\n    }), C(h === n.shape[3], function() {\n        return \"Error in conv2dDerInput: depth of output (\" + h + \") must match output depth for filter \" + n.shape[3] + \".\";\n    }), null != i && C(A(o), function() {\n        return \"Error in conv2dDerInput: pad must be an integer when using, dimRoundingMode \" + i + \" but got pad \" + o + \".\";\n    });\n    var f = Bo(a), d = So(s, n.shape, r, 1, o, i, !1, f), p = Lt.runKernelFunc(function(t, e) {\n        var r = t.conv2dDerInput(u, n, d);\n        return e([\n            n,\n            u\n        ]), r;\n    }, {\n        dy4D: u,\n        filter: n\n    }, function(t, e) {\n        var n = e[0], s = e[1];\n        return {\n            dy4D: function() {\n                return qc(t, n, r, o, a, 1, i);\n            },\n            filter: function() {\n                return jc(t, s, n.shape, r, o, a, i);\n            }\n        };\n    });\n    return c ? p.as3D(p.shape[1], p.shape[2], p.shape[3]) : p;\n}\nfunction zc(t) {\n    var e = function(t) {\n        return \"number\" == typeof t ? [\n            t,\n            t,\n            t\n        ] : 2 === t.length ? [\n            t[0],\n            t[1],\n            1\n        ] : t;\n    }(t), n = e[0], r = e[1], o = e[2];\n    return 1 === n && 1 === r && 1 === o;\n}\nfunction Gc(t, e, n, r, o) {\n    C(t.length === e.rank, function() {\n        return \"Length of inShape (\" + t.length + \") and rank of dy (\" + e.rank + \") must match\";\n    });\n    var a = t, i = e, s = !1;\n    4 === e.rank && (s = !0, i = e.as5D(1, e.shape[0], e.shape[1], e.shape[2], e.shape[3]), a = [\n        1,\n        t[0],\n        t[1],\n        t[2],\n        t[3]\n    ]);\n    var u = a[4], c = i.shape[4];\n    C(5 === a.length, function() {\n        return \"Error in conv3dDerInput: inShape must be length 5, but got length \" + a.length + \".\";\n    }), C(5 === i.rank, function() {\n        return \"Error in conv3dDerInput: dy must be rank 5, but got rank \" + i.rank;\n    }), C(5 === n.rank, function() {\n        return \"Error in conv3dDerInput: filter must be rank 5, but got rank \" + n.rank;\n    }), C(u === n.shape[3], function() {\n        return \"Error in conv3dDerInput: depth of input (\" + u + \") must match input depth for filter \" + n.shape[3] + \".\";\n    }), C(c === n.shape[4], function() {\n        return \"Error in conv3dDerInput: depth of output (\" + c + \") must match output depth for filter \" + n.shape[4] + \".\";\n    });\n    var l = Ao(a, n.shape, r, 1, o), h = Lt.runKernelFunc(function(t) {\n        return t.conv3dDerInput(i, n, l);\n    }, {\n        dy5D: i\n    });\n    return s ? h.as4D(h.shape[1], h.shape[2], h.shape[3], h.shape[4]) : h;\n}\nvar Hc = An({\n    conv1d_: function(t, e, n, r, o, a, i) {\n        void 0 === o && (o = \"NWC\"), void 0 === a && (a = 1);\n        var s = mn(t, \"x\", \"conv1d\"), u = mn(e, \"filter\", \"conv1d\"), c = s, l = !1;\n        2 === s.rank && (l = !0, c = s.as3D(1, s.shape[0], s.shape[1])), C(3 === c.rank, function() {\n            return \"Error in conv1d: input must be rank 3, but got rank \" + c.rank + \".\";\n        }), C(3 === u.rank, function() {\n            return \"Error in conv1d: filter must be rank 3, but got rank \" + u.rank + \".\";\n        }), null != i && C(A(r), function() {\n            return \"Error in conv1d: pad must be an integer when using, dimRoundingMode \" + i + \" but got pad \" + r + \".\";\n        }), C(c.shape[2] === u.shape[1], function() {\n            return \"Error in conv1d: depth of input (\" + c.shape[2] + \") must match input depth for filter \" + u.shape[1] + \".\";\n        }), C(Mo(n, a), function() {\n            return \"Error in conv1D: Either stride or dilation must be 1. Got stride \" + n + \" and dilation '\" + a + \"'\";\n        }), C(\"NWC\" === o, function() {\n            return \"Error in conv1d: got dataFormat of \" + o + \" but only NWC is currently supported.\";\n        });\n        var h = u.as4D(1, u.shape[0], u.shape[1], u.shape[2]), f = c.as4D(c.shape[0], 1, c.shape[1], c.shape[2]), d = qc(f, h, [\n            1,\n            n\n        ], r, \"NHWC\", [\n            1,\n            a\n        ], i);\n        return l ? d.as2D(d.shape[2], d.shape[3]) : d.as3D(d.shape[0], d.shape[2], d.shape[3]);\n    }\n}), qc = An({\n    conv2d_: function(t, e, n, r, o, a, i) {\n        void 0 === o && (o = \"NHWC\"), void 0 === a && (a = [\n            1,\n            1\n        ]);\n        var s = mn(t, \"x\", \"conv2d\"), u = mn(e, \"filter\", \"conv2d\"), c = s, l = !1;\n        3 === s.rank && (l = !0, c = s.as4D(1, s.shape[0], s.shape[1], s.shape[2])), C(4 === c.rank, function() {\n            return \"Error in conv2d: input must be rank 4, but got rank \" + c.rank + \".\";\n        }), C(4 === u.rank, function() {\n            return \"Error in conv2d: filter must be rank 4, but got rank \" + u.rank + \".\";\n        }), null != i && C(A(r), function() {\n            return \"Error in conv2d: pad must be an integer when using, dimRoundingMode \" + i + \" but got pad \" + r + \".\";\n        });\n        var h = \"NHWC\" === o ? c.shape[3] : c.shape[1];\n        C(h === u.shape[2], function() {\n            return \"Error in conv2d: depth of input (\" + h + \") must match input depth for filter \" + u.shape[2] + \".\";\n        }), C(Mo(n, a), function() {\n            return \"Error in conv2D: Either strides or dilations must be 1. Got strides \" + n + \" and dilations '\" + a + \"'\";\n        });\n        var f = Bo(o), d = So(c.shape, u.shape, n, a, r, i, !1, f), p = [\n            u,\n            c\n        ], v = Lt.runKernelFunc(function(t, e) {\n            var n = t.conv2d(c, u, d);\n            return e([\n                u,\n                c\n            ]), n;\n        }, {\n            x: c,\n            filter: u\n        }, function(t, e) {\n            var i = e, s = i[0], u = i[1];\n            return C(Oo(a), function() {\n                return \"Error in gradient of conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '\" + a + \"'\";\n            }), {\n                x: function() {\n                    return Xc(u.shape, t, s, n, r, o);\n                },\n                filter: function() {\n                    return jc(u, t, s.shape, n, r, o);\n                }\n            };\n        }, \"Conv2D\", d, p);\n        return l ? v.as3D(v.shape[1], v.shape[2], v.shape[3]) : v;\n    }\n}), Kc = An({\n    conv3d_: function(t, e, n, r, o, a) {\n        void 0 === o && (o = \"NDHWC\"), void 0 === a && (a = [\n            1,\n            1,\n            1\n        ]);\n        var i = mn(t, \"x\", \"conv3d\"), s = mn(e, \"filter\", \"conv3d\"), u = i, c = !1;\n        4 === i.rank && (c = !0, u = i.as5D(1, i.shape[0], i.shape[1], i.shape[2], i.shape[3])), C(5 === u.rank, function() {\n            return \"Error in conv3d: input must be rank 5, but got rank \" + u.rank + \".\";\n        }), C(5 === s.rank, function() {\n            return \"Error in conv3d: filter must be rank 5, but got rank \" + s.rank + \".\";\n        }), C(u.shape[4] === s.shape[3], function() {\n            return \"Error in conv3d: depth of input (\" + u.shape[4] + \") must match input depth for filter \" + s.shape[3] + \".\";\n        }), C(function(t, e) {\n            return zc(t) || zc(e);\n        }(n, a), function() {\n            return \"Error in conv3D: Either strides or dilations must be 1. Got strides \" + n + \" and dilations '\" + a + \"'\";\n        }), C(\"NDHWC\" === o, function() {\n            return \"Error in conv3d: got dataFormat of \" + o + \" but only NDHWC is currently supported.\";\n        });\n        var l = Ao(u.shape, s.shape, n, a, r), h = Lt.runKernelFunc(function(t, e) {\n            var n = t.conv3d(u, s, l);\n            return e([\n                u,\n                s\n            ]), n;\n        }, {\n            x: u,\n            $filter: s\n        }, function(t, e) {\n            C(zc(a), function() {\n                return \"Error in gradient of conv3D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '\" + a + \"'\";\n            });\n            var o = e[0], i = e[1];\n            return {\n                x: function() {\n                    return Gc(o.shape, t, i, n, r);\n                },\n                $filter: function() {\n                    return function(t, e, n, r, o) {\n                        var a = t;\n                        4 === t.rank && (a = t.as5D(1, t.shape[0], t.shape[1], t.shape[2], t.shape[3]));\n                        var i = e;\n                        4 === i.rank && (i = e.as5D(1, e.shape[0], e.shape[1], e.shape[2], e.shape[3]));\n                        C(5 === a.rank, function() {\n                            return \"Error in conv3dDerFilter: input must be rank 5, but got shape \" + a.shape + \".\";\n                        }), C(5 === i.rank, function() {\n                            return \"Error in conv3dDerFilter: dy must be rank 5, but got shape \" + i.shape + \".\";\n                        }), C(5 === n.length, function() {\n                            return \"Error in conv3dDerFilter: filterShape must be length 5, but got \" + n + \".\";\n                        }), C(a.shape[4] === n[3], function() {\n                            return \"Error in conv3dDerFilter: depth of input \" + a.shape[4] + \") must match input depth in filter (\" + n[3] + \".\";\n                        }), C(i.shape[4] === n[4], function() {\n                            return \"Error in conv3dDerFilter: depth of dy (\" + i.shape[4] + \") must match output depth for filter (\" + n[4] + \").\";\n                        });\n                        var s = Ao(a.shape, n, r, 1, o);\n                        return Lt.runKernelFunc(function(t) {\n                            return t.conv3dDerFilter(a, i, s);\n                        }, {\n                            x5D: a,\n                            dy5D: i\n                        });\n                    }(o, t, i.shape, n, r);\n                }\n            };\n        });\n        return c ? h.as4D(h.shape[1], h.shape[2], h.shape[3], h.shape[4]) : h;\n    }\n}), jc = An({\n    conv2dDerFilter_: function(t, e, n, r, o, a, i) {\n        void 0 === a && (a = \"NHWC\");\n        var s = t;\n        3 === t.rank && (s = t.as4D(1, t.shape[0], t.shape[1], t.shape[2]));\n        var u = e;\n        3 === u.rank && (u = e.as4D(1, e.shape[0], e.shape[1], e.shape[2])), C(4 === s.rank, function() {\n            return \"Error in conv2dDerFilter: input must be rank 4, but got shape \" + s.shape + \".\";\n        }), C(4 === u.rank, function() {\n            return \"Error in conv2dDerFilter: dy must be rank 4, but got shape \" + u.shape + \".\";\n        }), C(4 === n.length, function() {\n            return \"Error in conv2dDerFilter: filterShape must be length 4, but got \" + n + \".\";\n        });\n        var c = \"NHWC\" === a ? s.shape[3] : s.shape[1], l = \"NHWC\" === a ? u.shape[3] : u.shape[1];\n        C(c === n[2], function() {\n            return \"Error in conv2dDerFilter: depth of input \" + c + \") must match input depth in filter (\" + n[2] + \".\";\n        }), C(l === n[3], function() {\n            return \"Error in conv2dDerFilter: depth of dy (\" + l + \") must match output depth for filter (\" + n[3] + \").\";\n        }), null != i && C(A(o), function() {\n            return \"Error in conv2dDerFilter: pad must be an integer when using, dimRoundingMode \" + i + \" but got pad \" + o + \".\";\n        });\n        var h = Bo(a), f = So(s.shape, n, r, 1, o, i, !1, h);\n        return Lt.runKernelFunc(function(t) {\n            return t.conv2dDerFilter(s, u, f);\n        }, {\n            x4D: s,\n            dy4D: u\n        });\n    }\n}), Xc = An({\n    conv2dDerInput_: Vc\n}), Yc = An({\n    depthwiseConv2d_: function(t, e, n, r, o, a, i) {\n        void 0 === o && (o = \"NHWC\"), void 0 === a && (a = [\n            1,\n            1\n        ]);\n        var s = mn(t, \"x\", \"depthwiseConv2d\"), u = mn(e, \"filter\", \"depthwiseConv2d\"), c = s, l = !1;\n        3 === s.rank && (l = !0, c = s.as4D(1, s.shape[0], s.shape[1], s.shape[2])), C(4 === c.rank, function() {\n            return \"Error in depthwiseConv2d: input must be rank 4, but got rank \" + c.rank + \".\";\n        }), C(4 === u.rank, function() {\n            return \"Error in depthwiseConv2d: filter must be rank 4, but got rank \" + u.rank + \".\";\n        }), C(c.shape[3] === u.shape[2], function() {\n            return \"Error in depthwiseConv2d: number of input channels (\" + c.shape[3] + \") must match the inChannels dimension in filter \" + u.shape[2] + \".\";\n        }), null == a && (a = [\n            1,\n            1\n        ]), C(Mo(n, a), function() {\n            return \"Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides \" + n + \" and dilations '\" + a + \"'\";\n        }), null != i && C(A(r), function() {\n            return \"Error in depthwiseConv2d: pad must be an integer when using, dimRoundingMode \" + i + \" but got pad \" + r + \".\";\n        });\n        var h = So(c.shape, u.shape, n, a, r, i, !0), f = [\n            c,\n            u\n        ], d = Lt.runKernelFunc(function(t, e) {\n            var n = t.depthwiseConv2D(c, u, h);\n            return e([\n                c,\n                u\n            ]), n;\n        }, {\n            x: c,\n            filter: u\n        }, function(t, e) {\n            C(Oo(a), function() {\n                return \"Error in gradient of depthwiseConv2d: dilation rates greater than 1 are not yet supported. Got dilations '\" + a + \"'\";\n            });\n            var n = e[0], r = e[1];\n            return {\n                x: function() {\n                    return $c(n.shape, t, r, h);\n                },\n                filter: function() {\n                    return Qc(n, t, r.shape, h);\n                }\n            };\n        }, \"DepthwiseConv2dNative\", h, f);\n        return l ? d.as3D(d.shape[1], d.shape[2], d.shape[3]) : d;\n    }\n}), $c = An({\n    depthwiseConv2dDerInput_: function(t, e, n, r) {\n        var o = e, a = !1;\n        3 === e.rank && (a = !0, o = e.as4D(1, e.shape[0], e.shape[1], e.shape[2]));\n        var i = Lt.runKernelFunc(function(t) {\n            return t.depthwiseConv2DDerInput(o, n, r);\n        }, {\n            dy4D: o\n        });\n        return a ? i.as3D(i.shape[1], i.shape[2], i.shape[3]) : i;\n    }\n}), Qc = An({\n    depthwiseConv2dDerFilter_: function(t, e, n, r) {\n        var o = t;\n        3 === t.rank && (o = t.as4D(1, t.shape[0], t.shape[1], t.shape[2]));\n        var a = e;\n        return 3 === a.rank && (a = e.as4D(1, e.shape[0], e.shape[1], e.shape[2])), Lt.runKernelFunc(function(t) {\n            return t.depthwiseConv2DDerFilter(o, a, r);\n        }, {\n            x4D: o,\n            dy4D: a\n        });\n    }\n}), Jc = An({\n    separableConv2d_: function(t, e, n, r, o, a, i) {\n        void 0 === a && (a = [\n            1,\n            1\n        ]), void 0 === i && (i = \"NHWC\");\n        var s = mn(t, \"x\", \"separableConv2d\"), u = mn(e, \"depthwiseFilter\", \"separableConv2d\"), c = mn(n, \"pointwiseFilter\", \"separableConv2d\"), l = s, h = !1;\n        if (3 === s.rank && (h = !0, l = s.as4D(1, s.shape[0], s.shape[1], s.shape[2])), \"NCHW\" === i) throw new Error(\"separableConv2d currently does not support dataFormat NCHW; only NHWC is supported\");\n        C(4 === l.rank, function() {\n            return \"Error in separableConv2d: input must be rank 4, but got rank \" + l.rank + \".\";\n        }), C(4 === u.rank, function() {\n            return \"Error in separableConv2d: depthwise filter must be rank 4, but got rank \" + u.rank + \".\";\n        }), C(4 === c.rank, function() {\n            return \"Error in separableConv2d: pointwise filter must be rank 4, but got rank \" + u.rank + \".\";\n        }), C(1 === c.shape[0], function() {\n            return \"Error in separableConv2d: the first dimension of pointwise filter  must be 1, but got \" + c.shape[0] + \".\";\n        }), C(1 === c.shape[1], function() {\n            return \"Error in separableConv2d: the second dimension of pointwise filter must be 1, but got \" + c.shape[1] + \".\";\n        });\n        var f = u.shape[2], d = u.shape[3];\n        C(c.shape[2] === f * d, function() {\n            return \"Error in separableConv2d: the third dimension of pointwise filter must be \" + f * d + \", but got \" + c.shape[2] + \".\";\n        });\n        var p = Yc(l, u, r, o, i, a), v = qc(p, c, 1, \"valid\", i);\n        return h ? v.as3D(v.shape[1], v.shape[2], v.shape[3]) : v;\n    }\n}), Zc = An({\n    conv2dTranspose_: function(t, e, n, r, o, a) {\n        return Vc(n, mn(t, \"x\", \"conv2dTranspose\"), mn(e, \"filter\", \"conv2dTranspose\"), r, o, \"NHWC\", a);\n    }\n}), tl = An({\n    conv3dTranspose_: function(t, e, n, r, o) {\n        return Gc(n, mn(t, \"x\", \"conv3dTranspose\"), mn(e, \"filter\", \"conv3dTranspose\"), r, o);\n    }\n});\nvar el = An({\n    matMul_: function(t, e, n, r) {\n        var o;\n        void 0 === n && (n = !1), void 0 === r && (r = !1);\n        var a = mn(t, \"a\", \"matMul\"), i = mn(e, \"b\", \"matMul\");\n        o = Nt(a, i), a = o[0], i = o[1];\n        var s = n ? a.shape[a.rank - 2] : a.shape[a.rank - 1], u = r ? i.shape[i.rank - 1] : i.shape[i.rank - 2], c = n ? a.shape[a.rank - 1] : a.shape[a.rank - 2], l = r ? i.shape[i.rank - 2] : i.shape[i.rank - 1], h = a.shape.slice(0, -2), f = i.shape.slice(0, -2), d = k(h), p = k(f);\n        C(a.rank >= 2 && i.rank >= 2 && a.rank === i.rank, function() {\n            return \"Error in matMul: inputs must have the same rank of at least 2, got ranks \" + a.rank + \" and \" + i.rank + \".\";\n        }), C(S(h, f), function() {\n            return \"Error in matMul: outer dimensions (\" + h + \") and (\" + f + \") of Tensors with shapes \" + a.shape + \" and \" + i.shape + \" must match.\";\n        }), C(s === u, function() {\n            return \"Error in matMul: inner shapes (\" + s + \") and (\" + u + \") of Tensors with shapes \" + a.shape + \" and \" + i.shape + \" and transposeA=\" + n + \" and transposeB=\" + r + \" must match.\";\n        });\n        var v = a.shape.slice(0, -2).concat([\n            c,\n            l\n        ]), m = n ? a.as3D(d, s, c) : a.as3D(d, c, s), g = r ? i.as3D(p, l, u) : i.as3D(p, u, l), y = {\n            transposeA: n,\n            transposeB: r\n        };\n        return Lt.runKernelFunc(function(t, e) {\n            var o = t.batchMatMul(m, g, n, r);\n            return e([\n                m,\n                g\n            ]), o;\n        }, {\n            a: m,\n            b: g\n        }, function(t, e) {\n            var o = e, a = o[0], i = o[1];\n            return n || r ? !n && r ? {\n                a: function() {\n                    return t.matMul(i, !1, !1);\n                },\n                b: function() {\n                    return t.matMul(a, !0, !1);\n                }\n            } : n && !r ? {\n                a: function() {\n                    return i.matMul(t, !1, !0);\n                },\n                b: function() {\n                    return a.matMul(t, !1, !1);\n                }\n            } : {\n                a: function() {\n                    return i.matMul(t, !0, !0);\n                },\n                b: function() {\n                    return t.matMul(a, !0, !0);\n                }\n            } : {\n                a: function() {\n                    return t.matMul(i, !1, !0);\n                },\n                b: function() {\n                    return a.matMul(t, !0, !1);\n                }\n            };\n        }, \"BatchMatMul\", y).reshape(v);\n    }\n}), nl = An({\n    dot_: function(t, e) {\n        var n = mn(t, \"t1\", \"dot\"), r = mn(e, \"t2\", \"dot\");\n        C(!(1 !== n.rank && 2 !== n.rank || 1 !== r.rank && 2 !== r.rank), function() {\n            return \"Error in dot: inputs must all be rank 1 or 2, but got ranks \" + n.rank + \" and \" + r.rank + \".\";\n        });\n        var o = 1 === n.rank ? n.size : n.shape[1], a = 1 === r.rank ? r.size : r.shape[0];\n        return C(o === a, function() {\n            return \"Error in dot: inner dimensions of inputs must match, but got \" + o + \" and \" + a + \".\";\n        }), 1 === n.rank && 1 === r.rank ? n.as2D(1, -1).matMul(r.as2D(-1, 1)).asScalar() : 1 === n.rank && 2 === r.rank ? n.as2D(1, -1).matMul(r.as2D(r.shape[0], r.shape[1])).as1D() : 2 === n.rank && 1 === r.rank ? n.matMul(r.as2D(-1, 1)).as1D() : n.matMul(r.as2D(r.shape[0], r.shape[1]));\n    }\n}), rl = An({\n    outerProduct_: function(t, e) {\n        var n = mn(t, \"v1\", \"outerProduct\"), r = mn(e, \"v2\", \"outerProduct\");\n        return C(1 === n.rank && 1 === r.rank, function() {\n            return \"Error in outerProduct: inputs must be rank 1, but got ranks \" + n.rank + \" and \" + r.rank + \".\";\n        }), n.as2D(-1, 1).matMul(r.as2D(1, -1));\n    }\n});\nvar ol = An({\n    reverse_: function(t, e) {\n        var n = mn(t, \"x\", \"reverse\");\n        if (0 === n.rank) return n.clone();\n        var r = O(e, n.shape);\n        return Lt.runKernelFunc(function(t) {\n            return t.reverse(n, r);\n        }, {\n            $x: n\n        }, function(t) {\n            return {\n                $x: function() {\n                    return t.reverse(r);\n                }\n            };\n        }).reshapeAs(n);\n    }\n}), al = An({\n    reverse1d_: function(t) {\n        var e = mn(t, \"x\", \"reverse\");\n        return C(1 === e.rank, function() {\n            return \"Error in reverse1D: x must be rank 1 but got rank \" + e.rank + \".\";\n        }), ol(e, 0);\n    }\n}), il = An({\n    reverse2d_: function(t, e) {\n        var n = mn(t, \"x\", \"reverse\");\n        return C(2 === n.rank, function() {\n            return \"Error in reverse2D: x must be rank 2 but got rank \" + n.rank + \".\";\n        }), ol(n, e);\n    }\n}), sl = An({\n    reverse3d_: function(t, e) {\n        var n = mn(t, \"x\", \"reverse\");\n        return C(3 === n.rank, function() {\n            return \"Error in reverse3D: x must be rank 3 but got rank \" + n.rank + \".\";\n        }), ol(n, e);\n    }\n}), ul = An({\n    reverse4d_: function(t, e) {\n        var n = mn(t, \"x\", \"reverse\");\n        return C(4 === n.rank, function() {\n            return \"Error in reverse4D: x must be rank 4 but got rank \" + n.rank + \".\";\n        }), ol(n, e);\n    }\n});\nfunction cl(t, e, n, r, o, a) {\n    var i = mn(t, \"x\", \"maxPool\"), s = i, u = !1;\n    3 === i.rank && (u = !0, s = i.as4D(1, i.shape[0], i.shape[1], i.shape[2])), null == r && (r = [\n        1,\n        1\n    ]), C(4 === s.rank, function() {\n        return \"Error in maxPool: input must be rank 4 but got rank \" + s.rank + \".\";\n    }), C(Mo(n, r), function() {\n        return \"Error in maxPool: Either strides or dilations must be 1. Got strides \" + n + \" and dilations '\" + r + \"'\";\n    }), null != a && C(A(o), function() {\n        return \"Error in maxPool: pad must be an integer when using, dimRoundingMode \" + a + \" but got pad \" + o + \".\";\n    });\n    var c = Io(s.shape, e, n, r, o, a);\n    if (1 === c.filterWidth && 1 === c.filterHeight && S(c.inShape, c.outShape)) return i.clone();\n    var l = [\n        s\n    ], h = Lt.runKernelFunc(function(t, e) {\n        var n = t.maxPool(s, c);\n        return e([\n            s,\n            n\n        ]), n;\n    }, {\n        x: s\n    }, function(t, a) {\n        var i = a[0], s = a[1];\n        return {\n            x: function() {\n                return function(t, e, n, r, o, a, i, s) {\n                    var u = mn(t, \"dy\", \"maxPoolBackprop\"), c = mn(e, \"input\", \"maxPoolBackprop\"), l = mn(n, \"output\", \"maxPoolBackprop\");\n                    C(c.rank === u.rank, function() {\n                        return \"Rank of input (\" + c.rank + \") does not match rank of dy (\" + u.rank + \")\";\n                    }), null == a && (a = [\n                        1,\n                        1\n                    ]);\n                    C(Mo(o, a), function() {\n                        return \"Error in maxPoolBackProp: Either strides or dilations must be 1. Got strides \" + o + \" and dilations '\" + a + \"'\";\n                    }), C(4 === u.rank, function() {\n                        return \"Error in maxPoolBackprop: dy must be rank 4 but got rank \" + u.rank + \".\";\n                    }), C(4 === c.rank, function() {\n                        return \"Error in maxPoolBackprop: input must be rank 4 but got rank \" + c.rank + \".\";\n                    }), null != s && C(A(i), function() {\n                        return \"Error in maxPoolBackprop: pad must be an integer when using, dimRoundingMode \" + s + \" but got pad \" + i + \".\";\n                    });\n                    var h = Io(c.shape, r, o, a, i, s);\n                    return Lt.runKernelFunc(function(t) {\n                        return t.maxPoolBackprop(u, c, l, h);\n                    }, {\n                        $dy: u,\n                        $input: c\n                    });\n                }(t, i, s, e, n, r, o);\n            }\n        };\n    }, \"MaxPool\", c, l);\n    return u ? h.as3D(h.shape[1], h.shape[2], h.shape[3]) : h;\n}\nfunction ll(t, e, n, r, o, a) {\n    var i = mn(t, \"x\", \"avgPool\", \"float32\");\n    null == r && (r = [\n        1,\n        1\n    ]), C(Mo(n, r), function() {\n        return \"Error in avgPool: Either strides or dilations must be 1. Got strides \" + n + \" and dilations '\" + r + \"'\";\n    });\n    var s = i, u = !1;\n    3 === i.rank && (u = !0, s = i.as4D(1, i.shape[0], i.shape[1], i.shape[2])), C(4 === s.rank, function() {\n        return \"Error in avgPool: x must be rank 4 but got rank \" + s.rank + \".\";\n    }), null != a && C(A(o), function() {\n        return \"Error in avgPool: pad must be an integer when using, dimRoundingMode \" + a + \" but got pad \" + o + \".\";\n    });\n    var c = Io(s.shape, e, n, r, o, a);\n    if (1 === c.filterWidth && 1 === c.filterHeight && S(c.inShape, c.outShape)) return i.clone();\n    var l = Lt.runKernelFunc(function(t) {\n        return t.avgPool(s, c);\n    }, {\n        x: s\n    }, function(t) {\n        return {\n            x: function() {\n                return function(t, e, n, r, o, a) {\n                    var i = mn(t, \"dy\", \"avgPoolBackprop\"), s = mn(e, \"input\", \"avgPoolBackprop\");\n                    C(s.rank === i.rank, function() {\n                        return \"Rank of input (\" + s.rank + \") does not match rank of dy (\" + i.rank + \")\";\n                    }), null == o && (o = [\n                        1,\n                        1\n                    ]);\n                    C(Mo(r, o), function() {\n                        return \"Error in avgPoolBackprop: Either strides or dilations must be 1. Got strides \" + r + \" and dilations '\" + o + \"'\";\n                    });\n                    var u = s, c = i, l = !1;\n                    3 === s.rank && (l = !0, u = s.as4D(1, s.shape[0], s.shape[1], s.shape[2]), c = i.as4D(1, i.shape[0], i.shape[1], i.shape[2]));\n                    C(4 === c.rank, function() {\n                        return \"Error in avgPoolBackprop: dy must be rank 4 but got rank \" + c.rank + \".\";\n                    }), C(4 === u.rank, function() {\n                        return \"Error in avgPoolBackprop: input must be rank 4 but got rank \" + u.rank + \".\";\n                    });\n                    var h = Io(u.shape, n, r, o, a), f = Lt.runKernelFunc(function(t) {\n                        return t.avgPoolBackprop(c, u, h);\n                    }, {\n                        dy4D: c,\n                        input4D: u\n                    });\n                    if (l) return f.as3D(f.shape[1], f.shape[2], f.shape[3]);\n                    return f;\n                }(t, s, e, n, r, o);\n            }\n        };\n    }, \"AvgPool\", c);\n    return l = l.cast(i.dtype), u ? l.as3D(l.shape[1], l.shape[2], l.shape[3]) : l;\n}\nvar hl = An({\n    maxPool_: function(t, e, n, r, o) {\n        return cl(t, e, n, 1, r, o);\n    }\n}), fl = An({\n    avgPool_: function(t, e, n, r, o) {\n        return ll(t, e, n, 1, r, o);\n    }\n}), dl = An({\n    pool_: function(t, e, n, r, o, a) {\n        null == o && (o = [\n            1,\n            1\n        ]), null == a && (a = 1), 0 === r && (r = \"valid\");\n        var i = mn(t, \"x\", \"maxPool\"), s = i, u = !1;\n        3 === i.rank && (u = !0, s = i.as4D(1, i.shape[0], i.shape[1], i.shape[2])), C(Mo(a, o), function() {\n            return \"Error in pool: Either strides or dilations must be 1. Got strides \" + a + \" and dilations '\" + o + \"'\";\n        });\n        var c, l = Io(s.shape, e, a, o, r), h = [\n            l.dilationHeight,\n            l.dilationWidth\n        ];\n        c = \"same\" === r ? function(t, e) {\n            var n = t.map(function(t, n) {\n                return t + (t - 1) * (e[n] - 1);\n            }).map(function(t) {\n                return t - 1;\n            }), r = n.map(function(t) {\n                return Math.floor(t / 2);\n            }), o = n.map(function(t, e) {\n                return t - r[e];\n            });\n            return n.map(function(t, e) {\n                return [\n                    r[e],\n                    o[e]\n                ];\n            });\n        }([\n            l.filterHeight,\n            l.filterWidth\n        ], h) : [\n            [\n                0,\n                0\n            ],\n            [\n                0,\n                0\n            ]\n        ];\n        var f = 1 === h[0] && 1 === h[1], d = function(t, e, n) {\n            var r = n.map(function(t) {\n                return t[0];\n            }), o = n.map(function(t) {\n                return t[1];\n            }), a = t.concat(r, o), i = e.map(function(t, e) {\n                return (t - a[e] % t) % t;\n            }), s = o.map(function(t, e) {\n                return t + i[e];\n            }), u = e.map(function(t, e) {\n                return [\n                    r[e],\n                    s[e]\n                ];\n            }), c = e.map(function(t, e) {\n                return [\n                    0,\n                    i[e]\n                ];\n            });\n            return [\n                u,\n                c\n            ];\n        }([\n            l.inHeight,\n            l.inWidth\n        ], h, c), p = d[0], v = d[1], m = f ? r : \"valid\", g = f ? s : Mr(s, h, p), y = (\"avg\" === n ? function() {\n            return ll(g, e, a, 1, m);\n        } : function() {\n            return cl(g, e, a, 1, m);\n        })(), x = f ? y : vr(y, h, v);\n        return u ? x.as3D(x.shape[1], x.shape[2], x.shape[3]) : x;\n    }\n}), pl = An({\n    maxPool3d_: function(t, e, n, r, o, a, i) {\n        void 0 === a && (a = \"NDHWC\");\n        var s = mn(t, \"x\", \"maxPool3d\"), u = s, c = !1;\n        4 === s.rank && (c = !0, u = s.as5D(1, s.shape[0], s.shape[1], s.shape[2], s.shape[3])), null == i && (i = [\n            1,\n            1,\n            1\n        ]), C(5 === u.rank, function() {\n            return \"Error in maxPool3d: x must be rank 5 but got rank \" + u.rank + \".\";\n        }), C(\"NDHWC\" === a, function() {\n            return \"Error in maxPool3d: Only NDHWC is currently supported, but got dataFormat of \" + a;\n        }), C(Mo(n, i), function() {\n            return \"Error in maxPool3d: Either strides or dilations must be 1. Got strides \" + n + \" and dilations '\" + i + \"'\";\n        }), null != o && C(A(r), function() {\n            return \"Error in maxPool3d: pad must be an integer when using, dimRoundingMode \" + o + \" but got pad \" + r + \".\";\n        });\n        var l = ko(u.shape, e, n, i, r, o, a), h = Lt.runKernelFunc(function(t, e) {\n            var n = t.maxPool3d(u, l);\n            return e([\n                u,\n                n\n            ]), n;\n        }, {\n            x: u\n        }, function(t, a) {\n            var s = a[0], u = a[1];\n            return {\n                x: function() {\n                    return function(t, e, n, r, o, a, i, s) {\n                        var u = mn(t, \"dy\", \"maxPool3dBackprop\"), c = mn(e, \"input\", \"maxPool3dBackprop\"), l = mn(n, \"output\", \"maxPool3dBackprop\"), h = u, f = c, d = l, p = !1;\n                        4 === c.rank && (p = !0, h = u.as5D(1, u.shape[0], u.shape[1], u.shape[2], u.shape[3]), f = c.as5D(1, c.shape[0], c.shape[1], c.shape[2], c.shape[3]), d = l.as5D(1, l.shape[0], l.shape[1], l.shape[2], l.shape[3]));\n                        C(5 === h.rank, function() {\n                            return \"Error in maxPool3dBackprop: dy must be rank 5 but got rank \" + h.rank + \".\";\n                        }), C(5 === f.rank, function() {\n                            return \"Error in maxPool3dBackprop: input must be rank 5 but got rank \" + f.rank + \".\";\n                        }), C(5 === d.rank, function() {\n                            return \"Error in maxPool3dBackprop: output must be rank 5 but got rank \" + d.rank + \".\";\n                        }), null == a && (a = [\n                            1,\n                            1,\n                            1\n                        ]);\n                        C(Mo(o, a), function() {\n                            return \"Error in maxPool3dBackprop: Either strides or dilations must be 1. Got strides \" + o + \" and dilations '\" + a + \"'\";\n                        }), null != s && C(A(i), function() {\n                            return \"Error in maxPool3dBackprop: pad must be an integer when using, dimRoundingMode \" + s + \" but got pad \" + i + \".\";\n                        });\n                        var v = ko(f.shape, r, o, a, i, s), m = Lt.runKernelFunc(function(t) {\n                            return t.maxPool3dBackprop(h, f, d, v);\n                        }, {\n                            dy5D: h,\n                            input5D: f\n                        });\n                        if (p) return m.as4D(m.shape[1], m.shape[2], m.shape[3], m.shape[4]);\n                        return m;\n                    }(t, s, u, e, n, i, r, o);\n                }\n            };\n        });\n        return c ? h.as4D(h.shape[1], h.shape[2], h.shape[3], h.shape[4]) : h;\n    }\n}), vl = An({\n    avgPool3d_: function(t, e, n, r, o, a, i) {\n        void 0 === a && (a = \"NDHWC\");\n        var s = mn(t, \"x\", \"avgPool3d\", \"float32\"), u = s, c = !1;\n        4 === s.rank && (c = !0, u = s.as5D(1, s.shape[0], s.shape[1], s.shape[2], s.shape[3])), null == i && (i = [\n            1,\n            1,\n            1\n        ]), C(5 === u.rank, function() {\n            return \"Error in avgPool3d: x must be rank 5 but got rank \" + u.rank + \".\";\n        }), C(\"NDHWC\" === a, function() {\n            return \"Error in avgPool3d: Only NDHWC is currently supported, but got dataFormat of \" + a;\n        }), C(Mo(n, i), function() {\n            return \"Error in avgPool3d: Either strides or dilations must be 1. Got strides \" + n + \" and dilations '\" + i + \"'\";\n        }), null != o && C(A(r), function() {\n            return \"Error in avgPool3d: pad must be an integer when using, dimRoundingMode \" + o + \" but got pad \" + r + \".\";\n        });\n        var l = ko(u.shape, e, n, i, r, o, a), h = Lt.runKernelFunc(function(t) {\n            return t.avgPool3d(u, l);\n        }, {\n            x: u\n        }, function(t) {\n            return {\n                x: function() {\n                    return function(t, e, n, r, o, a, i) {\n                        var s = mn(t, \"dy\", \"avgPool3dBackprop\"), u = mn(e, \"input\", \"avgPool3dBackprop\"), c = s, l = u, h = !1;\n                        4 === u.rank && (h = !0, c = s.as5D(1, s.shape[0], s.shape[1], s.shape[2], s.shape[3]), l = u.as5D(1, u.shape[0], u.shape[1], u.shape[2], u.shape[3]));\n                        C(5 === c.rank, function() {\n                            return \"Error in avgPool3dBackprop: dy must be rank 5 but got rank \" + c.rank + \".\";\n                        }), C(5 === l.rank, function() {\n                            return \"Error in avgPool3dBackprop: input must be rank 5 but got rank \" + l.rank + \".\";\n                        }), null == o && (o = [\n                            1,\n                            1,\n                            1\n                        ]);\n                        C(Mo(r, o), function() {\n                            return \"Error in avgPool3dBackprop: Either strides or dilations must be 1. Got strides \" + r + \" and dilations '\" + o + \"'\";\n                        }), null != i && C(A(a), function() {\n                            return \"Error in maxPool3dBackprop: pad must be an integer when using, dimRoundingMode \" + i + \" but got pad \" + a + \".\";\n                        });\n                        var f = ko(l.shape, n, r, o, a, i), d = Lt.runKernelFunc(function(t) {\n                            return t.avgPool3dBackprop(c, l, f);\n                        }, {\n                            dy5D: c,\n                            input5D: l\n                        });\n                        if (h) return d.as4D(d.shape[1], d.shape[2], d.shape[3], d.shape[4]);\n                        return d;\n                    }(t, u, e, n, i, r, o);\n                }\n            };\n        });\n        return h = h.cast(u.dtype), c ? h.as4D(h.shape[1], h.shape[2], h.shape[3], h.shape[4]) : h;\n    }\n});\nvar ml = An({\n    slice_: function(t, e, n) {\n        var r, o, a = mn(t, \"x\", \"slice\");\n        if (0 === a.rank) throw new Error(\"Slicing scalar is not possible\");\n        (r = \"number\" == typeof e ? [\n            e\n        ].concat(new Array(a.rank - 1).fill(0)) : e.length < a.rank ? e.concat(new Array(a.rank - e.length).fill(0)) : e.slice()).forEach(function(t) {\n            C(-1 !== t, function() {\n                return \"slice() does not support negative begin indexing.\";\n            });\n        }), o = (o = null == n ? new Array(a.rank).fill(-1) : \"number\" == typeof n ? [\n            n\n        ].concat(new Array(a.rank - 1).fill(-1)) : n.length < a.rank ? n.concat(new Array(a.rank - n.length).fill(-1)) : n).map(function(t, e) {\n            return t >= 0 ? t : (C(-1 === t, function() {\n                return \"Negative size values should be exactly -1 but got \" + t + \" for the slice() size at index \" + e + \".\";\n            }), a.shape[e] - r[e]);\n        }), eo(a, r, o);\n        var i = a.shape, s = {\n            begin: r,\n            size: o\n        };\n        return Lt.runKernelFunc(function(t) {\n            return t.slice(a, r, o);\n        }, {\n            x: a\n        }, function(t) {\n            for(var e = [], n = 0; n < t.rank; n++)e.push([\n                r[n],\n                i[n] - r[n] - o[n]\n            ]);\n            return {\n                x: function() {\n                    return t.pad(e);\n                }\n            };\n        }, \"Slice\", s);\n    }\n}), gl = An({\n    slice1d_: function(t, e, n) {\n        var r = mn(t, \"x\", \"slice1d\");\n        return C(1 === r.rank, function() {\n            return \"slice1d expects a rank-1 tensor, but got a rank-\" + r.rank + \" tensor\";\n        }), ml(r, [\n            e\n        ], [\n            n\n        ]);\n    }\n}), yl = An({\n    slice2d_: function(t, e, n) {\n        var r = mn(t, \"x\", \"slice2d\");\n        return C(2 === r.rank, function() {\n            return \"slice2d expects a rank-2 tensor, but got a rank-\" + r.rank + \" tensor\";\n        }), ml(r, e, n);\n    }\n}), xl = An({\n    slice3d_: function(t, e, n) {\n        var r = mn(t, \"x\", \"slice3d\");\n        return C(3 === r.rank, function() {\n            return \"slice3d expects a rank-3 tensor, but got a rank-\" + r.rank + \" tensor\";\n        }), ml(r, e, n);\n    }\n}), bl = An({\n    slice4d_: function(t, e, n) {\n        var r = mn(t, \"x\", \"slice4d\");\n        return C(4 === r.rank, function() {\n            return \"slice4d expects a rank-4 tensor, but got a rank-\" + r.rank + \" tensor\";\n        }), ml(r, e, n);\n    }\n});\nfunction wl(t, e, n, r, o) {\n    return e.rank < n.rank && (e = e.reshape(wn(e.shape, r))), t.rank < n.rank && (t = t.reshape(wn(t.shape, r))), {\n        x: function() {\n            var r = t.mul(n.equal(e).cast(t.dtype));\n            return null == o ? r : r.transpose(o);\n        }\n    };\n}\nvar Cl = An({\n    all_: function(t, e, n) {\n        void 0 === e && (e = null), void 0 === n && (n = !1);\n        var r = mn(t, \"x\", \"all\", \"bool\"), o = O(e, r.shape), a = o, i = En(a, r.rank);\n        null != i && (r = r.transpose(i), a = In(a.length, r.rank));\n        var s = Lt.runKernelFunc(function(t) {\n            return t.all(r, a);\n        }, {\n            $x: r\n        });\n        if (n) {\n            var u = wn(s.shape, o);\n            return s.reshape(u);\n        }\n        return s;\n    }\n}), El = An({\n    any_: function(t, e, n) {\n        void 0 === e && (e = null), void 0 === n && (n = !1);\n        var r = mn(t, \"x\", \"any\", \"bool\"), o = O(e, r.shape), a = o, i = En(a, r.rank);\n        null != i && (r = r.transpose(i), a = In(a.length, r.rank));\n        var s = Lt.runKernelFunc(function(t) {\n            return t.any(r, a);\n        }, {\n            $x: r\n        });\n        if (n) {\n            var u = wn(s.shape, o);\n            return s.reshape(u);\n        }\n        return s;\n    }\n}), Rl = An({\n    argMax_: function(t, e) {\n        void 0 === e && (e = 0);\n        var n = mn(t, \"x\", \"argMax\");\n        null == e && (e = 0);\n        var r = O(e, n.shape), o = En(r, n.rank);\n        null != o && (n = n.transpose(o), r = In(r.length, n.rank));\n        var a = {\n            axis: r[0]\n        }, i = [\n            n\n        ];\n        return Lt.runKernelFunc(function(t, e) {\n            var o = t.argMax(n, r[0]);\n            return e([\n                n\n            ]), o;\n        }, {\n            x: n\n        }, function(t, e) {\n            var n = e[0];\n            return {\n                x: function() {\n                    return Xn(n);\n                }\n            };\n        }, \"ArgMax\", a, i);\n    }\n}), Il = An({\n    argMin_: function(t, e) {\n        void 0 === e && (e = 0);\n        var n = mn(t, \"x\", \"argMin\");\n        null == e && (e = 0);\n        var r = O(e, n.shape), o = En(r, n.rank);\n        return null != o && (n = n.transpose(o), r = In(r.length, n.rank)), Lt.runKernelFunc(function(t, e) {\n            var o = t.argMin(n, r[0]);\n            return e([\n                n\n            ]), o;\n        }, {\n            $x: n\n        }, function(t, e) {\n            var n = e[0];\n            return {\n                $x: function() {\n                    return Xn(n);\n                }\n            };\n        });\n    }\n}), kl = An({\n    logSumExp_: function(t, e, n) {\n        void 0 === e && (e = null), void 0 === n && (n = !1);\n        var r = mn(t, \"x\", \"logSumExp\"), o = O(e, r.shape), a = r.max(o, !0), i = r.sub(a).exp().sum(o).log(), s = a.reshape(i.shape).add(i);\n        if (n) {\n            var u = wn(s.shape, o);\n            return s.reshape(u);\n        }\n        return s;\n    }\n}), Sl = An({\n    max_: function(t, e, n) {\n        void 0 === e && (e = null), void 0 === n && (n = !1);\n        var r = mn(t, \"x\", \"max\"), o = r, a = O(e, r.shape), i = a, s = En(i, r.rank);\n        null != s && (r = r.transpose(s), i = In(i.length, r.rank));\n        var u = [\n            r\n        ], c = Lt.runKernelFunc(function(t, e) {\n            var n = t.max(r, i);\n            return e([\n                o,\n                n\n            ]), n;\n        }, {\n            x: r\n        }, function(t, e) {\n            return wl(t, e[1], e[0], a, s);\n        }, \"Max\", {\n            axes: i\n        }, u, [\n            !0\n        ]);\n        if (n) {\n            var l = wn(c.shape, a);\n            c = c.reshape(l);\n        }\n        return c;\n    }\n}), Al = An({\n    mean_: function(t, e, n) {\n        void 0 === e && (e = null), void 0 === n && (n = !1);\n        var r = mn(t, \"x\", \"mean\"), o = O(e, r.shape), a = k(bn(r.shape, o)[1]);\n        return vo(function(t) {\n            var r = On(a);\n            return {\n                value: (r.dtype === t.dtype ? t : t.cast(r.dtype)).div(r).sum(e, n),\n                gradFunc: function(e) {\n                    var n = t.shape.slice();\n                    return o.forEach(function(t) {\n                        n[t] = 1;\n                    }), e.reshape(n).mul(zn(t.shape, \"float32\")).div(a);\n                }\n            };\n        })(r);\n    }\n}), Dl = An({\n    min_: function(t, e, n) {\n        void 0 === e && (e = null), void 0 === n && (n = !1);\n        var r = mn(t, \"x\", \"min\"), o = r, a = O(e, r.shape), i = a, s = En(i, r.rank);\n        null != s && (r = r.transpose(s), i = In(i.length, r.rank));\n        var u = [\n            r\n        ], c = Lt.runKernelFunc(function(t, e) {\n            var n = t.min(r, i);\n            return e([\n                o,\n                n\n            ]), n;\n        }, {\n            x: r\n        }, function(t, e) {\n            return wl(t, e[1], e[0], a, s);\n        }, \"Min\", {\n            axes: i\n        }, u, [\n            !0\n        ]);\n        if (n) {\n            var l = wn(c.shape, a);\n            c = c.reshape(l);\n        }\n        return c;\n    }\n}), Tl = An({\n    moments_: function(t, e, n) {\n        void 0 === e && (e = null), void 0 === n && (n = !1);\n        var r = O(e, (t = mn(t, \"x\", \"moments\")).shape), o = t.mean(r, n), a = o.shape;\n        n || (a = wn(o.shape, r));\n        var i = t.toFloat().sub(o.reshape(a)).square();\n        return {\n            mean: o,\n            variance: i.mean(r, n)\n        };\n    }\n}), Nl = An({\n    sum_: function(t, e, n) {\n        void 0 === e && (e = null), void 0 === n && (n = !1);\n        var r = mn(t, \"x\", \"sum\");\n        \"bool\" === r.dtype && (r = r.toInt());\n        var o = O(e, r.shape);\n        return vo(function(t) {\n            var e = En(o, t.rank), r = o, a = t;\n            null != e && (a = t.transpose(e), r = In(r.length, t.rank));\n            var i = function(e) {\n                var n = t.shape.slice();\n                return o.forEach(function(t) {\n                    n[t] = 1;\n                }), e.reshape(n).mul(zn(t.shape, \"float32\"));\n            }, s = {\n                axes: r\n            }, u = Lt.runKernelFunc(function(t) {\n                return t.sum(a, r);\n            }, {\n                x: a\n            }, function(t) {\n                return {\n                    x: function() {\n                        return i(t);\n                    }\n                };\n            }, \"Sum\", s);\n            if (n) {\n                var c = wn(u.shape, o);\n                u = u.reshape(c);\n            }\n            return {\n                value: u,\n                gradFunc: i\n            };\n        })(r);\n    }\n}), Fl = An({\n    prod_: function(t, e, n) {\n        void 0 === e && (e = null), void 0 === n && (n = !1);\n        var r = mn(t, \"x\", \"prod\");\n        \"bool\" === r.dtype && (r = r.toInt());\n        var o = O(e, r.shape), a = En(o, r.rank), i = o, s = r;\n        null != a && (s = r.transpose(a), i = In(i.length, r.rank));\n        var u = Lt.runKernelFunc(function(t) {\n            return t.prod(s, i);\n        }, {\n            permutedX: s\n        });\n        if (n) {\n            var c = wn(u.shape, o);\n            u = u.reshape(c);\n        }\n        return u;\n    }\n});\nvar _l = An({\n    elu_: function(t) {\n        var e = mn(t, \"x\", \"elu\");\n        return Lt.runKernelFunc(function(t, n) {\n            var r = t.elu(e);\n            return n([\n                r\n            ]), r;\n        }, {\n            $x: e\n        }, function(t, e) {\n            var n = e[0];\n            return {\n                $x: function() {\n                    return Lt.runKernelFunc(function(e) {\n                        return e.eluDer(t, n);\n                    }, {\n                        dy: t,\n                        y: n\n                    });\n                }\n            };\n        });\n    }\n}), Ol = An({\n    leakyRelu_: function(t, e) {\n        void 0 === e && (e = .2);\n        var n = mn(t, \"x\", \"leakyRelu\");\n        return hc(On(e).mul(n), n);\n    }\n}), Ml = An({\n    prelu_: function(t, e) {\n        var n = mn(t, \"x\", \"prelu\"), r = mn(e, \"alpha\", \"prelu\");\n        return Lt.runKernelFunc(function(t, e) {\n            var o = t.prelu(n, r);\n            return e([\n                n,\n                r\n            ]), o;\n        }, {\n            x: n,\n            alpha: r\n        }, function(t, e) {\n            var n = e[0], r = e[1], o = n.greater(0);\n            return {\n                x: function() {\n                    return ec(o, t, t.mul(r));\n                },\n                alpha: function() {\n                    var e = ec(o, Xn(t), t.mul(n)), a = Eo(r.shape, t.shape);\n                    return a.length > 0 && (e = e.sum(a)), e.reshape(r.shape);\n                }\n            };\n        }, \"Prelu\");\n    }\n}), Bl = An({\n    relu_: function(t) {\n        var e = mn(t, \"x\", \"relu\");\n        return \"bool\" === e.dtype ? e.toInt() : Lt.runKernelFunc(function(t, n) {\n            var r = t.relu(e);\n            return n([\n                e\n            ]), r;\n        }, {\n            x: e\n        }, function(t, e) {\n            var n = e[0];\n            return {\n                x: function() {\n                    return t.mulStrict(n.step().toFloat());\n                }\n            };\n        }, \"Relu\");\n    }\n}), Pl = An({\n    relu6_: function(t) {\n        var e = mn(t, \"x\", \"relu6\");\n        return \"bool\" === e.dtype ? e.toInt() : Lt.runKernelFunc(function(t, n) {\n            var r = t.relu6(e);\n            return n([\n                e\n            ]), r;\n        }, {\n            x: e\n        }, function(t, e) {\n            var n = e[0], r = n.lessEqual(6).mul(n.step());\n            return {\n                x: function() {\n                    return t.mulStrict(r.toFloat());\n                }\n            };\n        }, \"Relu6\");\n    }\n}), Ll = An({\n    selu_: function(t) {\n        var e = mn(t, \"x\", \"selu\");\n        return Lt.runKernelFunc(function(t, n) {\n            var r = t.selu(e);\n            return n([\n                e\n            ]), r;\n        }, {\n            $x: e\n        }, function(t, e) {\n            var n = e[0];\n            return {\n                $x: function() {\n                    var e = n.greater(On(0)), r = On(bs), o = On(ws), a = t.mul(o), i = t.mul(r).mul(n.toFloat().exp());\n                    return ec(e, a, i);\n                }\n            };\n        });\n    }\n});\nvar Wl = An({\n    transpose_: function(t, e) {\n        var n = mn(t, \"x\", \"transpose\");\n        if (null == e && (e = n.shape.map(function(t, e) {\n            return e;\n        }).reverse()), C(n.rank === e.length, function() {\n            return \"Error in transpose: rank of input \" + n.rank + \" must match length of perm \" + e + \".\";\n        }), e.forEach(function(t) {\n            C(t >= 0 && t < n.rank, function() {\n                return \"All entries in 'perm' must be between 0 and \" + (n.rank - 1) + \" but got \" + e;\n            });\n        }), n.rank <= 1) return n.clone();\n        var r = {\n            perm: e\n        };\n        return Lt.runKernelFunc(function(t) {\n            return t.transpose(n, e);\n        }, {\n            x: n\n        }, function(t) {\n            var n = Rn(e);\n            return {\n                x: function() {\n                    return t.transpose(n);\n                }\n            };\n        }, \"Transpose\", r);\n    }\n});\nvar Ul = An({\n    localResponseNormalization_: function(t, e, n, r, o) {\n        void 0 === e && (e = 5), void 0 === n && (n = 1), void 0 === r && (r = 1), void 0 === o && (o = .5);\n        var a = mn(t, \"x\", \"localResponseNormalization\");\n        C(4 === a.rank || 3 === a.rank, function() {\n            return \"Error in localResponseNormalization: x must be rank 3 or 4 but got\\n               rank \" + a.rank + \".\";\n        }), C(A(e), function() {\n            return \"Error in localResponseNormalization: depthRadius must be an integer but got depthRadius \" + e + \".\";\n        });\n        var i = a, s = !1;\n        3 === a.rank && (s = !0, i = a.as4D(1, a.shape[0], a.shape[1], a.shape[2]));\n        var u = Lt.runKernelFunc(function(t, a) {\n            var s = t.localResponseNormalization4D(i, e, n, r, o);\n            return a([\n                i,\n                s\n            ]), s;\n        }, {\n            x4D: i\n        }, function(t, a) {\n            var i = a[0], s = a[1];\n            return {\n                x4D: function() {\n                    return Lt.runKernelFunc(function(a) {\n                        return a.LRNGrad(t, i, s, e, n, r, o);\n                    }, {});\n                }\n            };\n        });\n        return s ? u.as3D(u.shape[1], u.shape[2], u.shape[3]) : u;\n    }\n});\nvar Vl = An({\n    norm_: function(t, e, n, r) {\n        void 0 === e && (e = \"euclidean\"), void 0 === n && (n = null), void 0 === r && (r = !1);\n        var o = function t(e, n, r) {\n            void 0 === r && (r = null);\n            if (0 === e.rank) return e.abs();\n            if (1 !== e.rank && null === r) return t(e.reshape([\n                -1\n            ]), n, r);\n            if (1 === e.rank || \"number\" == typeof r || Array.isArray(r) && 1 === r.length) {\n                if (1 === n) return e.abs().sum(r);\n                if (n === 1 / 0) return e.abs().max(r);\n                if (n === -1 / 0) return e.abs().min(r);\n                if (\"euclidean\" === n || 2 === n) return e.abs().pow(On(2, \"int32\")).sum(r).sqrt();\n                throw new Error(\"Error in norm: invalid ord value: \" + n);\n            }\n            if (Array.isArray(r) && 2 === r.length) {\n                if (1 === n) return e.abs().sum(r[0]).max(r[1] - 1);\n                if (n === 1 / 0) return e.abs().sum(r[1]).max(r[0]);\n                if (n === -1 / 0) return e.abs().sum(r[1]).min(r[0]);\n                if (\"fro\" === n || \"euclidean\" === n) return e.square().sum(r).sqrt();\n                throw new Error(\"Error in norm: invalid ord value: \" + n);\n            }\n            throw new Error(\"Error in norm: invalid axis: \" + r);\n        }(t = mn(t, \"x\", \"norm\"), e, n), a = o.shape;\n        if (r) {\n            var i = O(n, t.shape);\n            a = wn(o.shape, i);\n        }\n        return o.reshape(a);\n    }\n});\nvar zl = An({\n    basicLSTMCell_: function(t, e, n, r, o, a) {\n        var i = mn(t, \"forgetBias\", \"basicLSTMCell\"), s = mn(e, \"lstmKernel\", \"basicLSTMCell\"), u = mn(n, \"lstmBias\", \"basicLSTMCell\"), c = mn(r, \"data\", \"basicLSTMCell\"), l = mn(o, \"c\", \"basicLSTMCell\"), h = mn(a, \"h\", \"basicLSTMCell\"), f = c.concat(h, 1).matMul(s).add(u), d = f.shape[0], p = f.shape[1] / 4, v = [\n            d,\n            p\n        ], m = f.slice([\n            0,\n            0\n        ], v), g = f.slice([\n            0,\n            p\n        ], v), y = f.slice([\n            0,\n            2 * p\n        ], v), x = f.slice([\n            0,\n            3 * p\n        ], v), b = m.sigmoid().mulStrict(g.tanh()).addStrict(l.mulStrict(i.add(y).sigmoid())), w = b.tanh().mulStrict(x.sigmoid());\n        return [\n            b,\n            w\n        ];\n    }\n}), Gl = An({\n    multiRNNCell_: function(t, e, n, r) {\n        for(var o = mn(e, \"data\", \"multiRNNCell\"), a = gn(n, \"c\", \"multiRNNCell\"), i = gn(r, \"h\", \"multiRNNCell\"), s = o, u = [], c = 0; c < t.length; c++){\n            var l = t[c](s, a[c], i[c]);\n            u.push(l[0]), u.push(l[1]), s = l[1];\n        }\n        var h = [], f = [];\n        for(c = 0; c < u.length; c += 2)h.push(u[c]), f.push(u[c + 1]);\n        return [\n            h,\n            f\n        ];\n    }\n});\nvar Hl = An({\n    movingAverage_: function(t, e, n, r, o) {\n        void 0 === o && (o = !0);\n        var a = mn(t, \"v\", \"movingAverage\"), i = mn(e, \"x\", \"movingAverage\"), s = mn(n, \"decay\", \"movingAverage\");\n        Ft(a, i), C(S(a.shape, i.shape), function() {\n            return \"Shape mismatch in v and x\";\n        });\n        var u = On(1), c = u.sub(s), l = i.sub(a).mul(c);\n        if (o) {\n            C(null != r, function() {\n                return \"When using zeroDebias: true, step is required.\";\n            });\n            var h = mn(r, \"step\", \"movingAverage\");\n            l = l.div(u.sub(xc(s, h)));\n        }\n        return a.add(l);\n    }\n});\nvar ql = An({\n    stridedSlice_: function(t, e, n, r, o, a, i, s, u) {\n        if (void 0 === o && (o = 0), void 0 === a && (a = 0), void 0 === i && (i = 0), void 0 === s && (s = 0), void 0 === u && (u = 0), null == r && (r = new Array(e.length)), 0 !== i) throw new Error(\"ellipsis mask is not yet supported\");\n        var c = mn(t, \"x\", \"stridedSlice\"), l = no(s), h = c.shape.slice();\n        l.forEach(function(t) {\n            e[t] = 0, n[t] = 1, h.splice(t, 0, 1);\n        }), c = c.reshape(h);\n        for(var f = 0; f < c.rank; f++)e[f] = oo(o, e, r, c.shape, f), n[f] = ao(a, n, r, c.shape, f), r[f] = r[f] || 1;\n        var d = no(u);\n        d.forEach(function(t) {\n            n[t] = e[t] + 1, r[t] = 1;\n        });\n        var p = ro(e, n, r), v = p.filter(function(t, e) {\n            return -1 === d.indexOf(e);\n        });\n        return r.every(function(t) {\n            return 1 === t;\n        }) ? ml(c, e, p).reshape(v) : Lt.runKernelFunc(function(t) {\n            return t.stridedSlice(c, e, n, r);\n        }, {\n            $x: c\n        }).reshape(v);\n    }\n});\nvar Kl = An({\n    topk_: function(t, e, n) {\n        void 0 === e && (e = 1), void 0 === n && (n = !0);\n        var r = mn(t, \"x\", \"topk\");\n        if (0 === r.rank) throw new Error(\"topk() expects the input to be of rank 1 or higher\");\n        var o = r.shape[r.shape.length - 1];\n        if (e > o) throw new Error(\"'k' passed to topk() must be <= the last dimension (\" + o + \") but got \" + e);\n        var a = Lt.runKernelFunc(function(t) {\n            return t.topk(r, e, n);\n        }, {\n            $x: r\n        });\n        return {\n            values: a[0],\n            indices: a[1]\n        };\n    }\n});\nvar jl = An({\n    scatterND_: function(t, e, n) {\n        var r = mn(t, \"indices\", \"scatterND\", \"int32\"), o = mn(e, \"updates\", \"scatterND\");\n        return Jr(o, r, n), Lt.runKernelFunc(function(t) {\n            return t.scatterND(r, o, n);\n        }, {\n            indices: r,\n            updates: o\n        }, null, \"ScatterNd\", {\n            shape: n\n        });\n    }\n});\nvar Xl = An({\n    fft_: function(t) {\n        C(\"complex64\" === t.dtype, function() {\n            return \"The dtype for tf.spectral.fft() must be complex64 but got \" + t.dtype + \".\";\n        });\n        var e = t.shape[t.shape.length - 1], n = t.size / e, r = t.as2D(n, e);\n        return Lt.runKernelFunc(function(t) {\n            return t.fft(r);\n        }, {\n            input: t\n        }).reshape(t.shape);\n    }\n}), Yl = An({\n    ifft_: function(t) {\n        C(\"complex64\" === t.dtype, function() {\n            return \"The dtype for tf.spectral.ifft() must be complex64 but got \" + t.dtype + \".\";\n        });\n        var e = t.shape[t.shape.length - 1], n = t.size / e, r = t.as2D(n, e);\n        return Lt.runKernelFunc(function(t) {\n            return t.ifft(r);\n        }, {\n            input: t\n        }).reshape(t.shape);\n    }\n}), $l = An({\n    rfft_: function(t, e) {\n        C(\"float32\" === t.dtype, function() {\n            return \"The dtype for rfft() must be real value but got \" + t.dtype;\n        });\n        var n, r = t.shape[t.shape.length - 1], o = t.size / r;\n        if (null != e && e < r) {\n            var a = t.shape.map(function(t) {\n                return 0;\n            }), i = t.shape.map(function(t) {\n                return t;\n            });\n            i[t.shape.length - 1] = e, n = t.slice(a, i), r = e;\n        } else if (null != e && e > r) {\n            var s = t.shape.map(function(t) {\n                return t;\n            });\n            s[t.shape.length - 1] = e - r, n = t.concat(Gn(s), t.shape.length - 1), r = e;\n        } else n = t;\n        var u = n.zerosLike(), c = Dn(n, u).as2D(o, r), l = Xl(c), h = Math.floor(r / 2) + 1, f = Tn(l), d = Nn(l), p = f.split([\n            h,\n            r - h\n        ], f.shape.length - 1), v = d.split([\n            h,\n            r - h\n        ], d.shape.length - 1), m = n.shape.slice();\n        return m[n.shape.length - 1] = h, Dn(p[0], v[0]).reshape(m);\n    }\n}), Ql = An({\n    irfft_: function(t) {\n        var e = t.shape[t.shape.length - 1], n = t.size / e;\n        if (e <= 2) {\n            var r = t.as2D(n, e), o = Yl(r);\n            return Tn(o);\n        }\n        var a = [\n            n,\n            2 * (e - 1)\n        ], i = Tn(t).as2D(n, e), s = Nn(t).as2D(n, e), u = i.slice([\n            0,\n            1\n        ], [\n            n,\n            e - 2\n        ]).reverse(1), c = s.slice([\n            0,\n            1\n        ], [\n            n,\n            e - 2\n        ]).reverse(1).mul(On(-1)), l = i.concat(u, 1), h = s.concat(c, 1);\n        return r = Dn(l, h).as2D(a[0], a[1]), o = Yl(r), Tn(o);\n    }\n}), Jl = Object.freeze({\n    fft: Xl,\n    ifft: Yl,\n    rfft: $l,\n    irfft: Ql\n});\nvar Zl = An({\n    sparseToDense_: function(t, e, n, r) {\n        void 0 === r && (r = 0);\n        var o = mn(t, \"sparseIndices\", \"sparseToDense\", \"int32\"), a = mn(e, \"sparseValues\", \"sparseToDense\"), i = mn(r, \"defaultValue\", \"sparseToDense\", a.dtype);\n        return function(t, e, n, r) {\n            if (\"int32\" !== t.dtype) throw new Error(\"tf.sparseToDense() expects the indices to be int32 type, but the dtype was \" + t.dtype + \".\");\n            if (t.rank > 2) throw new Error(\"sparseIndices should be a scalar, vector, or matrix, but got shape \" + t.shape + \".\");\n            var o = t.rank > 0 ? t.shape[0] : 1, a = t.rank > 1 ? t.shape[1] : 1;\n            if (n.length !== a) throw new Error(\"outputShape has incorrect number of elements:, \" + n.length + \", should be: \" + a + \".\");\n            var i = e.size;\n            if (0 !== e.rank && (1 !== e.rank || i !== o)) throw new Error(\"sparseValues has incorrect shape \" + e.shape + \", should be [] or [\" + o + \"]\");\n            if (e.dtype !== r.dtype) throw new Error(\"sparseValues.dtype must match defaultValues.dtype\");\n        }(o, a, n, i), Lt.runKernelFunc(function(t) {\n            return t.sparseToDense(o, a, n, i);\n        }, {\n            $sparseIndices: o,\n            $sparseValues: a,\n            $defaultValue: i\n        });\n    }\n});\nvar th = An({\n    gatherND_: function(t, e) {\n        var n = mn(e, \"indices\", \"gatherND\", \"int32\"), r = mn(t, \"x\", \"gatherND\");\n        return Lt.runKernelFunc(function(t) {\n            return t.gatherND(r, n);\n        }, {\n            x: r,\n            indices: n\n        }, null, \"GatherNd\");\n    }\n});\nvar eh = An({\n    diag_: function(t) {\n        var e = mn(t, \"x\", \"diag\").flatten(), n = t.shape.concat(t.shape);\n        return Lt.runKernelFunc(function(t) {\n            return t.diag(e);\n        }, {\n            $x: e\n        }).reshape(n);\n    }\n});\nvar nh = An({\n    dropout_: function(t, e, n, r) {\n        var o = mn(t, \"x\", \"dropout\");\n        if (C(\"float32\" === o.dtype, function() {\n            return \"x has to be a floating point tensor since it's going to be scaled, but got a \" + o.dtype + \" tensor instead.\";\n        }), C(e >= 0 && e < 1, function() {\n            return \"rate must be a float in the range [0, 1), but got \" + e + \".\";\n        }), 0 === e) return t instanceof wt ? o.clone() : o;\n        var a = function(t, e) {\n            if (null == e) return t.shape.slice();\n            if (S(t.shape, e)) return e;\n            if (t.shape.length === e.length) {\n                for(var n = [], r = 0; r < t.shape.length; r++)null == e[r] && null != t.shape[r] ? n.push(t.shape[r]) : n.push(e[r]);\n                return n;\n            }\n            return e;\n        }(o, n), i = 1 - e, s = _r(a, 0, 1, \"float32\", r).add(i).floor().div(i);\n        return o.mul(s);\n    }\n});\nfunction rh(t, e, n) {\n    for(var r = 1 - t % 2, o = new Float32Array(t), a = 0; a < t; ++a){\n        var i = 2 * Math.PI * a / (t + r - 1);\n        o[a] = e - n * Math.cos(i);\n    }\n    return Mn(o, \"float32\");\n}\nvar oh = An({\n    hannWindow_: function(t) {\n        return rh(t, .5, .5);\n    }\n}), ah = An({\n    hammingWindow_: function(t) {\n        return rh(t, .54, .46);\n    }\n}), ih = An({\n    frame_: function(t, e, n, r, o) {\n        void 0 === r && (r = !1), void 0 === o && (o = 0);\n        for(var a = 0, i = []; a + e <= t.size;)i.push(ml(t, a, e)), a += n;\n        if (r) for(; a < t.size;){\n            var s = a + e - t.size, u = Yn([\n                ml(t, a, e - s),\n                Hn([\n                    s\n                ], o)\n            ]);\n            i.push(u), a += n;\n        }\n        return 0 === i.length ? Bn([], [\n            0,\n            e\n        ]) : Yn(i).as2D(i.length, e);\n    }\n}), sh = An({\n    stft_: function(t, e, n, r, o) {\n        var a;\n        void 0 === o && (o = oh), null == r && (a = e, r = Math.floor(Math.pow(2, Math.ceil(Math.log(a) / Math.log(2)))));\n        for(var i = ih(t, e, n), s = gc(i, o(e)), u = [], c = 0; c < i.shape[0]; c++)u.push($l(s.slice([\n            c,\n            0\n        ], [\n            1,\n            e\n        ]), r));\n        return Yn(u);\n    }\n}), uh = Object.freeze({\n    hannWindow: oh,\n    hammingWindow: ah,\n    frame: ih,\n    stft: sh\n});\nvar ch, lh = function(t, e, o) {\n    return void 0 === o && (o = 1), n(this, void 0, void 0, function() {\n        var n, a, i, s, u, c, l, h, f, d, p, v, m, g;\n        return r(this, function(r) {\n            switch(r.label){\n                case 0:\n                    return n = mn(t, \"predictions\", \"inTopK\"), a = mn(e, \"targets\", \"inTopK\"), C(n.rank > 1, function() {\n                        return \"inTopK() expects the predictions to be of rank 2 or higher, but got \" + n.rank;\n                    }), C(n.rank - 1 === a.rank, function() {\n                        return \"predictions rank should be 1 larger than targets rank, but got predictions rank \" + n.rank + \" and targets rank \" + a.rank;\n                    }), E(n.shape.slice(0, n.shape.length - 1), a.shape, \"predictions's shape should be align with the targets' shape, except the last dimension.\"), i = n.shape[n.shape.length - 1], C(o > 0 && o <= i, function() {\n                        return \"'k' passed to inTopK() must be > 0 && <= the predictions last dimension (\" + i + \"), but got \" + o;\n                    }), [\n                        4,\n                        n.data()\n                    ];\n                case 1:\n                    return s = r.sent(), [\n                        4,\n                        a.data()\n                    ];\n                case 2:\n                    for(u = r.sent(), c = [\n                        s.length / i,\n                        i\n                    ], h = c[1], f = B(\"bool\", l = c[0]), d = 0; d < l; d++){\n                        for(p = d * h, v = s.subarray(p, p + h), m = [], g = 0; g < v.length; g++)m.push({\n                            value: v[g],\n                            index: g\n                        });\n                        for(m.sort(function(t, e) {\n                            return e.value - t.value;\n                        }), f[d] = 0, g = 0; g < o; g++)if (m[g].index === u[d]) {\n                            f[d] = 1;\n                            break;\n                        }\n                    }\n                    return t !== n && n.dispose(), e !== a && a.dispose(), [\n                        2,\n                        Fn(f, a.shape, \"bool\")\n                    ];\n            }\n        });\n    });\n};\n!function(t) {\n    t[t.NONE = 0] = \"NONE\", t[t.MEAN = 1] = \"MEAN\", t[t.SUM = 2] = \"SUM\", t[t.SUM_BY_NONZERO_WEIGHTS = 3] = \"SUM_BY_NONZERO_WEIGHTS\";\n}(ch || (ch = {}));\nvar hh = An({\n    absoluteDifference_: function(t, e, n, r) {\n        void 0 === r && (r = ch.SUM_BY_NONZERO_WEIGHTS);\n        var o = mn(t, \"labels\", \"absoluteDifference\"), a = mn(e, \"predictions\", \"absoluteDifference\"), i = null;\n        null != n && (i = mn(n, \"weights\", \"absoluteDifference\")), E(o.shape, a.shape, \"Error in absoluteDifference: \");\n        var s = o.sub(a).abs();\n        return fh(s, i, r);\n    }\n}), fh = An({\n    computeWeightedLoss_: function(t, e, n) {\n        void 0 === n && (n = ch.SUM_BY_NONZERO_WEIGHTS);\n        var r = mn(t, \"losses\", \"computeWeightedLoss\"), o = null;\n        null != e && (o = mn(e, \"weights\", \"computeWeightedLoss\"));\n        var a = null == o ? r : r.mul(o);\n        if (n === ch.NONE) return a;\n        if (n === ch.SUM) return a.sum();\n        if (n === ch.MEAN) {\n            if (null == o) return a.mean();\n            var i = r.size / o.size, s = a.sum().div(o.sum());\n            return i > 1 ? s.div(On(i)) : s;\n        }\n        if (n === ch.SUM_BY_NONZERO_WEIGHTS) {\n            if (null == o) return a.sum().div(On(r.size));\n            var u = o.mul(zn(r.shape)).notEqual(On(0)).sum().toFloat();\n            return a.sum().div(u);\n        }\n        throw Error(\"Unknown reduction: \" + n);\n    }\n}), dh = An({\n    cosineDistance_: function(t, e, n, r, o) {\n        void 0 === o && (o = ch.SUM_BY_NONZERO_WEIGHTS);\n        var a = mn(t, \"labels\", \"cosineDistance\"), i = mn(e, \"predictions\", \"cosineDistance\"), s = null;\n        null != r && (s = mn(r, \"weights\", \"cosineDistance\")), E(a.shape, i.shape, \"Error in cosineDistance: \");\n        var u = On(1).sub(a.mul(i).sum(n, !0));\n        return fh(u, s, o);\n    }\n}), ph = An({\n    hingeLoss_: function(t, e, n, r) {\n        void 0 === r && (r = ch.SUM_BY_NONZERO_WEIGHTS);\n        var o = mn(t, \"labels\", \"hingeLoss\"), a = mn(e, \"predictions\", \"hingeLoss\"), i = null;\n        null != n && (i = mn(n, \"weights\", \"hingeLoss\")), E(o.shape, a.shape, \"Error in hingeLoss: \");\n        var s = On(1);\n        o = On(2).mul(o).sub(s);\n        var u = s.sub(o.mul(a)).relu();\n        return fh(u, i, r);\n    }\n}), vh = An({\n    huberLoss_: function(t, e, n, r, o) {\n        void 0 === r && (r = 1), void 0 === o && (o = ch.SUM_BY_NONZERO_WEIGHTS);\n        var a = mn(t, \"labels\", \"huberLoss\"), i = mn(e, \"predictions\", \"huberLoss\"), s = null;\n        null != n && (s = mn(n, \"weights\", \"huberLoss\")), E(a.shape, i.shape, \"Error in huberLoss: \");\n        var u = On(r), c = i.sub(a).abs(), l = dc(c, u), h = c.sub(l), f = On(.5).mul(l.square()).add(u.mul(h));\n        return fh(f, s, o);\n    }\n}), mh = An({\n    logLoss_: function(t, e, n, r, o) {\n        void 0 === r && (r = 1e-7), void 0 === o && (o = ch.SUM_BY_NONZERO_WEIGHTS);\n        var a = mn(t, \"labels\", \"logLoss\"), i = mn(e, \"predictions\", \"logLoss\"), s = null;\n        null != n && (s = mn(n, \"weights\", \"logLoss\")), E(a.shape, i.shape, \"Error in logLoss: \");\n        var u = On(1), c = On(r), l = a.mul(i.add(c).log()).neg().sub(u.sub(a).mul(u.sub(i).add(c).log()));\n        return fh(l, s, o);\n    }\n}), gh = An({\n    meanSquaredError_: function(t, e, n, r) {\n        void 0 === r && (r = ch.SUM_BY_NONZERO_WEIGHTS);\n        var o = mn(t, \"labels\", \"meanSquaredError\"), a = mn(e, \"predictions\", \"meanSquaredError\"), i = null;\n        null != n && (i = mn(n, \"weights\", \"meanSquaredError\")), E(o.shape, a.shape, \"Error in meanSquaredError: \");\n        var s = o.squaredDifference(a);\n        return fh(s, i, r);\n    }\n}), yh = An({\n    sigmoidCrossEntropy_: function(t, e, n, r, o) {\n        void 0 === r && (r = 0), void 0 === o && (o = ch.SUM_BY_NONZERO_WEIGHTS);\n        var a = mn(t, \"multiClassLabels\", \"sigmoidCrossEntropy\"), i = mn(e, \"logits\", \"sigmoidCrossEntropy\"), s = null;\n        if (null != n && (s = mn(n, \"weights\", \"sigmoidCrossEntropy\")), E(a.shape, i.shape, \"Error in sigmoidCrossEntropy: \"), r > 0) {\n            var u = On(r), c = On(1), l = On(.5);\n            a = a.mul(c.sub(u)).add(l.mul(u));\n        }\n        var h = function(t, e) {\n            var n = mn(t, \"labels\", \"sigmoidCrossEntropyWithLogits\"), r = mn(e, \"logits\", \"sigmoidCrossEntropyWithLogits\");\n            E(n.shape, r.shape, \"Error in sigmoidCrossEntropyWithLogits: \");\n            var o = r.relu(), a = r.mul(n), i = r.abs().neg().exp().log1p();\n            return o.sub(a).add(i);\n        }(a, i);\n        return fh(h, s, o);\n    }\n}), xh = An({\n    softmaxCrossEntropy_: function(t, e, n, r, o) {\n        void 0 === r && (r = 0), void 0 === o && (o = ch.SUM_BY_NONZERO_WEIGHTS);\n        var a = mn(t, \"onehotLabels\", \"softmaxCrossEntropy\"), i = mn(e, \"logits\", \"softmaxCrossEntropy\"), s = null;\n        if (null != n && (s = mn(n, \"weights\", \"softmaxCrossEntropy\")), E(a.shape, i.shape, \"Error in softmaxCrossEntropy: \"), r > 0) {\n            var u = On(r), c = On(1), l = On(a.shape[1]);\n            a = a.mul(c.sub(u)).add(u.div(l));\n        }\n        var h = function(t, e, n) {\n            if (void 0 === n && (n = -1), -1 === n && (n = e.rank - 1), n !== e.rank - 1) throw Error(\"Softmax cross entropy along a non-last dimension is not yet supported. Labels / logits was rank \" + e.rank + \" and dim was \" + n);\n            return vo(function(t, e, r) {\n                var o = e.logSumExp([\n                    n\n                ], !0), a = e.toFloat().sub(o);\n                r([\n                    t,\n                    a\n                ]);\n                return {\n                    value: a.mul(t).neg().sum([\n                        n\n                    ]),\n                    gradFunc: function(t, e) {\n                        var r = e[0], o = e[1], a = wn(t.shape, [\n                            n\n                        ]);\n                        return [\n                            t.reshape(a).mul(r.toFloat().sub(o.exp())),\n                            t.reshape(a).mul(o.exp().sub(r.toFloat()))\n                        ];\n                    }\n                };\n            })(t, e);\n        }(a, i);\n        return fh(h, s, o);\n    }\n}), bh = Object.freeze({\n    get Reduction () {\n        return ch;\n    },\n    absoluteDifference: hh,\n    computeWeightedLoss: fh,\n    cosineDistance: dh,\n    hingeLoss: ph,\n    huberLoss: vh,\n    logLoss: mh,\n    meanSquaredError: gh,\n    sigmoidCrossEntropy: yh,\n    softmaxCrossEntropy: xh\n});\nfunction wh(t, e) {\n    return void 0 === e && (e = !1), Lt.tidy(function() {\n        if (2 !== t.shape.length) throw new Error(\"qr2d() requires a 2D Tensor, but got a \" + t.shape.length + \"D Tensor.\");\n        for(var n = t.shape[0], r = t.shape[1], o = Cr(n), a = t.clone(), i = Bn([\n            [\n                1\n            ]\n        ], [\n            1,\n            1\n        ]), s = i.clone(), u = n >= r ? r : n, c = function(t) {\n            var e, u = a, c = s, l = o;\n            e = Lt.tidy(function() {\n                var e = a.slice([\n                    t,\n                    t\n                ], [\n                    n - t,\n                    1\n                ]), u = e.norm(), c = a.slice([\n                    t,\n                    t\n                ], [\n                    1,\n                    1\n                ]), l = Bn([\n                    [\n                        -1\n                    ]\n                ]).where(c.greater(0), Bn([\n                    [\n                        1\n                    ]\n                ])), h = c.sub(l.mul(u)), f = e.div(h);\n                s = 1 === f.shape[0] ? i.clone() : i.concat(f.slice([\n                    1,\n                    0\n                ], [\n                    f.shape[0] - 1,\n                    f.shape[1]\n                ]), 0);\n                var d = l.matMul(h).div(u).neg(), p = a.slice([\n                    t,\n                    0\n                ], [\n                    n - t,\n                    r\n                ]), v = d.mul(s);\n                if (0 === t) a = p.sub(v.matMul(s.transpose().matMul(p)));\n                else {\n                    var m = p.sub(v.matMul(s.transpose().matMul(p)));\n                    a = a.slice([\n                        0,\n                        0\n                    ], [\n                        t,\n                        r\n                    ]).concat(m, 0);\n                }\n                var g = o.slice([\n                    0,\n                    t\n                ], [\n                    n,\n                    o.shape[1] - t\n                ]);\n                if (0 === t) o = g.sub(g.matMul(s).matMul(v.transpose()));\n                else {\n                    var y = g.sub(g.matMul(s).matMul(v.transpose()));\n                    o = o.slice([\n                        0,\n                        0\n                    ], [\n                        n,\n                        t\n                    ]).concat(y, 1);\n                }\n                return [\n                    s,\n                    a,\n                    o\n                ];\n            }), s = e[0], a = e[1], o = e[2], tn([\n                u,\n                c,\n                l\n            ]);\n        }, l = 0; l < u; ++l)c(l);\n        return !e && n > r && (o = o.slice([\n            0,\n            0\n        ], [\n            n,\n            r\n        ]), a = a.slice([\n            0,\n            0\n        ], [\n            r,\n            r\n        ])), [\n            o,\n            a\n        ];\n    });\n}\nvar Ch = An({\n    bandPart_: function(t, e, n) {\n        if (e % 1 != 0) throw new Error(\"bandPart(): numLower must be an integer, got \" + e + \".\");\n        if (n % 1 != 0) throw new Error(\"bandPart(): numUpper must be an integer, got \" + n + \".\");\n        var r = mn(t, \"a\", \"bandPart\");\n        if (r.rank < 2) throw new Error(\"bandPart(): Rank must be at least 2, got \" + r.rank + \".\");\n        var o = r.shape, a = r.shape.slice(-2), i = a[0], s = a[1];\n        if (!(e <= i)) throw new Error(\"bandPart(): numLower (\" + e + \") must not be greater than the number of rows (\" + i + \").\");\n        if (!(n <= s)) throw new Error(\"bandPart(): numUpper (\" + n + \") must not be greater than the number of columns (\" + s + \").\");\n        e < 0 && (e = i), n < 0 && (n = s);\n        var u = Kn(0, i, 1, \"int32\").reshape([\n            -1,\n            1\n        ]), c = Kn(0, s, 1, \"int32\"), l = Cc(u, c), h = Qu(l.lessEqual(On(+e, \"int32\")), l.greaterEqual(On(-n, \"int32\"))), f = Gn([\n            i,\n            s\n        ], r.dtype);\n        return Pr(Ur(r.reshape([\n            -1,\n            i,\n            s\n        ])).map(function(t) {\n            return ec(h, t, f);\n        })).reshape(o);\n    }\n}), Eh = An({\n    gramSchmidt_: function(t) {\n        var e;\n        if (Array.isArray(t)) {\n            e = !1, C(null != t && t.length > 0, function() {\n                return \"Gram-Schmidt process: input must not be null, undefined, or empty\";\n            });\n            for(var n = t[0].shape[0], r = function(e) {\n                C(t[e].shape[0] === n, function() {\n                    return \"Gram-Schmidt: Non-unique lengths found in the input vectors: (\" + t[e].shape[0] + \" vs. \" + n + \")\";\n                });\n            }, o = 1; o < t.length; ++o)r(o);\n        } else e = !0, t = tr(t, t.shape[0], 0).map(function(t) {\n            return Br(t, [\n                0\n            ]);\n        });\n        C(t.length <= t[0].shape[0], function() {\n            return \"Gram-Schmidt: Number of vectors (\" + t.length + \") exceeds number of dimensions (\" + t[0].shape[0] + \").\";\n        });\n        var a = [], i = t, s = function(t) {\n            a.push(Lt.tidy(function() {\n                var e = i[t];\n                if (t > 0) for(var n = 0; n < t; ++n){\n                    var r = Nl(a[n].mulStrict(e)).mul(a[n]);\n                    e = e.sub(r);\n                }\n                return e.div(Vl(e, \"euclidean\"));\n            }));\n        };\n        for(o = 0; o < t.length; ++o)s(o);\n        return e ? Pr(a, 0) : a;\n    }\n}), Rh = An({\n    qr_: function(t, e) {\n        if (void 0 === e && (e = !1), t.rank < 2) throw new Error(\"qr() requires input tensor to have a rank >= 2, but got rank \" + t.rank);\n        if (2 === t.rank) return wh(t, e);\n        var n = t.shape.slice(0, t.shape.length - 2).reduce(function(t, e) {\n            return t * e;\n        }), r = Ur(t.reshape([\n            n,\n            t.shape[t.shape.length - 2],\n            t.shape[t.shape.length - 1]\n        ]), 0), o = [], a = [];\n        return r.forEach(function(t) {\n            var n = wh(t, e), r = n[0], i = n[1];\n            o.push(r), a.push(i);\n        }), [\n            Pr(o, 0).reshape(t.shape),\n            Pr(a, 0).reshape(t.shape)\n        ];\n    }\n}), Ih = Object.freeze({\n    bandPart: Ch,\n    gramSchmidt: Eh,\n    qr: Rh\n});\nfunction kh(t, e, n, r, o, a) {\n    null == r && (r = .5), null == o && (o = Number.NEGATIVE_INFINITY), null == a && (a = 0);\n    var i = t.shape[0];\n    return n = Math.min(n, i), C(0 <= r && r <= 1, function() {\n        return \"iouThreshold must be in [0, 1], but was '\" + r + \"'\";\n    }), C(2 === t.rank, function() {\n        return \"boxes must be a 2D tensor, but was of rank '\" + t.rank + \"'\";\n    }), C(4 === t.shape[1], function() {\n        return \"boxes must have 4 columns, but 2nd dimension was \" + t.shape[1];\n    }), C(1 === e.rank, function() {\n        return \"scores must be a 1D tensor\";\n    }), C(e.shape[0] === i, function() {\n        return \"scores has incompatible shape with boxes. Expected \" + i + \", but was \" + e.shape[0];\n    }), C(0 <= a && a <= 1, function() {\n        return \"softNmsSigma must be in [0, 1], but was '\" + a + \"'\";\n    }), {\n        maxOutputSize: n,\n        iouThreshold: r,\n        scoreThreshold: o,\n        softNmsSigma: a\n    };\n}\nvar Sh = An({\n    resizeBilinear_: function(t, e, n) {\n        void 0 === n && (n = !1);\n        var r = mn(t, \"images\", \"resizeBilinear\");\n        C(3 === r.rank || 4 === r.rank, function() {\n            return \"Error in resizeBilinear: x must be rank 3 or 4, but got rank \" + r.rank + \".\";\n        }), C(2 === e.length, function() {\n            return \"Error in resizeBilinear: new shape must 2D, but got shape \" + e + \".\";\n        });\n        var o = r, a = !1;\n        3 === r.rank && (a = !0, o = r.as4D(1, r.shape[0], r.shape[1], r.shape[2]));\n        var i = e[0], s = e[1], u = Lt.runKernelFunc(function(t, e) {\n            return e([\n                o\n            ]), t.resizeBilinear(o, i, s, n);\n        }, {\n            x: o\n        }, function(t, e) {\n            return {\n                x: function() {\n                    return Lt.runKernelFunc(function(r) {\n                        return r.resizeBilinearBackprop(t, e[0], n);\n                    }, {});\n                }\n            };\n        }, \"ResizeBilinear\", {\n            alignCorners: n,\n            newHeight: i,\n            newWidth: s\n        });\n        return a ? u.as3D(u.shape[1], u.shape[2], u.shape[3]) : u;\n    }\n}), Ah = An({\n    resizeNearestNeighbor_: function(t, e, n) {\n        void 0 === n && (n = !1);\n        var r = mn(t, \"images\", \"resizeNearestNeighbor\");\n        C(3 === r.rank || 4 === r.rank, function() {\n            return \"Error in resizeNearestNeighbor: x must be rank 3 or 4, but got rank \" + r.rank + \".\";\n        }), C(2 === e.length, function() {\n            return \"Error in resizeNearestNeighbor: new shape must 2D, but got shape \" + e + \".\";\n        }), C(\"float32\" === r.dtype || \"int32\" === r.dtype, function() {\n            return \"`images` must have `int32` or `float32` as dtype\";\n        });\n        var o = r, a = !1;\n        3 === r.rank && (a = !0, o = r.as4D(1, r.shape[0], r.shape[1], r.shape[2]));\n        var i = e[0], s = e[1], u = Lt.runKernelFunc(function(t, e) {\n            return e([\n                o\n            ]), t.resizeNearestNeighbor(o, i, s, n);\n        }, {\n            batchImages: o\n        }, function(t, e) {\n            return {\n                batchImages: function() {\n                    return Lt.runKernelFunc(function(r) {\n                        return r.resizeNearestNeighborBackprop(t, e[0], n);\n                    }, {});\n                }\n            };\n        });\n        return a ? u.as3D(u.shape[1], u.shape[2], u.shape[3]) : u;\n    }\n}), Dh = An({\n    nonMaxSuppression_: function(t, e, n, r, o) {\n        void 0 === r && (r = .5), void 0 === o && (o = Number.NEGATIVE_INFINITY);\n        var a = mn(t, \"boxes\", \"nonMaxSuppression\"), i = mn(e, \"scores\", \"nonMaxSuppression\"), s = kh(a, i, n, r, o);\n        n = s.maxOutputSize, r = s.iouThreshold, o = s.scoreThreshold;\n        var u = {\n            maxOutputSize: n,\n            iouThreshold: r,\n            scoreThreshold: o\n        };\n        return Lt.runKernelFunc(function(t) {\n            return t.nonMaxSuppression(a, i, n, r, o);\n        }, {\n            boxes: a,\n            scores: i\n        }, null, \"NonMaxSuppressionV3\", u);\n    }\n}), Th = function(t, e, o, a, i) {\n    return void 0 === a && (a = .5), void 0 === i && (i = Number.NEGATIVE_INFINITY), n(this, void 0, void 0, function() {\n        var n, s, u, c, l, h, f;\n        return r(this, function(r) {\n            switch(r.label){\n                case 0:\n                    return n = mn(t, \"boxes\", \"nonMaxSuppressionAsync\"), s = mn(e, \"scores\", \"nonMaxSuppressionAsync\"), u = kh(n, s, o, a, i), o = u.maxOutputSize, a = u.iouThreshold, i = u.scoreThreshold, [\n                        4,\n                        Promise.all([\n                            n.data(),\n                            s.data()\n                        ])\n                    ];\n                case 1:\n                    return c = r.sent(), l = c[0], h = c[1], f = jo(l, h, o, a, i), n !== t && n.dispose(), s !== e && s.dispose(), [\n                        2,\n                        f\n                    ];\n            }\n        });\n    });\n}, Nh = An({\n    nonMaxSuppressionWithScore_: function(t, e, n, r, o, a) {\n        void 0 === r && (r = .5), void 0 === o && (o = Number.NEGATIVE_INFINITY), void 0 === a && (a = 0);\n        var i = mn(t, \"boxes\", \"nonMaxSuppression\"), s = mn(e, \"scores\", \"nonMaxSuppression\"), u = kh(i, s, n, r, o, a), c = {\n            maxOutputSize: n = u.maxOutputSize,\n            iouThreshold: r = u.iouThreshold,\n            scoreThreshold: o = u.scoreThreshold,\n            softNmsSigma: a = u.softNmsSigma\n        }, l = Lt.runKernel(\"NonMaxSuppressionV5\", {\n            boxes: i,\n            scores: s\n        }, c);\n        return {\n            selectedIndices: l[0],\n            selectedScores: l[1]\n        };\n    }\n}), Fh = function(t, e, o, a, i, s) {\n    return void 0 === a && (a = .5), void 0 === i && (i = Number.NEGATIVE_INFINITY), void 0 === s && (s = 0), n(this, void 0, void 0, function() {\n        var n, u, c, l, h, f, d;\n        return r(this, function(r) {\n            switch(r.label){\n                case 0:\n                    return n = mn(t, \"boxes\", \"nonMaxSuppressionAsync\"), u = mn(e, \"scores\", \"nonMaxSuppressionAsync\"), c = kh(n, u, o, a, i, s), o = c.maxOutputSize, a = c.iouThreshold, i = c.scoreThreshold, s = c.softNmsSigma, [\n                        4,\n                        Promise.all([\n                            n.data(),\n                            u.data()\n                        ])\n                    ];\n                case 1:\n                    return l = r.sent(), h = l[0], f = l[1], d = Xo(h, f, o, a, i, s), n !== t && n.dispose(), u !== e && u.dispose(), [\n                        2,\n                        d\n                    ];\n            }\n        });\n    });\n}, _h = An({\n    cropAndResize_: function(t, e, n, r, o, a) {\n        var i = mn(t, \"image\", \"cropAndResize\"), s = mn(e, \"boxes\", \"cropAndResize\", \"float32\"), u = mn(n, \"boxInd\", \"cropAndResize\", \"int32\");\n        o = o || \"bilinear\", a = a || 0;\n        var c = s.shape[0];\n        return C(4 === i.rank, function() {\n            return \"Error in cropAndResize: image must be rank 4,but got rank \" + i.rank + \".\";\n        }), C(2 === s.rank && 4 === s.shape[1], function() {\n            return \"Error in cropAndResize: boxes must be have size [\" + c + \",4] but had shape \" + s.shape + \".\";\n        }), C(1 === u.rank && u.shape[0] === c, function() {\n            return \"Error in cropAndResize: boxInd must be have size [\" + c + \"] but had shape \" + s.shape + \".\";\n        }), C(2 === r.length, function() {\n            return \"Error in cropAndResize: cropSize must be of length 2, but got length \" + r.length + \".\";\n        }), C(r[0] >= 1 && r[1] >= 1, function() {\n            return \"cropSize must be atleast [1,1], but was \" + r;\n        }), C(\"bilinear\" === o || \"nearest\" === o, function() {\n            return \"method must be bilinear or nearest, but was \" + o;\n        }), Lt.runKernelFunc(function(t, e) {\n            return t.cropAndResize(i, s, u, r, o, a);\n        }, {\n            images: i,\n            boxes: s,\n            boxInd: u\n        }, null, \"CropAndResize\", {\n            method: o,\n            extrapolationValue: a,\n            cropSize: r\n        });\n    }\n}), Oh = Object.freeze({\n    resizeBilinear: Sh,\n    resizeNearestNeighbor: Ah,\n    nonMaxSuppression: Dh,\n    nonMaxSuppressionAsync: Th,\n    nonMaxSuppressionWithScore: Nh,\n    nonMaxSuppressionWithScoreAsync: Fh,\n    cropAndResize: _h\n}), Mh = function(t, e) {\n    return !(t > 0) || \"linear\" === e;\n}, Bh = function(t, e, n) {\n    if (null == n || \"linear\" === n) return t;\n    if (\"relu\" === n) return t.mul(e.step());\n    throw new Error(\"Gradient for activation \" + n + \" has not been implemented yet.\");\n}, Ph = function(t, e) {\n    var n = e, r = Eo(t.shape, e.shape);\n    return r.length > 0 && (n = n.sum(r)), n.reshape(t.shape);\n}, Lh = function(t, e, n) {\n    if (\"linear\" === e) return t;\n    if (\"relu\" === e) return Bl(t);\n    if (\"elu\" === e) return _l(t);\n    if (\"relu6\" === e) return Pl(t);\n    if (\"prelu\" === e) return Ml(t, n);\n    throw new Error(\"Unknown fused activation \" + e + \".\");\n};\nvar Wh = An({\n    fusedMatMul_: function(t) {\n        var e, n = t.a, r = t.b, o = t.transposeA, a = void 0 !== o && o, i = t.transposeB, s = void 0 !== i && i, u = t.bias, c = t.activation, l = void 0 === c ? \"linear\" : c, h = t.preluActivationWeights;\n        if (!1 === Mh(Lt.state.gradientDepth, l)) {\n            var f = el(n, r, a, s);\n            return null != u && (f = rc(f, u)), Lh(f, l, h);\n        }\n        var d = mn(n, \"a\", \"fused matMul\"), p = mn(r, \"b\", \"fused matMul\");\n        e = Nt(d, p), d = e[0], p = e[1];\n        var v = a ? d.shape[d.rank - 2] : d.shape[d.rank - 1], m = s ? p.shape[p.rank - 1] : p.shape[p.rank - 2], g = a ? d.shape[d.rank - 1] : d.shape[d.rank - 2], y = s ? p.shape[p.rank - 2] : p.shape[p.rank - 1], x = d.shape.slice(0, -2), b = p.shape.slice(0, -2), w = k(x), E = k(b);\n        C(d.rank >= 2 && p.rank >= 2 && d.rank === p.rank, function() {\n            return \"Error in fused matMul: inputs must have the same rank of at least 2, got ranks \" + d.rank + \" and \" + p.rank + \".\";\n        }), C(S(x, b), function() {\n            return \"Error in fused matMul: outer dimensions (\" + x + \") and (\" + b + \") of Tensors with shapes \" + d.shape + \" and \" + p.shape + \" must match.\";\n        }), C(v === m, function() {\n            return \"Error in fused matMul: inner shapes (\" + v + \") and (\" + m + \") of Tensors with shapes \" + d.shape + \" and \" + p.shape + \" and transposeA=\" + a + \" and transposeB=\" + s + \" must match.\";\n        });\n        var R, I, A = d.shape.slice(0, -2).concat([\n            g,\n            y\n        ]), D = a ? d.as3D(w, v, g) : d.as3D(w, g, v), T = s ? p.as3D(E, y, m) : p.as3D(E, m, y);\n        null != u && Ro(A, (R = Nt(R = mn(u, \"bias\", \"fused matMul\"), d)[0]).shape), null != h && (I = mn(h, \"prelu weights\", \"fused matMul\"));\n        var N = {\n            a: D,\n            b: T\n        };\n        null != u && (N.bias = R), null != h && (N.preluActivationWeights = I);\n        var F = [\n            D,\n            T\n        ];\n        return Lt.runKernelFunc(function(t, e) {\n            var n = t.fusedBatchMatMul({\n                a: D,\n                b: T,\n                transposeA: a,\n                transposeB: s,\n                bias: R,\n                activation: l,\n                preluActivationWeights: I\n            });\n            return e([\n                D,\n                T,\n                n\n            ]), n;\n        }, N, function(t, e) {\n            var n = e[0], r = e[1], o = e[2], i = Bh(t, o, l), c = {};\n            return null != u && (c = {\n                bias: function() {\n                    return Ph(R, i);\n                }\n            }), a || s ? !a && s ? Object.assign({\n                a: function() {\n                    return i.matMul(r, !1, !1);\n                },\n                b: function() {\n                    return i.matMul(n, !0, !1);\n                }\n            }, c) : a && !s ? Object.assign({\n                a: function() {\n                    return r.matMul(i, !1, !0);\n                },\n                b: function() {\n                    return n.matMul(i, !1, !1);\n                }\n            }, c) : Object.assign({\n                a: function() {\n                    return r.matMul(i, !0, !0);\n                },\n                b: function() {\n                    return i.matMul(n, !0, !0);\n                }\n            }, c) : Object.assign({\n                a: function() {\n                    return i.matMul(r, !1, !0);\n                },\n                b: function() {\n                    return n.matMul(i, !0, !1);\n                }\n            }, c);\n        }, \"_FusedMatMul\", {\n            transposeA: a,\n            transposeB: s,\n            activation: l\n        }, F, [\n            !0\n        ]).reshape(A);\n    }\n}), Uh = An({\n    fusedConv2d_: function(t) {\n        var e = t.x, n = t.filter, r = t.strides, o = t.pad, a = t.dataFormat, i = void 0 === a ? \"NHWC\" : a, s = t.dilations, u = void 0 === s ? [\n            1,\n            1\n        ] : s, c = t.dimRoundingMode, l = t.bias, h = t.activation, f = void 0 === h ? \"linear\" : h, d = t.preluActivationWeights;\n        if (f = f || \"linear\", !1 === Mh(Lt.state.gradientDepth, f)) {\n            var p = qc(e, n, r, o, i, u, c);\n            return null != l && (p = rc(p, l)), Lh(p, f, d);\n        }\n        var v = mn(e, \"x\", \"conv2d\"), m = mn(n, \"filter\", \"conv2d\"), g = v, y = !1;\n        3 === v.rank && (y = !0, g = v.as4D(1, v.shape[0], v.shape[1], v.shape[2])), C(4 === g.rank, function() {\n            return \"Error in fused conv2d: input must be rank 4, but got rank \" + g.rank + \".\";\n        }), C(4 === m.rank, function() {\n            return \"Error in fused conv2d: filter must be rank 4, but got rank \" + m.rank + \".\";\n        }), null != c && C(A(o), function() {\n            return \"Error in fused conv2d: pad must be an integer when using, dimRoundingMode \" + c + \" but got pad \" + o + \".\";\n        }), C(g.shape[3] === m.shape[2], function() {\n            return \"Error in conv2d: depth of input (\" + g.shape[3] + \") must match input depth for filter \" + m.shape[2] + \".\";\n        }), C(Mo(r, u), function() {\n            return \"Error in conv2D: Either strides or dilations must be 1. Got strides \" + r + \" and dilations '\" + u + \"'\";\n        }), C(\"NHWC\" === i, function() {\n            return \"Error in conv2d: got dataFormat of \" + i + \" but only NHWC is currently supported.\";\n        });\n        var x, b, w = So(g.shape, m.shape, r, u, o, c);\n        null != l && (x = Nt(x = mn(l, \"bias\", \"fused conv2d\"), v)[0], Ro(w.outShape, x.shape)), null != d && (b = mn(d, \"prelu weights\", \"fused conv2d\"));\n        var E = {\n            x: g,\n            filter: m\n        };\n        null != l && (E.bias = x), null != d && (E.preluActivationWeights = b);\n        var R = [\n            m,\n            g\n        ], I = Lt.runKernelFunc(function(t, e) {\n            var n = t.fusedConv2d({\n                input: g,\n                filter: m,\n                convInfo: w,\n                bias: x,\n                activation: f,\n                preluActivationWeights: b\n            });\n            return e([\n                m,\n                g,\n                n\n            ]), n;\n        }, E, function(t, e) {\n            var n = e, a = n[0], i = n[1], s = n[2], c = Bh(t, s, f);\n            C(Oo(u), function() {\n                return \"Error in gradient of fused conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '\" + u + \"'\";\n            });\n            var h = {};\n            return null != l && (h = {\n                bias: function() {\n                    return Ph(x, c);\n                }\n            }), Object.assign({\n                x: function() {\n                    return Xc(i.shape, c, a, r, o);\n                },\n                filter: function() {\n                    return jc(i, c, a.shape, r, o);\n                }\n            }, h);\n        }, \"FusedConv2D\", {\n            convInfo: w,\n            activation: f\n        }, R, [\n            !0\n        ]);\n        return y ? I.as3D(I.shape[1], I.shape[2], I.shape[3]) : I;\n    }\n}), Vh = An({\n    fusedDepthwiseConv2d_: function(t) {\n        var e = t.x, n = t.filter, r = t.strides, o = t.pad, a = t.dataFormat, i = void 0 === a ? \"NHWC\" : a, s = t.dilations, u = void 0 === s ? [\n            1,\n            1\n        ] : s, c = t.dimRoundingMode, l = t.bias, h = t.activation, f = void 0 === h ? \"linear\" : h, d = t.preluActivationWeights;\n        if (!1 === Mh(Lt.state.gradientDepth, f)) {\n            var p = Yc(e, n, r, o, i, u, c);\n            return null != l && (p = rc(p, l)), Lh(p, f, d);\n        }\n        var v = mn(e, \"x\", \"depthwiseConv2d\"), m = mn(n, \"filter\", \"depthwiseConv2d\"), g = v, y = !1;\n        3 === v.rank && (y = !0, g = v.as4D(1, v.shape[0], v.shape[1], v.shape[2])), C(4 === g.rank, function() {\n            return \"Error in fused depthwiseConv2d: input must be rank 4, but got rank \" + g.rank + \".\";\n        }), C(4 === m.rank, function() {\n            return \"Error in fused depthwiseConv2d: filter must be rank 4, but got rank \" + m.rank + \".\";\n        }), C(g.shape[3] === m.shape[2], function() {\n            return \"Error in fused depthwiseConv2d: number of input channels (\" + g.shape[3] + \") must match the inChannels dimension in filter \" + m.shape[2] + \".\";\n        }), null == u && (u = [\n            1,\n            1\n        ]), C(Mo(r, u), function() {\n            return \"Error in fused depthwiseConv2d: Either strides or dilations must be 1. Got strides \" + r + \" and dilations '\" + u + \"'\";\n        }), null != c && C(A(o), function() {\n            return \"Error in fused depthwiseConv2d: pad must be an integer when using dimRoundingMode \" + c + \" but got pad \" + o + \".\";\n        });\n        var x, b, w = So(g.shape, m.shape, r, u, o, c, !0);\n        null != l && (x = Nt(x = mn(l, \"bias\", \"fused conv2d\"), v)[0], Ro(w.outShape, x.shape)), null != d && (b = mn(d, \"prelu weights\", \"fused depthwiseConv2d\"));\n        var E = {\n            x: g,\n            filter: m\n        };\n        null != l && (E.bias = x), null != d && (E.preluActivationWeights = b);\n        var R = [\n            m,\n            g\n        ], I = Lt.runKernelFunc(function(t, e) {\n            var n = t.fusedDepthwiseConv2D({\n                input: g,\n                filter: m,\n                convInfo: w,\n                bias: x,\n                activation: f,\n                preluActivationWeights: b\n            });\n            return e([\n                m,\n                g,\n                n\n            ]), n;\n        }, E, function(t, e) {\n            C(Oo(u), function() {\n                return \"Error in gradient of fused depthwiseConv2d: dilation rates greater than 1 are not yet supported. Got dilations '\" + u + \"'\";\n            });\n            var n = e[0], r = e[1], o = e[2], a = Bh(t, o, f), i = {};\n            return null != l && (i = {\n                bias: function() {\n                    return Ph(x, a);\n                }\n            }), Object.assign({\n                x: function() {\n                    return $c(r.shape, a, n, w);\n                },\n                filter: function() {\n                    return Qc(r, a, n.shape, w);\n                }\n            }, i);\n        }, \"FusedDepthwiseConv2D\", {\n            convInfo: w,\n            activation: f\n        }, R, [\n            !0\n        ]);\n        return y ? I.as3D(I.shape[1], I.shape[2], I.shape[3]) : I;\n    }\n}), zh = Object.freeze({\n    matMul: Wh,\n    conv2d: Uh,\n    depthwiseConv2d: Vh\n}), Gh = Object.freeze({\n    image: Oh,\n    linalg: Ih,\n    losses: bh,\n    spectral: Jl,\n    fused: zh,\n    signal: uh,\n    square: tu,\n    squaredDifference: nu,\n    conv1d: Hc,\n    conv2d: qc,\n    conv3d: Kc,\n    depthwiseConv2d: Yc,\n    separableConv2d: Jc,\n    conv2dTranspose: Zc,\n    conv3dTranspose: tl,\n    op: An,\n    batchNormalization2d: Gu,\n    batchNormalization3d: Hu,\n    batchNormalization4d: qu,\n    batchNormalization: Ku,\n    batchNorm: ju,\n    batchNorm2d: Xu,\n    batchNorm3d: Yu,\n    batchNorm4d: $u,\n    booleanMaskAsync: Uc,\n    complex: Dn,\n    real: Tn,\n    imag: Nn,\n    concat: Yn,\n    concat1d: $n,\n    concat2d: Qn,\n    concat3d: Jn,\n    concat4d: Zn,\n    split: tr,\n    matMul: el,\n    dot: nl,\n    outerProduct: rl,\n    reverse: ol,\n    reverse1d: al,\n    reverse2d: il,\n    reverse3d: sl,\n    reverse4d: ul,\n    maxPool: hl,\n    avgPool: fl,\n    pool: dl,\n    maxPool3d: pl,\n    avgPool3d: vl,\n    slice: ml,\n    slice1d: gl,\n    slice2d: yl,\n    slice3d: xl,\n    slice4d: bl,\n    abs: ru,\n    acos: ou,\n    acosh: au,\n    asin: iu,\n    asinh: su,\n    atan: uu,\n    atanh: cu,\n    ceil: lu,\n    clipByValue: hu,\n    cos: fu,\n    cosh: du,\n    erf: pu,\n    exp: vu,\n    expm1: mu,\n    floor: gu,\n    log: yu,\n    log1p: xu,\n    logSigmoid: bu,\n    neg: wu,\n    reciprocal: Cu,\n    round: Eu,\n    rsqrt: Ru,\n    sigmoid: Iu,\n    sign: ku,\n    isNaN: Su,\n    isInf: Au,\n    isFinite: Du,\n    sin: Tu,\n    sinh: Nu,\n    softplus: Fu,\n    sqrt: _u,\n    step: Ou,\n    tan: Mu,\n    tanh: Bu,\n    all: Cl,\n    any: El,\n    argMax: Rl,\n    argMin: Il,\n    logSumExp: kl,\n    max: Sl,\n    mean: Al,\n    min: Dl,\n    moments: Tl,\n    sum: Nl,\n    prod: Fl,\n    equal: Rc,\n    equalStrict: Ic,\n    greater: kc,\n    greaterEqual: Sc,\n    greaterEqualStrict: Ac,\n    greaterStrict: Dc,\n    less: Tc,\n    lessEqual: Nc,\n    lessEqualStrict: Fc,\n    lessStrict: _c,\n    notEqual: Oc,\n    notEqualStrict: Mc,\n    add: rc,\n    addN: oc,\n    addStrict: ac,\n    atan2: ic,\n    div: sc,\n    divNoNan: uc,\n    divStrict: cc,\n    floorDiv: lc,\n    maximum: hc,\n    maximumStrict: fc,\n    minimum: dc,\n    minimumStrict: pc,\n    mod: vc,\n    modStrict: mc,\n    mul: gc,\n    mulStrict: yc,\n    pow: xc,\n    powStrict: bc,\n    squaredDifferenceStrict: wc,\n    sub: Cc,\n    subStrict: Ec,\n    elu: _l,\n    leakyRelu: Ol,\n    prelu: Ml,\n    relu: Bl,\n    relu6: Pl,\n    selu: Ll,\n    logicalAnd: Qu,\n    logicalNot: Ju,\n    logicalOr: Zu,\n    logicalXor: tc,\n    where: ec,\n    whereAsync: nc,\n    buffer: dr,\n    print: pr,\n    batchToSpaceND: vr,\n    broadcastTo: mr,\n    cast: gr,\n    clone: yr,\n    cumsum: xr,\n    depthToSpace: br,\n    expandDims: wr,\n    eye: Cr,\n    multinomial: Er,\n    oneHot: Rr,\n    pad: Ir,\n    pad1d: kr,\n    pad2d: Sr,\n    pad3d: Ar,\n    pad4d: Dr,\n    rand: Tr,\n    randomNormal: Nr,\n    randomGamma: Fr,\n    randomUniform: _r,\n    reshape: Or,\n    spaceToBatchND: Mr,\n    squeeze: Br,\n    stack: Pr,\n    tile: Lr,\n    truncatedNormal: Wr,\n    unstack: Ur,\n    setdiff1dAsync: Vr,\n    fill: Hn,\n    linspace: qn,\n    ones: zn,\n    range: Kn,\n    scalar: On,\n    tensor: Fn,\n    tensor1d: Mn,\n    tensor2d: Bn,\n    tensor3d: Pn,\n    tensor4d: Ln,\n    tensor5d: Wn,\n    tensor6d: Un,\n    variable: Vn,\n    zeros: Gn,\n    onesLike: jn,\n    zerosLike: Xn,\n    transpose: Wl,\n    softmax: go,\n    logSoftmax: yo,\n    localResponseNormalization: Ul,\n    norm: Vl,\n    gather: Lc,\n    unsortedSegmentSum: Wc,\n    basicLSTMCell: zl,\n    multiRNNCell: Gl,\n    movingAverage: Hl,\n    stridedSlice: ql,\n    topk: Kl,\n    scatterND: jl,\n    fft: Xl,\n    ifft: Yl,\n    rfft: $l,\n    irfft: Ql,\n    sparseToDense: Zl,\n    gatherND: th,\n    diag: eh,\n    dropout: nh,\n    hannWindow: oh,\n    hammingWindow: ah,\n    frame: ih,\n    stft: sh,\n    inTopKAsync: lh\n});\nfunction Hh(t, e) {\n    Array.isArray(t) || (t = [\n        t\n    ]), t.forEach(function(t) {\n        null != t && C(\"complex64\" !== t.dtype, function() {\n            return e + \" does not support complex64 tensors.\";\n        });\n    });\n}\nfunction qh(t, e, n, r) {\n    if (\"linear\" === n) return t.linear(e);\n    if (\"relu\" === n) return t.relu(e);\n    if (\"elu\" === n) return t.elu(e);\n    if (\"relu6\" === n) return t.relu6(e);\n    if (\"prelu\" === n) return t.prelu(e, r);\n    throw new Error(\"Activation \" + n + \" has not been implemented for the CPU backend.\");\n}\nvar Kh = function(t) {\n    function o() {\n        var e = t.call(this) || this;\n        return e.blockSize = 48, e.firstUse = !0, e.data = new xo(e, Lt), e;\n    }\n    return e(o, t), o.prototype.write = function(t, e, n) {\n        this.firstUse && (this.firstUse = !1, i().get(\"IS_NODE\") && dn(\"\\n============================\\nHi there \\uD83D\\uDC4B. Looks like you are running TensorFlow.js in Node.js. To speed things up dramatically, install our node backend, which binds to TensorFlow C++, by running npm i @tensorflow/tfjs-node, or npm i @tensorflow/tfjs-node-gpu if you have CUDA. Then call require('@tensorflow/tfjs-node'); (-gpu suffix for CUDA) at the start of your program. Visit https://github.com/tensorflow/tfjs-node for more details.\\n============================\"));\n        var r = {};\n        return this.data.set(r, {\n            values: t,\n            dtype: n\n        }), r;\n    }, o.prototype.move = function(t, e, n, r) {\n        this.data.set(t, {\n            values: e,\n            dtype: r\n        });\n    }, o.prototype.numDataIds = function() {\n        return this.data.numDataIds();\n    }, o.prototype.read = function(t) {\n        return n(this, void 0, void 0, function() {\n            return r(this, function(e) {\n                return [\n                    2,\n                    this.readSync(t)\n                ];\n            });\n        });\n    }, o.prototype.readSync = function(t) {\n        var e = this.data.get(t), n = e.dtype, r = e.complexTensors;\n        return \"complex64\" === n ? Vo(this.readSync(r.real.dataId), this.readSync(r.imag.dataId)) : this.data.get(t).values;\n    }, o.prototype.bufferSync = function(t) {\n        var e = this.readSync(t.dataId), n = e;\n        if (\"string\" === t.dtype) try {\n            n = e.map(function(t) {\n                return ot(t);\n            });\n        } catch (t) {\n            throw new Error(\"Failed to decode encoded string bytes into utf-8\");\n        }\n        return dr(t.shape, t.dtype, n);\n    }, o.prototype.makeOutput = function(t, e, n) {\n        var r = this.write(t, e, n);\n        return Lt.makeTensorFromDataId(r, e, n, this);\n    }, o.prototype.disposeData = function(t) {\n        if (this.data.has(t)) {\n            var e = this.data.get(t).complexTensors;\n            null != e && (e.real.dispose(), e.imag.dispose()), this.data.delete(t);\n        }\n    }, o.prototype.time = function(t) {\n        return n(this, void 0, void 0, function() {\n            var e;\n            return r(this, function(n) {\n                return e = et(), t(), [\n                    2,\n                    {\n                        kernelMs: et() - e\n                    }\n                ];\n            });\n        });\n    }, o.prototype.memory = function() {\n        return {\n            unreliable: !0,\n            reasons: [\n                \"The reported memory is an upper bound. Due to automatic garbage collection, the true allocated memory may be less.\"\n            ]\n        };\n    }, o.prototype.complex = function(t, e) {\n        var n = this.makeOutput(null, t.shape, \"complex64\");\n        return this.data.get(n.dataId).complexTensors = {\n            real: Lt.keep(t.clone()),\n            imag: Lt.keep(e.clone())\n        }, n;\n    }, o.prototype.real = function(t) {\n        return this.data.get(t.dataId).complexTensors.real.clone();\n    }, o.prototype.imag = function(t) {\n        return this.data.get(t.dataId).complexTensors.imag.clone();\n    }, o.prototype.slice = function(t, e, n) {\n        if (Hh(t, \"slice\"), io(t.shape, e, n)) {\n            var r = so(e, t.strides), o = k(n);\n            return Fn(this.readSync(t.dataId).subarray(r, r + o), n, t.dtype);\n        }\n        for(var a = dr(n, t.dtype), i = this.bufferSync(t), s = 0; s < a.size; ++s){\n            var u = a.indexToLoc(s).map(function(t, n) {\n                return t + e[n];\n            });\n            a.values[s] = i.get.apply(i, u);\n        }\n        return a.toTensor();\n    }, o.prototype.stridedSlice = function(t, e, n, r) {\n        Hh(t, \"stridedSlice\");\n        var o = ro(e, n, r);\n        if (o.some(function(t) {\n            return 0 === t;\n        })) return Fn([], o);\n        for(var a = dr(o, t.dtype), i = this.bufferSync(t), s = 0; s < a.size; s++){\n            for(var u = a.indexToLoc(s), c = new Array(u.length), l = 0; l < c.length; l++)c[l] = u[l] * r[l] + e[l];\n            a.set.apply(a, [\n                i.get.apply(i, c)\n            ].concat(u));\n        }\n        return a.toTensor();\n    }, o.prototype.diag = function(t) {\n        for(var e = this.readSync(t.dataId), n = dr([\n            t.size,\n            t.size\n        ], t.dtype), r = n.values, o = 0; o < e.length; o++)r[o * t.size + o] = e[o];\n        return n.toTensor();\n    }, o.prototype.unstack = function(t, e) {\n        for(var n = t.shape[e], r = new Array(t.rank - 1), o = 0, a = 0; a < t.rank; a++)a !== e && (r[o++] = t.shape[a]);\n        var i = new Array(t.rank).fill(0), s = t.shape.slice();\n        s[e] = 1;\n        var u = new Array(n);\n        for(a = 0; a < u.length; a++)i[e] = a, u[a] = this.slice(t, i, s).reshape(r);\n        return u;\n    }, o.prototype.reverse = function(t, e) {\n        Hh(t, \"reverse\");\n        for(var n = dr(t.shape, t.dtype), r = this.bufferSync(t), o = function(o) {\n            var a = n.indexToLoc(o), i = a.slice();\n            e.forEach(function(e) {\n                return i[e] = t.shape[e] - 1 - i[e];\n            }), n.set.apply(n, [\n                r.get.apply(r, i)\n            ].concat(a));\n        }, a = 0; a < n.size; a++)o(a);\n        return n.toTensor();\n    }, o.prototype.concat = function(t, e) {\n        var n = this;\n        if (\"complex64\" === t[0].dtype) {\n            var r = t.map(function(t) {\n                return Tn(t);\n            }), o = t.map(function(t) {\n                return Nn(t);\n            });\n            return Dn(this.concat(r, e), this.concat(o, e));\n        }\n        var a = t.map(function(t) {\n            var n = k(t.shape.slice(e));\n            return t.as2D(-1, n);\n        }), i = Sn(a.map(function(t) {\n            return t.shape;\n        }), 1), s = dr(i, t[0].dtype).values;\n        if (1 === a[0].shape[0]) {\n            var u = 0;\n            a.forEach(function(t) {\n                s.set(n.readSync(t.dataId), u), u += t.size;\n            });\n        } else {\n            var c = 0;\n            a.forEach(function(t) {\n                for(var e = n.readSync(t.dataId), r = 0, o = 0; o < t.shape[0]; ++o)for(var a = o * i[1] + c, u = 0; u < t.shape[1]; ++u)s[a + u] = e[r++];\n                c += t.shape[1];\n            });\n        }\n        var l = Sn(t.map(function(t) {\n            return t.shape;\n        }), e);\n        return Fn(s, l, t[0].dtype);\n    }, o.prototype.neg = function(t) {\n        return Hh(t, \"neg\"), this.multiply(On(-1), t);\n    }, o.prototype.add = function(t, e) {\n        return \"complex64\" === t.dtype || \"complex64\" === e.dtype ? this.broadcastedBinaryComplexOp(t.cast(\"complex64\"), e.cast(\"complex64\"), function(t, e, n, r) {\n            return {\n                real: t + n,\n                imag: e + r\n            };\n        }) : this.broadcastedBinaryOp(t, e, Dt(t.dtype, e.dtype), function(t, e) {\n            return t + e;\n        });\n    }, o.prototype.addN = function(t) {\n        var e = this;\n        Hh(t, \"addN\");\n        for(var n = t.map(function(t) {\n            return e.readSync(t.dataId);\n        }), r = dr(t[0].shape, t[0].dtype), o = r.values, a = 0; a < t.length; a++)for(var i = n[a], s = 0; s < o.length; s++)o[s] += i[s];\n        return r.toTensor();\n    }, o.prototype.softmax = function(t, e) {\n        var n = O([\n            e\n        ], t.shape), r = this.max(t, n), o = wn(r.shape, n), a = this.subtract(t, r.reshape(o)), i = this.exp(a), s = this.sum(i, n).reshape(o);\n        return this.realDivide(i, s);\n    }, o.prototype.subtract = function(t, e) {\n        return \"complex64\" === t.dtype || \"complex64\" === e.dtype ? this.broadcastedBinaryComplexOp(t.cast(\"complex64\"), e.cast(\"complex64\"), function(t, e, n, r) {\n            return {\n                real: t - n,\n                imag: e - r\n            };\n        }) : this.broadcastedBinaryOp(t, e, Dt(t.dtype, e.dtype), function(t, e) {\n            return t - e;\n        });\n    }, o.prototype.pow = function(t, e) {\n        return Hh([\n            t,\n            e\n        ], \"pow\"), this.broadcastedBinaryOp(t, e, t.dtype, function(t, e) {\n            return Math.pow(t, e);\n        });\n    }, o.prototype.batchMatMul = function(t, e, n, r) {\n        Hh([\n            t,\n            e\n        ], \"matMul\");\n        for(var o = n ? t.shape[1] : t.shape[2], a = n ? t.shape[2] : t.shape[1], i = r ? e.shape[1] : e.shape[2], s = t.shape[0], u = this.readSync(t.dataId), c = this.readSync(e.dataId), l = n ? [\n            t.strides[0],\n            1,\n            t.strides[1]\n        ] : [\n            t.strides[0],\n            t.strides[1],\n            1\n        ], h = l[0], f = l[1], d = l[2], p = r ? [\n            1,\n            e.strides[1],\n            e.strides[0]\n        ] : [\n            e.strides[1],\n            1,\n            e.strides[0]\n        ], v = p[0], m = p[1], g = p[2], y = a * i, x = dr([\n            s,\n            a,\n            i\n        ], t.dtype), b = x.values, w = this.blockSize, C = 0; C < s; C++)for(var E = 0; E < a; E += w)for(var R = 0; R < i; R += w)for(var I = 0; I < o; I += w)for(var k = Math.min(E + w, a), S = Math.min(R + w, i), A = Math.min(I + w, o), D = E; D < k; D++)for(var T = R; T < S; T++){\n            for(var N = 0, F = I; F < A; F++)N += u[C * h + D * f + F * d] * c[F * v + T * m + C * g];\n            b[C * y + (D * i + T)] += N;\n        }\n        return x.toTensor();\n    }, o.prototype.fusedBatchMatMul = function(t) {\n        var e = t.a, n = t.b, r = t.transposeA, o = t.transposeB, a = t.bias, i = t.activation, s = t.preluActivationWeights, u = this.batchMatMul(e, n, r, o);\n        return a && (u = this.add(u, a)), i && (u = qh(this, u, i, s)), u;\n    }, o.prototype.multiply = function(t, e) {\n        return \"complex64\" === t.dtype || \"complex64\" === e.dtype ? this.broadcastedBinaryComplexOp(t.cast(\"complex64\"), e.cast(\"complex64\"), function(t, e, n, r) {\n            return {\n                real: t * n - e * r,\n                imag: t * r + e * n\n            };\n        }) : this.broadcastedBinaryOp(t, e, Dt(t.dtype, e.dtype), function(t, e) {\n            return t * e;\n        });\n    }, o.prototype.realDivide = function(t, e) {\n        Hh([\n            t,\n            e\n        ], \"realDivide\");\n        return this.broadcastedBinaryOp(t, e, \"float32\", function(t, e) {\n            return t / e;\n        });\n    }, o.prototype.floorDiv = function(t, e) {\n        Hh([\n            t,\n            e\n        ], \"floorDiv\");\n        return this.broadcastedBinaryOp(t, e, \"int32\", function(t, e) {\n            return Math.floor(t / e);\n        });\n    }, o.prototype.sum = function(t, e) {\n        Hh(t, \"sum\"), Cn(\"sum\", e, t.rank);\n        for(var n = bn(t.shape, e), r = n[0], o = n[1], a = Gn(r, Dt(t.dtype, \"int32\")), i = k(o), s = this.readSync(a.dataId), u = this.readSync(t.dataId), c = 0; c < s.length; ++c){\n            for(var l = c * i, h = 0, f = 0; f < i; ++f)h += u[l + f];\n            s[c] = h;\n        }\n        return a;\n    }, o.prototype.prod = function(t, e) {\n        Hh(t, \"sum\");\n        for(var n = bn(t.shape, e), r = n[0], o = n[1], a = Gn(r, Dt(t.dtype, \"int32\")), i = k(o), s = this.readSync(a.dataId), u = this.readSync(t.dataId), c = 0; c < s.length; ++c){\n            for(var l = c * i, h = 1, f = 0; f < i; ++f)h *= u[l + f];\n            s[c] = h;\n        }\n        return a;\n    }, o.prototype.unsortedSegmentSum = function(t, e, n) {\n        Hh(t, \"unsortedSegmentSum\");\n        for(var r = [], o = t.rank - e.rank, a = 0; a < o; ++a)e = e.expandDims(a + 1);\n        for(a = 0; a < n; ++a){\n            var i = On(a, \"int32\"), s = Rc(i, e).asType(\"float32\").mul(t).sum(0);\n            r.push(s);\n        }\n        return Pr(r);\n    }, o.prototype.argMin = function(t, e) {\n        Hh(t, \"argMin\");\n        var n = [\n            e\n        ];\n        Cn(\"argMin\", n, t.rank);\n        for(var r = bn(t.shape, n), o = r[0], a = r[1], i = Gn(o, \"int32\"), s = k(a), u = this.readSync(i.dataId), c = this.readSync(t.dataId), l = 0; l < u.length; ++l){\n            for(var h = l * s, f = c[h], d = 0, p = 0; p < s; ++p){\n                var v = c[h + p];\n                v < f && (f = v, d = p);\n            }\n            u[l] = d;\n        }\n        return i;\n    }, o.prototype.argMax = function(t, e) {\n        Hh(t, \"argMax\");\n        var n = [\n            e\n        ];\n        Cn(\"argMax\", n, t.rank);\n        for(var r = bn(t.shape, n), o = r[0], a = r[1], i = Gn(o, \"int32\"), s = k(a), u = this.readSync(i.dataId), c = this.readSync(t.dataId), l = 0; l < u.length; ++l){\n            for(var h = l * s, f = c[h], d = 0, p = 0; p < s; ++p){\n                var v = c[h + p];\n                v > f && (f = v, d = p);\n            }\n            u[l] = d;\n        }\n        return i;\n    }, o.prototype.cumsum = function(t, e, n, r) {\n        if (Hh(t, \"cumsum\"), e !== t.rank - 1) throw new Error(\"backend.cumsum in CPU expects an inner-most axis=\" + (t.rank - 1) + \" but got axis=\" + e);\n        for(var o = Dt(t.dtype, \"int32\"), a = Gn(t.shape, o), i = this.readSync(a.dataId), s = this.readSync(t.dataId), u = t.shape[t.rank - 1], c = r ? function(t, e) {\n            return t + u - e - 1;\n        } : function(t, e) {\n            return t + e;\n        }, l = 0; l < s.length; l += u)for(var h = 0; h < u; h++){\n            var f = c(l, h);\n            if (0 === h) i[f] = n ? 0 : s[f];\n            else {\n                var d = c(l, h - 1);\n                i[f] = n ? s[d] + i[d] : s[f] + i[d];\n            }\n        }\n        return a;\n    }, o.prototype.equal = function(t, e) {\n        return Hh([\n            t,\n            e\n        ], \"equal\"), this.broadcastedBinaryOp(t, e, \"bool\", function(t, e) {\n            return t === e ? 1 : 0;\n        });\n    }, o.prototype.notEqual = function(t, e) {\n        return Hh([\n            t,\n            e\n        ], \"notEqual\"), this.broadcastedBinaryOp(t, e, \"bool\", function(t, e) {\n            return t !== e ? 1 : 0;\n        });\n    }, o.prototype.less = function(t, e) {\n        return Hh([\n            t,\n            e\n        ], \"less\"), this.broadcastedBinaryOp(t, e, \"bool\", function(t, e) {\n            return t < e ? 1 : 0;\n        });\n    }, o.prototype.lessEqual = function(t, e) {\n        return Hh([\n            t,\n            e\n        ], \"lessEqual\"), this.broadcastedBinaryOp(t, e, \"bool\", function(t, e) {\n            return t <= e ? 1 : 0;\n        });\n    }, o.prototype.greater = function(t, e) {\n        return Hh([\n            t,\n            e\n        ], \"greater\"), this.broadcastedBinaryOp(t, e, \"bool\", function(t, e) {\n            return t > e ? 1 : 0;\n        });\n    }, o.prototype.greaterEqual = function(t, e) {\n        return Hh([\n            t,\n            e\n        ], \"greaterEqual\"), this.broadcastedBinaryOp(t, e, \"bool\", function(t, e) {\n            return t >= e ? 1 : 0;\n        });\n    }, o.prototype.logicalNot = function(t) {\n        Hh(t, \"logicalNot\");\n        for(var e = this.readSync(t.dataId), n = new Uint8Array(e.length), r = 0; r < e.length; ++r)n[r] = e[r] ? 0 : 1;\n        return this.makeOutput(n, t.shape, \"bool\");\n    }, o.prototype.logicalAnd = function(t, e) {\n        return Hh([\n            t,\n            e\n        ], \"logicalAnd\"), this.broadcastedBinaryOp(t, e, \"bool\", function(t, e) {\n            return t && e;\n        });\n    }, o.prototype.logicalOr = function(t, e) {\n        return Hh([\n            t,\n            e\n        ], \"logicalOr\"), this.broadcastedBinaryOp(t, e, \"bool\", function(t, e) {\n            return t || e;\n        });\n    }, o.prototype.select = function(t, e, n) {\n        Hh([\n            t,\n            e,\n            n\n        ], \"select\");\n        for(var r = this.readSync(t.dataId), o = this.readSync(e.dataId), a = this.readSync(n.dataId), i = Gn(e.shape, Dt(e.dtype, n.dtype)), s = this.readSync(i.dataId), u = 0, c = 0 === t.rank || t.rank > 1 || 1 === e.rank ? 1 : k(e.shape.slice(1)), l = 0; l < r.length; l++)for(var h = 0; h < c; h++)1 === r[l] ? s[u++] = o[l] : s[u++] = a[l];\n        return i;\n    }, o.prototype.where = function(t) {\n        Hh([\n            t\n        ], \"where\");\n        var e = this.readSync(t.dataId);\n        return na(t.shape, e);\n    }, o.prototype.topk = function(t, e, n) {\n        return Hh(t, \"topk\"), ea(this.readSync(t.dataId), t.shape, t.dtype, e);\n    }, o.prototype.min = function(t, e) {\n        Hh(t, \"min\"), Cn(\"min\", e, t.rank);\n        for(var n = bn(t.shape, e), r = n[0], o = n[1], a = Gn(r, t.dtype), i = k(o), s = this.readSync(a.dataId), u = this.readSync(t.dataId), c = 0; c < s.length; ++c){\n            for(var l = c * i, h = u[l], f = 0; f < i; ++f){\n                var d = u[l + f];\n                d < h && (h = d);\n            }\n            s[c] = h;\n        }\n        return a;\n    }, o.prototype.minimum = function(t, e) {\n        return Hh([\n            t,\n            e\n        ], \"minimum\"), this.broadcastedBinaryOp(t, e, t.dtype, function(t, e) {\n            return Math.min(t, e);\n        });\n    }, o.prototype.mod = function(t, e) {\n        return Hh([\n            t,\n            e\n        ], \"mod\"), this.broadcastedBinaryOp(t, e, t.dtype, function(t, e) {\n            var n = t % e;\n            return t < 0 && e < 0 || t >= 0 && e >= 0 ? n : (n + e) % e;\n        });\n    }, o.prototype.max = function(t, e) {\n        Hh(t, \"max\"), Cn(\"max\", e, t.rank);\n        for(var n = bn(t.shape, e), r = n[0], o = n[1], a = Gn(r, t.dtype), i = k(o), s = this.readSync(a.dataId), u = this.readSync(t.dataId), c = 0; c < s.length; ++c){\n            for(var l = c * i, h = u[l], f = 0; f < i; ++f){\n                var d = u[l + f];\n                d > h && (h = d);\n            }\n            s[c] = h;\n        }\n        return a;\n    }, o.prototype.maximum = function(t, e) {\n        return Hh([\n            t,\n            e\n        ], \"maximum\"), this.broadcastedBinaryOp(t, e, t.dtype, function(t, e) {\n            return Math.max(t, e);\n        });\n    }, o.prototype.all = function(t, e) {\n        Hh(t, \"all\"), Cn(\"all\", e, t.rank);\n        for(var n = bn(t.shape, e), r = n[0], o = n[1], a = Gn(r, t.dtype), i = k(o), s = this.readSync(a.dataId), u = this.readSync(t.dataId), c = 0; c < s.length; ++c){\n            for(var l = c * i, h = u[l], f = 0; f < i; ++f){\n                var d = u[l + f];\n                h = h && d;\n            }\n            s[c] = h;\n        }\n        return a;\n    }, o.prototype.any = function(t, e) {\n        Hh(t, \"any\"), Cn(\"any\", e, t.rank);\n        for(var n = bn(t.shape, e), r = n[0], o = n[1], a = Gn(r, t.dtype), i = k(o), s = this.readSync(a.dataId), u = this.readSync(t.dataId), c = 0; c < s.length; ++c){\n            for(var l = c * i, h = u[l], f = 0; f < i; ++f){\n                var d = u[l + f];\n                h = h || d;\n            }\n            s[c] = h;\n        }\n        return a;\n    }, o.prototype.squaredDifference = function(t, e) {\n        return Hh([\n            t,\n            e\n        ], \"squaredDifference\"), this.broadcastedBinaryOp(t, e, t.dtype, function(t, e) {\n            var n = t - e;\n            return n * n;\n        });\n    }, o.prototype.ceil = function(t) {\n        Hh(t, \"ceil\");\n        for(var e = this.readSync(t.dataId), n = new Float32Array(e.length), r = 0; r < e.length; ++r)n[r] = Math.ceil(e[r]);\n        return this.makeOutput(n, t.shape, \"float32\");\n    }, o.prototype.floor = function(t) {\n        Hh(t, \"floor\");\n        for(var e = this.readSync(t.dataId), n = new Float32Array(e.length), r = 0; r < e.length; ++r)n[r] = Math.floor(e[r]);\n        return this.makeOutput(n, t.shape, \"float32\");\n    }, o.prototype.sign = function(t) {\n        Hh(t, \"x\");\n        for(var e = this.readSync(t.dataId), n = new Float32Array(e.length), r = 0; r < e.length; ++r)e[r] < 0 ? n[r] = -1 : e[r] > 0 ? n[r] = 1 : n[r] = 0;\n        return this.makeOutput(n, t.shape, \"float32\");\n    }, o.prototype.isNaN = function(t) {\n        Hh(t, \"x\");\n        for(var e = this.readSync(t.dataId), n = new Uint8Array(e.length), r = 0; r < e.length; ++r)Number.isNaN(e[r]) && (n[r] = 1);\n        return this.makeOutput(n, t.shape, \"bool\");\n    }, o.prototype.isInf = function(t) {\n        Hh(t, \"x\");\n        for(var e = this.readSync(t.dataId), n = new Uint8Array(e.length), r = 0; r < e.length; ++r)Math.abs(e[r]) === 1 / 0 && (n[r] = 1);\n        return this.makeOutput(n, t.shape, \"bool\");\n    }, o.prototype.isFinite = function(t) {\n        Hh(t, \"x\");\n        for(var e = this.readSync(t.dataId), n = new Uint8Array(e.length), r = 0; r < e.length; ++r)Number.isFinite(e[r]) && (n[r] = 1);\n        return this.makeOutput(n, t.shape, \"bool\");\n    }, o.prototype.round = function(t) {\n        Hh(t, \"round\");\n        for(var e = this.readSync(t.dataId), n = new Float32Array(e.length), r = 0; r < e.length; ++r){\n            var o = Math.floor(e[r]);\n            e[r] - o < .5 ? n[r] = Math.floor(e[r]) : e[r] - o > .5 ? n[r] = Math.ceil(e[r]) : n[r] = o % 2 == 0 ? o : o + 1;\n        }\n        return this.makeOutput(n, t.shape, \"float32\");\n    }, o.prototype.exp = function(t) {\n        Hh(t, \"exp\");\n        for(var e = this.readSync(t.dataId), n = new Float32Array(e.length), r = 0; r < e.length; ++r)n[r] = Math.exp(e[r]);\n        return this.makeOutput(n, t.shape, \"float32\");\n    }, o.prototype.expm1 = function(t) {\n        Hh(t, \"expm1\");\n        for(var e = this.readSync(t.dataId), n = new Float32Array(e.length), r = 0; r < e.length; ++r)n[r] = Math.expm1(e[r]);\n        return this.makeOutput(n, t.shape, \"float32\");\n    }, o.prototype.log = function(t) {\n        Hh(t, \"log\");\n        for(var e = this.readSync(t.dataId), n = new Float32Array(e.length), r = 0; r < e.length; ++r){\n            var o = e[r];\n            n[r] = Math.log(o);\n        }\n        return this.makeOutput(n, t.shape, \"float32\");\n    }, o.prototype.log1p = function(t) {\n        Hh(t, \"log1p\");\n        for(var e = this.readSync(t.dataId), n = new Float32Array(e.length), r = 0; r < e.length; ++r){\n            var o = e[r];\n            n[r] = Math.log1p(o);\n        }\n        return this.makeOutput(n, t.shape, \"float32\");\n    }, o.prototype.sqrt = function(t) {\n        Hh(t, \"sqrt\");\n        for(var e = this.readSync(t.dataId), n = new Float32Array(e.length), r = 0; r < e.length; ++r){\n            var o = e[r];\n            n[r] = Math.sqrt(o);\n        }\n        return this.makeOutput(n, t.shape, \"float32\");\n    }, o.prototype.rsqrt = function(t) {\n        Hh(t, \"rsqrt\");\n        for(var e = this.readSync(t.dataId), n = new Float32Array(e.length), r = 0; r < e.length; ++r){\n            var o = e[r];\n            n[r] = 1 / Math.sqrt(o);\n        }\n        return this.makeOutput(n, t.shape, \"float32\");\n    }, o.prototype.reciprocal = function(t) {\n        Hh(t, \"reciprocal\");\n        for(var e = this.readSync(t.dataId), n = new Float32Array(e.length), r = 0; r < e.length; ++r)n[r] = 1 / e[r];\n        return this.makeOutput(n, t.shape, \"float32\");\n    }, o.prototype.linear = function(t) {\n        return t;\n    }, o.prototype.relu = function(t) {\n        Hh(t, \"relu\");\n        for(var e = Gn(t.shape, t.dtype), n = this.readSync(e.dataId), r = this.readSync(t.dataId), o = 0; o < r.length; ++o)n[o] = Math.max(0, r[o]);\n        return e;\n    }, o.prototype.relu6 = function(t) {\n        Hh(t, \"relu\");\n        for(var e = Gn(t.shape, t.dtype), n = this.readSync(e.dataId), r = this.readSync(t.dataId), o = 0; o < r.length; ++o)n[o] = Math.min(Math.max(0, r[o]), 6);\n        return e;\n    }, o.prototype.prelu = function(t, e) {\n        return Hh([\n            t,\n            e\n        ], \"prelu\"), this.broadcastedBinaryOp(t, e, t.dtype, function(t, e) {\n            return t < 0 ? e * t : t;\n        });\n    }, o.prototype.elu = function(t) {\n        Hh(t, \"elu\");\n        for(var e = new Float32Array(t.size), n = this.readSync(t.dataId), r = 0; r < n.length; ++r){\n            var o = n[r];\n            e[r] = o >= 0 ? o : Math.exp(o) - 1;\n        }\n        return this.makeOutput(e, t.shape, \"float32\");\n    }, o.prototype.eluDer = function(t, e) {\n        Hh([\n            t,\n            e\n        ], \"eluDer\");\n        for(var n = new Float32Array(e.size), r = this.readSync(e.dataId), o = this.readSync(t.dataId), a = 0; a < r.length; ++a){\n            var i = r[a];\n            n[a] = i >= 1 ? o[a] : o[a] * (i + 1);\n        }\n        return this.makeOutput(n, e.shape, \"float32\");\n    }, o.prototype.selu = function(t) {\n        Hh(t, \"selu\");\n        for(var e = bs, n = ws, r = new Float32Array(t.size), o = this.readSync(t.dataId), a = 0; a < o.length; ++a){\n            var i = o[a];\n            r[a] = i >= 0 ? n * i : e * (Math.exp(i) - 1);\n        }\n        return this.makeOutput(r, t.shape, \"float32\");\n    }, o.prototype.clip = function(t, e, n) {\n        Hh(t, \"clip\");\n        for(var r = new Float32Array(t.size), o = this.readSync(t.dataId), a = 0; a < o.length; ++a){\n            var i = o[a];\n            r[a] = i > n ? n : i < e ? e : i;\n        }\n        return this.makeOutput(r, t.shape, \"float32\");\n    }, o.prototype.abs = function(t) {\n        for(var e = new Float32Array(t.size), n = this.readSync(t.dataId), r = 0; r < n.length; ++r)e[r] = Math.abs(n[r]);\n        return this.makeOutput(e, t.shape, \"float32\");\n    }, o.prototype.complexAbs = function(t) {\n        for(var e = new Float32Array(t.size), n = this.readSync(t.dataId), r = 0; r < t.size; ++r){\n            var o = n[2 * r], a = n[2 * r + 1];\n            e[r] = Math.hypot(o, a);\n        }\n        return this.makeOutput(e, t.shape, \"float32\");\n    }, o.prototype.int = function(t) {\n        Hh(t, \"int\");\n        for(var e = new Int32Array(t.size), n = this.readSync(t.dataId), r = 0; r < n.length; ++r)e[r] = n[r];\n        return this.makeOutput(e, t.shape, \"int32\");\n    }, o.prototype.sigmoid = function(t) {\n        Hh(t, \"sigmoid\");\n        for(var e = new Float32Array(t.size), n = this.readSync(t.dataId), r = 0; r < n.length; ++r)e[r] = 1 / (1 + Math.exp(-n[r]));\n        return this.makeOutput(e, t.shape, \"float32\");\n    }, o.prototype.softplus = function(t) {\n        Hh(t, \"softplus\");\n        for(var e = Math.log(1.1920928955078125e-7) + 2, n = new Float32Array(t.size), r = this.readSync(t.dataId), o = 0; o < r.length; ++o){\n            var a = r[o] > -e, i = r[o] < e, s = Math.exp(r[o]), u = void 0;\n            u = i ? s : a ? r[o] : Math.log(1 + s), n[o] = u;\n        }\n        return this.makeOutput(n, t.shape, \"float32\");\n    }, o.prototype.sin = function(t) {\n        Hh(t, \"sin\");\n        for(var e = new Float32Array(t.size), n = this.readSync(t.dataId), r = 0; r < n.length; ++r)e[r] = Math.sin(n[r]);\n        return this.makeOutput(e, t.shape, \"float32\");\n    }, o.prototype.cos = function(t) {\n        Hh(t, \"cos\");\n        for(var e = new Float32Array(t.size), n = this.readSync(t.dataId), r = 0; r < n.length; ++r)e[r] = Math.cos(n[r]);\n        return this.makeOutput(e, t.shape, \"float32\");\n    }, o.prototype.tan = function(t) {\n        Hh(t, \"tan\");\n        for(var e = new Float32Array(t.size), n = this.readSync(t.dataId), r = 0; r < n.length; ++r)e[r] = Math.tan(n[r]);\n        return this.makeOutput(e, t.shape, \"float32\");\n    }, o.prototype.asin = function(t) {\n        Hh(t, \"asin\");\n        for(var e = new Float32Array(t.size), n = this.readSync(t.dataId), r = 0; r < n.length; ++r)e[r] = Math.asin(n[r]);\n        return this.makeOutput(e, t.shape, \"float32\");\n    }, o.prototype.acos = function(t) {\n        Hh(t, \"acos\");\n        for(var e = new Float32Array(t.size), n = this.readSync(t.dataId), r = 0; r < n.length; ++r)e[r] = Math.acos(n[r]);\n        return this.makeOutput(e, t.shape, \"float32\");\n    }, o.prototype.atan = function(t) {\n        Hh(t, \"atan\");\n        for(var e = new Float32Array(t.size), n = this.readSync(t.dataId), r = 0; r < n.length; ++r)e[r] = Math.atan(n[r]);\n        return this.makeOutput(e, t.shape, \"float32\");\n    }, o.prototype.atan2 = function(t, e) {\n        return Hh([\n            t,\n            e\n        ], \"atan2\"), this.broadcastedBinaryOp(t, e, t.dtype, function(t, e) {\n            return Math.atan2(t, e);\n        });\n    }, o.prototype.sinh = function(t) {\n        Hh(t, \"sinh\");\n        for(var e = new Float32Array(t.size), n = this.readSync(t.dataId), r = 0; r < n.length; ++r)e[r] = Math.sinh(n[r]);\n        return this.makeOutput(e, t.shape, \"float32\");\n    }, o.prototype.cosh = function(t) {\n        Hh(t, \"cosh\");\n        for(var e = new Float32Array(t.size), n = this.readSync(t.dataId), r = 0; r < n.length; ++r)e[r] = Math.cosh(n[r]);\n        return this.makeOutput(e, t.shape, \"float32\");\n    }, o.prototype.tanh = function(t) {\n        Hh(t, \"tanh\");\n        for(var e = new Float32Array(t.size), n = this.readSync(t.dataId), r = 0; r < n.length; ++r)e[r] = D(n[r]);\n        return this.makeOutput(e, t.shape, \"float32\");\n    }, o.prototype.asinh = function(t) {\n        Hh(t, \"asinh\");\n        for(var e = new Float32Array(t.size), n = this.readSync(t.dataId), r = 0; r < n.length; ++r)e[r] = Math.asinh(n[r]);\n        return this.makeOutput(e, t.shape, \"float32\");\n    }, o.prototype.acosh = function(t) {\n        Hh(t, \"acosh\");\n        for(var e = new Float32Array(t.size), n = this.readSync(t.dataId), r = 0; r < n.length; ++r)e[r] = Math.acosh(n[r]);\n        return this.makeOutput(e, t.shape, \"float32\");\n    }, o.prototype.atanh = function(t) {\n        Hh(t, \"atanh\");\n        for(var e = new Float32Array(t.size), n = this.readSync(t.dataId), r = 0; r < n.length; ++r)e[r] = Math.atanh(n[r]);\n        return this.makeOutput(e, t.shape, \"float32\");\n    }, o.prototype.erf = function(t) {\n        Hh(t, \"erf\");\n        for(var e = new Float32Array(t.size), n = this.readSync(t.dataId), r = 0; r < n.length; ++r){\n            var o = Math.sign(n[r]), a = Math.abs(n[r]), i = 1 / (1 + .3275911 * a);\n            e[r] = o * (1 - ((((1.061405429 * i - 1.453152027) * i + 1.421413741) * i - .284496736) * i + .254829592) * i * Math.exp(-a * a));\n        }\n        return this.makeOutput(e, t.shape, \"float32\");\n    }, o.prototype.step = function(t, e) {\n        void 0 === e && (e = 0), Hh(t, \"step\");\n        for(var n = new Float32Array(t.size), r = this.readSync(t.dataId), o = 0; o < r.length; ++o){\n            var a = r[o];\n            isNaN(a) ? n[o] = NaN : n[o] = a > 0 ? 1 : e;\n        }\n        return this.makeOutput(n, t.shape, \"float32\");\n    }, o.prototype.fusedConv2d = function(t) {\n        var e = t.input, n = t.filter, r = t.convInfo, o = t.bias, a = t.activation, i = t.preluActivationWeights, s = this.conv2d(e, n, r);\n        return o && (s = this.add(s, o)), a && (s = qh(this, s, a, i)), s;\n    }, o.prototype.conv2d = function(t, e, n) {\n        Hh([\n            t,\n            e\n        ], \"conv2d\");\n        for(var r = n.filterHeight, o = n.filterWidth, a = n.dilationHeight, i = n.dilationWidth, s = n.padInfo.left, u = n.padInfo.top, c = \"channelsLast\" === n.dataFormat, l = dr(n.outShape, t.dtype), h = t.strides[0], f = c ? t.strides[1] : t.strides[2], d = c ? t.strides[2] : 1, p = c ? 1 : t.strides[1], v = l.strides[0], m = c ? l.strides[1] : l.strides[2], g = c ? l.strides[2] : 1, y = c ? 1 : l.strides[1], x = this.readSync(t.dataId), b = this.readSync(e.dataId), w = l.values, C = 0; C < n.batchSize; ++C)for(var E = C * h, R = C * v, I = 0; I < n.outHeight; ++I)for(var k = R + I * m, S = I * n.strideHeight - u, A = 0; A < r; A++){\n            var D = S + A * a;\n            if (!(D < 0 || D >= n.inHeight)) for(var T = A * e.strides[0], N = E + D * f, F = 0; F < n.outWidth; ++F)for(var _ = k + F * g, O = F * n.strideWidth - s, M = 0; M < o; M++){\n                var B = O + M * i;\n                if (!(B < 0 || B >= n.inWidth)) for(var P = N + B * d, L = T + M * e.strides[1], W = 0; W < n.inChannels; ++W){\n                    for(var U = x[P + W * p], V = 0; V < n.outChannels; ++V)w[_ + V * y] += U * b[L + V];\n                    L += n.outChannels;\n                }\n            }\n        }\n        return l.toTensor();\n    }, o.prototype.conv3d = function(t, e, n) {\n        for(var r = n.filterDepth, o = n.filterHeight, a = n.filterWidth, i = n.dilationDepth, s = n.dilationHeight, u = n.dilationWidth, c = n.padInfo.front, l = n.padInfo.left, h = n.padInfo.top, f = dr(n.outShape, t.dtype), d = this.readSync(t.dataId), p = this.readSync(e.dataId), v = f.values, m = 0; m < n.batchSize; ++m)for(var g = m * t.strides[0], y = m * f.strides[0], x = 0; x < n.outDepth; ++x)for(var b = y + x * f.strides[1], w = x * n.strideDepth - c, C = 0; C < r; C++){\n            var E = w + C * i;\n            if (!(E < 0 || E >= n.inDepth)) for(var R = C * e.strides[0], I = g + E * t.strides[1], k = 0; k < n.outHeight; ++k)for(var S = b + k * f.strides[2], A = k * n.strideHeight - h, D = 0; D < o; D++){\n                var T = A + D * s;\n                if (!(T < 0 || T >= n.inHeight)) for(var N = R + D * e.strides[1], F = I + T * t.strides[2], _ = 0; _ < n.outWidth; ++_)for(var O = S + _ * n.outChannels, M = _ * n.strideWidth - l, B = 0; B < a; B++){\n                    var P = M + B * u;\n                    if (!(P < 0 || P >= n.inWidth)) for(var L = N + B * e.strides[2], W = F + P * n.inChannels, U = L, V = 0; V < n.inChannels; ++V){\n                        for(var z = d[W + V], G = 0; G < n.outChannels; ++G)v[O + G] += z * p[U + G];\n                        U += n.outChannels;\n                    }\n                }\n            }\n        }\n        return f.toTensor();\n    }, o.prototype.conv2dDerInput = function(t, e, n) {\n        Hh([\n            t,\n            e\n        ], \"conv2dDerInput\");\n        for(var r = dr(n.inShape, \"float32\"), o = r.values, a = this.readSync(t.dataId), i = this.readSync(e.dataId), s = e.strides, u = s[0], c = s[1], l = s[2], h = n.batchSize, f = n.filterHeight, d = n.filterWidth, p = n.inChannels, v = n.inHeight, m = n.inWidth, g = n.outChannels, y = n.outHeight, x = n.outWidth, b = n.strideHeight, w = n.strideWidth, C = n.dataFormat, E = f - 1 - n.padInfo.top, R = d - 1 - n.padInfo.left, I = \"channelsLast\" === C, k = r.strides[0], S = I ? r.strides[1] : r.strides[2], A = I ? r.strides[2] : 1, D = I ? 1 : r.strides[1], T = t.strides[0], N = I ? t.strides[1] : t.strides[2], F = I ? t.strides[2] : 1, _ = I ? 1 : t.strides[1], O = 0; O < h; ++O)for(var M = 0; M < p; ++M)for(var B = 0; B < v; ++B)for(var P = B - E, L = Math.max(0, Math.ceil(P / b)), W = Math.min(y, (f + P) / b), U = 0; U < m; ++U){\n            for(var V = U - R, z = Math.max(0, Math.ceil(V / w)), G = Math.min(x, (d + V) / w), H = 0, q = L; q < W; ++q)for(var K = q * b - P, j = z; j < G; ++j)for(var X = T * O + N * q + F * j, Y = u * (f - 1 - K) + c * (d - 1 - (j * w - V)) + l * M, $ = 0; $ < g; ++$){\n                H += a[X + _ * $] * i[Y + $];\n            }\n            o[k * O + S * B + A * U + D * M] = H;\n        }\n        return r.toTensor();\n    }, o.prototype.conv3dDerInput = function(t, e, n) {\n        for(var r = dr(n.inShape, \"float32\"), o = r.values, a = r.strides, i = a[0], s = a[1], u = a[2], c = a[3], l = this.readSync(t.dataId), h = t.strides, f = h[0], d = h[1], p = h[2], v = h[3], m = this.readSync(e.dataId), g = e.strides, y = g[0], x = g[1], b = g[2], w = g[3], C = n.batchSize, E = n.filterDepth, R = n.filterHeight, I = n.filterWidth, k = n.inChannels, S = n.inDepth, A = n.inHeight, D = n.inWidth, T = n.outChannels, N = n.outDepth, F = n.outHeight, _ = n.outWidth, O = n.strideDepth, M = n.strideHeight, B = n.strideWidth, P = E - 1 - n.padInfo.front, L = R - 1 - n.padInfo.top, W = I - 1 - n.padInfo.left, U = 0; U < C; ++U)for(var V = 0; V < k; ++V)for(var z = 0; z < S; ++z)for(var G = z - P, H = Math.max(0, Math.ceil(G / O)), q = Math.min(N, (E + G) / O), K = 0; K < A; ++K)for(var j = K - L, X = Math.max(0, Math.ceil(j / M)), Y = Math.min(F, (R + j) / M), $ = 0; $ < D; ++$){\n            for(var Q = $ - W, J = Math.max(0, Math.ceil(Q / B)), Z = Math.min(_, (I + Q) / B), tt = 0, et = H; et < q; ++et)for(var nt = et * O - G, rt = X; rt < Y; ++rt)for(var ot = rt * M - j, at = J; at < Z; ++at)for(var it = f * U + d * et + p * rt + v * at, st = y * (E - 1 - nt) + x * (R - 1 - ot) + b * (I - 1 - (at * B - Q)) + w * V, ut = 0; ut < T; ++ut){\n                tt += l[it + ut] * m[st + ut];\n            }\n            o[i * U + s * z + u * K + c * $ + V] = tt;\n        }\n        return r.toTensor();\n    }, o.prototype.conv2dDerFilter = function(t, e, n) {\n        Hh([\n            t,\n            e\n        ], \"conv2dDerFilter\");\n        for(var r = n.strideHeight, o = n.strideWidth, a = n.filterHeight, i = n.filterWidth, s = \"channelsLast\" === n.dataFormat, u = dr(n.filterShape, \"float32\"), c = n.padInfo.left, l = n.padInfo.top, h = this.bufferSync(t), f = this.bufferSync(e), d = 0; d < a; ++d)for(var p = Math.max(0, Math.ceil((l - d) / r)), v = Math.min(n.outHeight, (n.inHeight + l - d) / r), m = 0; m < i; ++m)for(var g = Math.max(0, Math.ceil((c - m) / o)), y = Math.min(n.outWidth, (n.inWidth + c - m) / o), x = 0; x < n.inChannels; ++x)for(var b = 0; b < n.outChannels; ++b){\n            for(var w = 0, C = 0; C < n.batchSize; ++C)for(var E = p; E < v; ++E)for(var R = d + E * r - l, I = g; I < y; ++I){\n                var k = m + I * o - c;\n                w += s ? h.get(C, R, k, x) * f.get(C, E, I, b) : h.get(C, x, R, k) * f.get(C, b, E, I);\n            }\n            u.set(w, d, m, x, b);\n        }\n        return u.toTensor();\n    }, o.prototype.conv3dDerFilter = function(t, e, n) {\n        for(var r = n.strideDepth, o = n.strideHeight, a = n.strideWidth, i = n.filterDepth, s = n.filterHeight, u = n.filterWidth, c = dr(n.filterShape, \"float32\"), l = c.values, h = c.strides, f = h[0], d = h[1], p = h[2], v = h[3], m = this.readSync(e.dataId), g = e.strides, y = g[0], x = g[1], b = g[2], w = g[3], C = this.readSync(t.dataId), E = t.strides, R = E[0], I = E[1], k = E[2], S = E[3], A = n.padInfo.front, D = n.padInfo.left, T = n.padInfo.top, N = 0; N < i; ++N)for(var F = Math.max(0, Math.ceil((A - N) / r)), _ = Math.min(n.outDepth, (n.inDepth + A - N) / r), O = N * f, M = 0; M < s; ++M)for(var B = Math.max(0, Math.ceil((T - M) / o)), P = Math.min(n.outHeight, (n.inHeight + T - M) / o), L = M * d + O, W = 0; W < u; ++W)for(var U = Math.max(0, Math.ceil((D - W) / a)), V = Math.min(n.outWidth, (n.inWidth + D - W) / a), z = W * p + L, G = 0; G < n.inChannels; ++G)for(var H = G * v + z, q = 0; q < n.outChannels; ++q){\n            for(var K = 0, j = 0; j < n.batchSize; ++j)for(var X = j * R, Y = j * y, $ = F; $ < _; ++$)for(var Q = (N + $ * r - A) * I + X, J = $ * x + Y, Z = B; Z < P; ++Z)for(var tt = (M + Z * o - T) * k + Q, et = Z * b + J, nt = U; nt < V; ++nt){\n                var rt = nt * w + et;\n                K += C[(W + nt * a - D) * S + tt + G] * m[rt + q];\n            }\n            l[H + q] = K;\n        }\n        return c.toTensor();\n    }, o.prototype.fusedDepthwiseConv2D = function(t) {\n        var e = t.input, n = t.filter, r = t.convInfo, o = t.bias, a = t.activation, i = t.preluActivationWeights, s = this.depthwiseConv2D(e, n, r);\n        return o && (s = this.add(s, o)), a && (s = qh(this, s, a, i)), s;\n    }, o.prototype.depthwiseConv2D = function(t, e, n) {\n        Hh([\n            t,\n            e\n        ], \"depthwiseConv2D\");\n        for(var r = n.filterHeight, o = n.filterWidth, a = n.dilationHeight, i = n.dilationWidth, s = n.padInfo.left, u = n.padInfo.top, c = n.outChannels / n.inChannels, l = dr(n.outShape, t.dtype), h = this.readSync(t.dataId), f = this.readSync(e.dataId), d = l.values, p = 0; p < n.batchSize; ++p)for(var v = p * t.strides[0], m = p * l.strides[0], g = 0; g < n.outHeight; ++g)for(var y = m + g * l.strides[1], x = g * n.strideHeight - s, b = 0; b < r; ++b){\n            var w = x + b * a;\n            if (!(w < 0 || w >= n.inHeight)) for(var C = b * e.strides[0], E = v + w * t.strides[1], R = 0; R < n.outWidth; ++R)for(var I = y + R * l.strides[2], k = R * n.strideWidth - u, S = 0; S < o; ++S){\n                var A = k + S * i;\n                if (!(A < 0 || A >= n.inWidth)) for(var D = C + S * e.strides[1], T = E + A * n.inChannels, N = I, F = D, _ = 0; _ < n.inChannels; ++_){\n                    for(var O = h[T + _], M = 0; M < c; ++M)d[N + M] += O * f[F + M];\n                    N += c, F += c;\n                }\n            }\n        }\n        return l.toTensor();\n    }, o.prototype.depthwiseConv2DDerInput = function(t, e, n) {\n        Hh([\n            t,\n            e\n        ], \"depthwiseConv2DDerInput\");\n        for(var r = dr(n.inShape, \"float32\"), o = r.values, a = r.strides, i = a[0], s = a[1], u = a[2], c = this.readSync(t.dataId), l = t.strides, h = l[0], f = l[1], d = l[2], p = this.readSync(e.dataId), v = e.strides, m = v[0], g = v[1], y = v[2], x = n.batchSize, b = n.filterHeight, w = n.filterWidth, C = n.inChannels, E = n.inHeight, R = n.inWidth, I = n.outChannels, k = n.outHeight, S = n.outWidth, A = n.strideHeight, D = n.strideWidth, T = b - 1 - n.padInfo.top, N = w - 1 - n.padInfo.left, F = I / C, _ = 0; _ < x; ++_)for(var O = 0; O < C; ++O)for(var M = 0; M < E; ++M)for(var B = M - T, P = Math.max(0, Math.ceil(B / A)), L = Math.min(k, (b + B) / A), W = 0; W < R; ++W){\n            for(var U = W - N, V = Math.max(0, Math.ceil(U / D)), z = Math.min(S, (w + U) / D), G = 0, H = P; H < L; ++H)for(var q = H * A - B, K = V; K < z; ++K)for(var j = h * _ + f * H + d * K, X = m * (b - 1 - q) + g * (w - 1 - (K * D - U)) + y * O, Y = 0; Y < F; ++Y){\n                G += c[j + (O * F + Y)] * p[X + Y];\n            }\n            o[i * _ + s * M + u * W + O] = G;\n        }\n        return r.toTensor();\n    }, o.prototype.depthwiseConv2DDerFilter = function(t, e, n) {\n        Hh([\n            t,\n            e\n        ], \"depthwiseConv2DDerFilter\");\n        for(var r = n.strideHeight, o = n.strideWidth, a = n.filterHeight, i = n.filterWidth, s = dr(n.filterShape, \"float32\"), u = n.padInfo.left, c = n.padInfo.top, l = n.outChannels / n.inChannels, h = this.bufferSync(t), f = this.bufferSync(e), d = 0; d < a; ++d)for(var p = Math.max(0, Math.ceil((c - d) / r)), v = Math.min(n.outHeight, (n.inHeight + c - d) / r), m = 0; m < i; ++m)for(var g = Math.max(0, Math.ceil((u - m) / o)), y = Math.min(n.outWidth, (n.inWidth + u - m) / o), x = 0; x < n.outChannels; ++x){\n            for(var b = Math.trunc(x / l), w = x % l, C = 0, E = 0; E < n.batchSize; ++E)for(var R = p; R < v; ++R)for(var I = d + R * r - c, k = g; k < y; ++k){\n                var S = m + k * o - u;\n                C += h.get(E, I, S, b) * f.get(E, R, k, x);\n            }\n            s.set(C, d, m, b, w);\n        }\n        return s.toTensor();\n    }, o.prototype.tile = function(t, e) {\n        return Hh(t, \"tile\"), ta(this.bufferSync(t), e);\n    }, o.prototype.pad = function(t, e, n) {\n        Hh(t, \"pad\");\n        var r = e.map(function(e, n) {\n            return e[0] + t.shape[n] + e[1];\n        }), o = e.map(function(t) {\n            return t[0];\n        }), a = this.bufferSync(t), i = dr(r, t.dtype);\n        0 !== n && i.values.fill(n);\n        for(var s = 0; s < t.size; s++){\n            var u = a.indexToLoc(s), c = u.map(function(t, e) {\n                return t + o[e];\n            });\n            i.set.apply(i, [\n                a.get.apply(a, u)\n            ].concat(c));\n        }\n        return i.toTensor();\n    }, o.prototype.transpose = function(t, e) {\n        Hh(t, \"transpose\");\n        for(var n = new Array(t.rank), r = 0; r < n.length; r++)n[r] = t.shape[e[r]];\n        var o = this.readSync(t.dataId), a = dr(n, t.dtype), i = this.bufferSync(t);\n        for(r = 0; r < t.size; ++r){\n            for(var s = i.indexToLoc(r), u = new Array(s.length), c = 0; c < u.length; c++)u[c] = s[e[c]];\n            var l = a.locToIndex(u);\n            a.values[l] = o[r];\n        }\n        return a.toTensor();\n    }, o.prototype.gather = function(t, e, n) {\n        Hh([\n            t,\n            e\n        ], \"gather\");\n        var r = t.shape.slice(), o = this.readSync(e.dataId);\n        r[n] = o.length;\n        for(var a = dr(r, t.dtype), i = this.bufferSync(t), s = 0; s < a.size; ++s){\n            var u = a.indexToLoc(s), c = u.slice();\n            c[n] = o[u[n]];\n            var l = i.locToIndex(c);\n            a.values[s] = i.values[l];\n        }\n        return a.toTensor();\n    }, o.prototype.batchToSpaceND = function(t, e, n) {\n        Hh([\n            t\n        ], \"batchToSpaceND\");\n        var r = e.reduce(function(t, e) {\n            return t * e;\n        }), o = zr(t.shape, e, r), a = Gr(o.length, e.length), i = Hr(t.shape, e, r), s = qr(n, e.length), u = Kr(i, n, e.length);\n        return t.reshape(o).transpose(a).reshape(i).slice(s, u);\n    }, o.prototype.spaceToBatchND = function(t, e, n) {\n        Hh([\n            t\n        ], \"spaceToBatchND\");\n        var r = e.reduce(function(t, e) {\n            return t * e;\n        }), o = [\n            [\n                0,\n                0\n            ]\n        ];\n        o.push.apply(o, n);\n        for(var a = 1 + e.length; a < t.shape.length; ++a)o.push([\n            0,\n            0\n        ]);\n        var i = t.pad(o), s = zr(i.shape, e, r, !1), u = Gr(s.length, e.length, !1), c = Hr(i.shape, e, r, !1);\n        return i.reshape(s).transpose(u).reshape(c);\n    }, o.prototype.pool = function(t, e, n) {\n        Hh(t, \"pool\");\n        for(var r = e.strideHeight, o = e.strideWidth, a = e.dilationHeight, i = e.dilationWidth, s = e.effectiveFilterHeight, u = e.effectiveFilterWidth, c = e.padInfo.top, l = e.padInfo.left, h = \"max\" === n ? Number.NEGATIVE_INFINITY : Number.POSITIVE_INFINITY, f = this.readSync(t.dataId), d = dr(e.outShape, t.dtype), p = d.values, v = e.outShape[1] * e.outShape[2] * e.outShape[3], m = e.outShape[2] * e.outShape[3], g = e.outShape[3], y = 0; y < e.batchSize; ++y)for(var x = y * v, b = y * t.strides[0], w = 0; w < e.inChannels; ++w)for(var C = 0; C < e.outHeight; ++C)for(var E = C * r - c, R = Math.max(0, E), I = Math.min(e.inHeight, s + E), k = x + C * m, S = 0; S < e.outWidth; ++S){\n            for(var A = S * o - l, D = Math.max(0, A), T = Math.min(e.inWidth, u + A), N = h, F = 0, _ = 0, O = R; O < I; O += a){\n                for(var M = b + O * t.strides[1], B = D; B < T; B += i){\n                    var P = f[M + B * t.strides[2] + w];\n                    \"max\" === n && P > N ? N = P : \"avg\" === n && (F += P, _++);\n                }\n                if (isNaN(N)) break;\n            }\n            p[k + S * g + w] = \"avg\" === n ? F / _ : N;\n        }\n        return d.toTensor();\n    }, o.prototype.maxPool = function(t, e) {\n        return this.pool(t, e, \"max\");\n    }, o.prototype.maxPoolPositions = function(t, e) {\n        for(var n = dr(e.outShape, \"int32\"), r = e.strideHeight, o = e.strideWidth, a = e.dilationHeight, i = e.dilationWidth, s = e.effectiveFilterHeight, u = e.effectiveFilterWidth, c = e.padInfo.top, l = e.padInfo.left, h = this.bufferSync(t), f = 0; f < e.batchSize; ++f)for(var d = 0; d < e.inChannels; ++d)for(var p = 0; p < e.outHeight; ++p){\n            for(var v = p * r - c, m = v; m < 0;)m += a;\n            for(var g = Math.min(e.inHeight, s + v), y = 0; y < e.outWidth; ++y){\n                for(var x = y * o - l, b = x; b < 0;)b += i;\n                for(var w = Math.min(e.inWidth, u + x), C = Number.NEGATIVE_INFINITY, E = -1, R = m; R < g; R += a)for(var I = R - v, k = b; k < w; k += i){\n                    var S = k - x, A = h.get(f, R, k, d);\n                    A > C && (C = A, E = I * u + S);\n                }\n                n.set(E, f, p, y, d);\n            }\n        }\n        return n.toTensor();\n    }, o.prototype.maxPoolBackprop = function(t, e, n, r) {\n        Hh([\n            e,\n            n\n        ], \"maxPoolBackprop\");\n        for(var o = this.maxPoolPositions(e, r), a = r.strideHeight, i = r.strideWidth, s = r.dilationHeight, u = r.dilationWidth, c = r.effectiveFilterHeight, l = r.effectiveFilterWidth, h = l - 1 - r.padInfo.left, f = c - 1 - r.padInfo.top, d = dr(e.shape, \"float32\"), p = this.bufferSync(o), v = this.bufferSync(t), m = 0; m < r.batchSize; ++m)for(var g = 0; g < r.inChannels; ++g)for(var y = 0; y < r.inHeight; ++y)for(var x = 0; x < r.inWidth; ++x){\n            for(var b = y - f, w = x - h, C = 0, E = 0; E < c; E += s){\n                var R = (b + E) / a;\n                if (!(R < 0 || R >= r.outHeight || Math.floor(R) !== R)) for(var I = 0; I < l; I += u){\n                    var k = (w + I) / i;\n                    if (!(k < 0 || k >= r.outWidth || Math.floor(k) !== k)) {\n                        var S = c * l - 1 - p.get(m, R, k, g) === E * l + I ? 1 : 0;\n                        if (0 !== S) C += v.get(m, R, k, g) * S;\n                    }\n                }\n            }\n            d.set(C, m, y, x, g);\n        }\n        return d.toTensor();\n    }, o.prototype.avgPoolBackprop = function(t, e, n) {\n        Hh([\n            t,\n            e\n        ], \"avgPoolBackprop\");\n        for(var r = n.strideHeight, o = n.strideWidth, a = n.filterHeight, i = n.filterWidth, s = n.dilationHeight, u = n.dilationWidth, c = n.effectiveFilterHeight, l = n.effectiveFilterWidth, h = l - 1 - n.padInfo.left, f = c - 1 - n.padInfo.top, d = dr(e.shape, \"float32\"), p = 1 / (a * i), v = this.bufferSync(t), m = 0; m < n.batchSize; ++m)for(var g = 0; g < n.inChannels; ++g)for(var y = 0; y < n.inHeight; ++y)for(var x = 0; x < n.inWidth; ++x){\n            for(var b = y - f, w = x - h, C = 0, E = 0; E < c; E += s){\n                var R = (b + E) / r;\n                if (!(R < 0 || R >= n.outHeight || Math.floor(R) !== R)) for(var I = 0; I < l; I += u){\n                    var k = (w + I) / o;\n                    if (!(k < 0 || k >= n.outWidth || Math.floor(k) !== k)) C += v.get(m, R, k, g);\n                }\n            }\n            d.set(C * p, m, y, x, g);\n        }\n        return d.toTensor();\n    }, o.prototype.pool3d = function(t, e, n) {\n        Hh(t, \"pool3d\");\n        for(var r = e.strideDepth, o = e.strideHeight, a = e.strideWidth, i = e.dilationDepth, s = e.dilationHeight, u = e.dilationWidth, c = e.effectiveFilterDepth, l = e.effectiveFilterHeight, h = e.effectiveFilterWidth, f = e.padInfo.front, d = e.padInfo.top, p = e.padInfo.left, v = \"max\" === n ? Number.NEGATIVE_INFINITY : Number.POSITIVE_INFINITY, m = this.readSync(t.dataId), g = dr(e.outShape, t.dtype), y = g.values, x = e.outShape[1] * e.outShape[2] * e.outShape[3] * e.outShape[4], b = e.outShape[2] * e.outShape[3] * e.outShape[4], w = e.outShape[3] * e.outShape[4], C = e.outShape[4], E = 0; E < e.batchSize; ++E)for(var R = E * x, I = E * t.strides[0], k = 0; k < e.inChannels; ++k)for(var S = 0; S < e.outDepth; ++S){\n            for(var A = S * r - f, D = A; D < 0;)D += i;\n            for(var T = Math.min(e.inDepth, c + A), N = R + S * b, F = 0; F < e.outHeight; ++F){\n                for(var _ = F * o - d, O = _; O < 0;)O += s;\n                for(var M = Math.min(e.inHeight, l + _), B = N + F * w, P = 0; P < e.outWidth; ++P){\n                    for(var L = P * a - p, W = L; W < 0;)W += u;\n                    for(var U = Math.min(e.inWidth, h + L), V = B + P * C, z = v, G = 0, H = 0, q = D; q < T; q += i){\n                        for(var K = I + q * t.strides[1], j = O; j < M; j += s){\n                            for(var X = K + j * t.strides[2], Y = W; Y < U; Y += u){\n                                var $ = m[X + Y * t.strides[3] + k];\n                                if (\"max\" === n && $ > z ? z = $ : \"avg\" === n && (G += $, H++), isNaN(z)) break;\n                            }\n                            if (isNaN(z)) break;\n                        }\n                        if (isNaN(z)) break;\n                    }\n                    y[V + k] = \"avg\" === n ? G / H : z;\n                }\n            }\n        }\n        return g.toTensor();\n    }, o.prototype.avgPool3d = function(t, e) {\n        return Hh(t, \"avgPool3d\"), this.pool3d(t, e, \"avg\").toFloat();\n    }, o.prototype.avgPool3dBackprop = function(t, e, n) {\n        Hh([\n            t,\n            e\n        ], \"avgPool3dBackprop\");\n        for(var r = n.strideDepth, o = n.strideHeight, a = n.strideWidth, i = n.filterDepth, s = n.filterHeight, u = n.filterWidth, c = n.dilationDepth, l = n.dilationHeight, h = n.dilationWidth, f = n.effectiveFilterDepth, d = n.effectiveFilterHeight, p = n.effectiveFilterWidth, v = f - 1 - n.padInfo.front, m = p - 1 - n.padInfo.left, g = d - 1 - n.padInfo.top, y = dr(e.shape, \"float32\"), x = 1 / (i * s * u), b = this.bufferSync(t), w = 0; w < n.batchSize; ++w)for(var C = 0; C < n.inChannels; ++C)for(var E = 0; E < n.inDepth; ++E)for(var R = 0; R < n.inHeight; ++R)for(var I = 0; I < n.inWidth; ++I){\n            for(var k = E - v, S = R - g, A = I - m, D = 0, T = 0; T < f; T += c){\n                var N = (k + T) / r;\n                if (!(N < 0 || N >= n.outDepth || Math.floor(N) !== N)) for(var F = 0; F < d; F += l){\n                    var _ = (S + F) / o;\n                    if (!(_ < 0 || _ >= n.outHeight || Math.floor(_) !== _)) for(var O = 0; O < p; O += h){\n                        var M = (A + O) / a;\n                        if (!(M < 0 || M >= n.outWidth || Math.floor(M) !== M)) D += b.get(w, N, _, M, C);\n                    }\n                }\n            }\n            y.set(D * x, w, E, R, I, C);\n        }\n        return y.toTensor();\n    }, o.prototype.maxPool3d = function(t, e) {\n        return Hh(t, \"maxPool3d\"), this.pool3d(t, e, \"max\").toFloat();\n    }, o.prototype.maxPool3dPositions = function(t, e) {\n        for(var n = dr(e.outShape, \"int32\"), r = e.strideDepth, o = e.strideHeight, a = e.strideWidth, i = e.dilationDepth, s = e.dilationHeight, u = e.dilationWidth, c = e.effectiveFilterDepth, l = e.effectiveFilterHeight, h = e.effectiveFilterWidth, f = e.padInfo.front, d = e.padInfo.top, p = e.padInfo.left, v = this.bufferSync(t), m = 0; m < e.batchSize; ++m)for(var g = 0; g < e.inChannels; ++g)for(var y = 0; y < e.outDepth; ++y){\n            for(var x = y * r - f, b = x; b < 0;)b += i;\n            for(var w = Math.min(e.inDepth, c + x), C = 0; C < e.outHeight; ++C){\n                for(var E = C * o - d, R = E; R < 0;)R += s;\n                for(var I = Math.min(e.inHeight, l + E), k = 0; k < e.outWidth; ++k){\n                    for(var S = k * a - p, A = S; A < 0;)A += u;\n                    for(var D = Math.min(e.inWidth, h + S), T = Number.NEGATIVE_INFINITY, N = -1, F = b; F < w; F += i)for(var _ = F - x, O = R; O < I; O += s)for(var M = O - E, B = A; B < D; B += u){\n                        var P = B - S, L = v.get(m, F, O, B, g);\n                        L >= T && (T = L, N = _ * l * h + M * l + P);\n                    }\n                    n.set(N, m, y, C, k, g);\n                }\n            }\n        }\n        return n.toTensor();\n    }, o.prototype.maxPool3dBackprop = function(t, e, n, r) {\n        Hh([\n            e,\n            n\n        ], \"maxPool3dBackprop\");\n        for(var o = this.maxPool3dPositions(e, r), a = r.strideDepth, i = r.strideHeight, s = r.strideWidth, u = r.dilationDepth, c = r.dilationHeight, l = r.dilationWidth, h = r.effectiveFilterDepth, f = r.effectiveFilterHeight, d = r.effectiveFilterWidth, p = h - 1 - r.padInfo.front, v = d - 1 - r.padInfo.left, m = f - 1 - r.padInfo.top, g = dr(e.shape, \"float32\"), y = this.bufferSync(o), x = this.bufferSync(t), b = 0; b < r.batchSize; ++b)for(var w = 0; w < r.inChannels; ++w)for(var C = 0; C < r.inDepth; ++C)for(var E = 0; E < r.inHeight; ++E)for(var R = 0; R < r.inWidth; ++R){\n            for(var I = C - p, k = E - m, S = R - v, A = 0, D = 0; D < h; D += u){\n                var T = (I + D) / a;\n                if (!(T < 0 || T >= r.outDepth || Math.floor(T) !== T)) for(var N = 0; N < f; N += c){\n                    var F = (k + N) / i;\n                    if (!(F < 0 || F >= r.outHeight || Math.floor(F) !== F)) for(var _ = 0; _ < d; _ += l){\n                        var O = (S + _) / s;\n                        if (!(O < 0 || O >= r.outWidth || Math.floor(O) !== O)) {\n                            var M = h * f * d - 1 - y.get(b, T, F, O, w) === D * f * d + N * d + _ ? 1 : 0;\n                            if (0 !== M) A += x.get(b, T, F, O, w) * M;\n                        }\n                    }\n                }\n            }\n            g.set(A, b, C, E, R, w);\n        }\n        return g.toTensor();\n    }, o.prototype.cast = function(t, e) {\n        return Po(t, e, this);\n    }, o.prototype.reshape = function(t, e) {\n        return Lo(t, e);\n    }, o.prototype.avgPool = function(t, e) {\n        return Hh(t, \"avgPool\"), this.pool(t, e, \"avg\").toFloat();\n    }, o.prototype.resizeBilinear = function(t, e, n, r) {\n        Hh(t, \"resizeBilinear\");\n        for(var o = t.shape, a = o[0], i = o[1], s = o[2], u = o[3], c = this.readSync(t.dataId), l = new Float32Array(k([\n            a,\n            e,\n            n,\n            u\n        ])), h = [\n            r && e > 1 ? i - 1 : i,\n            r && n > 1 ? s - 1 : s\n        ], f = [\n            r && e > 1 ? e - 1 : e,\n            r && n > 1 ? n - 1 : n\n        ], d = 0, p = h[0] / f[0], v = h[1] / f[1], m = 0; m < a; m++)for(var g = 0; g < e; g++)for(var y = p * g, x = Math.floor(y), b = y - x, w = Math.min(i - 1, Math.ceil(y)), C = m * t.strides[0] + x * t.strides[1], E = m * t.strides[0] + w * t.strides[1], R = 0; R < n; R++)for(var I = v * R, S = Math.floor(I), A = I - S, D = Math.min(s - 1, Math.ceil(I)), T = C + S * t.strides[2], N = E + S * t.strides[2], F = C + D * t.strides[2], _ = E + D * t.strides[2], O = 0; O < u; O++){\n            var M = c[T + O], B = c[N + O], P = M + (c[F + O] - M) * A, L = P + (B + (c[_ + O] - B) * A - P) * b;\n            l[d++] = L;\n        }\n        return Fn(l, [\n            a,\n            e,\n            n,\n            u\n        ]);\n    }, o.prototype.resizeBilinearBackprop = function(t, e, n) {\n        Hh([\n            t,\n            e\n        ], \"resizeBilinearBackprop\");\n        for(var r = e.shape, o = r[0], a = r[1], i = r[2], s = r[3], u = t.shape, c = u[1], l = u[2], h = new Float32Array(o * a * i * s), f = [\n            n && c > 1 ? a - 1 : a,\n            n && l > 1 ? i - 1 : i\n        ], d = [\n            n && c > 1 ? c - 1 : c,\n            n && l > 1 ? l - 1 : l\n        ], p = f[0] / d[0], v = f[1] / d[1], m = this.readSync(t.dataId), g = 0, y = 0; y < o; y++)for(var x = y * e.strides[0], b = 0; b < c; b++)for(var w = b * p, C = Math.floor(w), E = Math.min(Math.ceil(w), a - 1), R = x + C * e.strides[1], I = x + E * e.strides[1], k = w - C, S = 1 - k, A = 0; A < l; A++)for(var D = A * v, T = Math.floor(D), N = Math.min(Math.ceil(D), i - 1), F = D - T, _ = 1 - F, O = R + T * e.strides[2], M = R + N * e.strides[2], B = I + T * e.strides[2], P = I + N * e.strides[2], L = S * _, W = S * F, U = k * _, V = k * F, z = 0; z < s; z++){\n            var G = m[g++];\n            h[O + z] += G * L, h[M + z] += G * W, h[B + z] += G * U, h[P + z] += G * V;\n        }\n        return Ln(h, [\n            o,\n            i,\n            a,\n            s\n        ], e.dtype);\n    }, o.prototype.resizeNearestNeighbor = function(t, e, n, r) {\n        Hh(t, \"resizeNearestNeighbor\");\n        for(var o = t.shape, a = o[0], i = o[1], s = o[2], u = o[3], c = this.readSync(t.dataId), l = new Float32Array(a * e * n * u), h = [\n            r && e > 1 ? i - 1 : i,\n            r && n > 1 ? s - 1 : s\n        ], f = [\n            r && e > 1 ? e - 1 : e,\n            r && n > 1 ? n - 1 : n\n        ], d = h[0] / f[0], p = h[1] / f[1], v = 0, m = 0; m < a; m++)for(var g = m * t.strides[0], y = 0; y < e; y++)for(var x = d * y, b = g + Math.min(i - 1, r ? Math.round(x) : Math.floor(x)) * t.strides[1], w = 0; w < n; w++)for(var C = p * w, E = b + Math.min(s - 1, r ? Math.round(C) : Math.floor(C)) * t.strides[2], R = 0; R < u; R++){\n            var I = c[E + R];\n            l[v++] = I;\n        }\n        return Fn(l, [\n            a,\n            e,\n            n,\n            u\n        ], t.dtype);\n    }, o.prototype.resizeNearestNeighborBackprop = function(t, e, n) {\n        Hh([\n            t,\n            e\n        ], \"resizeNearestNeighborBackprop\");\n        for(var r = e.shape, o = r[0], a = r[1], i = r[2], s = r[3], u = t.shape, c = u[1], l = u[2], h = new Float32Array(o * a * i * s), f = this.readSync(t.dataId), d = [\n            n && c > 1 ? a - 1 : a,\n            n && l > 1 ? i - 1 : i\n        ], p = [\n            n && c > 1 ? c - 1 : c,\n            n && l > 1 ? l - 1 : l\n        ], v = d[0] / p[0], m = d[1] / p[1], g = 1 / v, y = 1 / m, x = 2 * Math.ceil(g) + 2, b = 2 * Math.ceil(y) + 2, w = 0; w < o; w++)for(var C = w * e.strides[0], E = 0; E < a; E++)for(var R = C + E * e.strides[1], I = Math.floor(E * g), k = Math.floor(I - x / 2), S = 0; S < i; S++)for(var A = R + S * e.strides[2], D = Math.floor(S * y), T = Math.floor(D - b / 2), N = 0; N < s; N++){\n            for(var F = 0, _ = 0; _ < x; _++){\n                var O = _ + k;\n                if (!(O < 0 || O >= c)) {\n                    var M = C + O * t.strides[1], B = O * v;\n                    if (E === Math.min(a - 1, n ? Math.round(B) : Math.floor(B))) for(var P = 0; P < b; P++){\n                        var L = P + T;\n                        if (!(L < 0 || L >= l)) {\n                            var W = M + L * t.strides[2], U = L * m;\n                            S === Math.min(i - 1, n ? Math.round(U) : Math.floor(U)) && (F += f[W + N]);\n                        }\n                    }\n                }\n            }\n            h[A + N] = F;\n        }\n        return Ln(h, e.shape, e.dtype);\n    }, o.prototype.batchNormalization = function(t, e, n, r, o, a) {\n        Hh([\n            t,\n            e,\n            n,\n            o,\n            a\n        ], \"batchNorm\");\n        for(var i = this.readSync(t.dataId), s = this.readSync(e.dataId), u = this.readSync(n.dataId), c = o ? this.readSync(o.dataId) : new Float32Array([\n            1\n        ]), l = a ? this.readSync(a.dataId) : new Float32Array([\n            0\n        ]), h = new Float32Array(i.length), f = l.length, d = c.length, p = u.length, v = s.length, m = 0, g = 0, y = 0, x = 0, b = 0; b < i.length; ++b)h[b] = l[m++] + (i[b] - s[g++]) * c[y++] / Math.sqrt(u[x++] + r), m >= f && (m = 0), g >= v && (g = 0), y >= d && (y = 0), x >= p && (x = 0);\n        return Ln(h, t.shape);\n    }, o.prototype.localResponseNormalization4D = function(t, e, n, r, o) {\n        Hh(t, \"localResponseNormalization4D\");\n        var a = t.shape[3], i = a - 1, s = this.readSync(t.dataId), u = t.size, c = new Float32Array(u);\n        function l(t) {\n            for(var n = t % a, r = t - n + Math.max(0, n - e), o = t - n + Math.min(n + e, i), u = 0; r <= o; r++){\n                var c = s[r];\n                u += c * c;\n            }\n            return u;\n        }\n        for(var h = 0; h < u; h++){\n            var f = l(h), d = s[h] * Math.pow(n + r * f, -o);\n            c[h] = d;\n        }\n        return Ln(c, t.shape);\n    }, o.prototype.LRNGrad = function(t, e, n, r, o, a, i) {\n        Hh(t, \"LRNGrad\");\n        for(var s = t.shape[3], u = this.readSync(t.dataId), c = this.readSync(e.dataId), l = this.readSync(n.dataId), h = new Float32Array(t.size), f = t.size, d = 0; d < f; d++){\n            for(var p = d % s, v = d - p + Math.max(0, p - r), m = d - p + Math.min(s, p + r + 1), g = 0, y = v; y < m; y++)g += Math.pow(c[y], 2);\n            g = a * g + o;\n            for(y = v; y < m; y++){\n                var x = -2 * a * i * c[y] * l[d] / g;\n                d === y && (x += Math.pow(g, -i)), x *= u[d], h[y] += x;\n            }\n        }\n        return Ln(h, t.shape);\n    }, o.prototype.multinomial = function(t, e, n, r) {\n        Hh(t, \"multinomial\");\n        for(var o = e ? t : go(t), a = o.shape[0], i = o.shape[1], s = Gn([\n            a,\n            n\n        ], \"int32\"), u = this.readSync(s.dataId), c = this.readSync(o.dataId), l = 0; l < a; ++l){\n            var h = l * i, f = new Float32Array(i - 1);\n            f[0] = c[h];\n            for(var d = 1; d < f.length; ++d)f[d] = f[d - 1] + c[h + d];\n            for(var p = cr(r.toString()), v = l * n, m = 0; m < n; ++m){\n                var g = p();\n                u[v + m] = f.length;\n                for(var y = 0; y < f.length; y++)if (g < f[y]) {\n                    u[v + m] = y;\n                    break;\n                }\n            }\n        }\n        return s;\n    }, o.prototype.oneHot = function(t, e, n, r) {\n        Hh(t, \"oneHot\");\n        var o = new Float32Array(t.size * e);\n        o.fill(r);\n        for(var a = this.readSync(t.dataId), i = 0; i < t.size; ++i)a[i] >= 0 && a[i] < e && (o[i * e + a[i]] = n);\n        return Bn(o, [\n            t.size,\n            e\n        ], \"int32\");\n    }, o.prototype.nonMaxSuppression = function(t, e, n, r, o) {\n        return Hh(t, \"nonMaxSuppression\"), jo(this.readSync(t.dataId), this.readSync(e.dataId), n, r, o);\n    }, o.prototype.fft = function(t) {\n        return this.fftBatch(t, !1);\n    }, o.prototype.ifft = function(t) {\n        return this.fftBatch(t, !0);\n    }, o.prototype.fftBatch = function(t, e) {\n        for(var n = t.shape[0], r = t.shape[1], o = dr(t.shape, \"float32\"), a = dr(t.shape, \"float32\"), i = Tn(t).as2D(n, r), s = Nn(t).as2D(n, r), u = 0; u < n; u++)for(var c = i.slice([\n            u,\n            0\n        ], [\n            1,\n            r\n        ]), l = s.slice([\n            u,\n            0\n        ], [\n            1,\n            r\n        ]), h = Dn(c, l), f = this.readSync(this.fftImpl(h, e).dataId), d = 0; d < r; d++){\n            var p = zo(f, d);\n            o.values[u * r + d] = p.real, a.values[u * r + d] = p.imag;\n        }\n        return Dn(o.toTensor(), a.toTensor()).as2D(n, r);\n    }, o.prototype.fftImpl = function(t, e) {\n        var n = t.as1D(), r = n.size;\n        if (this.isExponentOf2(r)) {\n            var o = this.fftRadix2(n, r, e).as2D(t.shape[0], t.shape[1]);\n            return e && (o = Dn(Tn(o).div(On(r)), Nn(o).div(On(r)))), o;\n        }\n        var a = this.readSync(t.dataId), i = function(t) {\n            for(var e = new Float32Array(t.length / 2), n = new Float32Array(t.length / 2), r = 0; r < t.length; r += 2)e[r / 2] = t[r], n[r / 2] = t[r + 1];\n            return {\n                real: e,\n                imag: n\n            };\n        }(this.fourierTransformByMatmul(a, r, e));\n        return Dn(i.real, i.imag).as2D(t.shape[0], t.shape[1]);\n    }, o.prototype.isExponentOf2 = function(t) {\n        return 0 == (t & t - 1);\n    }, o.prototype.fftRadix2 = function(t, e, n) {\n        if (1 === e) return t;\n        var r = this.readSync(t.dataId), o = e / 2, a = function(t) {\n            for(var e = Math.ceil(t.length / 4), n = new Float32Array(e), r = new Float32Array(e), o = 0; o < t.length; o += 4)n[Math.floor(o / 4)] = t[o], r[Math.floor(o / 4)] = t[o + 1];\n            return {\n                real: n,\n                imag: r\n            };\n        }(r), i = Dn(a.real, a.imag).as1D(), s = function(t) {\n            for(var e = Math.floor(t.length / 4), n = new Float32Array(e), r = new Float32Array(e), o = 2; o < t.length; o += 4)n[Math.floor(o / 4)] = t[o], r[Math.floor(o / 4)] = t[o + 1];\n            return {\n                real: n,\n                imag: r\n            };\n        }(r), u = Dn(s.real, s.imag).as1D();\n        i = this.fftRadix2(i, o, n), u = this.fftRadix2(u, o, n);\n        var c = function(t, e) {\n            for(var n = new Float32Array(t / 2), r = new Float32Array(t / 2), o = 0; o < Math.ceil(t / 2); o++){\n                var a = (e ? 2 : -2) * Math.PI * (o / t);\n                n[o] = Math.cos(a), r[o] = Math.sin(a);\n            }\n            return {\n                real: n,\n                imag: r\n            };\n        }(e, n), l = Dn(c.real, c.imag).mul(u), h = i.add(l), f = i.sub(l), d = Tn(h).concat(Tn(f)), p = Nn(h).concat(Nn(f));\n        return Dn(d, p).as1D();\n    }, o.prototype.fourierTransformByMatmul = function(t, e, n) {\n        for(var r = new Float32Array(2 * e), o = 0; o < e; o++){\n            for(var a = 0, i = 0, s = 0; s < e; s++){\n                var u = Ho(o * s, e, n), c = zo(t, s);\n                a += c.real * u.real - c.imag * u.imag, i += c.real * u.imag + c.imag * u.real;\n            }\n            n && (a /= e, i /= e), Go(r, a, i, o);\n        }\n        return r;\n    }, o.prototype.depthToSpace = function(t, e, n) {\n        C(\"NHWC\" === n, function() {\n            return \"Only NHWC dataFormat supported on CPU for depthToSpace. Got \" + n;\n        }), C(e > 1, function() {\n            return \"blockSize should be > 1 for depthToSpace, but was: \" + e;\n        });\n        for(var r = t.shape[0], o = t.shape[1], a = t.shape[2], i = t.shape[3], s = o * e, u = a * e, c = i / (e * e), l = this.readSync(t.dataId), h = new Float32Array(r * s * u * c), f = 0, d = 0; d < r; ++d)for(var p = 0; p < s; ++p)for(var v = Math.floor(p / e), m = p % e, g = 0; g < u; ++g)for(var y = Math.floor(g / e), x = (m * e + g % e) * c, b = 0; b < c; ++b){\n            var w = b + x + i * (y + a * (v + o * d));\n            h[f++] = l[w];\n        }\n        return Ln(h, [\n            r,\n            s,\n            u,\n            c\n        ]);\n    }, o.prototype.broadcastedBinaryOp = function(t, e, n, r) {\n        var o = Ro(t.shape, e.shape), a = dr(o, n), i = this.readSync(t.dataId), s = this.readSync(e.dataId), u = Co(t.shape, o), c = Co(e.shape, o), l = a.values;\n        if (u.length + c.length === 0) for(var h = 0; h < l.length; ++h)l[h] = r(i[h % i.length], s[h % s.length]);\n        else {\n            var f = this.bufferSync(t), d = this.bufferSync(e), p = function(n) {\n                var o = a.indexToLoc(n), h = o.slice(-t.rank);\n                u.forEach(function(t) {\n                    return h[t] = 0;\n                });\n                var p = f.locToIndex(h), v = o.slice(-e.rank);\n                c.forEach(function(t) {\n                    return v[t] = 0;\n                });\n                var m = d.locToIndex(v);\n                l[n] = r(i[p], s[m]);\n            };\n            for(h = 0; h < l.length; ++h)p(h);\n        }\n        return a.toTensor();\n    }, o.prototype.broadcastedBinaryComplexOp = function(t, e, n) {\n        var r = Ro(t.shape, e.shape), o = dr(r, \"float32\"), a = dr(r, \"float32\"), i = this.readSync(t.dataId), s = this.readSync(e.dataId), u = Co(t.shape, r), c = Co(e.shape, r), l = o.values, h = a.values;\n        if (u.length + c.length === 0) for(var f = 0; f < l.length; f++){\n            var d = f % i.length, p = f % s.length, v = n(i[2 * d], i[2 * d + 1], s[2 * p], s[2 * p + 1]);\n            l[f] = v.real, h[f] = v.imag;\n        }\n        else {\n            var m = this.bufferSync(this.data.get(t.dataId).complexTensors.real), g = this.bufferSync(this.data.get(e.dataId).complexTensors.real), y = function(r) {\n                var a = o.indexToLoc(r), f = a.slice(-t.rank);\n                u.forEach(function(t) {\n                    return f[t] = 0;\n                });\n                var d = m.locToIndex(f), p = a.slice(-e.rank);\n                c.forEach(function(t) {\n                    return p[t] = 0;\n                });\n                var v = g.locToIndex(p), y = n(i[2 * d], i[2 * d + 1], s[2 * v], s[2 * v + 1]);\n                l[r] = y.real, h[r] = y.imag;\n            };\n            for(f = 0; f < l.length; f++)y(f);\n        }\n        return this.complex(o.toTensor(), a.toTensor());\n    }, o.prototype.split = function(t, e, n) {\n        return Zo(t, e, n);\n    }, o.prototype.dispose = function() {}, o.prototype.floatPrecision = function() {\n        return 32;\n    }, o.prototype.epsilon = function() {\n        return 1e-7;\n    }, o.prototype.cropAndResize = function(t, e, n, r, o, a) {\n        for(var i = t.shape, s = i[0], u = i[1], c = i[2], l = i[3], h = e.shape[0], f = r[0], d = r[1], p = dr([\n            h,\n            f,\n            d,\n            l\n        ], \"float32\"), v = this.readSync(e.dataId), m = this.readSync(n.dataId), g = this.readSync(t.dataId), y = t.strides, x = p.strides, b = 0; b < h; b++){\n            var w = 4 * b, C = v[w], E = v[w + 1], R = v[w + 2], I = v[w + 3], k = m[b];\n            if (!(k >= s)) for(var S = f > 1 ? (R - C) * (u - 1) / (f - 1) : 0, A = d > 1 ? (I - E) * (c - 1) / (d - 1) : 0, D = 0; D < f; D++){\n                var T = f > 1 ? C * (u - 1) + D * S : .5 * (C + R) * (u - 1);\n                if (T < 0 || T > u - 1) for(var N = 0; N < d; N++)for(var F = 0; F < l; F++){\n                    var _ = F + N * x[2] + D * x[1] + b * x[0];\n                    p.values[_] = a;\n                }\n                else if (\"bilinear\" === o) {\n                    var O = Math.floor(T), M = Math.ceil(T), B = T - O;\n                    for(N = 0; N < d; N++){\n                        if ((q = d > 1 ? E * (c - 1) + N * A : .5 * (E + I) * (c - 1)) < 0 || q > c - 1) for(F = 0; F < l; F++){\n                            _ = F + N * x[2] + D * x[1] + b * x[0];\n                            p.values[_] = a;\n                        }\n                        else {\n                            var P = Math.floor(q), L = Math.ceil(q), W = q - P;\n                            for(F = 0; F < l; F++){\n                                var U = g[_ = F + P * y[2] + O * y[1] + k * y[0]], V = g[_ = F + L * y[2] + O * y[1] + k * y[0]], z = g[_ = F + P * y[2] + M * y[1] + k * y[0]], G = U + (V - U) * W, H = z + (g[_ = F + L * y[2] + M * y[1] + k * y[0]] - z) * W;\n                                _ = F + N * x[2] + D * x[1] + b * x[0], p.values[_] = G + (H - G) * B;\n                            }\n                        }\n                    }\n                } else for(N = 0; N < d; ++N){\n                    var q;\n                    if ((q = d > 1 ? E * (c - 1) + N * A : .5 * (E + I) * (c - 1)) < 0 || q > c - 1) for(F = 0; F < l; F++){\n                        _ = F + N * x[2] + D * x[1] + b * x[0];\n                        p.values[_] = a;\n                    }\n                    else {\n                        var K = Math.round(q), j = Math.round(T);\n                        for(F = 0; F < l; F++){\n                            var X = F + K * y[2] + j * y[1] + k * y[0], Y = F + N * x[2] + D * x[1] + b * x[0];\n                            p.values[Y] = g[X];\n                        }\n                    }\n                }\n            }\n        }\n        return p.toTensor();\n    }, o.prototype.sparseToDense = function(t, e, n, r) {\n        var o = Zr(0, t, n), a = o.sliceRank, i = o.numUpdates, s = o.sliceSize, u = o.strides, c = o.outputSize;\n        return this.scatter(t, e, n, c, s, i, a, u, r, !1);\n    }, o.prototype.gatherND = function(t, e) {\n        var n = e.shape, r = n[n.length - 1], o = jr(t, e), a = o[0], i = o[1], s = o[2], u = o[3];\n        if (0 === i) return Fn([], a, t.dtype);\n        for(var c = new gt([\n            i,\n            s\n        ], t.dtype), l = this.readSync(e.dataId), h = this.readSync(t.dataId), f = 0; f < i; f++){\n            for(var d = [], p = 0, v = 0; v < r; v++){\n                var m = l[f * r + v];\n                p += m * u[v], d.push(m);\n            }\n            if (p < 0 || p >= t.size / s) throw new Error(\"Invalid indices: \" + d + \" does not index into \" + t.shape);\n            for(var g = 0; g < s; g++)c.values[f * s + g] = h[p * s + g];\n        }\n        return c.toTensor().reshape(a);\n    }, o.prototype.scatterND = function(t, e, n) {\n        var r = Zr(0, t, n), o = r.sliceRank, a = r.numUpdates, i = r.sliceSize, s = r.strides, u = r.outputSize, c = On(0);\n        return this.scatter(t, e, n, u, i, a, o, s, c, !0);\n    }, o.prototype.fill = function(t, e, n) {\n        var r = P(n = n || j(e), k(t));\n        return r.fill(e), Lt.makeTensor(r, t, n, this);\n    }, o.prototype.onesLike = function(t) {\n        if (\"string\" === t.dtype) throw new Error(\"onesLike is not supported for string tensors\");\n        return this.fill(t.shape, 1, t.dtype);\n    }, o.prototype.zerosLike = function(t) {\n        var e = P(t.dtype, k(t.shape));\n        return this.makeOutput(e, t.shape, t.dtype);\n    }, o.prototype.linspace = function(t, e, n) {\n        return Wo(t, e, n);\n    }, o.prototype.scatter = function(t, e, n, r, o, a, i, s, u, c) {\n        var l = [\n            r / o,\n            o\n        ], h = this.readSync(t.dataId), f = this.readSync(e.dataId);\n        if (0 === r) return Fn([], n, e.dtype);\n        var d = new gt(l, e.dtype);\n        d.values.fill(this.readSync(u.dataId)[0]);\n        for(var p = 0; p < a; p++){\n            for(var v = [], m = 0, g = 0; g < i; g++){\n                var y = h[p * i + g];\n                v.push(y), m += y * s[g];\n            }\n            if (m < 0 || m >= r / o) throw new Error(\"Invalid indices: \" + v + \" does not index into \" + n);\n            for(var x = 0; x < o; x++)c ? d.values[m * o + x] += f[p * o + x] : d.values[m * o + x] = 0 === e.rank ? f[0] : f[p * o + x];\n        }\n        return d.toTensor().reshape(n);\n    }, o;\n}(bo);\nLt.registerBackend(\"cpu\", function() {\n    return new Kh;\n}, 1);\nfor(var jh = 0, Xh = [\n    {\n        kernelName: \"NonMaxSuppressionV5\",\n        backendName: \"cpu\",\n        kernelFunc: function(t) {\n            var e = t.inputs, n = t.backend, r = t.attrs, o = e, a = o.boxes, i = o.scores, s = r, u = s.maxOutputSize, c = s.iouThreshold, l = s.scoreThreshold, h = s.softNmsSigma, f = n;\n            Hh(a, \"NonMaxSuppressionWithScore\");\n            var d = Xo(f.data.get(a.dataId).values, f.data.get(i.dataId).values, u, c, l, h);\n            return [\n                d.selectedIndices,\n                d.selectedScores\n            ];\n        }\n    },\n    {\n        kernelName: \"Square\",\n        backendName: \"cpu\",\n        kernelFunc: function(t) {\n            var e = t.inputs, n = t.backend, r = e.x, o = n;\n            Hh(r, \"square\");\n            for(var a = o.data.get(r.dataId).values, i = new Float32Array(a.length), s = 0; s < a.length; ++s){\n                var u = a[s];\n                i[s] = u * u;\n            }\n            return {\n                dataId: o.write(i, r.shape, r.dtype),\n                shape: r.shape,\n                dtype: r.dtype\n            };\n        }\n    },\n    {\n        kernelName: eu,\n        backendName: \"cpu\",\n        kernelFunc: function(t) {\n            var e = t.inputs, n = t.backend, r = e, o = r.a, a = r.b, i = n;\n            Hh([\n                o,\n                a\n            ], eu);\n            var s = i.data.get(o.dataId).values, u = i.data.get(a.dataId).values, c = function(t, e, n, r, o, a) {\n                var i = Ro(t, e), s = i.length, u = $(i), c = B(o, k(i)), l = t.length, h = e.length, f = $(t), d = $(e), p = Co(t, i), v = Co(e, i);\n                if (p.length + v.length === 0) for(var m = 0; m < c.length; ++m)c[m] = a(n[m % n.length], r[m % r.length]);\n                else {\n                    var g = function(t) {\n                        var e = it(t, s, u), o = e.slice(-l);\n                        p.forEach(function(t) {\n                            return o[t] = 0;\n                        });\n                        var i = at(o, l, f), m = e.slice(-h);\n                        v.forEach(function(t) {\n                            return m[t] = 0;\n                        });\n                        var g = at(m, h, d);\n                        c[t] = a(n[i], r[g]);\n                    };\n                    for(m = 0; m < c.length; ++m)g(m);\n                }\n                return [\n                    c,\n                    i\n                ];\n            }(o.shape, a.shape, s, u, o.dtype, function(t, e) {\n                var n = t - e;\n                return n * n;\n            }), l = c[0], h = c[1];\n            return {\n                dataId: i.write(l, h, o.dtype),\n                shape: h,\n                dtype: o.dtype\n            };\n        }\n    }\n]; jh < Xh.length; jh++){\n    d(Xh[jh]);\n}\nvar Yh, $h = function(t) {\n    this.variableNames = [\n        \"A\"\n    ];\n    var e = ua(), n = t[0], r = t[1];\n    this.outputShape = t, this.userCode = \"\\n      void main() {\\n        ivec3 coords = getOutputCoords();\\n        int texR = coords[0];\\n        int texC = coords[1];\\n        int depth = coords[2];\\n        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(\" + r + \".0, \" + n + \".0);\\n\\n        vec4 values = \" + e.texture2D + \"(A, uv);\\n        float value;\\n        if (depth == 0) {\\n          value = values.r;\\n        } else if (depth == 1) {\\n          value = values.g;\\n        } else if (depth == 2) {\\n          value = values.b;\\n        } else if (depth == 3) {\\n          value = values.a;\\n        }\\n\\n        setOutput(floor(value * 255.0 + 0.5));\\n      }\\n    \";\n}, Qh = function(t) {\n    this.variableNames = [\n        \"A\"\n    ], this.packedInputs = !1, this.packedOutput = !0;\n    var e = ua(), n = t[0], r = t[1];\n    this.outputShape = t, this.userCode = \"\\n      void main() {\\n        ivec3 coords = getOutputCoords();\\n        int texR = coords[0];\\n        int texC = coords[1];\\n        int depth = coords[2];\\n\\n        vec4 result = vec4(0.);\\n\\n        for(int row=0; row<=1; row++) {\\n          for(int col=0; col<=1; col++) {\\n            texC = coords[1] + row;\\n            depth = coords[2] + col;\\n\\n            vec2 uv = (vec2(texC, texR) + halfCR) /\\n                       vec2(\" + r + \".0, \" + n + \".0);\\n            vec4 values = \" + e.texture2D + \"(A, uv);\\n            float value;\\n            if (depth == 0) {\\n              value = values.r;\\n            } else if (depth == 1) {\\n              value = values.g;\\n            } else if (depth == 2) {\\n              value = values.b;\\n            } else if (depth == 3) {\\n              value = values.a;\\n            }\\n\\n            result[row * 2 + col] = floor(value * 255.0 + 0.5);\\n          }\\n        }\\n\\n        \" + e.output + \" = result;\\n      }\\n    \";\n};\nfor(var Jh = 0, Zh = [\n    {\n        kernelName: \"FromPixels\",\n        backendName: \"webgl\",\n        kernelFunc: function(t) {\n            var e = t.inputs, n = t.backend, r = t.attrs, o = e.pixels, a = r.numChannels, s = \"undefined\" != typeof HTMLVideoElement && o instanceof HTMLVideoElement, u = \"undefined\" != typeof HTMLImageElement && o instanceof HTMLImageElement, c = s ? [\n                o.videoWidth,\n                o.videoHeight\n            ] : [\n                o.width,\n                o.height\n            ], l = c[0], h = c[1], f = [\n                h,\n                l\n            ], d = [\n                h,\n                l,\n                a\n            ];\n            (u || s) && (null == Yh && (Yh = document.createElement(\"canvas\").getContext(\"2d\")), Yh.canvas.width = l, Yh.canvas.height = h, Yh.drawImage(o, 0, 0, l, h), o = Yh.canvas);\n            var p = n.makeTensorInfo(f, \"int32\");\n            n.texData.get(p.dataId).usage = zt.PIXELS, n.gpgpu.uploadPixelDataToTexture(n.getTexture(p.dataId), o);\n            var v = i().getBool(\"WEBGL_PACK\") ? new Qh(d) : new $h(d), m = n.runWebGLProgram(v, [\n                p\n            ], \"int32\");\n            return n.disposeData(p.dataId), m;\n        }\n    },\n    {\n        kernelName: \"NonMaxSuppressionV5\",\n        backendName: \"webgl\",\n        kernelFunc: function(t) {\n            var e = t.inputs, n = t.backend, r = t.attrs;\n            dn(\"tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead\");\n            var o = e, a = o.boxes, i = o.scores, s = r, u = s.maxOutputSize, c = s.iouThreshold, l = s.scoreThreshold, h = s.softNmsSigma, f = n, d = Xo(f.readSync(a.dataId), f.readSync(i.dataId), u, c, l, h);\n            return [\n                d.selectedIndices,\n                d.selectedScores\n            ];\n        }\n    },\n    {\n        kernelName: \"Square\",\n        backendName: \"webgl\",\n        kernelFunc: function(t) {\n            var e = t.inputs, n = t.backend, r = e.x, o = n, a = new Cs(r.shape, \"return x * x;\");\n            return o.runWebGLProgram(a, [\n                r\n            ], r.dtype);\n        }\n    },\n    {\n        kernelName: eu,\n        backendName: \"webgl\",\n        kernelFunc: function(t) {\n            var e = t.inputs, n = t.backend, r = e, o = r.a, a = r.b, s = n, u = i().getBool(\"WEBGL_PACK_BINARY_OPERATIONS\") ? new La(\"return (a - b) * (a - b);\", o.shape, a.shape) : new Ba(\"return (a - b) * (a - b);\", o.shape, a.shape);\n            return s.compileAndRun(u, [\n                o,\n                a\n            ]);\n        }\n    }\n]; Jh < Zh.length; Jh++){\n    d(Zh[Jh]);\n}\nfor(var tf = 0, ef = [\n    {\n        kernelName: \"Square\",\n        gradFunc: function(t, e) {\n            var n = e[0];\n            return {\n                x: function() {\n                    return t.mul(n.toFloat().mul(2));\n                }\n            };\n        }\n    },\n    {\n        kernelName: eu,\n        gradFunc: function(t, e) {\n            var n = e[0], r = e[1], o = On(2);\n            return {\n                a: function() {\n                    return gc(t, gc(o, Cc(n, r)));\n                },\n                b: function() {\n                    return gc(t, gc(o, Cc(r, n)));\n                }\n            };\n        }\n    }\n]; tf < ef.length; tf++){\n    p(ef[tf]);\n}\nvar nf = function() {\n    function t() {}\n    return t.prototype.fetch = function(t, e) {\n        return fetch(t, e);\n    }, t.prototype.now = function() {\n        return performance.now();\n    }, t.prototype.encode = function(t, e) {\n        if (\"utf-8\" !== e && \"utf8\" !== e) throw new Error(\"Browser's encoder only supports utf-8, but got \" + e);\n        return null == this.textEncoder && (this.textEncoder = new TextEncoder), this.textEncoder.encode(t);\n    }, t.prototype.decode = function(t, e) {\n        return new TextDecoder(e).decode(t);\n    }, t;\n}();\ni().get(\"IS_BROWSER\") && i().setPlatform(\"browser\", new nf);\nvar rf, of = function() {\n    return __webpack_require__(/*! node-fetch */ \"(ssr)/./node_modules/node-fetch/lib/index.es.js\");\n}, af = function() {\n    function t() {\n        this.util = __webpack_require__(/*! util */ \"util\"), this.textEncoder = new this.util.TextEncoder;\n    }\n    return t.prototype.fetch = function(t, e) {\n        return null != i().global.fetch ? i().global.fetch(t, e) : (null == rf && (rf = of()), rf(t, e));\n    }, t.prototype.now = function() {\n        var t = process.hrtime();\n        return 1e3 * t[0] + t[1] / 1e6;\n    }, t.prototype.encode = function(t, e) {\n        if (\"utf-8\" !== e && \"utf8\" !== e) throw new Error(\"Node built-in encoder only supports utf-8, but got \" + e);\n        return this.textEncoder.encode(t);\n    }, t.prototype.decode = function(t, e) {\n        return 0 === t.length ? \"\" : new this.util.TextDecoder(e).decode(t);\n    }, t;\n}();\ni().get(\"IS_NODE\") && i().setPlatform(\"node\", new af);\nvar sf = {\n    float32: 4,\n    int32: 4,\n    uint16: 2,\n    uint8: 1,\n    bool: 1\n}, uf = 4;\nfunction cf(t, e) {\n    for(var n = {}, r = 0, o = function(e) {\n        var o = e.name, a = e.dtype, i = e.shape, s = k(i), u = void 0;\n        if ((\"quantization\" in e)) {\n            var c = e.quantization;\n            if (\"uint8\" !== c.dtype && \"uint16\" !== c.dtype) throw new Error(\"Weight \" + e.name + \" has unknown quantization dtype \" + c.dtype + \". Supported quantization dtypes are: 'uint8' and 'uint16'.\");\n            var l = sf[c.dtype], h = t.slice(r, r + s * l), f = \"uint8\" === c.dtype ? new Uint8Array(h) : new Uint16Array(h);\n            if (\"float32\" === a) u = Float32Array.from(f, function(t) {\n                return t * c.scale + c.min;\n            });\n            else {\n                if (\"int32\" !== a) throw new Error(\"Unsupported dtype in weight '\" + o + \"': \" + a);\n                u = Int32Array.from(f, function(t) {\n                    return Math.round(t * c.scale + c.min);\n                });\n            }\n            r += s * l;\n        } else if (\"string\" === a) {\n            var d = k(e.shape);\n            u = [];\n            for(var p = 0; p < d; p++){\n                var v = new Uint32Array(t.slice(r, r + uf))[0];\n                r += uf;\n                var m = new Uint8Array(t.slice(r, r + v));\n                u.push(m), r += v;\n            }\n        } else {\n            var g = sf[a];\n            h = t.slice(r, r + s * g);\n            if (\"float32\" === a) u = new Float32Array(h);\n            else if (\"int32\" === a) u = new Int32Array(h);\n            else {\n                if (\"bool\" !== a) throw new Error(\"Unsupported dtype in weight '\" + o + \"': \" + a);\n                u = new Uint8Array(h);\n            }\n            r += s * g;\n        }\n        n[o] = Fn(u, i, a);\n    }, a = 0, i = e; a < i.length; a++){\n        o(i[a]);\n    }\n    return n;\n}\nfunction lf(t) {\n    if (null === t) throw new Error(\"Invalid input value: \" + JSON.stringify(t));\n    var e = 0, n = [];\n    t.forEach(function(t) {\n        if (e += t.byteLength, n.push(t.byteLength === t.buffer.byteLength ? t : new t.constructor(t)), !(t instanceof Float32Array || t instanceof Int32Array || t instanceof Uint8Array)) throw new Error(\"Unsupported TypedArray subtype: \" + t.constructor.name);\n    });\n    var r = new Uint8Array(e), o = 0;\n    return n.forEach(function(t) {\n        r.set(new Uint8Array(t.buffer), o), o += t.byteLength;\n    }), r.buffer;\n}\nvar hf = \"undefined\" != typeof Buffer && (\"undefined\" == typeof Blob || \"undefined\" == typeof atob || \"undefined\" == typeof btoa);\nfunction ff(t) {\n    return hf ? Buffer.byteLength(t) : new Blob([\n        t\n    ]).size;\n}\nfunction df(t) {\n    var e = 0;\n    t.forEach(function(t) {\n        e += t.byteLength;\n    });\n    var n = new Uint8Array(e), r = 0;\n    return t.forEach(function(t) {\n        n.set(new Uint8Array(t), r), r += t.byteLength;\n    }), n.buffer;\n}\nfunction pf(t) {\n    for(t = t.trim(); t.endsWith(\"/\");)t = t.slice(0, t.length - 1);\n    var e = t.split(\"/\");\n    return e[e.length - 1];\n}\nfunction vf(t) {\n    if (t.modelTopology instanceof ArrayBuffer) throw new Error(\"Expected JSON model topology, received ArrayBuffer.\");\n    return {\n        dateSaved: new Date,\n        modelTopologyType: \"JSON\",\n        modelTopologyBytes: null == t.modelTopology ? 0 : ff(JSON.stringify(t.modelTopology)),\n        weightSpecsBytes: null == t.weightSpecs ? 0 : ff(JSON.stringify(t.weightSpecs)),\n        weightDataBytes: null == t.weightData ? 0 : t.weightData.byteLength\n    };\n}\nvar mf = function() {\n    function t() {\n        this.saveRouters = [], this.loadRouters = [];\n    }\n    return t.getInstance = function() {\n        return null == t.instance && (t.instance = new t), t.instance;\n    }, t.registerSaveRouter = function(e) {\n        t.getInstance().saveRouters.push(e);\n    }, t.registerLoadRouter = function(e) {\n        t.getInstance().loadRouters.push(e);\n    }, t.getSaveHandlers = function(e) {\n        return t.getHandlers(e, \"save\");\n    }, t.getLoadHandlers = function(e, n) {\n        return t.getHandlers(e, \"load\", n);\n    }, t.getHandlers = function(e, n, r) {\n        var o = [];\n        return (\"load\" === n ? t.getInstance().loadRouters : t.getInstance().saveRouters).forEach(function(t) {\n            var n = t(e, r);\n            null !== n && o.push(n);\n        }), o;\n    }, t;\n}(), gf = \"://\", yf = function() {\n    function t() {\n        this.managers = {};\n    }\n    return t.getInstance = function() {\n        return null == t.instance && (t.instance = new t), t.instance;\n    }, t.registerManager = function(e, n) {\n        C(null != e, function() {\n            return \"scheme must not be undefined or null.\";\n        }), e.endsWith(gf) && (e = e.slice(0, e.indexOf(gf))), C(e.length > 0, function() {\n            return \"scheme must not be an empty string.\";\n        });\n        var r = t.getInstance();\n        C(null == r.managers[e], function() {\n            return \"A model store manager is already registered for scheme '\" + e + \"'.\";\n        }), r.managers[e] = n;\n    }, t.getManager = function(t) {\n        var e = this.getInstance().managers[t];\n        if (null == e) throw new Error(\"Cannot find model manager for scheme '\" + t + \"'\");\n        return e;\n    }, t.getSchemes = function() {\n        return Object.keys(this.getInstance().managers);\n    }, t;\n}();\nfunction xf(t) {\n    if (-1 === t.indexOf(gf)) throw new Error(\"The url string provided does not contain a scheme. Supported schemes are: \" + yf.getSchemes().join(\",\"));\n    return {\n        scheme: t.split(gf)[0],\n        path: t.split(gf)[1]\n    };\n}\nfunction bf(t, e, o) {\n    return void 0 === o && (o = !1), n(this, void 0, void 0, function() {\n        var n, a, i, s, u, c, l, h, f;\n        return r(this, function(r) {\n            switch(r.label){\n                case 0:\n                    return C(t !== e, function() {\n                        return \"Old path and new path are the same: '\" + t + \"'\";\n                    }), C((n = mf.getLoadHandlers(t)).length > 0, function() {\n                        return \"Copying failed because no load handler is found for source URL \" + t + \".\";\n                    }), C(n.length < 2, function() {\n                        return \"Copying failed because more than one (\" + n.length + \") load handlers for source URL \" + t + \".\";\n                    }), a = n[0], C((i = mf.getSaveHandlers(e)).length > 0, function() {\n                        return \"Copying failed because no save handler is found for destination URL \" + e + \".\";\n                    }), C(i.length < 2, function() {\n                        return \"Copying failed because more than one (\" + n.length + \") save handlers for destination URL \" + e + \".\";\n                    }), s = i[0], u = xf(t).scheme, c = xf(t).path, l = u === xf(t).scheme, [\n                        4,\n                        a.load()\n                    ];\n                case 1:\n                    return h = r.sent(), o && l ? [\n                        4,\n                        yf.getManager(u).removeModel(c)\n                    ] : [\n                        3,\n                        3\n                    ];\n                case 2:\n                    r.sent(), r.label = 3;\n                case 3:\n                    return [\n                        4,\n                        s.save(h)\n                    ];\n                case 4:\n                    return f = r.sent(), !o || l ? [\n                        3,\n                        6\n                    ] : [\n                        4,\n                        yf.getManager(u).removeModel(c)\n                    ];\n                case 5:\n                    r.sent(), r.label = 6;\n                case 6:\n                    return [\n                        2,\n                        f.modelArtifactsInfo\n                    ];\n            }\n        });\n    });\n}\nvar wf = \"models_store\", Cf = \"model_info_store\";\nfunction Ef() {\n    if (!i().getBool(\"IS_BROWSER\")) throw new Error(\"Failed to obtain IndexedDB factory because the current environmentis not a web browser.\");\n    var t = window || self, e = t.indexedDB || t.mozIndexedDB || t.webkitIndexedDB || t.msIndexedDB || t.shimIndexedDB;\n    if (null == e) throw new Error(\"The current browser does not appear to support IndexedDB.\");\n    return e;\n}\nfunction Rf(t) {\n    var e = t.result;\n    e.createObjectStore(wf, {\n        keyPath: \"modelPath\"\n    }), e.createObjectStore(Cf, {\n        keyPath: \"modelPath\"\n    });\n}\nvar If = function() {\n    function t(t) {\n        if (this.indexedDB = Ef(), null == t || !t) throw new Error(\"For IndexedDB, modelPath must not be null, undefined or empty.\");\n        this.modelPath = t;\n    }\n    return t.prototype.save = function(t) {\n        return n(this, void 0, void 0, function() {\n            return r(this, function(e) {\n                if (t.modelTopology instanceof ArrayBuffer) throw new Error(\"BrowserLocalStorage.save() does not support saving model topology in binary formats yet.\");\n                return [\n                    2,\n                    this.databaseAction(this.modelPath, t)\n                ];\n            });\n        });\n    }, t.prototype.load = function() {\n        return n(this, void 0, void 0, function() {\n            return r(this, function(t) {\n                return [\n                    2,\n                    this.databaseAction(this.modelPath)\n                ];\n            });\n        });\n    }, t.prototype.databaseAction = function(t, e) {\n        var n = this;\n        return new Promise(function(t, r) {\n            var o = n.indexedDB.open(\"tensorflowjs\", 1);\n            o.onupgradeneeded = function() {\n                return Rf(o);\n            }, o.onsuccess = function() {\n                var a = o.result;\n                if (null == e) {\n                    var i = a.transaction(wf, \"readonly\"), s = i.objectStore(wf).get(n.modelPath);\n                    s.onsuccess = function() {\n                        if (null == s.result) return a.close(), r(new Error(\"Cannot find model with path '\" + n.modelPath + \"' in IndexedDB.\"));\n                        t(s.result.modelArtifacts);\n                    }, s.onerror = function(t) {\n                        return a.close(), r(s.error);\n                    }, i.oncomplete = function() {\n                        return a.close();\n                    };\n                } else {\n                    var u, c = vf(e), l = a.transaction(Cf, \"readwrite\"), h = l.objectStore(Cf), f = h.put({\n                        modelPath: n.modelPath,\n                        modelArtifactsInfo: c\n                    });\n                    f.onsuccess = function() {\n                        var o = (u = a.transaction(wf, \"readwrite\")).objectStore(wf).put({\n                            modelPath: n.modelPath,\n                            modelArtifacts: e,\n                            modelArtifactsInfo: c\n                        });\n                        o.onsuccess = function() {\n                            return t({\n                                modelArtifactsInfo: c\n                            });\n                        }, o.onerror = function(t) {\n                            var e = (h = l.objectStore(Cf)).delete(n.modelPath);\n                            e.onsuccess = function() {\n                                return a.close(), r(o.error);\n                            }, e.onerror = function(t) {\n                                return a.close(), r(o.error);\n                            };\n                        };\n                    }, f.onerror = function(t) {\n                        return a.close(), r(f.error);\n                    }, l.oncomplete = function() {\n                        null == u ? a.close() : u.oncomplete = function() {\n                            return a.close();\n                        };\n                    };\n                }\n            }, o.onerror = function(t) {\n                return r(o.error);\n            };\n        });\n    }, t.URL_SCHEME = \"indexeddb://\", t;\n}(), kf = function(t) {\n    return i().getBool(\"IS_BROWSER\") && !Array.isArray(t) && t.startsWith(If.URL_SCHEME) ? (e = t.slice(If.URL_SCHEME.length), new If(e)) : null;\n    var e;\n};\nmf.registerSaveRouter(kf), mf.registerLoadRouter(kf);\nvar Sf = function() {\n    function t() {\n        this.indexedDB = Ef();\n    }\n    return t.prototype.listModels = function() {\n        return n(this, void 0, void 0, function() {\n            var t = this;\n            return r(this, function(e) {\n                return [\n                    2,\n                    new Promise(function(e, n) {\n                        var r = t.indexedDB.open(\"tensorflowjs\", 1);\n                        r.onupgradeneeded = function() {\n                            return Rf(r);\n                        }, r.onsuccess = function() {\n                            var t = r.result, o = t.transaction(Cf, \"readonly\"), a = o.objectStore(Cf).getAll();\n                            a.onsuccess = function() {\n                                for(var t = {}, n = 0, r = a.result; n < r.length; n++){\n                                    var o = r[n];\n                                    t[o.modelPath] = o.modelArtifactsInfo;\n                                }\n                                e(t);\n                            }, a.onerror = function(e) {\n                                return t.close(), n(a.error);\n                            }, o.oncomplete = function() {\n                                return t.close();\n                            };\n                        }, r.onerror = function(t) {\n                            return n(r.error);\n                        };\n                    })\n                ];\n            });\n        });\n    }, t.prototype.removeModel = function(t) {\n        return n(this, void 0, void 0, function() {\n            var e = this;\n            return r(this, function(n) {\n                var r;\n                return t = (r = t).startsWith(If.URL_SCHEME) ? r.slice(If.URL_SCHEME.length) : r, [\n                    2,\n                    new Promise(function(n, r) {\n                        var o = e.indexedDB.open(\"tensorflowjs\", 1);\n                        o.onupgradeneeded = function() {\n                            return Rf(o);\n                        }, o.onsuccess = function() {\n                            var e, a = o.result, i = a.transaction(Cf, \"readwrite\"), s = i.objectStore(Cf), u = s.get(t);\n                            u.onsuccess = function() {\n                                if (null == u.result) return a.close(), r(new Error(\"Cannot find model with path '\" + t + \"' in IndexedDB.\"));\n                                var o = s.delete(t), i = function() {\n                                    var o = (e = a.transaction(wf, \"readwrite\")).objectStore(wf).delete(t);\n                                    o.onsuccess = function() {\n                                        return n(u.result.modelArtifactsInfo);\n                                    }, o.onerror = function(t) {\n                                        return r(u.error);\n                                    };\n                                };\n                                o.onsuccess = i, o.onerror = function(t) {\n                                    return i(), a.close(), r(u.error);\n                                };\n                            }, u.onerror = function(t) {\n                                return a.close(), r(u.error);\n                            }, i.oncomplete = function() {\n                                null == e ? a.close() : e.oncomplete = function() {\n                                    return a.close();\n                                };\n                            };\n                        }, o.onerror = function(t) {\n                            return r(o.error);\n                        };\n                    })\n                ];\n            });\n        });\n    }, t;\n}();\nif (i().getBool(\"IS_BROWSER\")) try {\n    yf.registerManager(If.URL_SCHEME, new Sf);\n} catch (t) {}\nvar Af = \"/\", Df = \"tensorflowjs_models\", Tf = \"info\", Nf = \"model_topology\", Ff = \"weight_specs\", _f = \"weight_data\", Of = \"model_metadata\";\nfunction Mf(t) {\n    return {\n        info: [\n            Df,\n            t,\n            Tf\n        ].join(Af),\n        topology: [\n            Df,\n            t,\n            Nf\n        ].join(Af),\n        weightSpecs: [\n            Df,\n            t,\n            Ff\n        ].join(Af),\n        weightData: [\n            Df,\n            t,\n            _f\n        ].join(Af),\n        modelMetadata: [\n            Df,\n            t,\n            Of\n        ].join(Af)\n    };\n}\nfunction Bf(t) {\n    var e = t.split(Af);\n    if (e.length < 3) throw new Error(\"Invalid key format: \" + t);\n    return e.slice(1, e.length - 1).join(Af);\n}\nvar Pf = function() {\n    function t(t) {\n        if (!i().getBool(\"IS_BROWSER\") || \"undefined\" == \"undefined\" || 0) throw new Error(\"The current environment does not support local storage.\");\n        if (this.LS = window.localStorage, null == t || !t) throw new Error(\"For local storage, modelPath must not be null, undefined or empty.\");\n        this.modelPath = t, this.keys = Mf(this.modelPath);\n    }\n    return t.prototype.save = function(t) {\n        return n(this, void 0, void 0, function() {\n            var e, n, o;\n            return r(this, function(r) {\n                if (t.modelTopology instanceof ArrayBuffer) throw new Error(\"BrowserLocalStorage.save() does not support saving model topology in binary formats yet.\");\n                e = JSON.stringify(t.modelTopology), n = JSON.stringify(t.weightSpecs), o = vf(t);\n                try {\n                    return this.LS.setItem(this.keys.info, JSON.stringify(o)), this.LS.setItem(this.keys.topology, e), this.LS.setItem(this.keys.weightSpecs, n), this.LS.setItem(this.keys.weightData, function(t) {\n                        if (hf) return Buffer.from(t).toString(\"base64\");\n                        for(var e = new Uint8Array(t), n = \"\", r = 0, o = e.length; r < o; r++)n += String.fromCharCode(e[r]);\n                        return btoa(n);\n                    }(t.weightData)), this.LS.setItem(this.keys.modelMetadata, JSON.stringify({\n                        format: t.format,\n                        generatedBy: t.generatedBy,\n                        convertedBy: t.convertedBy,\n                        userDefinedMetadata: t.userDefinedMetadata\n                    })), [\n                        2,\n                        {\n                            modelArtifactsInfo: o\n                        }\n                    ];\n                } catch (t) {\n                    throw this.LS.removeItem(this.keys.info), this.LS.removeItem(this.keys.topology), this.LS.removeItem(this.keys.weightSpecs), this.LS.removeItem(this.keys.weightData), this.LS.removeItem(this.keys.modelMetadata), new Error(\"Failed to save model '\" + this.modelPath + \"' to local storage: size quota being exceeded is a possible cause of this failure: modelTopologyBytes=\" + o.modelTopologyBytes + \", weightSpecsBytes=\" + o.weightSpecsBytes + \", weightDataBytes=\" + o.weightDataBytes + \".\");\n                }\n                return [\n                    2\n                ];\n            });\n        });\n    }, t.prototype.load = function() {\n        return n(this, void 0, void 0, function() {\n            var t, e, n, o, a, i, s;\n            return r(this, function(r) {\n                if (null == (t = JSON.parse(this.LS.getItem(this.keys.info)))) throw new Error(\"In local storage, there is no model with name '\" + this.modelPath + \"'\");\n                if (\"JSON\" !== t.modelTopologyType) throw new Error(\"BrowserLocalStorage does not support loading non-JSON model topology yet.\");\n                if (e = {}, null == (n = JSON.parse(this.LS.getItem(this.keys.topology)))) throw new Error(\"In local storage, the topology of model '\" + this.modelPath + \"' is missing.\");\n                if (e.modelTopology = n, null == (o = JSON.parse(this.LS.getItem(this.keys.weightSpecs)))) throw new Error(\"In local storage, the weight specs of model '\" + this.modelPath + \"' are missing.\");\n                if (e.weightSpecs = o, null != (a = this.LS.getItem(this.keys.modelMetadata)) && (i = JSON.parse(a), e.format = i.format, e.generatedBy = i.generatedBy, e.convertedBy = i.convertedBy, e.userDefinedMetadata = i.userDefinedMetadata), null == (s = this.LS.getItem(this.keys.weightData))) throw new Error(\"In local storage, the binary weight values of model '\" + this.modelPath + \"' are missing.\");\n                return e.weightData = function(t) {\n                    if (hf) {\n                        var e = Buffer.from(t, \"base64\");\n                        return e.buffer.slice(e.byteOffset, e.byteOffset + e.byteLength);\n                    }\n                    for(var n = atob(t), r = new Uint8Array(n.length), o = 0; o < n.length; ++o)r.set([\n                        n.charCodeAt(o)\n                    ], o);\n                    return r.buffer;\n                }(s), [\n                    2,\n                    e\n                ];\n            });\n        });\n    }, t.URL_SCHEME = \"localstorage://\", t;\n}(), Lf = function(t) {\n    return i().getBool(\"IS_BROWSER\") && !Array.isArray(t) && t.startsWith(Pf.URL_SCHEME) ? (e = t.slice(Pf.URL_SCHEME.length), new Pf(e)) : null;\n    var e;\n};\nmf.registerSaveRouter(Lf), mf.registerLoadRouter(Lf);\nvar Wf = function() {\n    function t() {\n        C(i().getBool(\"IS_BROWSER\"), function() {\n            return \"Current environment is not a web browser\";\n        }), C( true || 0, function() {\n            return \"Current browser does not appear to support localStorage\";\n        }), this.LS = window.localStorage;\n    }\n    return t.prototype.listModels = function() {\n        return n(this, void 0, void 0, function() {\n            var t, e, n, o, a, i;\n            return r(this, function(r) {\n                for(t = {}, e = Df + Af, n = Af + Tf, o = 0; o < this.LS.length; ++o)(a = this.LS.key(o)).startsWith(e) && a.endsWith(n) && (i = Bf(a), t[i] = JSON.parse(this.LS.getItem(a)));\n                return [\n                    2,\n                    t\n                ];\n            });\n        });\n    }, t.prototype.removeModel = function(t) {\n        return n(this, void 0, void 0, function() {\n            var e, n;\n            return r(this, function(r) {\n                var o;\n                if (t = (o = t).startsWith(Pf.URL_SCHEME) ? o.slice(Pf.URL_SCHEME.length) : o, e = Mf(t), null == this.LS.getItem(e.info)) throw new Error(\"Cannot find model at path '\" + t + \"'\");\n                return n = JSON.parse(this.LS.getItem(e.info)), this.LS.removeItem(e.info), this.LS.removeItem(e.topology), this.LS.removeItem(e.weightSpecs), this.LS.removeItem(e.weightData), [\n                    2,\n                    n\n                ];\n            });\n        });\n    }, t;\n}();\nif (i().getBool(\"IS_BROWSER\")) try {\n    yf.registerManager(Pf.URL_SCHEME, new Wf);\n} catch (t) {}\nvar Uf = \"model\", Vf = \".json\", zf = \".weights.bin\";\nfunction Gf(t) {\n    return new Promise(function(t) {\n        return setTimeout(t);\n    }).then(t);\n}\nvar Hf = function() {\n    function t(e) {\n        if (!i().getBool(\"IS_BROWSER\")) throw new Error(\"browserDownloads() cannot proceed because the current environment is not a browser.\");\n        e.startsWith(t.URL_SCHEME) && (e = e.slice(t.URL_SCHEME.length)), null != e && 0 !== e.length || (e = Uf), this.modelTopologyFileName = e + Vf, this.weightDataFileName = e + zf;\n    }\n    return t.prototype.save = function(t) {\n        return n(this, void 0, void 0, function() {\n            var e, n, o, a, i, s;\n            return r(this, function(r) {\n                switch(r.label){\n                    case 0:\n                        if (\"undefined\" == typeof document) throw new Error(\"Browser downloads are not supported in this environment since `document` is not present\");\n                        if (e = window.URL.createObjectURL(new Blob([\n                            t.weightData\n                        ], {\n                            type: \"application/octet-stream\"\n                        })), !(t.modelTopology instanceof ArrayBuffer)) return [\n                            3,\n                            1\n                        ];\n                        throw new Error(\"BrowserDownloads.save() does not support saving model topology in binary formats yet.\");\n                    case 1:\n                        return n = [\n                            {\n                                paths: [\n                                    \"./\" + this.weightDataFileName\n                                ],\n                                weights: t.weightSpecs\n                            }\n                        ], o = {\n                            modelTopology: t.modelTopology,\n                            format: t.format,\n                            generatedBy: t.generatedBy,\n                            convertedBy: t.convertedBy,\n                            weightsManifest: n\n                        }, a = window.URL.createObjectURL(new Blob([\n                            JSON.stringify(o)\n                        ], {\n                            type: \"application/json\"\n                        })), (i = null == this.jsonAnchor ? document.createElement(\"a\") : this.jsonAnchor).download = this.modelTopologyFileName, i.href = a, [\n                            4,\n                            Gf(function() {\n                                return i.dispatchEvent(new MouseEvent(\"click\"));\n                            })\n                        ];\n                    case 2:\n                        return r.sent(), null == t.weightData ? [\n                            3,\n                            4\n                        ] : ((s = null == this.weightDataAnchor ? document.createElement(\"a\") : this.weightDataAnchor).download = this.weightDataFileName, s.href = e, [\n                            4,\n                            Gf(function() {\n                                return s.dispatchEvent(new MouseEvent(\"click\"));\n                            })\n                        ]);\n                    case 3:\n                        r.sent(), r.label = 4;\n                    case 4:\n                        return [\n                            2,\n                            {\n                                modelArtifactsInfo: vf(t)\n                            }\n                        ];\n                }\n            });\n        });\n    }, t.URL_SCHEME = \"downloads://\", t;\n}(), qf = function() {\n    function t(t) {\n        if (null == t || t.length < 1) throw new Error(\"When calling browserFiles, at least 1 file is required, but received \" + t);\n        this.files = t;\n    }\n    return t.prototype.load = function() {\n        return n(this, void 0, void 0, function() {\n            var t, e, n = this;\n            return r(this, function(r) {\n                return t = this.files[0], e = this.files.slice(1), [\n                    2,\n                    new Promise(function(r, o) {\n                        var a = new FileReader;\n                        a.onload = function(a) {\n                            var i = JSON.parse(a.target.result), s = i.modelTopology;\n                            if (null != s) {\n                                0 === e.length && r({\n                                    modelTopology: s\n                                });\n                                var u = i.weightsManifest;\n                                if (null != u) {\n                                    var c;\n                                    try {\n                                        c = n.checkManifestAndWeightFiles(u, e);\n                                    } catch (t) {\n                                        return void o(t);\n                                    }\n                                    var l = [], h = [], f = [];\n                                    u.forEach(function(t) {\n                                        t.paths.forEach(function(t) {\n                                            h.push(t), f.push(null);\n                                        }), l.push.apply(l, t.weights);\n                                    }), u.forEach(function(t) {\n                                        t.paths.forEach(function(t) {\n                                            var e = new FileReader;\n                                            e.onload = function(e) {\n                                                var n = e.target.result, o = h.indexOf(t);\n                                                f[o] = n, -1 === f.indexOf(null) && r({\n                                                    modelTopology: s,\n                                                    weightSpecs: l,\n                                                    weightData: df(f),\n                                                    format: i.format,\n                                                    generatedBy: i.generatedBy,\n                                                    convertedBy: i.convertedBy,\n                                                    userDefinedMetadata: i.userDefinedMetadata\n                                                });\n                                            }, e.onerror = function(e) {\n                                                return o(\"Failed to weights data from file of path '\" + t + \"'.\");\n                                            }, e.readAsArrayBuffer(c[t]);\n                                        });\n                                    });\n                                } else o(new Error(\"weightManifest field is missing from file \" + t.name));\n                            } else o(new Error(\"modelTopology field is missing from file \" + t.name));\n                        }, a.onerror = function(e) {\n                            return o(\"Failed to read model topology and weights manifest JSON from file '\" + t.name + \"'. BrowserFiles supports loading Keras-style tf.Model artifacts only.\");\n                        }, a.readAsText(t);\n                    })\n                ];\n            });\n        });\n    }, t.prototype.checkManifestAndWeightFiles = function(t, e) {\n        for(var n = [], r = e.map(function(t) {\n            return pf(t.name);\n        }), o = {}, a = 0, i = t; a < i.length; a++){\n            i[a].paths.forEach(function(t) {\n                var a = pf(t);\n                if (-1 !== n.indexOf(a)) throw new Error(\"Duplicate file basename found in weights manifest: '\" + a + \"'\");\n                if (n.push(a), -1 === r.indexOf(a)) throw new Error(\"Weight file with basename '\" + a + \"' is not provided.\");\n                o[t] = e[r.indexOf(a)];\n            });\n        }\n        if (n.length !== e.length) throw new Error(\"Mismatch in the number of files in weights manifest (\" + n.length + \") and the number of weight files provided (\" + e.length + \").\");\n        return o;\n    }, t;\n}();\nfunction Kf(t, e, n, r) {\n    !function(t) {\n        C(null != t && Array.isArray(t) && t.length > 0, function() {\n            return \"promises must be a none empty array\";\n        });\n    }(t), function(t, e) {\n        C(t >= 0 && t <= 1, function() {\n            return \"Progress fraction must be in range [0, 1], but got startFraction \" + t;\n        }), C(e >= 0 && e <= 1, function() {\n            return \"Progress fraction must be in range [0, 1], but got endFraction \" + e;\n        }), C(e >= t, function() {\n            return \"startFraction must be no more than endFraction, but got startFraction \" + t + \" and endFraction \" + e;\n        });\n    }(n = null == n ? 0 : n, r = null == r ? 1 : r);\n    var o = 0;\n    return Promise.all(t.map(function(a) {\n        return a.then(function(a) {\n            var i = n + ++o / t.length * (r - n);\n            return e(i), a;\n        }), a;\n    }));\n}\nfunction jf(t, e) {\n    return n(this, void 0, void 0, function() {\n        var n, o, a, s, u, c, l, h, f;\n        return r(this, function(r) {\n            switch(r.label){\n                case 0:\n                    return null == e && (e = {}), n = null == e.fetchFunc ? i().platform.fetch : e.fetchFunc, o = t.map(function(t) {\n                        return n(t, e.requestInit, {\n                            isBinary: !0\n                        });\n                    }), a = 0, s = .5, null != e.onProgress ? [\n                        3,\n                        2\n                    ] : [\n                        4,\n                        Promise.all(o)\n                    ];\n                case 1:\n                    return u = r.sent(), [\n                        3,\n                        4\n                    ];\n                case 2:\n                    return [\n                        4,\n                        Kf(o, e.onProgress, a, s)\n                    ];\n                case 3:\n                    u = r.sent(), r.label = 4;\n                case 4:\n                    return c = u.map(function(t) {\n                        return t.arrayBuffer();\n                    }), l = .5, h = 1, null != e.onProgress ? [\n                        3,\n                        6\n                    ] : [\n                        4,\n                        Promise.all(c)\n                    ];\n                case 5:\n                    return f = r.sent(), [\n                        3,\n                        8\n                    ];\n                case 6:\n                    return [\n                        4,\n                        Kf(c, e.onProgress, l, h)\n                    ];\n                case 7:\n                    f = r.sent(), r.label = 8;\n                case 8:\n                    return [\n                        2,\n                        f\n                    ];\n            }\n        });\n    });\n}\nfunction Xf(t) {\n    var e = this;\n    return function(o, a, i) {\n        return void 0 === a && (a = \"\"), n(e, void 0, void 0, function() {\n            var e, n, s, u, c, l, h, f, d, p;\n            return r(this, function(r) {\n                switch(r.label){\n                    case 0:\n                        if (e = o.map(function() {\n                            return !1;\n                        }), n = {}, s = null != i ? i.map(function() {\n                            return !1;\n                        }) : [], u = [], o.forEach(function(t, r) {\n                            var o = 0;\n                            t.weights.forEach(function(t) {\n                                var a = \"quantization\" in t ? t.quantization.dtype : t.dtype, c = sf[a] * k(t.shape), l = function() {\n                                    e[r] = !0, null == n[r] && (n[r] = []), n[r].push({\n                                        manifestEntry: t,\n                                        groupOffset: o,\n                                        sizeBytes: c\n                                    });\n                                };\n                                null != i ? i.forEach(function(e, n) {\n                                    e === t.name && (l(), s[n] = !0);\n                                }) : l(), u.push(t.name), o += c;\n                            });\n                        }), !s.every(function(t) {\n                            return t;\n                        })) throw c = i.filter(function(t, e) {\n                            return !s[e];\n                        }), new Error(\"Could not find weights in manifest with names: \" + c.join(\", \") + \". \\nManifest JSON has weights with names: \" + u.join(\", \") + \".\");\n                        return l = e.reduce(function(t, e, n) {\n                            return e && t.push(n), t;\n                        }, []), h = [], l.forEach(function(t) {\n                            o[t].paths.forEach(function(t) {\n                                var e = a + (a.endsWith(\"/\") ? \"\" : \"/\") + t;\n                                h.push(e);\n                            });\n                        }), [\n                            4,\n                            t(h)\n                        ];\n                    case 1:\n                        return f = r.sent(), d = {}, p = 0, l.forEach(function(t) {\n                            for(var e = o[t].paths.length, r = 0, a = 0; a < e; a++)r += f[p + a].byteLength;\n                            for(var i = new ArrayBuffer(r), s = new Uint8Array(i), u = 0, c = 0; c < e; c++){\n                                var l = new Uint8Array(f[p + c]);\n                                s.set(l, u), u += l.byteLength;\n                            }\n                            n[t].forEach(function(t) {\n                                var e = cf(i.slice(t.groupOffset, t.groupOffset + t.sizeBytes), [\n                                    t.manifestEntry\n                                ]);\n                                for(var n in e)d[n] = e[n];\n                            }), p += e;\n                        }), [\n                            2,\n                            d\n                        ];\n                }\n            });\n        });\n    };\n}\nmf.registerSaveRouter(function(t) {\n    return i().getBool(\"IS_BROWSER\") && !Array.isArray(t) && t.startsWith(Hf.URL_SCHEME) ? function(t) {\n        void 0 === t && (t = \"model\");\n        return new Hf(t);\n    }(t.slice(Hf.URL_SCHEME.length)) : null;\n});\nvar Yf = function() {\n    function t(t, e) {\n        if (this.DEFAULT_METHOD = \"POST\", null == e && (e = {}), this.weightPathPrefix = e.weightPathPrefix, this.onProgress = e.onProgress, null != e.fetchFunc ? (C(\"function\" == typeof e.fetchFunc, function() {\n            return \"Must pass a function that matches the signature of `fetch` (see https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API)\";\n        }), this.fetch = e.fetchFunc) : this.fetch = i().platform.fetch, C(null != t && t.length > 0, function() {\n            return \"URL path for http must not be null, undefined or empty.\";\n        }), Array.isArray(t) && C(2 === t.length, function() {\n            return \"URL paths for http must have a length of 2, (actual length is \" + t.length + \").\";\n        }), this.path = t, null != e.requestInit && null != e.requestInit.body) throw new Error(\"requestInit is expected to have no pre-existing body, but has one.\");\n        this.requestInit = e.requestInit || {};\n    }\n    return t.prototype.save = function(t) {\n        return n(this, void 0, void 0, function() {\n            var e, n, o, a;\n            return r(this, function(r) {\n                switch(r.label){\n                    case 0:\n                        if (t.modelTopology instanceof ArrayBuffer) throw new Error(\"BrowserHTTPRequest.save() does not support saving model topology in binary formats yet.\");\n                        return (e = Object.assign({\n                            method: this.DEFAULT_METHOD\n                        }, this.requestInit)).body = new FormData, n = [\n                            {\n                                paths: [\n                                    \"./model.weights.bin\"\n                                ],\n                                weights: t.weightSpecs\n                            }\n                        ], o = {\n                            modelTopology: t.modelTopology,\n                            format: t.format,\n                            generatedBy: t.generatedBy,\n                            convertedBy: t.convertedBy,\n                            userDefinedMetadata: t.userDefinedMetadata,\n                            weightsManifest: n\n                        }, e.body.append(\"model.json\", new Blob([\n                            JSON.stringify(o)\n                        ], {\n                            type: \"application/json\"\n                        }), \"model.json\"), null != t.weightData && e.body.append(\"model.weights.bin\", new Blob([\n                            t.weightData\n                        ], {\n                            type: \"application/octet-stream\"\n                        }), \"model.weights.bin\"), [\n                            4,\n                            this.fetch(this.path, e)\n                        ];\n                    case 1:\n                        if ((a = r.sent()).ok) return [\n                            2,\n                            {\n                                modelArtifactsInfo: vf(t),\n                                responses: [\n                                    a\n                                ]\n                            }\n                        ];\n                        throw new Error(\"BrowserHTTPRequest.save() failed due to HTTP response status \" + a.status + \".\");\n                }\n            });\n        });\n    }, t.prototype.load = function() {\n        return n(this, void 0, void 0, function() {\n            var t, e, n, o, a, i, s, u, c, l, h, f;\n            return r(this, function(r) {\n                switch(r.label){\n                    case 0:\n                        return [\n                            4,\n                            this.fetch(this.path, this.requestInit)\n                        ];\n                    case 1:\n                        if (!(t = r.sent()).ok) throw new Error(\"Request to \" + this.path + \" failed with status code \" + t.status + \". Please verify this URL points to the model JSON of the model to load.\");\n                        r.label = 2;\n                    case 2:\n                        return r.trys.push([\n                            2,\n                            4,\n                            ,\n                            5\n                        ]), [\n                            4,\n                            t.json()\n                        ];\n                    case 3:\n                        return e = r.sent(), [\n                            3,\n                            5\n                        ];\n                    case 4:\n                        throw r.sent(), n = \"Failed to parse model JSON of response from \" + this.path + \".\", this.path.endsWith(\".pb\") ? n += \" Your path contains a .pb file extension. Support for .pb models have been removed in TensorFlow.js 1.0 in favor of .json models. You can re-convert your Python TensorFlow model using the TensorFlow.js 1.0 conversion scripts or you can convert your.pb models with the 'pb2json'NPM script in the tensorflow/tfjs-converter repository.\" : n += \" Please make sure the server is serving valid JSON for this request.\", new Error(n);\n                    case 5:\n                        if (o = e.modelTopology, a = e.weightsManifest, i = e.generatedBy, s = e.convertedBy, u = e.format, c = e.userDefinedMetadata, null == o && null == a) throw new Error(\"The JSON from HTTP path \" + this.path + \" contains neither model topology or manifest for weights.\");\n                        return null == a ? [\n                            3,\n                            7\n                        ] : [\n                            4,\n                            this.loadWeights(a)\n                        ];\n                    case 6:\n                        f = r.sent(), l = f[0], h = f[1], r.label = 7;\n                    case 7:\n                        return [\n                            2,\n                            {\n                                modelTopology: o,\n                                weightSpecs: l,\n                                weightData: h,\n                                userDefinedMetadata: c,\n                                generatedBy: i,\n                                convertedBy: s,\n                                format: u\n                            }\n                        ];\n                }\n            });\n        });\n    }, t.prototype.loadWeights = function(t) {\n        return n(this, void 0, void 0, function() {\n            var e, n, o, a, i, s, u, c, l, h, f;\n            return r(this, function(r) {\n                switch(r.label){\n                    case 0:\n                        for(e = Array.isArray(this.path) ? this.path[1] : this.path, n = function(t) {\n                            var e = t.lastIndexOf(\"/\"), n = t.lastIndexOf(\"?\"), r = t.substring(0, e), o = n > e ? t.substring(n) : \"\";\n                            return [\n                                r + \"/\",\n                                o\n                            ];\n                        }(e), o = n[0], a = n[1], i = this.weightPathPrefix || o, s = [], u = 0, c = t; u < c.length; u++)l = c[u], s.push.apply(s, l.weights);\n                        return h = [], t.forEach(function(t) {\n                            t.paths.forEach(function(t) {\n                                h.push(i + t + a);\n                            });\n                        }), [\n                            4,\n                            jf(h, {\n                                requestInit: this.requestInit,\n                                fetchFunc: this.fetch,\n                                onProgress: this.onProgress\n                            })\n                        ];\n                    case 1:\n                        return f = r.sent(), [\n                            2,\n                            [\n                                s,\n                                df(f)\n                            ]\n                        ];\n                }\n            });\n        });\n    }, t.URL_SCHEME_REGEX = /^https?:\\/\\//, t;\n}();\nfunction $f(t) {\n    return null != t.match(Yf.URL_SCHEME_REGEX);\n}\nvar Qf = function(t, e) {\n    if (\"undefined\" == typeof fetch) return null;\n    return (Array.isArray(t) ? t.every(function(t) {\n        return $f(t);\n    }) : $f(t)) ? Jf(t, {\n        onProgress: e\n    }) : null;\n};\nfunction Jf(t, e) {\n    return new Yf(t, e);\n}\nmf.registerSaveRouter(Qf), mf.registerLoadRouter(Qf);\nvar Zf = function() {\n    function t(t) {\n        this.modelArtifacts = t;\n    }\n    return t.prototype.load = function() {\n        return n(this, void 0, void 0, function() {\n            return r(this, function(t) {\n                return [\n                    2,\n                    this.modelArtifacts\n                ];\n            });\n        });\n    }, t;\n}(), td = function() {\n    function t(t) {\n        this.saveHandler = t;\n    }\n    return t.prototype.save = function(t) {\n        return n(this, void 0, void 0, function() {\n            return r(this, function(e) {\n                return [\n                    2,\n                    this.saveHandler(t)\n                ];\n            });\n        });\n    }, t;\n}();\nvar ed = Object.freeze({\n    browserFiles: function(t) {\n        return new qf(t);\n    },\n    browserHTTPRequest: function(t, e) {\n        return Jf(t, e);\n    },\n    concatenateArrayBuffers: df,\n    decodeWeights: cf,\n    encodeWeights: function(t, e) {\n        return n(this, void 0, void 0, function() {\n            var o, a, i, s, u, c = this;\n            return r(this, function(l) {\n                switch(l.label){\n                    case 0:\n                        for(o = [], a = [], i = Array.isArray(t) ? t.map(function(t) {\n                            return t.name;\n                        }) : Object.keys(t), s = function(s) {\n                            var u = i[s], l = Array.isArray(t) ? t[s].tensor : t[u];\n                            if (\"float32\" !== l.dtype && \"int32\" !== l.dtype && \"bool\" !== l.dtype && \"string\" !== l.dtype) throw new Error(\"Unsupported dtype in weight '\" + u + \"': \" + l.dtype);\n                            var h = {\n                                name: u,\n                                shape: l.shape,\n                                dtype: l.dtype\n                            };\n                            if (\"string\" === l.dtype) {\n                                var f = new Promise(function(t) {\n                                    return n(c, void 0, void 0, function() {\n                                        var e, n, o, a, i, s, u;\n                                        return r(this, function(r) {\n                                            switch(r.label){\n                                                case 0:\n                                                    return [\n                                                        4,\n                                                        l.bytes()\n                                                    ];\n                                                case 1:\n                                                    for(e = r.sent(), n = e.reduce(function(t, e) {\n                                                        return t + e.length;\n                                                    }, 0) + uf * e.length, o = new Uint8Array(n), a = 0, i = 0; i < e.length; i++)s = e[i], u = new Uint8Array(new Uint32Array([\n                                                        s.length\n                                                    ]).buffer), o.set(u, a), a += uf, o.set(s, a), a += s.length;\n                                                    return t(o), [\n                                                        2\n                                                    ];\n                                            }\n                                        });\n                                    });\n                                });\n                                a.push(f);\n                            } else a.push(l.data());\n                            null != e && (h.group = e), o.push(h);\n                        }, u = 0; u < i.length; ++u)s(u);\n                        return [\n                            4,\n                            Promise.all(a)\n                        ];\n                    case 1:\n                        return [\n                            2,\n                            {\n                                data: lf(l.sent()),\n                                specs: o\n                            }\n                        ];\n                }\n            });\n        });\n    },\n    fromMemory: function(t, e, n, r) {\n        return 1 === arguments.length ? null != t.modelTopology || null != t.weightSpecs ? new Zf(t) : (console.warn(\"Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release.\"), new Zf({\n            modelTopology: t\n        })) : (console.warn(\"Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release.\"), new Zf({\n            modelTopology: t,\n            weightSpecs: e,\n            weightData: n,\n            trainingConfig: r\n        }));\n    },\n    getLoadHandlers: function(t, e) {\n        return mf.getLoadHandlers(t, e);\n    },\n    getModelArtifactsInfoForJSON: vf,\n    getSaveHandlers: function(t) {\n        return mf.getSaveHandlers(t);\n    },\n    http: Jf,\n    isHTTPScheme: $f,\n    loadWeights: function(t, e, o, a) {\n        return void 0 === e && (e = \"\"), n(this, void 0, void 0, function() {\n            return r(this, function(n) {\n                return [\n                    2,\n                    Xf(function(t) {\n                        return jf(t, {\n                            requestInit: a\n                        });\n                    })(t, e, o)\n                ];\n            });\n        });\n    },\n    registerLoadRouter: function(t) {\n        return mf.registerLoadRouter(t);\n    },\n    registerSaveRouter: function(t) {\n        return mf.registerSaveRouter(t);\n    },\n    weightsLoaderFactory: Xf,\n    withSaveHandler: function(t) {\n        return new td(t);\n    },\n    copyModel: function(t, e) {\n        return n(this, void 0, void 0, function() {\n            return r(this, function(n) {\n                return !1, [\n                    2,\n                    bf(t, e, !1)\n                ];\n            });\n        });\n    },\n    listModels: function() {\n        return n(this, void 0, void 0, function() {\n            var t, e, n, o, a, i, s;\n            return r(this, function(r) {\n                switch(r.label){\n                    case 0:\n                        t = yf.getSchemes(), e = {}, n = 0, o = t, r.label = 1;\n                    case 1:\n                        return n < o.length ? (a = o[n], [\n                            4,\n                            yf.getManager(a).listModels()\n                        ]) : [\n                            3,\n                            4\n                        ];\n                    case 2:\n                        for(s in i = r.sent())e[a + gf + s] = i[s];\n                        r.label = 3;\n                    case 3:\n                        return n++, [\n                            3,\n                            1\n                        ];\n                    case 4:\n                        return [\n                            2,\n                            e\n                        ];\n                }\n            });\n        });\n    },\n    moveModel: function(t, e) {\n        return n(this, void 0, void 0, function() {\n            return r(this, function(n) {\n                return !0, [\n                    2,\n                    bf(t, e, !0)\n                ];\n            });\n        });\n    },\n    removeModel: function(t) {\n        return n(this, void 0, void 0, function() {\n            var e;\n            return r(this, function(n) {\n                return e = xf(t), [\n                    2,\n                    yf.getManager(e.scheme).removeModel(e.path)\n                ];\n            });\n        });\n    }\n});\nvar nd, rd = An({\n    confusionMatrix_: function(t, e, n) {\n        var r = mn(t, \"labels\", \"confusionMatrix\"), o = mn(e, \"predictions\", \"confusionMatrix\");\n        C(null == n || n > 0 && Number.isInteger(n), function() {\n            return \"If provided, numClasses must be a positive integer, but got \" + n;\n        }), C(1 === r.rank, function() {\n            return \"Expected the rank of labels to be 1, but got \" + r.rank;\n        }), C(1 === o.rank, function() {\n            return \"Expected the rank of predictions to be 1, but got \" + o.rank;\n        }), C(r.shape[0] === o.shape[0], function() {\n            return \"Mismatch in the number of examples: \" + r.shape[0] + \" vs. \" + o.shape[0] + \". Labels and predictions should have the same number of elements.\";\n        }), C(n > 0 && Number.isInteger(n), function() {\n            return \"numClasses is required to be a positive integer, but got \" + n;\n        });\n        var a = Rr(r.asType(\"int32\"), n), i = Rr(o.asType(\"int32\"), n);\n        return a.transpose().matMul(i).asType(\"int32\");\n    }\n}), od = Object.freeze({\n    confusionMatrix: rd\n});\nvar ad = An({\n    fromPixels_: function(t, e) {\n        if (void 0 === e && (e = 3), e > 4) throw new Error(\"Cannot construct Tensor with more than 4 channels from pixels.\");\n        if (null == t) throw new Error(\"pixels passed to tf.browser.fromPixels() can not be null\");\n        var n = !1, r = !1, o = !1, a = !1, i = !1;\n        if (t.data instanceof Uint8Array) n = !0;\n        else if (\"undefined\" != typeof ImageData && t instanceof ImageData) r = !0;\n        else if (\"undefined\" != typeof HTMLVideoElement && t instanceof HTMLVideoElement) o = !0;\n        else if (\"undefined\" != typeof HTMLImageElement && t instanceof HTMLImageElement) a = !0;\n        else {\n            if (null == t.getContext) throw new Error(\"pixels passed to tf.browser.fromPixels() must be either an HTMLVideoElement, HTMLImageElement, HTMLCanvasElement, ImageData in browser, or OffscreenCanvas, ImageData in webworker or {data: Uint32Array, width: number, height: number}, but was \" + t.constructor.name);\n            i = !0;\n        }\n        if (o) {\n            if (o && t.readyState < 2) throw new Error(\"The video element has not loaded data yet. Please wait for `loadeddata` event on the <video> element.\");\n        }\n        if (null != l(\"FromPixels\", Lt.backendName)) return Lt.runKernel(\"FromPixels\", {\n            pixels: t\n        }, {\n            numChannels: e\n        });\n        var s, u, c = o ? [\n            t.videoWidth,\n            t.videoHeight\n        ] : [\n            t.width,\n            t.height\n        ], h = c[0], f = c[1];\n        if (i ? s = t.getContext(\"2d\").getImageData(0, 0, h, f).data : r || n ? s = t.data : (a || o) && (null == nd && (nd = document.createElement(\"canvas\").getContext(\"2d\")), nd.canvas.width = h, nd.canvas.height = f, nd.drawImage(t, 0, 0, h, f), s = nd.getImageData(0, 0, h, f).data), 4 === e) u = new Int32Array(s);\n        else {\n            var d = h * f;\n            u = new Int32Array(d * e);\n            for(var p = 0; p < d; p++)for(var v = 0; v < e; ++v)u[p * e + v] = s[4 * p + v];\n        }\n        return Pn(u, [\n            f,\n            h,\n            e\n        ], \"int32\");\n    }\n}), id = Object.freeze({\n    toPixels: function(t, e) {\n        return n(this, void 0, void 0, function() {\n            var n, o, a, i, s, u, c, l, h, f, d, p, v, m, g, y, x, b, w, C, E, R, I;\n            return r(this, function(r) {\n                switch(r.label){\n                    case 0:\n                        if (n = mn(t, \"img\", \"toPixels\"), t instanceof wt || (n = n.toInt()), 2 !== n.rank && 3 !== n.rank) throw new Error(\"toPixels only supports rank 2 or 3 tensors, got rank \" + n.rank + \".\");\n                        if (o = n.shape.slice(0, 2), a = o[0], i = o[1], (s = 2 === n.rank ? 1 : n.shape[2]) > 4 || 2 === s) throw new Error(\"toPixels only supports depth of size 1, 3 or 4 but got \" + s);\n                        return [\n                            4,\n                            n.data()\n                        ];\n                    case 1:\n                        return u = r.sent(), c = n.min(), l = n.max(), [\n                            4,\n                            Promise.all([\n                                c.data(),\n                                l.data()\n                            ])\n                        ];\n                    case 2:\n                        if (h = r.sent(), f = h[0], d = h[1], p = f[0], v = d[0], c.dispose(), l.dispose(), \"float32\" === n.dtype) {\n                            if (p < 0 || v > 1) throw new Error(\"Tensor values for a float32 Tensor must be in the range [0 - 1] but got range [\" + p + \" - \" + v + \"].\");\n                        } else {\n                            if (\"int32\" !== n.dtype) throw new Error(\"Unsupported type for toPixels: \" + n.dtype + \". Please use float32 or int32 tensors.\");\n                            if (p < 0 || v > 255) throw new Error(\"Tensor values for a int32 Tensor must be in the range [0 - 255] but got range [\" + p + \" - \" + v + \"].\");\n                        }\n                        for(m = \"float32\" === n.dtype ? 255 : 1, g = new Uint8ClampedArray(i * a * 4), y = 0; y < a * i; ++y)x = void 0, b = void 0, w = void 0, C = void 0, 1 === s ? (x = u[y] * m, b = u[y] * m, w = u[y] * m, C = 255) : 3 === s ? (x = u[3 * y] * m, b = u[3 * y + 1] * m, w = u[3 * y + 2] * m, C = 255) : 4 === s && (x = u[4 * y] * m, b = u[4 * y + 1] * m, w = u[4 * y + 2] * m, C = u[4 * y + 3] * m), g[(E = 4 * y) + 0] = Math.round(x), g[E + 1] = Math.round(b), g[E + 2] = Math.round(w), g[E + 3] = Math.round(C);\n                        return null != e && (e.width = i, e.height = a, R = e.getContext(\"2d\"), I = new ImageData(g, i, a), R.putImageData(I, 0, 0)), n !== t && n.dispose(), [\n                            2,\n                            g\n                        ];\n                }\n            });\n        });\n    },\n    fromPixels: ad\n}), sd = function() {\n    function t() {}\n    return t.prototype.getClassName = function() {\n        return this.constructor.className;\n    }, t.fromConfig = function(t, e) {\n        return new t(e);\n    }, t;\n}(), ud = function() {\n    function t() {\n        this.classNameMap = {};\n    }\n    return t.getMap = function() {\n        return null == t.instance && (t.instance = new t), t.instance;\n    }, t.register = function(e) {\n        t.getMap().classNameMap[e.className] = [\n            e,\n            e.fromConfig\n        ];\n    }, t;\n}();\nfunction cd(t) {\n    C(null != t.className, function() {\n        return \"Class being registered does not have the static className property defined.\";\n    }), C(\"string\" == typeof t.className, function() {\n        return \"className is required to be a string, but got type \" + typeof t.className;\n    }), C(t.className.length > 0, function() {\n        return \"Class being registered has an empty-string as its className, which is disallowed.\";\n    }), ud.register(t);\n}\nvar ld = Object.freeze({\n    Serializable: sd,\n    SerializationMap: ud,\n    registerClass: cd\n}), hd = .001, fd = .1;\nfunction dd() {\n    return 32 === Lt.backend.floatPrecision() ? hd : fd;\n}\nfunction pd(t, e, n) {\n    var r = !0;\n    if ((V(t) || V(e)) && (r = !1), V(t) && V(e) && (r = !0), r) {\n        var o = t.constructor.name, a = e.constructor.name;\n        if (o !== a) throw new Error(\"Arrays are of different type. Actual: \" + o + \". Expected: \" + a);\n    }\n    if (Array.isArray(t) && Array.isArray(e)) {\n        var i = pn(t), s = pn(e);\n        if (!S(i, s)) throw new Error(\"Arrays have different shapes. Actual: [\" + i + \"]. Expected: [\" + s + \"]\");\n    }\n    var u = V(t) ? t : I(t), c = V(e) ? e : I(e);\n    if (u.length !== c.length) throw new Error(\"Arrays have different lengths actual: \" + u.length + \" vs expected: \" + c.length + \".\\nActual:   \" + u + \".\\nExpected: \" + c + \".\");\n    for(var l = 0; l < c.length; ++l){\n        var h = u[l], f = c[l];\n        if (!n(h, f)) throw new Error(\"Arrays differ: actual[\" + l + \"] = \" + h + \", expected[\" + l + \"] = \" + f + \".\\nActual:   \" + u + \".\\nExpected: \" + c + \".\");\n    }\n}\nfunction vd(t, e, n) {\n    return !isFinite(t) && !isFinite(e) || !(isNaN(t) || isNaN(e) || Math.abs(t - e) > n);\n}\nvar md = Object.freeze({\n    TEST_EPSILON_FLOAT16: fd,\n    expectArraysClose: function(t, e, n) {\n        return null == n && (n = dd()), pd(t, e, function(t, e) {\n            return vd(t, e, n);\n        });\n    },\n    testEpsilon: dd,\n    expectPromiseToFail: function(t, e) {\n        t().then(function() {\n            return e.fail();\n        }, function() {\n            return e();\n        });\n    },\n    expectArraysEqual: function(t, e) {\n        var n = \"string\" == typeof e || \"number\" == typeof e || \"boolean\" == typeof e ? [\n            e\n        ] : e;\n        return H(t) || H(t[0]) || H(e) || H(e[0]) ? pd(t, n, function(t, e) {\n            return t == e;\n        }) : pd(t, e, function(t, e) {\n            return vd(t, e, 0);\n        });\n    },\n    expectNumbersClose: function(t, e, n) {\n        if (null == n && (n = dd()), !vd(t, e, n)) throw new Error(\"Numbers differ: actual === \" + t + \", expected === \" + e);\n    },\n    expectValuesInRange: function(t, e, n) {\n        for(var r = 0; r < t.length; r++)if (t[r] < e || t[r] > n) throw new Error(\"Value out of range:\" + t[r] + \" low: \" + e + \", high: \" + n);\n    },\n    expectArrayBuffersEqual: function(t, e) {\n        expect(new Float32Array(t)).toEqual(new Float32Array(e));\n    }\n}), gd = \"1.7.0\";\nvar yd = Object.freeze({\n    gpgpu_util: Mi,\n    webgl_util: Ge,\n    forceHalfFloat: function() {\n        i().set(\"WEBGL_FORCE_F16_TEXTURES\", !0);\n    },\n    MathBackendWebGL: Zs,\n    setWebGLContext: Kt,\n    GPGPUContext: Bi\n}), xd = function(t) {\n    function o() {\n        return null !== t && t.apply(this, arguments) || this;\n    }\n    return e(o, t), o.prototype.minimize = function(t, e, n) {\n        void 0 === e && (e = !1);\n        var r = this.computeGradients(t, n), o = r.value, a = r.grads;\n        if (null != n) {\n            var i = n.map(function(t) {\n                return {\n                    name: t.name,\n                    tensor: a[t.name]\n                };\n            });\n            this.applyGradients(i);\n        } else this.applyGradients(a);\n        return tn(a), e ? o : (o.dispose(), null);\n    }, Object.defineProperty(o.prototype, \"iterations\", {\n        get: function() {\n            return null == this.iterations_ && (this.iterations_ = 0), this.iterations_;\n        },\n        enumerable: !0,\n        configurable: !0\n    }), o.prototype.incrementIterations = function() {\n        this.iterations_ = this.iterations + 1;\n    }, o.prototype.computeGradients = function(t, e) {\n        return po(t, e);\n    }, o.prototype.dispose = function() {\n        null != this.iterations_ && tn(this.iterations_);\n    }, o.prototype.saveIterations = function() {\n        return n(this, void 0, void 0, function() {\n            return r(this, function(t) {\n                return null == this.iterations_ && (this.iterations_ = 0), [\n                    2,\n                    {\n                        name: \"iter\",\n                        tensor: On(this.iterations_, \"int32\")\n                    }\n                ];\n            });\n        });\n    }, o.prototype.getWeights = function() {\n        return n(this, void 0, void 0, function() {\n            return r(this, function(t) {\n                throw new Error(\"getWeights() is not implemented for this optimizer yet.\");\n            });\n        });\n    }, o.prototype.setWeights = function(t) {\n        return n(this, void 0, void 0, function() {\n            return r(this, function(t) {\n                throw new Error(\"setWeights() is not implemented for this optimizer class \" + this.getClassName());\n            });\n        });\n    }, o.prototype.extractIterations = function(t) {\n        return n(this, void 0, void 0, function() {\n            var e;\n            return r(this, function(n) {\n                switch(n.label){\n                    case 0:\n                        return e = this, [\n                            4,\n                            t[0].tensor.data()\n                        ];\n                    case 1:\n                        return e.iterations_ = n.sent()[0], [\n                            2,\n                            t.slice(1)\n                        ];\n                }\n            });\n        });\n    }, o;\n}(sd);\nObject.defineProperty(xd, Symbol.hasInstance, {\n    value: function(t) {\n        return null != t.minimize && null != t.computeGradients && null != t.applyGradients;\n    }\n});\nvar bd = function(t) {\n    function o(e, n, r) {\n        void 0 === r && (r = null);\n        var o = t.call(this) || this;\n        return o.learningRate = e, o.rho = n, o.epsilon = r, o.accumulatedGrads = [], o.accumulatedUpdates = [], null == r && (o.epsilon = Lt.backend.epsilon()), o;\n    }\n    return e(o, t), o.prototype.applyGradients = function(t) {\n        var e = this;\n        (Array.isArray(t) ? t.map(function(t) {\n            return t.name;\n        }) : Object.keys(t)).forEach(function(n, r) {\n            var o = Lt.registeredVariables[n];\n            null == e.accumulatedGrads[r] && (e.accumulatedGrads[r] = {\n                originalName: n + \"/accum_grad\",\n                variable: Ze(function() {\n                    return Xn(o).variable(!1);\n                })\n            }), null == e.accumulatedUpdates[r] && (e.accumulatedUpdates[r] = {\n                originalName: n + \"/accum_var\",\n                variable: Ze(function() {\n                    return Xn(o).variable(!1);\n                })\n            });\n            var a = Array.isArray(t) ? t[r].tensor : t[n];\n            if (null != a) {\n                var i = e.accumulatedGrads[r].variable, s = e.accumulatedUpdates[r].variable;\n                Ze(function() {\n                    var t = i.mul(e.rho).add(a.square().mul(1 - e.rho)), n = s.add(e.epsilon).sqrt().div(i.add(e.epsilon).sqrt()).mul(a), r = s.mul(e.rho).add(n.square().mul(1 - e.rho));\n                    i.assign(t), s.assign(r);\n                    var u = n.mul(-e.learningRate).add(o);\n                    o.assign(u);\n                });\n            }\n        }), this.incrementIterations();\n    }, o.prototype.dispose = function() {\n        null != this.accumulatedUpdates && (tn(this.accumulatedGrads.map(function(t) {\n            return t.variable;\n        })), tn(this.accumulatedUpdates.map(function(t) {\n            return t.variable;\n        })));\n    }, o.prototype.getWeights = function() {\n        return n(this, void 0, void 0, function() {\n            var t;\n            return r(this, function(e) {\n                switch(e.label){\n                    case 0:\n                        return t = this.accumulatedGrads.concat(this.accumulatedUpdates), [\n                            4,\n                            this.saveIterations()\n                        ];\n                    case 1:\n                        return [\n                            2,\n                            [\n                                e.sent()\n                            ].concat(t.map(function(t) {\n                                return {\n                                    name: t.originalName,\n                                    tensor: t.variable\n                                };\n                            }))\n                        ];\n                }\n            });\n        });\n    }, o.prototype.setWeights = function(t) {\n        return n(this, void 0, void 0, function() {\n            var e;\n            return r(this, function(n) {\n                switch(n.label){\n                    case 0:\n                        return [\n                            4,\n                            this.extractIterations(t)\n                        ];\n                    case 1:\n                        return t = n.sent(), e = t.length / 2, !1, this.accumulatedGrads = t.slice(0, e).map(function(t) {\n                            return {\n                                originalName: t.name,\n                                variable: t.tensor.variable(!1)\n                            };\n                        }), this.accumulatedUpdates = t.slice(e, 2 * e).map(function(t) {\n                            return {\n                                originalName: t.name,\n                                variable: t.tensor.variable(!1)\n                            };\n                        }), [\n                            2\n                        ];\n                }\n            });\n        });\n    }, o.prototype.getConfig = function() {\n        return {\n            learningRate: this.learningRate,\n            rho: this.rho,\n            epsilon: this.epsilon\n        };\n    }, o.fromConfig = function(t, e) {\n        return new t(e.learningRate, e.rho, e.epsilon);\n    }, o.className = \"Adadelta\", o;\n}(xd);\ncd(bd);\nvar wd = function(t) {\n    function o(e, n) {\n        void 0 === n && (n = .1);\n        var r = t.call(this) || this;\n        return r.learningRate = e, r.initialAccumulatorValue = n, r.accumulatedGrads = [], r;\n    }\n    return e(o, t), o.prototype.applyGradients = function(t) {\n        var e = this;\n        (Array.isArray(t) ? t.map(function(t) {\n            return t.name;\n        }) : Object.keys(t)).forEach(function(n, r) {\n            var o = Lt.registeredVariables[n];\n            if (null == e.accumulatedGrads[r]) {\n                e.accumulatedGrads[r] = {\n                    originalName: n + \"/accumulator\",\n                    variable: Ze(function() {\n                        return Hn(o.shape, e.initialAccumulatorValue).variable(!1);\n                    })\n                };\n            }\n            var a = Array.isArray(t) ? t[r].tensor : t[n];\n            if (null != a) {\n                var i = e.accumulatedGrads[r].variable;\n                Ze(function() {\n                    var t = i.add(a.square());\n                    i.assign(t);\n                    var n = a.div(t.add(Lt.backend.epsilon()).sqrt()).mul(-e.learningRate).add(o);\n                    o.assign(n);\n                });\n            }\n        }), this.incrementIterations();\n    }, o.prototype.dispose = function() {\n        null != this.accumulatedGrads && tn(this.accumulatedGrads.map(function(t) {\n            return t.variable;\n        }));\n    }, o.prototype.getWeights = function() {\n        return n(this, void 0, void 0, function() {\n            return r(this, function(t) {\n                switch(t.label){\n                    case 0:\n                        return [\n                            4,\n                            this.saveIterations()\n                        ];\n                    case 1:\n                        return [\n                            2,\n                            [\n                                t.sent()\n                            ].concat(this.accumulatedGrads.map(function(t) {\n                                return {\n                                    name: t.originalName,\n                                    tensor: t.variable\n                                };\n                            }))\n                        ];\n                }\n            });\n        });\n    }, o.prototype.setWeights = function(t) {\n        return n(this, void 0, void 0, function() {\n            return r(this, function(e) {\n                switch(e.label){\n                    case 0:\n                        return [\n                            4,\n                            this.extractIterations(t)\n                        ];\n                    case 1:\n                        return t = e.sent(), !1, this.accumulatedGrads = t.map(function(t) {\n                            return {\n                                originalName: t.name,\n                                variable: t.tensor.variable(!1)\n                            };\n                        }), [\n                            2\n                        ];\n                }\n            });\n        });\n    }, o.prototype.getConfig = function() {\n        return {\n            learningRate: this.learningRate,\n            initialAccumulatorValue: this.initialAccumulatorValue\n        };\n    }, o.fromConfig = function(t, e) {\n        return new t(e.learningRate, e.initialAccumulatorValue);\n    }, o.className = \"Adagrad\", o;\n}(xd);\ncd(wd);\nvar Cd = function(t) {\n    function o(e, n, r, o) {\n        void 0 === o && (o = null);\n        var a = t.call(this) || this;\n        return a.learningRate = e, a.beta1 = n, a.beta2 = r, a.epsilon = o, a.accumulatedFirstMoment = [], a.accumulatedSecondMoment = [], Ze(function() {\n            a.accBeta1 = On(n).variable(), a.accBeta2 = On(r).variable();\n        }), null == o && (a.epsilon = Lt.backend.epsilon()), a;\n    }\n    return e(o, t), o.prototype.applyGradients = function(t) {\n        var e = this, n = Array.isArray(t) ? t.map(function(t) {\n            return t.name;\n        }) : Object.keys(t);\n        Ze(function() {\n            var r = Cc(1, e.accBeta1), o = Cc(1, e.accBeta2);\n            n.forEach(function(n, a) {\n                var i = Lt.registeredVariables[n];\n                null == e.accumulatedFirstMoment[a] && (e.accumulatedFirstMoment[a] = {\n                    originalName: n + \"/m\",\n                    variable: Ze(function() {\n                        return Xn(i).variable(!1);\n                    })\n                }), null == e.accumulatedSecondMoment[a] && (e.accumulatedSecondMoment[a] = {\n                    originalName: n + \"/v\",\n                    variable: Ze(function() {\n                        return Xn(i).variable(!1);\n                    })\n                });\n                var s = Array.isArray(t) ? t[a].tensor : t[n];\n                if (null != s) {\n                    var u = e.accumulatedFirstMoment[a].variable, c = e.accumulatedSecondMoment[a].variable, l = u.mul(e.beta1).add(s.mul(1 - e.beta1)), h = c.mul(e.beta2).add(s.square().mul(1 - e.beta2)), f = l.div(r), d = h.div(o);\n                    u.assign(l), c.assign(h);\n                    var p = f.div(d.sqrt().add(e.epsilon)).mul(-e.learningRate).add(i);\n                    i.assign(p);\n                }\n            }), e.accBeta1.assign(e.accBeta1.mul(e.beta1)), e.accBeta2.assign(e.accBeta2.mul(e.beta2));\n        }), this.incrementIterations();\n    }, o.prototype.dispose = function() {\n        this.accBeta1.dispose(), this.accBeta2.dispose(), null != this.accumulatedFirstMoment && tn(this.accumulatedFirstMoment.map(function(t) {\n            return t.variable;\n        })), null != this.accumulatedSecondMoment && tn(this.accumulatedSecondMoment.map(function(t) {\n            return t.variable;\n        }));\n    }, o.prototype.getWeights = function() {\n        return n(this, void 0, void 0, function() {\n            var t;\n            return r(this, function(e) {\n                switch(e.label){\n                    case 0:\n                        return t = this.accumulatedFirstMoment.concat(this.accumulatedSecondMoment), [\n                            4,\n                            this.saveIterations()\n                        ];\n                    case 1:\n                        return [\n                            2,\n                            [\n                                e.sent()\n                            ].concat(t.map(function(t) {\n                                return {\n                                    name: t.originalName,\n                                    tensor: t.variable\n                                };\n                            }))\n                        ];\n                }\n            });\n        });\n    }, o.prototype.setWeights = function(t) {\n        return n(this, void 0, void 0, function() {\n            var e, n = this;\n            return r(this, function(r) {\n                switch(r.label){\n                    case 0:\n                        return [\n                            4,\n                            this.extractIterations(t)\n                        ];\n                    case 1:\n                        return t = r.sent(), Ze(function() {\n                            n.accBeta1.assign(xc(n.beta1, n.iterations_ + 1)), n.accBeta2.assign(xc(n.beta2, n.iterations_ + 1));\n                        }), e = t.length / 2, !1, this.accumulatedFirstMoment = t.slice(0, e).map(function(t) {\n                            return {\n                                originalName: t.name,\n                                variable: t.tensor.variable(!1)\n                            };\n                        }), this.accumulatedSecondMoment = t.slice(e, 2 * e).map(function(t) {\n                            return {\n                                originalName: t.name,\n                                variable: t.tensor.variable(!1)\n                            };\n                        }), [\n                            2\n                        ];\n                }\n            });\n        });\n    }, o.prototype.getConfig = function() {\n        return {\n            learningRate: this.learningRate,\n            beta1: this.beta1,\n            beta2: this.beta2,\n            epsilon: this.epsilon\n        };\n    }, o.fromConfig = function(t, e) {\n        return new t(e.learningRate, e.beta1, e.beta2, e.epsilon);\n    }, o.className = \"Adam\", o;\n}(xd);\ncd(Cd);\nvar Ed = function(t) {\n    function o(e, n, r, o, a) {\n        void 0 === o && (o = null), void 0 === a && (a = 0);\n        var i = t.call(this) || this;\n        return i.learningRate = e, i.beta1 = n, i.beta2 = r, i.epsilon = o, i.decay = a, i.accumulatedFirstMoment = [], i.accumulatedWeightedInfNorm = [], Ze(function() {\n            i.iteration = On(0).variable(), i.accBeta1 = On(n).variable();\n        }), null == o && (i.epsilon = Lt.backend.epsilon()), i;\n    }\n    return e(o, t), o.prototype.applyGradients = function(t) {\n        var e = this, n = Array.isArray(t) ? t.map(function(t) {\n            return t.name;\n        }) : Object.keys(t);\n        Ze(function() {\n            var r = Cc(1, e.accBeta1), o = sc(-e.learningRate, e.iteration.mul(e.decay).add(1));\n            n.forEach(function(n, a) {\n                var i = Lt.registeredVariables[n];\n                null == e.accumulatedFirstMoment[a] && (e.accumulatedFirstMoment[a] = {\n                    originalName: n + \"/m\",\n                    variable: Xn(i).variable(!1)\n                }), null == e.accumulatedWeightedInfNorm[a] && (e.accumulatedWeightedInfNorm[a] = {\n                    originalName: n + \"/v\",\n                    variable: Xn(i).variable(!1)\n                });\n                var s = Array.isArray(t) ? t[a].tensor : t[n];\n                if (null != s) {\n                    var u = e.accumulatedFirstMoment[a].variable, c = e.accumulatedWeightedInfNorm[a].variable, l = u.mul(e.beta1).add(s.mul(1 - e.beta1)), h = c.mul(e.beta2), f = s.abs(), d = h.maximum(f);\n                    u.assign(l), c.assign(d);\n                    var p = o.div(r).mul(l.div(d.add(e.epsilon))).add(i);\n                    i.assign(p);\n                }\n            }), e.iteration.assign(e.iteration.add(1)), e.accBeta1.assign(e.accBeta1.mul(e.beta1));\n        }), this.incrementIterations();\n    }, o.prototype.dispose = function() {\n        this.accBeta1.dispose(), this.iteration.dispose(), null != this.accumulatedFirstMoment && tn(this.accumulatedFirstMoment.map(function(t) {\n            return t.variable;\n        })), null != this.accumulatedWeightedInfNorm && tn(this.accumulatedWeightedInfNorm.map(function(t) {\n            return t.variable;\n        }));\n    }, o.prototype.getWeights = function() {\n        return n(this, void 0, void 0, function() {\n            return r(this, function(t) {\n                throw new Error(\"getWeights() is not implemented for Adamax yet.\");\n            });\n        });\n    }, o.prototype.setWeights = function(t) {\n        return n(this, void 0, void 0, function() {\n            return r(this, function(t) {\n                throw new Error(\"setWeights() is not implemented for Adamax yet.\");\n            });\n        });\n    }, o.prototype.getConfig = function() {\n        return {\n            learningRate: this.learningRate,\n            beta1: this.beta1,\n            beta2: this.beta2,\n            epsilon: this.epsilon,\n            decay: this.decay\n        };\n    }, o.fromConfig = function(t, e) {\n        return new t(e.learningRate, e.beta1, e.beta2, e.epsilon, e.decay);\n    }, o.className = \"Adamax\", o;\n}(xd);\ncd(Ed);\nvar Rd = function(t) {\n    function o(e) {\n        var n = t.call(this) || this;\n        return n.learningRate = e, n.setLearningRate(e), n;\n    }\n    return e(o, t), o.prototype.applyGradients = function(t) {\n        var e = this;\n        (Array.isArray(t) ? t.map(function(t) {\n            return t.name;\n        }) : Object.keys(t)).forEach(function(n, r) {\n            var o = Array.isArray(t) ? t[r].tensor : t[n];\n            if (null != o) {\n                var a = Lt.registeredVariables[n];\n                Ze(function() {\n                    var t = e.c.mul(o).add(a);\n                    a.assign(t);\n                });\n            }\n        }), this.incrementIterations();\n    }, o.prototype.setLearningRate = function(t) {\n        this.learningRate = t, null != this.c && this.c.dispose(), this.c = en(On(-t));\n    }, o.prototype.dispose = function() {\n        this.c.dispose();\n    }, o.prototype.getWeights = function() {\n        return n(this, void 0, void 0, function() {\n            return r(this, function(t) {\n                switch(t.label){\n                    case 0:\n                        return [\n                            4,\n                            this.saveIterations()\n                        ];\n                    case 1:\n                        return [\n                            2,\n                            [\n                                t.sent()\n                            ]\n                        ];\n                }\n            });\n        });\n    }, o.prototype.setWeights = function(t) {\n        return n(this, void 0, void 0, function() {\n            return r(this, function(e) {\n                switch(e.label){\n                    case 0:\n                        return [\n                            4,\n                            this.extractIterations(t)\n                        ];\n                    case 1:\n                        if (0 !== (t = e.sent()).length) throw new Error(\"SGD optimizer does not have settable weights.\");\n                        return [\n                            2\n                        ];\n                }\n            });\n        });\n    }, o.prototype.getConfig = function() {\n        return {\n            learningRate: this.learningRate\n        };\n    }, o.fromConfig = function(t, e) {\n        return new t(e.learningRate);\n    }, o.className = \"SGD\", o;\n}(xd);\ncd(Rd);\nvar Id = function(t) {\n    function o(e, n, r) {\n        void 0 === r && (r = !1);\n        var o = t.call(this, e) || this;\n        return o.learningRate = e, o.momentum = n, o.useNesterov = r, o.accumulations = [], o.m = On(o.momentum), o;\n    }\n    return e(o, t), o.prototype.applyGradients = function(t) {\n        var e = this;\n        (Array.isArray(t) ? t.map(function(t) {\n            return t.name;\n        }) : Object.keys(t)).forEach(function(n, r) {\n            var o = Lt.registeredVariables[n];\n            if (null == e.accumulations[r]) {\n                e.accumulations[r] = {\n                    originalName: n + \"/momentum\",\n                    variable: Ze(function() {\n                        return Xn(o).variable(!1);\n                    })\n                };\n            }\n            var a = e.accumulations[r].variable, i = Array.isArray(t) ? t[r].tensor : t[n];\n            null != i && Ze(function() {\n                var t, n = e.m.mul(a).add(i);\n                t = e.useNesterov ? e.c.mul(i.add(n.mul(e.m))).add(o) : e.c.mul(n).add(o), a.assign(n), o.assign(t);\n            });\n        }), this.incrementIterations();\n    }, o.prototype.dispose = function() {\n        this.m.dispose(), null != this.accumulations && tn(this.accumulations.map(function(t) {\n            return t.variable;\n        }));\n    }, o.prototype.setMomentum = function(t) {\n        this.momentum = t;\n    }, o.prototype.getWeights = function() {\n        return n(this, void 0, void 0, function() {\n            return r(this, function(t) {\n                switch(t.label){\n                    case 0:\n                        return [\n                            4,\n                            this.saveIterations()\n                        ];\n                    case 1:\n                        return [\n                            2,\n                            [\n                                t.sent()\n                            ].concat(this.accumulations.map(function(t) {\n                                return {\n                                    name: t.originalName,\n                                    tensor: t.variable\n                                };\n                            }))\n                        ];\n                }\n            });\n        });\n    }, o.prototype.setWeights = function(t) {\n        return n(this, void 0, void 0, function() {\n            return r(this, function(e) {\n                switch(e.label){\n                    case 0:\n                        return [\n                            4,\n                            this.extractIterations(t)\n                        ];\n                    case 1:\n                        return t = e.sent(), !1, this.accumulations = t.map(function(t) {\n                            return {\n                                originalName: t.name,\n                                variable: t.tensor.variable(!1)\n                            };\n                        }), [\n                            2\n                        ];\n                }\n            });\n        });\n    }, o.prototype.getConfig = function() {\n        return {\n            learningRate: this.learningRate,\n            momentum: this.momentum,\n            useNesterov: this.useNesterov\n        };\n    }, o.fromConfig = function(t, e) {\n        return new t(e.learningRate, e.momentum, e.useNesterov);\n    }, o.className = \"Momentum\", o;\n}(Rd);\ncd(Id);\nvar kd = function(t) {\n    function o(e, n, r, o, a) {\n        void 0 === n && (n = .9), void 0 === r && (r = 0), void 0 === o && (o = null), void 0 === a && (a = !1);\n        var i = t.call(this) || this;\n        if (i.learningRate = e, i.decay = n, i.momentum = r, i.epsilon = o, i.accumulatedMeanSquares = [], i.accumulatedMoments = [], i.accumulatedMeanGrads = [], i.centered = a, null == o && (i.epsilon = Lt.backend.epsilon()), null == e) throw new Error(\"learningRate for RMSPropOptimizer must be defined.\");\n        return i;\n    }\n    return e(o, t), o.prototype.applyGradients = function(t) {\n        var e = this;\n        (Array.isArray(t) ? t.map(function(t) {\n            return t.name;\n        }) : Object.keys(t)).forEach(function(n, r) {\n            var o = Lt.registeredVariables[n];\n            null == e.accumulatedMeanSquares[r] && (e.accumulatedMeanSquares[r] = {\n                originalName: n + \"/rms\",\n                variable: Ze(function() {\n                    return Xn(o).variable(!1);\n                })\n            }), null == e.accumulatedMoments[r] && (e.accumulatedMoments[r] = {\n                originalName: n + \"/momentum\",\n                variable: Ze(function() {\n                    return Xn(o).variable(!1);\n                })\n            }), null == e.accumulatedMeanGrads[r] && e.centered && (e.accumulatedMeanGrads[r] = {\n                originalName: n + \"/mg\",\n                variable: Ze(function() {\n                    return Xn(o).variable(!1);\n                })\n            });\n            var a = Array.isArray(t) ? t[r].tensor : t[n];\n            if (null != a) {\n                var i = e.accumulatedMeanSquares[r].variable, s = e.accumulatedMoments[r].variable;\n                Ze(function() {\n                    var t = i.mul(e.decay).add(a.square().mul(1 - e.decay));\n                    if (e.centered) {\n                        var n = e.accumulatedMeanGrads[r].variable, u = n.mul(e.decay).add(a.mul(1 - e.decay)), c = s.mul(e.momentum).add(a.mul(e.learningRate).div(t.sub(u.square().add(e.epsilon)).sqrt()));\n                        i.assign(t), n.assign(u), s.assign(c);\n                        var l = o.sub(c);\n                        o.assign(l);\n                    } else {\n                        var h = i.mul(e.decay).add(a.square().mul(1 - e.decay));\n                        c = s.mul(e.momentum).add(a.mul(e.learningRate).div(h.add(e.epsilon).sqrt()));\n                        i.assign(h), s.assign(c);\n                        l = o.sub(c);\n                        o.assign(l);\n                    }\n                });\n            }\n        }), this.incrementIterations();\n    }, o.prototype.dispose = function() {\n        null != this.accumulatedMeanSquares && tn(this.accumulatedMeanSquares.map(function(t) {\n            return t.variable;\n        })), null != this.accumulatedMeanGrads && this.centered && tn(this.accumulatedMeanGrads.map(function(t) {\n            return t.variable;\n        })), null != this.accumulatedMoments && tn(this.accumulatedMoments.map(function(t) {\n            return t.variable;\n        }));\n    }, o.prototype.getWeights = function() {\n        return n(this, void 0, void 0, function() {\n            var t;\n            return r(this, function(e) {\n                switch(e.label){\n                    case 0:\n                        return t = this.accumulatedMeanSquares.concat(this.accumulatedMoments), this.centered && t.push.apply(t, this.accumulatedMeanGrads), [\n                            4,\n                            this.saveIterations()\n                        ];\n                    case 1:\n                        return [\n                            2,\n                            [\n                                e.sent()\n                            ].concat(t.map(function(t) {\n                                return {\n                                    name: t.originalName,\n                                    tensor: t.variable\n                                };\n                            }))\n                        ];\n                }\n            });\n        });\n    }, o.prototype.setWeights = function(t) {\n        return n(this, void 0, void 0, function() {\n            var e;\n            return r(this, function(n) {\n                switch(n.label){\n                    case 0:\n                        return [\n                            4,\n                            this.extractIterations(t)\n                        ];\n                    case 1:\n                        return t = n.sent(), e = this.centered ? t.length / 3 : t.length / 2, !1, this.accumulatedMeanSquares = t.slice(0, e).map(function(t) {\n                            return {\n                                originalName: t.name,\n                                variable: t.tensor.variable(!1)\n                            };\n                        }), this.accumulatedMoments = t.slice(e, 2 * e).map(function(t) {\n                            return {\n                                originalName: t.name,\n                                variable: t.tensor.variable(!1)\n                            };\n                        }), this.centered && (this.accumulatedMeanGrads = t.slice(2 * e, 3 * e).map(function(t) {\n                            return {\n                                originalName: t.name,\n                                variable: t.tensor.variable(!1)\n                            };\n                        })), [\n                            2\n                        ];\n                }\n            });\n        });\n    }, o.prototype.getConfig = function() {\n        return {\n            learningRate: this.learningRate,\n            decay: this.decay,\n            momentum: this.momentum,\n            epsilon: this.epsilon,\n            centered: this.centered\n        };\n    }, o.fromConfig = function(t, e) {\n        return new t(e.learningRate, e.decay, e.momentum, e.epsilon, e.centered);\n    }, o.className = \"RMSProp\", o;\n}(xd);\ncd(kd);\nvar Sd = function() {\n    function t() {}\n    return t.sgd = function(t) {\n        return new Rd(t);\n    }, t.momentum = function(t, e, n) {\n        return void 0 === n && (n = !1), new Id(t, e, n);\n    }, t.rmsprop = function(t, e, n, r, o) {\n        return void 0 === e && (e = .9), void 0 === n && (n = 0), void 0 === r && (r = null), void 0 === o && (o = !1), new kd(t, e, n, r, o);\n    }, t.adam = function(t, e, n, r) {\n        return void 0 === t && (t = .001), void 0 === e && (e = .9), void 0 === n && (n = .999), void 0 === r && (r = null), new Cd(t, e, n, r);\n    }, t.adadelta = function(t, e, n) {\n        return void 0 === t && (t = .001), void 0 === e && (e = .95), void 0 === n && (n = null), new bd(t, e, n);\n    }, t.adamax = function(t, e, n, r, o) {\n        return void 0 === t && (t = .002), void 0 === e && (e = .9), void 0 === n && (n = .999), void 0 === r && (r = null), void 0 === o && (o = 0), new Ed(t, e, n, r, o);\n    }, t.adagrad = function(t, e) {\n        return void 0 === e && (e = .1), new wd(t, e);\n    }, t;\n}(), Ad = {\n    sgd: Sd.sgd,\n    momentum: Sd.momentum,\n    adadelta: Sd.adadelta,\n    adagrad: Sd.adagrad,\n    rmsprop: Sd.rmsprop,\n    adamax: Sd.adamax,\n    adam: Sd.adam\n}, Dd = \"undefined\" != typeof requestAnimationFrame ? requestAnimationFrame : \"undefined\" != typeof setImmediate ? setImmediate : function(t) {\n    return t();\n};\nfunction Td() {\n    return new Promise(function(t) {\n        return Dd(function() {\n            return t();\n        });\n    });\n}\nwt.prototype.squaredDifference = function(t) {\n    return nu(this, t);\n}, xt = Gh;\n //# sourceMappingURL=tf-core.esm.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHRlbnNvcmZsb3cvdGZqcy1jb3JlL2Rpc3QvdGYtY29yZS5lc20uanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTs7Ozs7Ozs7Ozs7Ozs7O0NBZUMsR0FDRCxJQUFJQSxJQUFFLFNBQVNDLENBQUMsRUFBQ0MsQ0FBQztJQUFFLE9BQU0sQ0FBQ0YsSUFBRUcsT0FBT0MsY0FBYyxJQUFFO1FBQUNDLFdBQVUsRUFBRTtJQUFBLGNBQVlDLFNBQU8sU0FBU04sQ0FBQyxFQUFDQyxDQUFDO1FBQUVELEVBQUVLLFNBQVMsR0FBQ0o7SUFBQyxLQUFHLFNBQVNELENBQUMsRUFBQ0MsQ0FBQztRQUFFLElBQUksSUFBSUMsS0FBS0QsRUFBRUEsRUFBRU0sY0FBYyxDQUFDTCxNQUFLRixDQUFBQSxDQUFDLENBQUNFLEVBQUUsR0FBQ0QsQ0FBQyxDQUFDQyxFQUFFO0lBQUMsR0FBR0QsR0FBRUM7QUFBRTtBQUFFLFNBQVNELEVBQUVBLENBQUMsRUFBQ0MsQ0FBQztJQUFFLFNBQVNNO1FBQUksSUFBSSxDQUFDQyxXQUFXLEdBQUNSO0lBQUM7SUFBQ0QsRUFBRUMsR0FBRUMsSUFBR0QsRUFBRVMsU0FBUyxHQUFDLFNBQU9SLElBQUVDLE9BQU9RLE1BQU0sQ0FBQ1QsS0FBSU0sQ0FBQUEsRUFBRUUsU0FBUyxHQUFDUixFQUFFUSxTQUFTLEVBQUMsSUFB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QUssTUFBSUMsS0FBSUEsQ0FBQUEsSUFBRSxJQUFHLEdBQUcsS0FBSyxNQUFJTSxLQUFJQSxDQUFBQSxJQUFFLElBQUcsR0FBRyxLQUFLLE1BQUlLLEtBQUlBLENBQUFBLElBQUUsSUFBRyxJQUFJMHpFLEdBQUd2MEUsR0FBRUMsR0FBRUMsR0FBRU0sR0FBRUs7SUFBRSxHQUFFYixFQUFFNjFFLE9BQU8sR0FBQyxTQUFTNzFFLENBQUMsRUFBQ0MsQ0FBQztRQUFFLE9BQU8sS0FBSyxNQUFJQSxLQUFJQSxDQUFBQSxJQUFFLEVBQUMsR0FBRyxJQUFJNnpFLEdBQUc5ekUsR0FBRUM7SUFBRSxHQUFFRDtBQUFDLEtBQUk4MUUsS0FBRztJQUFDTixLQUFJRCxHQUFHQyxHQUFHO0lBQUNWLFVBQVNTLEdBQUdULFFBQVE7SUFBQ2EsVUFBU0osR0FBR0ksUUFBUTtJQUFDRSxTQUFRTixHQUFHTSxPQUFPO0lBQUNKLFNBQVFGLEdBQUdFLE9BQU87SUFBQ0csUUFBT0wsR0FBR0ssTUFBTTtJQUFDRixNQUFLSCxHQUFHRyxJQUFJO0FBQUEsR0FBRUssS0FBRyxlQUFhLE9BQU9DLHdCQUFzQkEsd0JBQXNCLGVBQWEsT0FBT0MsZUFBYUEsZUFBYSxTQUFTajJFLENBQUM7SUFBRSxPQUFPQTtBQUFHO0FBQUUsU0FBU2syRTtJQUFLLE9BQU8sSUFBSXQxRSxRQUFTLFNBQVNaLENBQUM7UUFBRSxPQUFPKzFFLEdBQUk7WUFBVyxPQUFPLzFFO1FBQUc7SUFBRztBQUFHO0FBQUN1UCxHQUFHN08sU0FBUyxDQUFDNGdDLGlCQUFpQixHQUFDLFNBQVN0aEMsQ0FBQztJQUFFLE9BQU8waUQsR0FBRyxJQUFJLEVBQUMxaUQ7QUFBRSxHQUFFcVAsS0FBRzB1RDtBQUF5dEksQ0FDN24xaEIsdUNBQXVDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdmVyaWZhY2UvLi9ub2RlX21vZHVsZXMvQHRlbnNvcmZsb3cvdGZqcy1jb3JlL2Rpc3QvdGYtY29yZS5lc20uanM/NDBjMyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICovXG52YXIgdD1mdW5jdGlvbihlLG4pe3JldHVybih0PU9iamVjdC5zZXRQcm90b3R5cGVPZnx8e19fcHJvdG9fXzpbXX1pbnN0YW5jZW9mIEFycmF5JiZmdW5jdGlvbih0LGUpe3QuX19wcm90b19fPWV9fHxmdW5jdGlvbih0LGUpe2Zvcih2YXIgbiBpbiBlKWUuaGFzT3duUHJvcGVydHkobikmJih0W25dPWVbbl0pfSkoZSxuKX07ZnVuY3Rpb24gZShlLG4pe2Z1bmN0aW9uIHIoKXt0aGlzLmNvbnN0cnVjdG9yPWV9dChlLG4pLGUucHJvdG90eXBlPW51bGw9PT1uP09iamVjdC5jcmVhdGUobik6KHIucHJvdG90eXBlPW4ucHJvdG90eXBlLG5ldyByKX1mdW5jdGlvbiBuKHQsZSxuLHIpe3JldHVybiBuZXcobnx8KG49UHJvbWlzZSkpKChmdW5jdGlvbihvLGEpe2Z1bmN0aW9uIGkodCl7dHJ5e3Uoci5uZXh0KHQpKX1jYXRjaCh0KXthKHQpfX1mdW5jdGlvbiBzKHQpe3RyeXt1KHIudGhyb3codCkpfWNhdGNoKHQpe2EodCl9fWZ1bmN0aW9uIHUodCl7dC5kb25lP28odC52YWx1ZSk6bmV3IG4oKGZ1bmN0aW9uKGUpe2UodC52YWx1ZSl9KSkudGhlbihpLHMpfXUoKHI9ci5hcHBseSh0LGV8fFtdKSkubmV4dCgpKX0pKX1mdW5jdGlvbiByKHQsZSl7dmFyIG4scixvLGEsaT17bGFiZWw6MCxzZW50OmZ1bmN0aW9uKCl7aWYoMSZvWzBdKXRocm93IG9bMV07cmV0dXJuIG9bMV19LHRyeXM6W10sb3BzOltdfTtyZXR1cm4gYT17bmV4dDpzKDApLHRocm93OnMoMSkscmV0dXJuOnMoMil9LFwiZnVuY3Rpb25cIj09dHlwZW9mIFN5bWJvbCYmKGFbU3ltYm9sLml0ZXJhdG9yXT1mdW5jdGlvbigpe3JldHVybiB0aGlzfSksYTtmdW5jdGlvbiBzKGEpe3JldHVybiBmdW5jdGlvbihzKXtyZXR1cm4gZnVuY3Rpb24oYSl7aWYobil0aHJvdyBuZXcgVHlwZUVycm9yKFwiR2VuZXJhdG9yIGlzIGFscmVhZHkgZXhlY3V0aW5nLlwiKTtmb3IoO2k7KXRyeXtpZihuPTEsciYmKG89MiZhWzBdP3IucmV0dXJuOmFbMF0/ci50aHJvd3x8KChvPXIucmV0dXJuKSYmby5jYWxsKHIpLDApOnIubmV4dCkmJiEobz1vLmNhbGwocixhWzFdKSkuZG9uZSlyZXR1cm4gbztzd2l0Y2gocj0wLG8mJihhPVsyJmFbMF0sby52YWx1ZV0pLGFbMF0pe2Nhc2UgMDpjYXNlIDE6bz1hO2JyZWFrO2Nhc2UgNDpyZXR1cm4gaS5sYWJlbCsrLHt2YWx1ZTphWzFdLGRvbmU6ITF9O2Nhc2UgNTppLmxhYmVsKysscj1hWzFdLGE9WzBdO2NvbnRpbnVlO2Nhc2UgNzphPWkub3BzLnBvcCgpLGkudHJ5cy5wb3AoKTtjb250aW51ZTtkZWZhdWx0OmlmKCEobz0obz1pLnRyeXMpLmxlbmd0aD4wJiZvW28ubGVuZ3RoLTFdKSYmKDY9PT1hWzBdfHwyPT09YVswXSkpe2k9MDtjb250aW51ZX1pZigzPT09YVswXSYmKCFvfHxhWzFdPm9bMF0mJmFbMV08b1szXSkpe2kubGFiZWw9YVsxXTticmVha31pZig2PT09YVswXSYmaS5sYWJlbDxvWzFdKXtpLmxhYmVsPW9bMV0sbz1hO2JyZWFrfWlmKG8mJmkubGFiZWw8b1syXSl7aS5sYWJlbD1vWzJdLGkub3BzLnB1c2goYSk7YnJlYWt9b1syXSYmaS5vcHMucG9wKCksaS50cnlzLnBvcCgpO2NvbnRpbnVlfWE9ZS5jYWxsKHQsaSl9Y2F0Y2godCl7YT1bNix0XSxyPTB9ZmluYWxseXtuPW89MH1pZig1JmFbMF0pdGhyb3cgYVsxXTtyZXR1cm57dmFsdWU6YVswXT9hWzFdOnZvaWQgMCxkb25lOiEwfX0oW2Esc10pfX19dmFyIG89ZnVuY3Rpb24oKXtmdW5jdGlvbiB0KHQpe3RoaXMuZ2xvYmFsPXQsdGhpcy5mbGFncz17fSx0aGlzLmZsYWdSZWdpc3RyeT17fSx0aGlzLnVybEZsYWdzPXt9LHRoaXMucG9wdWxhdGVVUkxGbGFncygpfXJldHVybiB0LnByb3RvdHlwZS5zZXRQbGF0Zm9ybT1mdW5jdGlvbih0LGUpe251bGwhPXRoaXMucGxhdGZvcm0mJmNvbnNvbGUud2FybihcIlBsYXRmb3JtIFwiK3RoaXMucGxhdGZvcm1OYW1lK1wiIGhhcyBhbHJlYWR5IGJlZW4gc2V0LiBPdmVyd3JpdGluZyB0aGUgcGxhdGZvcm0gd2l0aCBcIitlK1wiLlwiKSx0aGlzLnBsYXRmb3JtTmFtZT10LHRoaXMucGxhdGZvcm09ZX0sdC5wcm90b3R5cGUucmVnaXN0ZXJGbGFnPWZ1bmN0aW9uKHQsZSxuKXtpZih0aGlzLmZsYWdSZWdpc3RyeVt0XT17ZXZhbHVhdGlvbkZuOmUsc2V0SG9vazpufSxudWxsIT10aGlzLnVybEZsYWdzW3RdKXt2YXIgcj10aGlzLnVybEZsYWdzW3RdO2NvbnNvbGUud2FybihcIlNldHRpbmcgZmVhdHVyZSBvdmVycmlkZSBmcm9tIFVSTCBcIit0K1wiOiBcIityK1wiLlwiKSx0aGlzLnNldCh0LHIpfX0sdC5wcm90b3R5cGUuZ2V0PWZ1bmN0aW9uKHQpe3JldHVybiB0IGluIHRoaXMuZmxhZ3M/dGhpcy5mbGFnc1t0XToodGhpcy5mbGFnc1t0XT10aGlzLmV2YWx1YXRlRmxhZyh0KSx0aGlzLmZsYWdzW3RdKX0sdC5wcm90b3R5cGUuZ2V0TnVtYmVyPWZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLmdldCh0KX0sdC5wcm90b3R5cGUuZ2V0Qm9vbD1mdW5jdGlvbih0KXtyZXR1cm4gdGhpcy5nZXQodCl9LHQucHJvdG90eXBlLmdldEZsYWdzPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZmxhZ3N9LE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LnByb3RvdHlwZSxcImZlYXR1cmVzXCIse2dldDpmdW5jdGlvbigpe3JldHVybiB0aGlzLmZsYWdzfSxlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMH0pLHQucHJvdG90eXBlLnNldD1mdW5jdGlvbih0LGUpe2lmKG51bGw9PXRoaXMuZmxhZ1JlZ2lzdHJ5W3RdKXRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBzZXQgZmxhZyBcIit0K1wiIGFzIGl0IGhhcyBub3QgYmVlbiByZWdpc3RlcmVkLlwiKTt0aGlzLmZsYWdzW3RdPWUsbnVsbCE9dGhpcy5mbGFnUmVnaXN0cnlbdF0uc2V0SG9vayYmdGhpcy5mbGFnUmVnaXN0cnlbdF0uc2V0SG9vayhlKX0sdC5wcm90b3R5cGUuZXZhbHVhdGVGbGFnPWZ1bmN0aW9uKHQpe2lmKG51bGw9PXRoaXMuZmxhZ1JlZ2lzdHJ5W3RdKXRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBldmFsdWF0ZSBmbGFnICdcIit0K1wiJzogbm8gZXZhbHVhdGlvbiBmdW5jdGlvbiBmb3VuZC5cIik7cmV0dXJuIHRoaXMuZmxhZ1JlZ2lzdHJ5W3RdLmV2YWx1YXRpb25GbigpfSx0LnByb3RvdHlwZS5zZXRGbGFncz1mdW5jdGlvbih0KXt0aGlzLmZsYWdzPU9iamVjdC5hc3NpZ24oe30sdCl9LHQucHJvdG90eXBlLnJlc2V0PWZ1bmN0aW9uKCl7dGhpcy5mbGFncz17fSx0aGlzLnVybEZsYWdzPXt9LHRoaXMucG9wdWxhdGVVUkxGbGFncygpfSx0LnByb3RvdHlwZS5wb3B1bGF0ZVVSTEZsYWdzPWZ1bmN0aW9uKCl7dmFyIHQ9dGhpcztpZih2b2lkIDAhPT10aGlzLmdsb2JhbCYmdm9pZCAwIT09dGhpcy5nbG9iYWwubG9jYXRpb24mJnZvaWQgMCE9PXRoaXMuZ2xvYmFsLmxvY2F0aW9uLnNlYXJjaCl7dmFyIGUsbixyPShlPXRoaXMuZ2xvYmFsLmxvY2F0aW9uLnNlYXJjaCxuPXt9LGUucmVwbGFjZSgvWz8mXShbXj0/Jl0rKSg/Oj0oW14mXSopKT8vZywoZnVuY3Rpb24odCl7Zm9yKHZhciBlPVtdLHI9MTtyPGFyZ3VtZW50cy5sZW5ndGg7cisrKWVbci0xXT1hcmd1bWVudHNbcl07cmV0dXJuIGEobixlWzBdLGVbMV0pLGUuam9pbihcIj1cIil9KSksbik7aWYoXCJ0ZmpzZmxhZ3NcImluIHIpci50ZmpzZmxhZ3Muc3BsaXQoXCIsXCIpLmZvckVhY2goKGZ1bmN0aW9uKGUpe3ZhciBuPWUuc3BsaXQoXCI6XCIpLHI9blswXSxvPW5bMV07dC51cmxGbGFnc1tyXT1mdW5jdGlvbih0LGUpe2lmKFwidHJ1ZVwiPT09KGU9ZS50b0xvd2VyQ2FzZSgpKXx8XCJmYWxzZVwiPT09ZSlyZXR1cm5cInRydWVcIj09PWU7aWYoXCJcIisgK2U9PT1lKXJldHVybitlO3Rocm93IG5ldyBFcnJvcihcIkNvdWxkIG5vdCBwYXJzZSB2YWx1ZSBmbGFnIHZhbHVlIFwiK2UrXCIgZm9yIGZsYWcgXCIrdCtcIi5cIil9KHIsbyl9KSl9fSx0fSgpO2Z1bmN0aW9uIGEodCxlLG4pe3RbZGVjb2RlVVJJQ29tcG9uZW50KGUpXT1kZWNvZGVVUklDb21wb25lbnQobnx8XCJcIil9ZnVuY3Rpb24gaSgpe3JldHVybiBzfXZhciBzPW51bGw7dmFyIHU9bmV3IE1hcCxjPW5ldyBNYXA7ZnVuY3Rpb24gbCh0LGUpe3ZhciBuPWcodCxlKTtyZXR1cm4gdS5nZXQobil9ZnVuY3Rpb24gaCh0KXtyZXR1cm4gYy5nZXQodCl9ZnVuY3Rpb24gZih0KXtmb3IodmFyIGU9dS5lbnRyaWVzKCksbj1bXTs7KXt2YXIgcj1lLm5leHQoKSxvPXIuZG9uZSxhPXIudmFsdWU7aWYobylicmVhazt2YXIgaT1hWzBdLHM9YVsxXTtpLnNwbGl0KFwiX1wiKVswXT09PXQmJm4ucHVzaChzKX1yZXR1cm4gbn1mdW5jdGlvbiBkKHQpe3ZhciBlPXQua2VybmVsTmFtZSxuPXQuYmFja2VuZE5hbWUscj1nKGUsbik7aWYodS5oYXMocikpdGhyb3cgbmV3IEVycm9yKFwiVGhlIGtlcm5lbCAnXCIrZStcIicgZm9yIGJhY2tlbmQgJ1wiK24rXCInIGlzIGFscmVhZHkgcmVnaXN0ZXJlZFwiKTt1LnNldChyLHQpfWZ1bmN0aW9uIHAodCl7dmFyIGU9dC5rZXJuZWxOYW1lO2MuaGFzKGUpJiZjb25zb2xlLndhcm4oXCJPdmVycmlkaW5nIHRoZSBncmFkaWVudCBmb3IgJ1wiK2UrXCInXCIpLGMuc2V0KGUsdCl9ZnVuY3Rpb24gdih0LGUpe3ZhciBuPWcodCxlKTtpZighdS5oYXMobikpdGhyb3cgbmV3IEVycm9yKFwiVGhlIGtlcm5lbCAnXCIrdCtcIicgZm9yIGJhY2tlbmQgJ1wiK2UrXCInIGlzIG5vdCByZWdpc3RlcmVkXCIpO3UuZGVsZXRlKG4pfWZ1bmN0aW9uIG0odCl7aWYoIWMuaGFzKHQpKXRocm93IG5ldyBFcnJvcihcIlRoZSBncmFkaWVudCAnXCIrdCtcIicgZm9yIGJhY2tlbmQgaXMgbm90IHJlZ2lzdGVyZWRcIik7Yy5kZWxldGUodCl9ZnVuY3Rpb24gZyh0LGUpe3JldHVybiBlK1wiX1wiK3R9ZnVuY3Rpb24geSh0KXtmb3IodmFyIGU9dC5sZW5ndGgsbj0wLHI9MDtlPjA7KXI9TWF0aC5yYW5kb20oKSplfDAsbj10Wy0tZV0sdFtlXT10W3JdLHRbcl09bn1mdW5jdGlvbiB4KHQsZSxuKXtyZXR1cm4gTWF0aC5tYXgodCxNYXRoLm1pbihlLG4pKX1mdW5jdGlvbiBiKHQpe3JldHVybiB0JTI9PTA/dDp0KzF9ZnVuY3Rpb24gdyh0KXtmb3IodmFyIGU9MCxuPTA7bjx0Lmxlbmd0aDtuKyspZSs9dFtuXTtyZXR1cm4gZX1mdW5jdGlvbiBDKHQsZSl7aWYoIXQpdGhyb3cgbmV3IEVycm9yKFwic3RyaW5nXCI9PXR5cGVvZiBlP2U6ZSgpKX1mdW5jdGlvbiBFKHQsZSxuKXt2b2lkIDA9PT1uJiYobj1cIlwiKSxDKFModCxlKSwoZnVuY3Rpb24oKXtyZXR1cm4gbitcIiBTaGFwZXMgXCIrdCtcIiBhbmQgXCIrZStcIiBtdXN0IG1hdGNoXCJ9KSl9ZnVuY3Rpb24gUih0KXtDKG51bGwhPXQsKGZ1bmN0aW9uKCl7cmV0dXJuXCJUaGUgaW5wdXQgdG8gdGhlIHRlbnNvciBjb25zdHJ1Y3RvciBtdXN0IGJlIGEgbm9uLW51bGwgdmFsdWUuXCJ9KSl9ZnVuY3Rpb24gSSh0LGUsbil7aWYodm9pZCAwPT09ZSYmKGU9W10pLHZvaWQgMD09PW4mJihuPSExKSxudWxsPT1lJiYoZT1bXSksQXJyYXkuaXNBcnJheSh0KXx8Vih0KSYmIW4pZm9yKHZhciByPTA7cjx0Lmxlbmd0aDsrK3IpSSh0W3JdLGUsbik7ZWxzZSBlLnB1c2godCk7cmV0dXJuIGV9ZnVuY3Rpb24gayh0KXtpZigwPT09dC5sZW5ndGgpcmV0dXJuIDE7Zm9yKHZhciBlPXRbMF0sbj0xO248dC5sZW5ndGg7bisrKWUqPXRbbl07cmV0dXJuIGV9ZnVuY3Rpb24gUyh0LGUpe2lmKHQ9PT1lKXJldHVybiEwO2lmKG51bGw9PXR8fG51bGw9PWUpcmV0dXJuITE7aWYodC5sZW5ndGghPT1lLmxlbmd0aClyZXR1cm4hMTtmb3IodmFyIG49MDtuPHQubGVuZ3RoO24rKylpZih0W25dIT09ZVtuXSlyZXR1cm4hMTtyZXR1cm4hMH1mdW5jdGlvbiBBKHQpe3JldHVybiB0JTE9PTB9ZnVuY3Rpb24gRCh0KXtpZihudWxsIT1NYXRoLnRhbmgpcmV0dXJuIE1hdGgudGFuaCh0KTtpZih0PT09MS8wKXJldHVybiAxO2lmKHQ9PT0tMS8wKXJldHVybi0xO3ZhciBlPU1hdGguZXhwKDIqdCk7cmV0dXJuKGUtMSkvKGUrMSl9ZnVuY3Rpb24gVCh0KXt2YXIgZT1NYXRoLmNlaWwoTWF0aC5zcXJ0KHQpKTtyZXR1cm5bZSxNYXRoLmNlaWwodC9lKV19ZnVuY3Rpb24gTih0LGUpe3JldHVybiBlPD10Lmxlbmd0aD90OnQrXCIgXCIucmVwZWF0KGUtdC5sZW5ndGgpfWZ1bmN0aW9uIEYodCxlLG4pe3JldHVybiB2b2lkIDA9PT1lJiYoZT1mdW5jdGlvbih0KXtyZXR1cm4gMH0pLG5ldyBQcm9taXNlKChmdW5jdGlvbihyLG8pe3ZhciBhPTAsaT1mdW5jdGlvbigpe2lmKHQoKSlyKCk7ZWxzZXthKys7dmFyIHM9ZShhKTtudWxsIT1uJiZhPj1uP28oKTpzZXRUaW1lb3V0KGkscyl9fTtpKCl9KSl9ZnVuY3Rpb24gXyh0LGUpe2Zvcih2YXIgbj0xLHI9LTEsbz0wO288dC5sZW5ndGg7KytvKWlmKHRbb10+PTApbio9dFtvXTtlbHNlIGlmKC0xPT09dFtvXSl7aWYoLTEhPT1yKXRocm93IEVycm9yKFwiU2hhcGVzIGNhbiBvbmx5IGhhdmUgMSBpbXBsaWNpdCBzaXplLiBGb3VuZCAtMSBhdCBkaW0gXCIrcitcIiBhbmQgZGltIFwiK28pO3I9b31lbHNlIGlmKHRbb108MCl0aHJvdyBFcnJvcihcIlNoYXBlcyBjYW4gbm90IGJlIDwgMC4gRm91bmQgXCIrdFtvXStcIiBhdCBkaW0gXCIrbyk7aWYoLTE9PT1yKXtpZihlPjAmJmUhPT1uKXRocm93IEVycm9yKFwiU2l6ZShcIitlK1wiKSBtdXN0IG1hdGNoIHRoZSBwcm9kdWN0IG9mIHNoYXBlIFwiK3QpO3JldHVybiB0fWlmKDA9PT1uKXRocm93IEVycm9yKFwiQ2Fubm90IGluZmVyIHRoZSBtaXNzaW5nIHNpemUgaW4gW1wiK3QrXCJdIHdoZW4gdGhlcmUgYXJlIDAgZWxlbWVudHNcIik7aWYoZSVuIT0wKXRocm93IEVycm9yKFwiVGhlIGltcGxpY2l0IHNoYXBlIGNhbid0IGJlIGEgZnJhY3Rpb25hbCBudW1iZXIuIEdvdCBcIitlK1wiIC8gXCIrbik7dmFyIGE9dC5zbGljZSgpO3JldHVybiBhW3JdPWUvbixhfWZ1bmN0aW9uIE8odCxlKXt2YXIgbj1lLmxlbmd0aDtyZXR1cm4gQygodD1udWxsPT10P2UubWFwKChmdW5jdGlvbih0LGUpe3JldHVybiBlfSkpOltdLmNvbmNhdCh0KSkuZXZlcnkoKGZ1bmN0aW9uKHQpe3JldHVybiB0Pj0tbiYmdDxufSkpLChmdW5jdGlvbigpe3JldHVyblwiQWxsIHZhbHVlcyBpbiBheGlzIHBhcmFtIG11c3QgYmUgaW4gcmFuZ2UgWy1cIituK1wiLCBcIituK1wiKSBidXQgZ290IGF4aXMgXCIrdH0pKSxDKHQuZXZlcnkoKGZ1bmN0aW9uKHQpe3JldHVybiBBKHQpfSkpLChmdW5jdGlvbigpe3JldHVyblwiQWxsIHZhbHVlcyBpbiBheGlzIHBhcmFtIG11c3QgYmUgaW50ZWdlcnMgYnV0IGdvdCBheGlzIFwiK3R9KSksdC5tYXAoKGZ1bmN0aW9uKHQpe3JldHVybiB0PDA/bit0OnR9KSl9ZnVuY3Rpb24gTSh0LGUpe2Zvcih2YXIgbj1bXSxyPVtdLG89bnVsbCE9ZSYmQXJyYXkuaXNBcnJheShlKSYmMD09PWUubGVuZ3RoLGE9bnVsbD09ZXx8bz9udWxsOk8oZSx0KS5zb3J0KCksaT0wLHM9MDtzPHQubGVuZ3RoOysrcyl7aWYobnVsbCE9YSl7aWYoYVtpXT09PXMmJjEhPT10W3NdKXRocm93IG5ldyBFcnJvcihcIkNhbid0IHNxdWVlemUgYXhpcyBcIitzK1wiIHNpbmNlIGl0cyBkaW0gJ1wiK3Rbc10rXCInIGlzIG5vdCAxXCIpOyhudWxsPT1hW2ldfHxhW2ldPnMpJiYxPT09dFtzXSYmKG4ucHVzaCh0W3NdKSxyLnB1c2gocykpLGFbaV08PXMmJmkrK30xIT09dFtzXSYmKG4ucHVzaCh0W3NdKSxyLnB1c2gocykpfXJldHVybntuZXdTaGFwZTpuLGtlcHREaW1zOnJ9fWZ1bmN0aW9uIEIodCxlKXt2YXIgbj1udWxsO2lmKG51bGw9PXR8fFwiZmxvYXQzMlwiPT09dCluPW5ldyBGbG9hdDMyQXJyYXkoZSk7ZWxzZSBpZihcImludDMyXCI9PT10KW49bmV3IEludDMyQXJyYXkoZSk7ZWxzZXtpZihcImJvb2xcIiE9PXQpdGhyb3cgbmV3IEVycm9yKFwiVW5rbm93biBkYXRhIHR5cGUgXCIrdCk7bj1uZXcgVWludDhBcnJheShlKX1yZXR1cm4gbn1mdW5jdGlvbiBQKHQsZSl7dmFyIG49bnVsbDtpZihudWxsPT10fHxcImZsb2F0MzJcIj09PXQpbj1uZXcgRmxvYXQzMkFycmF5KGUpO2Vsc2UgaWYoXCJpbnQzMlwiPT09dCluPW5ldyBJbnQzMkFycmF5KGUpO2Vsc2UgaWYoXCJib29sXCI9PT10KW49bmV3IFVpbnQ4QXJyYXkoZSk7ZWxzZXtpZihcInN0cmluZ1wiIT09dCl0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIGRhdGEgdHlwZSBcIit0KTtuPW5ldyBBcnJheShlKX1yZXR1cm4gbn1mdW5jdGlvbiBMKHQsZSl7Zm9yKHZhciBuPTA7bjx0Lmxlbmd0aDtuKyspe3ZhciByPXRbbl07aWYoaXNOYU4ocil8fCFpc0Zpbml0ZShyKSl0aHJvdyBFcnJvcihcIkEgdGVuc29yIG9mIHR5cGUgXCIrZStcIiBiZWluZyB1cGxvYWRlZCBjb250YWlucyBcIityK1wiLlwiKX19ZnVuY3Rpb24gVyh0KXtyZXR1cm5cImJvb2xcIj09PXR8fFwiY29tcGxleDY0XCI9PT10fHxcImZsb2F0MzJcIj09PXR8fFwiaW50MzJcIj09PXR8fFwic3RyaW5nXCI9PT10fWZ1bmN0aW9uIFUodCxlKXtyZXR1cm5cImNvbXBsZXg2NFwiIT09ZSYmKChcImZsb2F0MzJcIiE9PWV8fFwiY29tcGxleDY0XCI9PT10KSYmKChcImludDMyXCIhPT1lfHxcImZsb2F0MzJcIj09PXR8fFwiY29tcGxleDY0XCI9PT10KSYmKFwiYm9vbFwiIT09ZXx8XCJib29sXCIhPT10KSkpfWZ1bmN0aW9uIFYodCl7cmV0dXJuIHQgaW5zdGFuY2VvZiBGbG9hdDMyQXJyYXl8fHQgaW5zdGFuY2VvZiBJbnQzMkFycmF5fHx0IGluc3RhbmNlb2YgVWludDhBcnJheX1mdW5jdGlvbiB6KHQpe2lmKFwiZmxvYXQzMlwiPT09dHx8XCJpbnQzMlwiPT09dClyZXR1cm4gNDtpZihcImNvbXBsZXg2NFwiPT09dClyZXR1cm4gODtpZihcImJvb2xcIj09PXQpcmV0dXJuIDE7dGhyb3cgbmV3IEVycm9yKFwiVW5rbm93biBkdHlwZSBcIit0KX1mdW5jdGlvbiBHKHQpe2lmKG51bGw9PXQpcmV0dXJuIDA7dmFyIGU9MDtyZXR1cm4gdC5mb3JFYWNoKChmdW5jdGlvbih0KXtyZXR1cm4gZSs9dC5sZW5ndGh9KSksZX1mdW5jdGlvbiBIKHQpe3JldHVyblwic3RyaW5nXCI9PXR5cGVvZiB0fHx0IGluc3RhbmNlb2YgU3RyaW5nfWZ1bmN0aW9uIHEodCl7cmV0dXJuXCJib29sZWFuXCI9PXR5cGVvZiB0fWZ1bmN0aW9uIEsodCl7cmV0dXJuXCJudW1iZXJcIj09dHlwZW9mIHR9ZnVuY3Rpb24gaih0KXtyZXR1cm4gQXJyYXkuaXNBcnJheSh0KT9qKHRbMF0pOnQgaW5zdGFuY2VvZiBGbG9hdDMyQXJyYXk/XCJmbG9hdDMyXCI6dCBpbnN0YW5jZW9mIEludDMyQXJyYXl8fHQgaW5zdGFuY2VvZiBVaW50OEFycmF5P1wiaW50MzJcIjpLKHQpP1wiZmxvYXQzMlwiOkgodCk/XCJzdHJpbmdcIjpxKHQpP1wiYm9vbFwiOlwiZmxvYXQzMlwifWZ1bmN0aW9uIFgodCl7cmV0dXJuISEodCYmdC5jb25zdHJ1Y3RvciYmdC5jYWxsJiZ0LmFwcGx5KX1mdW5jdGlvbiBZKHQsZSl7Zm9yKHZhciBuPWU7bjx0OysrbilpZih0JW49PTApcmV0dXJuIG47cmV0dXJuIHR9ZnVuY3Rpb24gJCh0KXt2YXIgZT10Lmxlbmd0aDtpZihlPDIpcmV0dXJuW107dmFyIG49bmV3IEFycmF5KGUtMSk7bltlLTJdPXRbZS0xXTtmb3IodmFyIHI9ZS0zO3I+PTA7LS1yKW5bcl09bltyKzFdKnRbcisxXTtyZXR1cm4gbn1mdW5jdGlvbiBRKHQsZSxuKXtpZihcInN0cmluZ1wiPT09ZSl0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgY29udmVydCBhIHN0cmluZ1tdIHRvIGEgVHlwZWRBcnJheVwiKTtpZihBcnJheS5pc0FycmF5KHQpJiYodD1JKHQpKSxuJiZMKHQsZSksZnVuY3Rpb24odCxlKXtyZXR1cm4gdCBpbnN0YW5jZW9mIEZsb2F0MzJBcnJheSYmXCJmbG9hdDMyXCI9PT1lfHx0IGluc3RhbmNlb2YgSW50MzJBcnJheSYmXCJpbnQzMlwiPT09ZXx8dCBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkmJlwiYm9vbFwiPT09ZX0odCxlKSlyZXR1cm4gdDtpZihudWxsPT1lfHxcImZsb2F0MzJcIj09PWV8fFwiY29tcGxleDY0XCI9PT1lKXJldHVybiBuZXcgRmxvYXQzMkFycmF5KHQpO2lmKFwiaW50MzJcIj09PWUpcmV0dXJuIG5ldyBJbnQzMkFycmF5KHQpO2lmKFwiYm9vbFwiPT09ZSl7Zm9yKHZhciByPW5ldyBVaW50OEFycmF5KHQubGVuZ3RoKSxvPTA7bzxyLmxlbmd0aDsrK28pMCE9PU1hdGgucm91bmQodFtvXSkmJihyW29dPTEpO3JldHVybiByfXRocm93IG5ldyBFcnJvcihcIlVua25vd24gZGF0YSB0eXBlIFwiK2UpfWZ1bmN0aW9uIEoodCxlKXtpZigwPT09dC5sZW5ndGgpcmV0dXJuIGVbMF07dmFyIG49dC5yZWR1Y2UoKGZ1bmN0aW9uKHQsZSl7cmV0dXJuIHQqZX0pKTtpZigwPT09bilyZXR1cm5bXTtpZihuIT09ZS5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwiW1wiK3QrXCJdIGRvZXMgbm90IG1hdGNoIHRoZSBpbnB1dCBzaXplLlwiKTtyZXR1cm4gZnVuY3Rpb24gdChlLG4scil7dmFyIG89bmV3IEFycmF5O2lmKDE9PT1uLmxlbmd0aClmb3IodmFyIGE9blswXSxpPTA7aTxhO2krKylvW2ldPXJbZStpXTtlbHNle2E9blswXTt2YXIgcz1uLnNsaWNlKDEpLHU9cy5yZWR1Y2UoKGZ1bmN0aW9uKHQsZSl7cmV0dXJuIHQqZX0pKTtmb3IoaT0wO2k8YTtpKyspb1tpXT10KGUraSp1LHMscil9cmV0dXJuIG99KDAsdCxlKX1mdW5jdGlvbiBaKHQsZSl7Zm9yKHZhciBuPXR0KHQsZSkscj0wO3I8bi5sZW5ndGg7cisrKW5bcl09MTtyZXR1cm4gbn1mdW5jdGlvbiB0dCh0LGUpe2lmKG51bGw9PWV8fFwiZmxvYXQzMlwiPT09ZXx8XCJjb21wbGV4NjRcIj09PWUpcmV0dXJuIG5ldyBGbG9hdDMyQXJyYXkodCk7aWYoXCJpbnQzMlwiPT09ZSlyZXR1cm4gbmV3IEludDMyQXJyYXkodCk7aWYoXCJib29sXCI9PT1lKXJldHVybiBuZXcgVWludDhBcnJheSh0KTt0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIGRhdGEgdHlwZSBcIitlKX1mdW5jdGlvbiBldCgpe3JldHVybiBpKCkucGxhdGZvcm0ubm93KCl9ZnVuY3Rpb24gbnQodCl7dC5mb3JFYWNoKChmdW5jdGlvbihlKXtDKE51bWJlci5pc0ludGVnZXIoZSkmJmU+PTAsKGZ1bmN0aW9uKCl7cmV0dXJuXCJUZW5zb3IgbXVzdCBoYXZlIGEgc2hhcGUgY29tcHJpc2VkIG9mIHBvc2l0aXZlIGludGVnZXJzIGJ1dCBnb3Qgc2hhcGUgW1wiK3QrXCJdLlwifSkpfSkpfWZ1bmN0aW9uIHJ0KHQsZSl7cmV0dXJuIHZvaWQgMD09PWUmJihlPVwidXRmLThcIiksZT1lfHxcInV0Zi04XCIsaSgpLnBsYXRmb3JtLmVuY29kZSh0LGUpfWZ1bmN0aW9uIG90KHQsZSl7cmV0dXJuIHZvaWQgMD09PWUmJihlPVwidXRmLThcIiksZT1lfHxcInV0Zi04XCIsaSgpLnBsYXRmb3JtLmRlY29kZSh0LGUpfWZ1bmN0aW9uIGF0KHQsZSxuKXtpZigwPT09ZSlyZXR1cm4gMDtpZigxPT09ZSlyZXR1cm4gdFswXTtmb3IodmFyIHI9dFt0Lmxlbmd0aC0xXSxvPTA7bzx0Lmxlbmd0aC0xOysrbylyKz1uW29dKnRbb107cmV0dXJuIHJ9ZnVuY3Rpb24gaXQodCxlLG4pe2lmKDA9PT1lKXJldHVybltdO2lmKDE9PT1lKXJldHVyblt0XTtmb3IodmFyIHI9bmV3IEFycmF5KGUpLG89MDtvPHIubGVuZ3RoLTE7KytvKXJbb109TWF0aC5mbG9vcih0L25bb10pLHQtPXJbb10qbltvXTtyZXR1cm4gcltyLmxlbmd0aC0xXT10LHJ9dmFyIHN0PU9iamVjdC5mcmVlemUoe3NodWZmbGU6eSxjbGFtcDp4LG5lYXJlc3RMYXJnZXJFdmVuOmIsc3VtOncscmFuZFVuaWZvcm06ZnVuY3Rpb24odCxlKXt2YXIgbj1NYXRoLnJhbmRvbSgpO3JldHVybiBlKm4rKDEtbikqdH0sZGlzdFNxdWFyZWQ6ZnVuY3Rpb24odCxlKXtmb3IodmFyIG49MCxyPTA7cjx0Lmxlbmd0aDtyKyspe3ZhciBvPU51bWJlcih0W3JdKS1OdW1iZXIoZVtyXSk7bis9bypvfXJldHVybiBufSxhc3NlcnQ6Qyxhc3NlcnRTaGFwZXNNYXRjaDpFLGFzc2VydE5vbk51bGw6UixmbGF0dGVuOkksc2l6ZUZyb21TaGFwZTprLGlzU2NhbGFyU2hhcGU6ZnVuY3Rpb24odCl7cmV0dXJuIDA9PT10Lmxlbmd0aH0sYXJyYXlzRXF1YWw6Uyxpc0ludDpBLHRhbmg6RCxzaXplVG9TcXVhcmlzaFNoYXBlOlQsY3JlYXRlU2h1ZmZsZWRJbmRpY2VzOmZ1bmN0aW9uKHQpe2Zvcih2YXIgZT1uZXcgVWludDMyQXJyYXkodCksbj0wO248dDsrK24pZVtuXT1uO3JldHVybiB5KGUpLGV9LHJpZ2h0UGFkOk4scmVwZWF0ZWRUcnk6RixpbmZlckZyb21JbXBsaWNpdFNoYXBlOl8scGFyc2VBeGlzUGFyYW06TyxzcXVlZXplU2hhcGU6TSxnZXRUeXBlZEFycmF5RnJvbURUeXBlOkIsZ2V0QXJyYXlGcm9tRFR5cGU6UCxjaGVja0NvbnZlcnNpb25Gb3JFcnJvcnM6TCxpc1ZhbGlkRHR5cGU6VyxoYXNFbmNvZGluZ0xvc3M6VSxpc1R5cGVkQXJyYXk6VixieXRlc1BlckVsZW1lbnQ6eixieXRlc0Zyb21TdHJpbmdBcnJheTpHLGlzU3RyaW5nOkgsaXNCb29sZWFuOnEsaXNOdW1iZXI6SyxpbmZlckR0eXBlOmosaXNGdW5jdGlvbjpYLG5lYXJlc3REaXZpc29yOlksY29tcHV0ZVN0cmlkZXM6JCx0b1R5cGVkQXJyYXk6USx0b05lc3RlZEFycmF5OkosbWFrZU9uZXNUeXBlZEFycmF5OlosbWFrZVplcm9zVHlwZWRBcnJheTp0dCxub3c6ZXQsYXNzZXJ0Tm9uTmVnYXRpdmVJbnRlZ2VyRGltZW5zaW9uczpudCxmZXRjaDpmdW5jdGlvbih0LGUpe3JldHVybiBpKCkucGxhdGZvcm0uZmV0Y2godCxlKX0sZW5jb2RlU3RyaW5nOnJ0LGRlY29kZVN0cmluZzpvdCxsb2NUb0luZGV4OmF0LGluZGV4VG9Mb2M6aXR9KSx1dD1mdW5jdGlvbigpe2Z1bmN0aW9uIHQodCxlKXt0aGlzLmJhY2tlbmRUaW1lcj10LHRoaXMubG9nZ2VyPWUsbnVsbD09ZSYmKHRoaXMubG9nZ2VyPW5ldyBjdCl9cmV0dXJuIHQucHJvdG90eXBlLnByb2ZpbGVLZXJuZWw9ZnVuY3Rpb24odCxlLG4pe3ZhciByLG89dGhpcyxhPXRoaXMuYmFja2VuZFRpbWVyLnRpbWUoKGZ1bmN0aW9uKCl7cj1uKCl9KSk7cmV0dXJuIHIuZm9yRWFjaCgoZnVuY3Rpb24obil7bi5kYXRhKCkudGhlbigoZnVuY3Rpb24ocil7IWZ1bmN0aW9uKHQsZSxuKXtpZihcImZsb2F0MzJcIiE9PWUpcmV0dXJuITE7Zm9yKHZhciByPTA7cjx0Lmxlbmd0aDtyKyspe3ZhciBvPXRbcl07aWYoaXNOYU4obyl8fCFpc0Zpbml0ZShvKSlyZXR1cm4gY29uc29sZS53YXJuKFwiRm91bmQgXCIrbytcIiBpbiB0aGUgcmVzdWx0IG9mICdcIituK1wiJ1wiKSwhMH19KHIsbi5kdHlwZSx0KSxhLnRoZW4oKGZ1bmN0aW9uKGEpe3ZhciBpPVwiXCI7bnVsbCE9YS5nZXRFeHRyYVByb2ZpbGVJbmZvJiYoaT1hLmdldEV4dHJhUHJvZmlsZUluZm8oKSksby5sb2dnZXIubG9nS2VybmVsUHJvZmlsZSh0LG4scixhLmtlcm5lbE1zLGUsaSl9KSl9KSl9KSkscn0sdH0oKTt2YXIgY3Q9ZnVuY3Rpb24oKXtmdW5jdGlvbiB0KCl7fXJldHVybiB0LnByb3RvdHlwZS5sb2dLZXJuZWxQcm9maWxlPWZ1bmN0aW9uKHQsZSxuLHIsbyxhKXt2YXIgaT1cIm51bWJlclwiPT10eXBlb2Ygcj9OKHIrXCJtc1wiLDkpOnIuZXJyb3Iscz1OKHQsMjUpLHU9ZS5yYW5rLGM9ZS5zaXplLGw9TihlLnNoYXBlLnRvU3RyaW5nKCksMTQpLGg9XCJcIjtmb3IodmFyIGYgaW4gbyl7dmFyIGQ9b1tmXS5zaGFwZXx8ZS5zaGFwZSxwPWQubGVuZ3RoO2grPWYrXCI6IFwiK3ArXCJEIFwiKyhwPjA/ZDpcIlwiKStcIiBcIn1jb25zb2xlLmxvZyhcIiVjXCIrcytcIlxcdCVjXCIraStcIlxcdCVjXCIrdStcIkQgXCIrbCtcIlxcdCVjXCIrYytcIlxcdCVjXCIraCtcIlxcdCVjXCIrYSxcImZvbnQtd2VpZ2h0OmJvbGRcIixcImNvbG9yOnJlZFwiLFwiY29sb3I6Ymx1ZVwiLFwiY29sb3I6IG9yYW5nZVwiLFwiY29sb3I6IGdyZWVuXCIsXCJjb2xvcjogc3RlZWxibHVlXCIpfSx0fSgpO3ZhciBsdD0yMCxodD0zLGZ0PTc7ZnVuY3Rpb24gZHQodCxlLG4scil7dmFyIG89JChlKSxhPWZ1bmN0aW9uKHQsZSxuLHIpe3ZhciBvPWsoZSksYT1yW3IubGVuZ3RoLTFdLGk9bmV3IEFycmF5KGEpLmZpbGwoMCkscz1lLmxlbmd0aCx1PVwiY29tcGxleDY0XCI9PT1uP210KHQpOnQ7aWYocz4xKWZvcih2YXIgYz0wO2M8by9hO2MrKylmb3IodmFyIGw9YyphLGg9MDtoPGE7aCsrKWlbaF09TWF0aC5tYXgoaVtoXSxwdCh1W2wraF0sMCxuKS5sZW5ndGgpO3JldHVybiBpfSh0LGUsbixvKSxpPWUubGVuZ3RoLHM9ZnVuY3Rpb24gdChlLG4scixvLGEsaSl7dm9pZCAwPT09aSYmKGk9ITApO3ZhciBzPVwiY29tcGxleDY0XCI9PT1yPzI6MSx1PW5bMF0sYz1uLmxlbmd0aDtpZigwPT09Yyl7cmV0dXJuXCJjb21wbGV4NjRcIj09PXI/W3B0KG10KGUpWzBdLDAscildOlwiYm9vbFwiPT09cj9bdnQoZVswXSldOltlWzBdLnRvU3RyaW5nKCldfWlmKDE9PT1jKXtpZih1Pmx0KXt2YXIgbD1odCpzLGg9QXJyYXkuZnJvbShlLnNsaWNlKDAsbCkpLGY9QXJyYXkuZnJvbShlLnNsaWNlKCh1LWh0KSpzLHUqcykpO3JldHVyblwiY29tcGxleDY0XCI9PT1yJiYoaD1tdChoKSxmPW10KGYpKSxbXCJbXCIraC5tYXAoKGZ1bmN0aW9uKHQsZSl7cmV0dXJuIHB0KHQsYVtlXSxyKX0pKS5qb2luKFwiLCBcIikrXCIsIC4uLiwgXCIrZi5tYXAoKGZ1bmN0aW9uKHQsZSl7cmV0dXJuIHB0KHQsYVt1LWh0K2VdLHIpfSkpLmpvaW4oXCIsIFwiKStcIl1cIl19cmV0dXJuW1wiW1wiKyhcImNvbXBsZXg2NFwiPT09cj9tdChlKTpBcnJheS5mcm9tKGUpKS5tYXAoKGZ1bmN0aW9uKHQsZSl7cmV0dXJuIHB0KHQsYVtlXSxyKX0pKS5qb2luKFwiLCBcIikrXCJdXCJdfXZhciBkPW4uc2xpY2UoMSkscD1vLnNsaWNlKDEpLHY9b1swXSpzLG09W107aWYodT5sdCl7Zm9yKHZhciBnPTA7ZzxodDtnKyspe3ZhciB5PSh4PWcqdikrdjttLnB1c2guYXBwbHkobSx0KGUuc2xpY2UoeCx5KSxkLHIscCxhLCExKSl9bS5wdXNoKFwiLi4uXCIpO2ZvcihnPXUtaHQ7Zzx1O2crKyl7eT0oeD1nKnYpK3Y7bS5wdXNoLmFwcGx5KG0sdChlLnNsaWNlKHgseSksZCxyLHAsYSxnPT09dS0xKSl9fWVsc2UgZm9yKGc9MDtnPHU7ZysrKXt2YXIgeDt5PSh4PWcqdikrdjttLnB1c2guYXBwbHkobSx0KGUuc2xpY2UoeCx5KSxkLHIscCxhLGc9PT11LTEpKX12YXIgYj0yPT09Yz9cIixcIjpcIlwiO21bMF09XCJbXCIrbVswXStiO2ZvcihnPTE7ZzxtLmxlbmd0aC0xO2crKyltW2ddPVwiIFwiK21bZ10rYjt2YXIgdz1cIixcXG5cIjtmb3IoZz0yO2c8YztnKyspdys9XCJcXG5cIjtyZXR1cm4gbVttLmxlbmd0aC0xXT1cIiBcIittW20ubGVuZ3RoLTFdK1wiXVwiKyhpP1wiXCI6dyksbX0odCxlLG4sbyxhKSx1PVtcIlRlbnNvclwiXTtyZXR1cm4gciYmKHUucHVzaChcIiAgZHR5cGU6IFwiK24pLHUucHVzaChcIiAgcmFuazogXCIraSksdS5wdXNoKFwiICBzaGFwZTogW1wiK2UrXCJdXCIpLHUucHVzaChcIiAgdmFsdWVzOlwiKSksdS5wdXNoKHMubWFwKChmdW5jdGlvbih0KXtyZXR1cm5cIiAgICBcIit0fSkpLmpvaW4oXCJcXG5cIikpLHUuam9pbihcIlxcblwiKX1mdW5jdGlvbiBwdCh0LGUsbil7cmV0dXJuIE4oQXJyYXkuaXNBcnJheSh0KT9wYXJzZUZsb2F0KHRbMF0udG9GaXhlZChmdCkpK1wiICsgXCIrcGFyc2VGbG9hdCh0WzFdLnRvRml4ZWQoZnQpKStcImpcIjpIKHQpP1wiJ1wiK3QrXCInXCI6XCJib29sXCI9PT1uP3Z0KHQpOnBhcnNlRmxvYXQodC50b0ZpeGVkKGZ0KSkudG9TdHJpbmcoKSxlKX1mdW5jdGlvbiB2dCh0KXtyZXR1cm4gMD09PXQ/XCJmYWxzZVwiOlwidHJ1ZVwifWZ1bmN0aW9uIG10KHQpe2Zvcih2YXIgZT1bXSxuPTA7bjx0Lmxlbmd0aDtuKz0yKWUucHVzaChbdFtuXSx0W24rMV1dKTtyZXR1cm4gZX12YXIgZ3Q9ZnVuY3Rpb24oKXtmdW5jdGlvbiB0KHQsZSxuKXt2YXIgcj10aGlzO2lmKHRoaXMuZHR5cGU9ZSx0aGlzLnNoYXBlPXQuc2xpY2UoKSx0aGlzLnNpemU9ayh0KSxudWxsIT1uKXt2YXIgbz1uLmxlbmd0aDtDKG89PT10aGlzLnNpemUsKGZ1bmN0aW9uKCl7cmV0dXJuXCJMZW5ndGggb2YgdmFsdWVzICdcIitvK1wiJyBkb2VzIG5vdCBtYXRjaCB0aGUgc2l6ZSBpbmZlcnJlZCBieSB0aGUgc2hhcGUgJ1wiK3Iuc2l6ZStcIicuXCJ9KSl9aWYoXCJjb21wbGV4NjRcIj09PWUpdGhyb3cgbmV3IEVycm9yKFwiY29tcGxleDY0IGR0eXBlIFRlbnNvckJ1ZmZlcnMgYXJlIG5vdCBzdXBwb3J0ZWQuIFBsZWFzZSBjcmVhdGUgYSBUZW5zb3JCdWZmZXIgZm9yIHRoZSByZWFsIGFuZCBpbWFnaW5hcnkgcGFydHMgc2VwYXJhdGVseSBhbmQgY2FsbCB0Zi5jb21wbGV4KHJlYWwsIGltYWcpLlwiKTt0aGlzLnZhbHVlcz1ufHxQKGUsdGhpcy5zaXplKSx0aGlzLnN0cmlkZXM9JCh0KX1yZXR1cm4gdC5wcm90b3R5cGUuc2V0PWZ1bmN0aW9uKHQpe2Zvcih2YXIgZT10aGlzLG49W10scj0xO3I8YXJndW1lbnRzLmxlbmd0aDtyKyspbltyLTFdPWFyZ3VtZW50c1tyXTswPT09bi5sZW5ndGgmJihuPVswXSksQyhuLmxlbmd0aD09PXRoaXMucmFuaywoZnVuY3Rpb24oKXtyZXR1cm5cIlRoZSBudW1iZXIgb2YgcHJvdmlkZWQgY29vcmRpbmF0ZXMgKFwiK24ubGVuZ3RoK1wiKSBtdXN0IG1hdGNoIHRoZSByYW5rIChcIitlLnJhbmsrXCIpXCJ9KSk7dmFyIG89dGhpcy5sb2NUb0luZGV4KG4pO3RoaXMudmFsdWVzW29dPXR9LHQucHJvdG90eXBlLmdldD1mdW5jdGlvbigpe2Zvcih2YXIgdD1bXSxlPTA7ZTxhcmd1bWVudHMubGVuZ3RoO2UrKyl0W2VdPWFyZ3VtZW50c1tlXTswPT09dC5sZW5ndGgmJih0PVswXSk7Zm9yKHZhciBuPTAscj0wLG89dDtyPG8ubGVuZ3RoO3IrKyl7dmFyIGE9b1tyXTtpZihhPDB8fGE+PXRoaXMuc2hhcGVbbl0pe3ZhciBpPVwiUmVxdWVzdGVkIG91dCBvZiByYW5nZSBlbGVtZW50IGF0IFwiK3QrXCIuICAgQnVmZmVyIHNoYXBlPVwiK3RoaXMuc2hhcGU7dGhyb3cgbmV3IEVycm9yKGkpfW4rK31mb3IodmFyIHM9dFt0Lmxlbmd0aC0xXSx1PTA7dTx0Lmxlbmd0aC0xOysrdSlzKz10aGlzLnN0cmlkZXNbdV0qdFt1XTtyZXR1cm4gdGhpcy52YWx1ZXNbc119LHQucHJvdG90eXBlLmxvY1RvSW5kZXg9ZnVuY3Rpb24odCl7aWYoMD09PXRoaXMucmFuaylyZXR1cm4gMDtpZigxPT09dGhpcy5yYW5rKXJldHVybiB0WzBdO2Zvcih2YXIgZT10W3QubGVuZ3RoLTFdLG49MDtuPHQubGVuZ3RoLTE7KytuKWUrPXRoaXMuc3RyaWRlc1tuXSp0W25dO3JldHVybiBlfSx0LnByb3RvdHlwZS5pbmRleFRvTG9jPWZ1bmN0aW9uKHQpe2lmKDA9PT10aGlzLnJhbmspcmV0dXJuW107aWYoMT09PXRoaXMucmFuaylyZXR1cm5bdF07Zm9yKHZhciBlPW5ldyBBcnJheSh0aGlzLnNoYXBlLmxlbmd0aCksbj0wO248ZS5sZW5ndGgtMTsrK24pZVtuXT1NYXRoLmZsb29yKHQvdGhpcy5zdHJpZGVzW25dKSx0LT1lW25dKnRoaXMuc3RyaWRlc1tuXTtyZXR1cm4gZVtlLmxlbmd0aC0xXT10LGV9LE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LnByb3RvdHlwZSxcInJhbmtcIix7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuc2hhcGUubGVuZ3RofSxlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMH0pLHQucHJvdG90eXBlLnRvVGVuc29yPWZ1bmN0aW9uKCl7cmV0dXJuIHl0KCkubWFrZVRlbnNvcih0aGlzLnZhbHVlcyx0aGlzLnNoYXBlLHRoaXMuZHR5cGUpfSx0fSgpLHl0PW51bGwseHQ9bnVsbCxidD1udWxsO3ZhciB3dD1mdW5jdGlvbigpe2Z1bmN0aW9uIHQodCxlLG4scil7dGhpcy5rZXB0PSExLHRoaXMuaXNEaXNwb3NlZEludGVybmFsPSExLHRoaXMuc2hhcGU9dC5zbGljZSgpLHRoaXMuZHR5cGU9ZXx8XCJmbG9hdDMyXCIsdGhpcy5zaXplPWsodCksdGhpcy5zdHJpZGVzPSQodCksdGhpcy5kYXRhSWQ9bix0aGlzLmlkPXIsdGhpcy5yYW5rVHlwZT10aGlzLnJhbms8NT90aGlzLnJhbmsudG9TdHJpbmcoKTpcImhpZ2hlclwifXJldHVybiB0LnByb3RvdHlwZS5mbGF0dGVuPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCksdGhpcy5hczFEKCl9LHQucHJvdG90eXBlLmFzU2NhbGFyPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCksQygxPT09dGhpcy5zaXplLChmdW5jdGlvbigpe3JldHVyblwiVGhlIGFycmF5IG11c3QgaGF2ZSBvbmx5IDEgZWxlbWVudC5cIn0pKSx0aGlzLnJlc2hhcGUoW10pfSx0LnByb3RvdHlwZS5hczFEPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCksdGhpcy5yZXNoYXBlKFt0aGlzLnNpemVdKX0sdC5wcm90b3R5cGUuYXMyRD1mdW5jdGlvbih0LGUpe3JldHVybiB0aGlzLnRocm93SWZEaXNwb3NlZCgpLHRoaXMucmVzaGFwZShbdCxlXSl9LHQucHJvdG90eXBlLmFzM0Q9ZnVuY3Rpb24odCxlLG4pe3JldHVybiB0aGlzLnRocm93SWZEaXNwb3NlZCgpLHRoaXMucmVzaGFwZShbdCxlLG5dKX0sdC5wcm90b3R5cGUuYXM0RD1mdW5jdGlvbih0LGUsbixyKXtyZXR1cm4gdGhpcy50aHJvd0lmRGlzcG9zZWQoKSx0aGlzLnJlc2hhcGUoW3QsZSxuLHJdKX0sdC5wcm90b3R5cGUuYXM1RD1mdW5jdGlvbih0LGUsbixyLG8pe3JldHVybiB0aGlzLnRocm93SWZEaXNwb3NlZCgpLHRoaXMucmVzaGFwZShbdCxlLG4scixvXSl9LHQucHJvdG90eXBlLmFzVHlwZT1mdW5jdGlvbih0KXtyZXR1cm4gdGhpcy50aHJvd0lmRGlzcG9zZWQoKSx4dC5jYXN0KHRoaXMsdCl9LE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LnByb3RvdHlwZSxcInJhbmtcIix7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuc2hhcGUubGVuZ3RofSxlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMH0pLHQucHJvdG90eXBlLmJ1ZmZlcj1mdW5jdGlvbigpe3JldHVybiBuKHRoaXMsdm9pZCAwLHZvaWQgMCwoZnVuY3Rpb24oKXt2YXIgdDtyZXR1cm4gcih0aGlzLChmdW5jdGlvbihlKXtzd2l0Y2goZS5sYWJlbCl7Y2FzZSAwOnJldHVybls0LHRoaXMuZGF0YSgpXTtjYXNlIDE6cmV0dXJuIHQ9ZS5zZW50KCksWzIseHQuYnVmZmVyKHRoaXMuc2hhcGUsdGhpcy5kdHlwZSx0KV19fSkpfSkpfSx0LnByb3RvdHlwZS5idWZmZXJTeW5jPWZ1bmN0aW9uKCl7cmV0dXJuIHh0LmJ1ZmZlcih0aGlzLnNoYXBlLHRoaXMuZHR5cGUsdGhpcy5kYXRhU3luYygpKX0sdC5wcm90b3R5cGUuYXJyYXk9ZnVuY3Rpb24oKXtyZXR1cm4gbih0aGlzLHZvaWQgMCx2b2lkIDAsKGZ1bmN0aW9uKCl7dmFyIHQ7cmV0dXJuIHIodGhpcywoZnVuY3Rpb24oZSl7c3dpdGNoKGUubGFiZWwpe2Nhc2UgMDpyZXR1cm5bNCx0aGlzLmRhdGEoKV07Y2FzZSAxOnJldHVybiB0PWUuc2VudCgpLFsyLEoodGhpcy5zaGFwZSx0KV19fSkpfSkpfSx0LnByb3RvdHlwZS5hcnJheVN5bmM9ZnVuY3Rpb24oKXtyZXR1cm4gSih0aGlzLnNoYXBlLHRoaXMuZGF0YVN5bmMoKSl9LHQucHJvdG90eXBlLmRhdGE9ZnVuY3Rpb24oKXtyZXR1cm4gbih0aGlzLHZvaWQgMCx2b2lkIDAsKGZ1bmN0aW9uKCl7dmFyIHQsZTtyZXR1cm4gcih0aGlzLChmdW5jdGlvbihuKXtzd2l0Y2gobi5sYWJlbCl7Y2FzZSAwOnJldHVybiB0aGlzLnRocm93SWZEaXNwb3NlZCgpLHQ9eXQoKS5yZWFkKHRoaXMuZGF0YUlkKSxcInN0cmluZ1wiIT09dGhpcy5kdHlwZT9bMywyXTpbNCx0XTtjYXNlIDE6ZT1uLnNlbnQoKTt0cnl7cmV0dXJuWzIsZS5tYXAoKGZ1bmN0aW9uKHQpe3JldHVybiBvdCh0KX0pKV19Y2F0Y2godCl7dGhyb3cgbmV3IEVycm9yKFwiRmFpbGVkIHRvIGRlY29kZSB0aGUgc3RyaW5nIGJ5dGVzIGludG8gdXRmLTguIFRvIGdldCB0aGUgb3JpZ2luYWwgYnl0ZXMsIGNhbGwgdGVuc29yLmJ5dGVzKCkuXCIpfW4ubGFiZWw9MjtjYXNlIDI6cmV0dXJuWzIsdF19fSkpfSkpfSx0LnByb3RvdHlwZS5kYXRhU3luYz1mdW5jdGlvbigpe3RoaXMudGhyb3dJZkRpc3Bvc2VkKCk7dmFyIHQ9eXQoKS5yZWFkU3luYyh0aGlzLmRhdGFJZCk7aWYoXCJzdHJpbmdcIj09PXRoaXMuZHR5cGUpdHJ5e3JldHVybiB0Lm1hcCgoZnVuY3Rpb24odCl7cmV0dXJuIG90KHQpfSkpfWNhdGNoKHQpe3Rocm93IG5ldyBFcnJvcihcIkZhaWxlZCB0byBkZWNvZGUgdGhlIHN0cmluZyBieXRlcyBpbnRvIHV0Zi04LiBUbyBnZXQgdGhlIG9yaWdpbmFsIGJ5dGVzLCBjYWxsIHRlbnNvci5ieXRlcygpLlwiKX1yZXR1cm4gdH0sdC5wcm90b3R5cGUuYnl0ZXM9ZnVuY3Rpb24oKXtyZXR1cm4gbih0aGlzLHZvaWQgMCx2b2lkIDAsKGZ1bmN0aW9uKCl7dmFyIHQ7cmV0dXJuIHIodGhpcywoZnVuY3Rpb24oZSl7c3dpdGNoKGUubGFiZWwpe2Nhc2UgMDpyZXR1cm4gdGhpcy50aHJvd0lmRGlzcG9zZWQoKSxbNCx5dCgpLnJlYWQodGhpcy5kYXRhSWQpXTtjYXNlIDE6cmV0dXJuIHQ9ZS5zZW50KCksXCJzdHJpbmdcIj09PXRoaXMuZHR5cGU/WzIsdF06WzIsbmV3IFVpbnQ4QXJyYXkodC5idWZmZXIpXX19KSl9KSl9LHQucHJvdG90eXBlLmRpc3Bvc2U9ZnVuY3Rpb24oKXt0aGlzLmlzRGlzcG9zZWR8fCh5dCgpLmRpc3Bvc2VUZW5zb3IodGhpcyksdGhpcy5pc0Rpc3Bvc2VkSW50ZXJuYWw9ITApfSxPYmplY3QuZGVmaW5lUHJvcGVydHkodC5wcm90b3R5cGUsXCJpc0Rpc3Bvc2VkXCIse2dldDpmdW5jdGlvbigpe3JldHVybiB0aGlzLmlzRGlzcG9zZWRJbnRlcm5hbH0sZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITB9KSx0LnByb3RvdHlwZS50aHJvd0lmRGlzcG9zZWQ9ZnVuY3Rpb24oKXtpZih0aGlzLmlzRGlzcG9zZWQpdGhyb3cgbmV3IEVycm9yKFwiVGVuc29yIGlzIGRpc3Bvc2VkLlwiKX0sdC5wcm90b3R5cGUudG9GbG9hdD1mdW5jdGlvbigpe3JldHVybiB0aGlzLmFzVHlwZShcImZsb2F0MzJcIil9LHQucHJvdG90eXBlLnRvSW50PWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuYXNUeXBlKFwiaW50MzJcIil9LHQucHJvdG90eXBlLnRvQm9vbD1mdW5jdGlvbigpe3JldHVybiB0aGlzLmFzVHlwZShcImJvb2xcIil9LHQucHJvdG90eXBlLnByaW50PWZ1bmN0aW9uKHQpe3JldHVybiB2b2lkIDA9PT10JiYodD0hMSkseHQucHJpbnQodGhpcyx0KX0sdC5wcm90b3R5cGUucmVzaGFwZT1mdW5jdGlvbih0KXtyZXR1cm4gdGhpcy50aHJvd0lmRGlzcG9zZWQoKSx4dC5yZXNoYXBlKHRoaXMsdCl9LHQucHJvdG90eXBlLnJlc2hhcGVBcz1mdW5jdGlvbih0KXtyZXR1cm4gdGhpcy50aHJvd0lmRGlzcG9zZWQoKSx0aGlzLnJlc2hhcGUodC5zaGFwZSl9LHQucHJvdG90eXBlLmV4cGFuZERpbXM9ZnVuY3Rpb24odCl7cmV0dXJuIHZvaWQgMD09PXQmJih0PTApLHh0LmV4cGFuZERpbXModGhpcyx0KX0sdC5wcm90b3R5cGUuY3Vtc3VtPWZ1bmN0aW9uKHQsZSxuKXtyZXR1cm4gdm9pZCAwPT09dCYmKHQ9MCksdm9pZCAwPT09ZSYmKGU9ITEpLHZvaWQgMD09PW4mJihuPSExKSx4dC5jdW1zdW0odGhpcyx0LGUsbil9LHQucHJvdG90eXBlLnNxdWVlemU9ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCkseHQuc3F1ZWV6ZSh0aGlzLHQpfSx0LnByb3RvdHlwZS5jbG9uZT1mdW5jdGlvbigpe3JldHVybiB0aGlzLnRocm93SWZEaXNwb3NlZCgpLHh0LmNsb25lKHRoaXMpfSx0LnByb3RvdHlwZS5vbmVIb3Q9ZnVuY3Rpb24odCxlLG4pe3JldHVybiB0aGlzLnRocm93SWZEaXNwb3NlZCgpLHh0Lm9uZUhvdCh0aGlzLHQsZSxuKX0sdC5wcm90b3R5cGUudG9TdHJpbmc9ZnVuY3Rpb24odCl7cmV0dXJuIHZvaWQgMD09PXQmJih0PSExKSxkdCh0aGlzLmRhdGFTeW5jKCksdGhpcy5zaGFwZSx0aGlzLmR0eXBlLHQpfSx0LnByb3RvdHlwZS50aWxlPWZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLnRocm93SWZEaXNwb3NlZCgpLHh0LnRpbGUodGhpcyx0KX0sdC5wcm90b3R5cGUuZ2F0aGVyPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIHZvaWQgMD09PWUmJihlPTApLHRoaXMudGhyb3dJZkRpc3Bvc2VkKCkseHQuZ2F0aGVyKHRoaXMsdCxlKX0sdC5wcm90b3R5cGUubWF0TXVsPWZ1bmN0aW9uKHQsZSxuKXtyZXR1cm4gdm9pZCAwPT09ZSYmKGU9ITEpLHZvaWQgMD09PW4mJihuPSExKSx0aGlzLnRocm93SWZEaXNwb3NlZCgpLHh0Lm1hdE11bCh0aGlzLHQsZSxuKX0sdC5wcm90b3R5cGUuZG90PWZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLnRocm93SWZEaXNwb3NlZCgpLHh0LmRvdCh0aGlzLHQpfSx0LnByb3RvdHlwZS5ub3JtPWZ1bmN0aW9uKHQsZSxuKXtyZXR1cm4gdm9pZCAwPT09dCYmKHQ9XCJldWNsaWRlYW5cIiksdm9pZCAwPT09ZSYmKGU9bnVsbCksdm9pZCAwPT09biYmKG49ITEpLHRoaXMudGhyb3dJZkRpc3Bvc2VkKCkseHQubm9ybSh0aGlzLHQsZSxuKX0sdC5wcm90b3R5cGUuc2xpY2U9ZnVuY3Rpb24odCxlKXtyZXR1cm4gdGhpcy50aHJvd0lmRGlzcG9zZWQoKSx4dC5zbGljZSh0aGlzLHQsZSl9LHQucHJvdG90eXBlLnJldmVyc2U9ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCkseHQucmV2ZXJzZSh0aGlzLHQpfSx0LnByb3RvdHlwZS5jb25jYXQ9ZnVuY3Rpb24oZSxuKXtyZXR1cm4gdm9pZCAwPT09biYmKG49MCksdGhpcy50aHJvd0lmRGlzcG9zZWQoKSxlIGluc3RhbmNlb2YgdCYmKGU9W2VdKSx4dC5jb25jYXQoW3RoaXNdLmNvbmNhdChlKSxuKX0sdC5wcm90b3R5cGUuc3BsaXQ9ZnVuY3Rpb24odCxlKXtyZXR1cm4gdm9pZCAwPT09ZSYmKGU9MCksdGhpcy50aHJvd0lmRGlzcG9zZWQoKSx4dC5zcGxpdCh0aGlzLHQsZSl9LHQucHJvdG90eXBlLnN0YWNrPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIHZvaWQgMD09PWUmJihlPTApLHh0LnN0YWNrKFt0aGlzLHRdLGUpfSx0LnByb3RvdHlwZS51bnN0YWNrPWZ1bmN0aW9uKHQpe3JldHVybiB2b2lkIDA9PT10JiYodD0wKSx4dC51bnN0YWNrKHRoaXMsdCl9LHQucHJvdG90eXBlLnBhZD1mdW5jdGlvbih0LGUpe3JldHVybiB2b2lkIDA9PT1lJiYoZT0wKSx4dC5wYWQodGhpcyx0LGUpfSx0LnByb3RvdHlwZS5iYXRjaE5vcm1hbGl6YXRpb249ZnVuY3Rpb24odCxlLG4scixvKXtyZXR1cm4gdm9pZCAwPT09biYmKG49LjAwMSksYnQoXCJ0Zi5iYXRjaE5vcm1hbGl6YXRpb24oKSBpcyBnb2luZyBhd2F5LiBVc2UgdGYuYmF0Y2hOb3JtKCkgaW5zdGVhZCwgYW5kIG5vdGUgdGhlIHBvc2l0aW9uYWwgYXJndW1lbnQgY2hhbmdlIG9mIHNjYWxlLCBvZmZzZXQsIGFuZCB2YXJpYW5jZUVwc2lsb25cIiksdGhpcy5iYXRjaE5vcm0odCxlLG8scixuKX0sdC5wcm90b3R5cGUuYmF0Y2hOb3JtPWZ1bmN0aW9uKHQsZSxuLHIsbyl7cmV0dXJuIHZvaWQgMD09PW8mJihvPS4wMDEpLHRoaXMudGhyb3dJZkRpc3Bvc2VkKCkseHQuYmF0Y2hOb3JtKHRoaXMsdCxlLG4scixvKX0sdC5wcm90b3R5cGUuYWxsPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIHZvaWQgMD09PXQmJih0PW51bGwpLHZvaWQgMD09PWUmJihlPSExKSx0aGlzLnRocm93SWZEaXNwb3NlZCgpLHh0LmFsbCh0aGlzLHQsZSl9LHQucHJvdG90eXBlLmFueT1mdW5jdGlvbih0LGUpe3JldHVybiB2b2lkIDA9PT10JiYodD1udWxsKSx2b2lkIDA9PT1lJiYoZT0hMSksdGhpcy50aHJvd0lmRGlzcG9zZWQoKSx4dC5hbnkodGhpcyx0LGUpfSx0LnByb3RvdHlwZS5sb2dTdW1FeHA9ZnVuY3Rpb24odCxlKXtyZXR1cm4gdm9pZCAwPT09dCYmKHQ9bnVsbCksdm9pZCAwPT09ZSYmKGU9ITEpLHRoaXMudGhyb3dJZkRpc3Bvc2VkKCkseHQubG9nU3VtRXhwKHRoaXMsdCxlKX0sdC5wcm90b3R5cGUuc3VtPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIHZvaWQgMD09PXQmJih0PW51bGwpLHZvaWQgMD09PWUmJihlPSExKSx0aGlzLnRocm93SWZEaXNwb3NlZCgpLHh0LnN1bSh0aGlzLHQsZSl9LHQucHJvdG90eXBlLnByb2Q9ZnVuY3Rpb24odCxlKXtyZXR1cm4gdm9pZCAwPT09dCYmKHQ9bnVsbCksdm9pZCAwPT09ZSYmKGU9ITEpLHRoaXMudGhyb3dJZkRpc3Bvc2VkKCkseHQucHJvZCh0aGlzLHQsZSl9LHQucHJvdG90eXBlLm1lYW49ZnVuY3Rpb24odCxlKXtyZXR1cm4gdm9pZCAwPT09dCYmKHQ9bnVsbCksdm9pZCAwPT09ZSYmKGU9ITEpLHRoaXMudGhyb3dJZkRpc3Bvc2VkKCkseHQubWVhbih0aGlzLHQsZSl9LHQucHJvdG90eXBlLm1pbj1mdW5jdGlvbih0LGUpe3JldHVybiB2b2lkIDA9PT10JiYodD1udWxsKSx2b2lkIDA9PT1lJiYoZT0hMSksdGhpcy50aHJvd0lmRGlzcG9zZWQoKSx4dC5taW4odGhpcyx0LGUpfSx0LnByb3RvdHlwZS5tYXg9ZnVuY3Rpb24odCxlKXtyZXR1cm4gdm9pZCAwPT09dCYmKHQ9bnVsbCksdm9pZCAwPT09ZSYmKGU9ITEpLHRoaXMudGhyb3dJZkRpc3Bvc2VkKCkseHQubWF4KHRoaXMsdCxlKX0sdC5wcm90b3R5cGUuYXJnTWluPWZ1bmN0aW9uKHQpe3JldHVybiB2b2lkIDA9PT10JiYodD1udWxsKSx0aGlzLnRocm93SWZEaXNwb3NlZCgpLHh0LmFyZ01pbih0aGlzLHQpfSx0LnByb3RvdHlwZS5hcmdNYXg9ZnVuY3Rpb24odCl7cmV0dXJuIHZvaWQgMD09PXQmJih0PW51bGwpLHRoaXMudGhyb3dJZkRpc3Bvc2VkKCkseHQuYXJnTWF4KHRoaXMsdCl9LHQucHJvdG90eXBlLmNhc3Q9ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCkseHQuY2FzdCh0aGlzLHQpfSx0LnByb3RvdHlwZS5hZGQ9ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCkseHQuYWRkKHRoaXMsdCl9LHQucHJvdG90eXBlLmFkZFN0cmljdD1mdW5jdGlvbih0KXtyZXR1cm4gdGhpcy50aHJvd0lmRGlzcG9zZWQoKSx4dC5hZGRTdHJpY3QodGhpcyx0KX0sdC5wcm90b3R5cGUuYXRhbjI9ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCkseHQuYXRhbjIodGhpcyx0KX0sdC5wcm90b3R5cGUuc3ViPWZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLnRocm93SWZEaXNwb3NlZCgpLHh0LnN1Yih0aGlzLHQpfSx0LnByb3RvdHlwZS5zdWJTdHJpY3Q9ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCkseHQuc3ViU3RyaWN0KHRoaXMsdCl9LHQucHJvdG90eXBlLnBvdz1mdW5jdGlvbih0KXtyZXR1cm4gdGhpcy50aHJvd0lmRGlzcG9zZWQoKSx4dC5wb3codGhpcyx0KX0sdC5wcm90b3R5cGUucG93U3RyaWN0PWZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLnRocm93SWZEaXNwb3NlZCgpLHh0LnBvd1N0cmljdCh0aGlzLHQpfSx0LnByb3RvdHlwZS5tdWw9ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCkseHQubXVsKHRoaXMsdCl9LHQucHJvdG90eXBlLm11bFN0cmljdD1mdW5jdGlvbih0KXtyZXR1cm4gdGhpcy50aHJvd0lmRGlzcG9zZWQoKSx4dC5tdWxTdHJpY3QodGhpcyx0KX0sdC5wcm90b3R5cGUuZGl2PWZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLnRocm93SWZEaXNwb3NlZCgpLHh0LmRpdih0aGlzLHQpfSx0LnByb3RvdHlwZS5kaXZOb05hbj1mdW5jdGlvbih0KXtyZXR1cm4gdGhpcy50aHJvd0lmRGlzcG9zZWQoKSx4dC5kaXZOb05hbih0aGlzLHQpfSx0LnByb3RvdHlwZS5mbG9vckRpdj1mdW5jdGlvbih0KXtyZXR1cm4gdGhpcy50aHJvd0lmRGlzcG9zZWQoKSx4dC5mbG9vckRpdih0aGlzLHQpfSx0LnByb3RvdHlwZS5kaXZTdHJpY3Q9ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCkseHQuZGl2U3RyaWN0KHRoaXMsdCl9LHQucHJvdG90eXBlLm1pbmltdW09ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCkseHQubWluaW11bSh0aGlzLHQpfSx0LnByb3RvdHlwZS5taW5pbXVtU3RyaWN0PWZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLnRocm93SWZEaXNwb3NlZCgpLHh0Lm1pbmltdW1TdHJpY3QodGhpcyx0KX0sdC5wcm90b3R5cGUubWF4aW11bT1mdW5jdGlvbih0KXtyZXR1cm4gdGhpcy50aHJvd0lmRGlzcG9zZWQoKSx4dC5tYXhpbXVtKHRoaXMsdCl9LHQucHJvdG90eXBlLm1heGltdW1TdHJpY3Q9ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCkseHQubWF4aW11bVN0cmljdCh0aGlzLHQpfSx0LnByb3RvdHlwZS5tb2Q9ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCkseHQubW9kKHRoaXMsdCl9LHQucHJvdG90eXBlLm1vZFN0cmljdD1mdW5jdGlvbih0KXtyZXR1cm4gdGhpcy50aHJvd0lmRGlzcG9zZWQoKSx4dC5tb2RTdHJpY3QodGhpcyx0KX0sdC5wcm90b3R5cGUuc3F1YXJlZERpZmZlcmVuY2VTdHJpY3Q9ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCkseHQuc3F1YXJlZERpZmZlcmVuY2VTdHJpY3QodGhpcyx0KX0sdC5wcm90b3R5cGUudHJhbnNwb3NlPWZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLnRocm93SWZEaXNwb3NlZCgpLHh0LnRyYW5zcG9zZSh0aGlzLHQpfSx0LnByb3RvdHlwZS5ub3RFcXVhbD1mdW5jdGlvbih0KXtyZXR1cm4gdGhpcy50aHJvd0lmRGlzcG9zZWQoKSx4dC5ub3RFcXVhbCh0aGlzLHQpfSx0LnByb3RvdHlwZS5ub3RFcXVhbFN0cmljdD1mdW5jdGlvbih0KXtyZXR1cm4gdGhpcy50aHJvd0lmRGlzcG9zZWQoKSx4dC5ub3RFcXVhbFN0cmljdCh0aGlzLHQpfSx0LnByb3RvdHlwZS5sZXNzPWZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLnRocm93SWZEaXNwb3NlZCgpLHh0Lmxlc3ModGhpcyx0KX0sdC5wcm90b3R5cGUubGVzc1N0cmljdD1mdW5jdGlvbih0KXtyZXR1cm4gdGhpcy50aHJvd0lmRGlzcG9zZWQoKSx4dC5sZXNzU3RyaWN0KHRoaXMsdCl9LHQucHJvdG90eXBlLmVxdWFsPWZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLnRocm93SWZEaXNwb3NlZCgpLHh0LmVxdWFsKHRoaXMsdCl9LHQucHJvdG90eXBlLmVxdWFsU3RyaWN0PWZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLnRocm93SWZEaXNwb3NlZCgpLHh0LmVxdWFsU3RyaWN0KHRoaXMsdCl9LHQucHJvdG90eXBlLmxlc3NFcXVhbD1mdW5jdGlvbih0KXtyZXR1cm4gdGhpcy50aHJvd0lmRGlzcG9zZWQoKSx4dC5sZXNzRXF1YWwodGhpcyx0KX0sdC5wcm90b3R5cGUubGVzc0VxdWFsU3RyaWN0PWZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLnRocm93SWZEaXNwb3NlZCgpLHh0Lmxlc3NFcXVhbFN0cmljdCh0aGlzLHQpfSx0LnByb3RvdHlwZS5ncmVhdGVyPWZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLnRocm93SWZEaXNwb3NlZCgpLHh0LmdyZWF0ZXIodGhpcyx0KX0sdC5wcm90b3R5cGUuZ3JlYXRlclN0cmljdD1mdW5jdGlvbih0KXtyZXR1cm4gdGhpcy50aHJvd0lmRGlzcG9zZWQoKSx4dC5ncmVhdGVyU3RyaWN0KHRoaXMsdCl9LHQucHJvdG90eXBlLmdyZWF0ZXJFcXVhbD1mdW5jdGlvbih0KXtyZXR1cm4gdGhpcy50aHJvd0lmRGlzcG9zZWQoKSx4dC5ncmVhdGVyRXF1YWwodGhpcyx0KX0sdC5wcm90b3R5cGUuZ3JlYXRlckVxdWFsU3RyaWN0PWZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLnRocm93SWZEaXNwb3NlZCgpLHh0LmdyZWF0ZXJFcXVhbFN0cmljdCh0aGlzLHQpfSx0LnByb3RvdHlwZS5sb2dpY2FsQW5kPWZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLnRocm93SWZEaXNwb3NlZCgpLHh0LmxvZ2ljYWxBbmQodGhpcyx0KX0sdC5wcm90b3R5cGUubG9naWNhbE9yPWZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLnRocm93SWZEaXNwb3NlZCgpLHh0LmxvZ2ljYWxPcih0aGlzLHQpfSx0LnByb3RvdHlwZS5sb2dpY2FsTm90PWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCkseHQubG9naWNhbE5vdCh0aGlzKX0sdC5wcm90b3R5cGUubG9naWNhbFhvcj1mdW5jdGlvbih0KXtyZXR1cm4gdGhpcy50aHJvd0lmRGlzcG9zZWQoKSx4dC5sb2dpY2FsWG9yKHRoaXMsdCl9LHQucHJvdG90eXBlLndoZXJlPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCkseHQud2hlcmUodCx0aGlzLGUpfSx0LnByb3RvdHlwZS5uZWc9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy50aHJvd0lmRGlzcG9zZWQoKSx4dC5uZWcodGhpcyl9LHQucHJvdG90eXBlLmNlaWw9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy50aHJvd0lmRGlzcG9zZWQoKSx4dC5jZWlsKHRoaXMpfSx0LnByb3RvdHlwZS5mbG9vcj1mdW5jdGlvbigpe3JldHVybiB0aGlzLnRocm93SWZEaXNwb3NlZCgpLHh0LmZsb29yKHRoaXMpfSx0LnByb3RvdHlwZS5zaWduPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCkseHQuc2lnbih0aGlzKX0sdC5wcm90b3R5cGUuaXNOYU49ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy50aHJvd0lmRGlzcG9zZWQoKSx4dC5pc05hTih0aGlzKX0sdC5wcm90b3R5cGUuaXNJbmY9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy50aHJvd0lmRGlzcG9zZWQoKSx4dC5pc0luZih0aGlzKX0sdC5wcm90b3R5cGUuaXNGaW5pdGU9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy50aHJvd0lmRGlzcG9zZWQoKSx4dC5pc0Zpbml0ZSh0aGlzKX0sdC5wcm90b3R5cGUuZXhwPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCkseHQuZXhwKHRoaXMpfSx0LnByb3RvdHlwZS5leHBtMT1mdW5jdGlvbigpe3JldHVybiB0aGlzLnRocm93SWZEaXNwb3NlZCgpLHh0LmV4cG0xKHRoaXMpfSx0LnByb3RvdHlwZS5sb2c9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy50aHJvd0lmRGlzcG9zZWQoKSx4dC5sb2codGhpcyl9LHQucHJvdG90eXBlLmxvZzFwPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCkseHQubG9nMXAodGhpcyl9LHQucHJvdG90eXBlLnNxcnQ9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy50aHJvd0lmRGlzcG9zZWQoKSx4dC5zcXJ0KHRoaXMpfSx0LnByb3RvdHlwZS5yc3FydD1mdW5jdGlvbigpe3JldHVybiB0aGlzLnRocm93SWZEaXNwb3NlZCgpLHh0LnJzcXJ0KHRoaXMpfSx0LnByb3RvdHlwZS5zcXVhcmU9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy50aHJvd0lmRGlzcG9zZWQoKSx4dC5zcXVhcmUodGhpcyl9LHQucHJvdG90eXBlLnJlY2lwcm9jYWw9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy50aHJvd0lmRGlzcG9zZWQoKSx4dC5yZWNpcHJvY2FsKHRoaXMpfSx0LnByb3RvdHlwZS5hYnM9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy50aHJvd0lmRGlzcG9zZWQoKSx4dC5hYnModGhpcyl9LHQucHJvdG90eXBlLmNsaXBCeVZhbHVlPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCkseHQuY2xpcEJ5VmFsdWUodGhpcyx0LGUpfSx0LnByb3RvdHlwZS5yZWx1PWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCkseHQucmVsdSh0aGlzKX0sdC5wcm90b3R5cGUucmVsdTY9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy50aHJvd0lmRGlzcG9zZWQoKSx4dC5yZWx1Nih0aGlzKX0sdC5wcm90b3R5cGUuZWx1PWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCkseHQuZWx1KHRoaXMpfSx0LnByb3RvdHlwZS5zZWx1PWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCkseHQuc2VsdSh0aGlzKX0sdC5wcm90b3R5cGUubGVha3lSZWx1PWZ1bmN0aW9uKHQpe3JldHVybiB2b2lkIDA9PT10JiYodD0uMiksdGhpcy50aHJvd0lmRGlzcG9zZWQoKSx4dC5sZWFreVJlbHUodGhpcyx0KX0sdC5wcm90b3R5cGUucHJlbHU9ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCkseHQucHJlbHUodGhpcyx0KX0sdC5wcm90b3R5cGUuc2lnbW9pZD1mdW5jdGlvbigpe3JldHVybiB0aGlzLnRocm93SWZEaXNwb3NlZCgpLHh0LnNpZ21vaWQodGhpcyl9LHQucHJvdG90eXBlLmxvZ1NpZ21vaWQ9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy50aHJvd0lmRGlzcG9zZWQoKSx4dC5sb2dTaWdtb2lkKHRoaXMpfSx0LnByb3RvdHlwZS5zb2Z0cGx1cz1mdW5jdGlvbigpe3JldHVybiB0aGlzLnRocm93SWZEaXNwb3NlZCgpLHh0LnNvZnRwbHVzKHRoaXMpfSx0LnByb3RvdHlwZS56ZXJvc0xpa2U9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy50aHJvd0lmRGlzcG9zZWQoKSx4dC56ZXJvc0xpa2UodGhpcyl9LHQucHJvdG90eXBlLm9uZXNMaWtlPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCkseHQub25lc0xpa2UodGhpcyl9LHQucHJvdG90eXBlLnNpbj1mdW5jdGlvbigpe3JldHVybiB0aGlzLnRocm93SWZEaXNwb3NlZCgpLHh0LnNpbih0aGlzKX0sdC5wcm90b3R5cGUuY29zPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCkseHQuY29zKHRoaXMpfSx0LnByb3RvdHlwZS50YW49ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy50aHJvd0lmRGlzcG9zZWQoKSx4dC50YW4odGhpcyl9LHQucHJvdG90eXBlLmFzaW49ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy50aHJvd0lmRGlzcG9zZWQoKSx4dC5hc2luKHRoaXMpfSx0LnByb3RvdHlwZS5hY29zPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCkseHQuYWNvcyh0aGlzKX0sdC5wcm90b3R5cGUuYXRhbj1mdW5jdGlvbigpe3JldHVybiB0aGlzLnRocm93SWZEaXNwb3NlZCgpLHh0LmF0YW4odGhpcyl9LHQucHJvdG90eXBlLnNpbmg9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy50aHJvd0lmRGlzcG9zZWQoKSx4dC5zaW5oKHRoaXMpfSx0LnByb3RvdHlwZS5jb3NoPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCkseHQuY29zaCh0aGlzKX0sdC5wcm90b3R5cGUudGFuaD1mdW5jdGlvbigpe3JldHVybiB0aGlzLnRocm93SWZEaXNwb3NlZCgpLHh0LnRhbmgodGhpcyl9LHQucHJvdG90eXBlLmFzaW5oPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCkseHQuYXNpbmgodGhpcyl9LHQucHJvdG90eXBlLmFjb3NoPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCkseHQuYWNvc2godGhpcyl9LHQucHJvdG90eXBlLmF0YW5oPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCkseHQuYXRhbmgodGhpcyl9LHQucHJvdG90eXBlLmVyZj1mdW5jdGlvbigpe3JldHVybiB0aGlzLnRocm93SWZEaXNwb3NlZCgpLHh0LmVyZih0aGlzKX0sdC5wcm90b3R5cGUucm91bmQ9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy50aHJvd0lmRGlzcG9zZWQoKSx4dC5yb3VuZCh0aGlzKX0sdC5wcm90b3R5cGUuc3RlcD1mdW5jdGlvbih0KXtyZXR1cm4gdm9pZCAwPT09dCYmKHQ9MCksdGhpcy50aHJvd0lmRGlzcG9zZWQoKSx4dC5zdGVwKHRoaXMsdCl9LHQucHJvdG90eXBlLnNvZnRtYXg9ZnVuY3Rpb24odCl7cmV0dXJuIHZvaWQgMD09PXQmJih0PS0xKSx0aGlzLnRocm93SWZEaXNwb3NlZCgpLHh0LnNvZnRtYXgodGhpcyx0KX0sdC5wcm90b3R5cGUubG9nU29mdG1heD1mdW5jdGlvbih0KXtyZXR1cm4gdm9pZCAwPT09dCYmKHQ9LTEpLHRoaXMudGhyb3dJZkRpc3Bvc2VkKCkseHQubG9nU29mdG1heCh0aGlzLHQpfSx0LnByb3RvdHlwZS5yZXNpemVCaWxpbmVhcj1mdW5jdGlvbih0LGUpe3JldHVybiB2b2lkIDA9PT1lJiYoZT0hMSksdGhpcy50aHJvd0lmRGlzcG9zZWQoKSx4dC5pbWFnZS5yZXNpemVCaWxpbmVhcih0aGlzLHQsZSl9LHQucHJvdG90eXBlLnJlc2l6ZU5lYXJlc3ROZWlnaGJvcj1mdW5jdGlvbih0LGUpe3JldHVybiB2b2lkIDA9PT1lJiYoZT0hMSksdGhpcy50aHJvd0lmRGlzcG9zZWQoKSx4dC5pbWFnZS5yZXNpemVOZWFyZXN0TmVpZ2hib3IodGhpcyx0LGUpfSx0LnByb3RvdHlwZS5jb252MWQ9ZnVuY3Rpb24odCxlLG4scixvLGEpe3JldHVybiB2b2lkIDA9PT1yJiYocj1cIk5XQ1wiKSx2b2lkIDA9PT1vJiYobz0xKSx0aGlzLnRocm93SWZEaXNwb3NlZCgpLHh0LmNvbnYxZCh0aGlzLHQsZSxuLHIsbyxhKX0sdC5wcm90b3R5cGUuY29udjJkPWZ1bmN0aW9uKHQsZSxuLHIsbyxhKXtyZXR1cm4gdm9pZCAwPT09ciYmKHI9XCJOSFdDXCIpLHZvaWQgMD09PW8mJihvPVsxLDFdKSx0aGlzLnRocm93SWZEaXNwb3NlZCgpLHh0LmNvbnYyZCh0aGlzLHQsZSxuLHIsbyxhKX0sdC5wcm90b3R5cGUuY29udjJkVHJhbnNwb3NlPWZ1bmN0aW9uKHQsZSxuLHIsbyl7cmV0dXJuIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCkseHQuY29udjJkVHJhbnNwb3NlKHRoaXMsdCxlLG4scixvKX0sdC5wcm90b3R5cGUuZGVwdGh3aXNlQ29udjJEPWZ1bmN0aW9uKHQsZSxuLHIsbyxhKXtyZXR1cm4gdm9pZCAwPT09ciYmKHI9XCJOSFdDXCIpLHZvaWQgMD09PW8mJihvPVsxLDFdKSx0aGlzLnRocm93SWZEaXNwb3NlZCgpLHh0LmRlcHRod2lzZUNvbnYyZCh0aGlzLHQsZSxuLHIsbyxhKX0sdC5wcm90b3R5cGUuc2VwYXJhYmxlQ29udjJkPWZ1bmN0aW9uKHQsZSxuLHIsbyxhKXtyZXR1cm4gdm9pZCAwPT09byYmKG89WzEsMV0pLHZvaWQgMD09PWEmJihhPVwiTkhXQ1wiKSx0aGlzLnRocm93SWZEaXNwb3NlZCgpLHh0LnNlcGFyYWJsZUNvbnYyZCh0aGlzLHQsZSxuLHIsbyxhKX0sdC5wcm90b3R5cGUuYXZnUG9vbD1mdW5jdGlvbih0LGUsbixyKXtyZXR1cm4gdGhpcy50aHJvd0lmRGlzcG9zZWQoKSx4dC5hdmdQb29sKHRoaXMsdCxlLG4scil9LHQucHJvdG90eXBlLm1heFBvb2w9ZnVuY3Rpb24odCxlLG4scil7cmV0dXJuIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCkseHQubWF4UG9vbCh0aGlzLHQsZSxuLHIpfSx0LnByb3RvdHlwZS5sb2NhbFJlc3BvbnNlTm9ybWFsaXphdGlvbj1mdW5jdGlvbih0LGUsbixyKXtyZXR1cm4gdm9pZCAwPT09dCYmKHQ9NSksdm9pZCAwPT09ZSYmKGU9MSksdm9pZCAwPT09biYmKG49MSksdm9pZCAwPT09ciYmKHI9LjUpLHh0LmxvY2FsUmVzcG9uc2VOb3JtYWxpemF0aW9uKHRoaXMsdCxlLG4scil9LHQucHJvdG90eXBlLnBvb2w9ZnVuY3Rpb24odCxlLG4scixvKXtyZXR1cm4gdGhpcy50aHJvd0lmRGlzcG9zZWQoKSx4dC5wb29sKHRoaXMsdCxlLG4scixvKX0sdC5wcm90b3R5cGUudmFyaWFibGU9ZnVuY3Rpb24odCxlLG4pe3JldHVybiB2b2lkIDA9PT10JiYodD0hMCksdGhpcy50aHJvd0lmRGlzcG9zZWQoKSx5dCgpLm1ha2VWYXJpYWJsZSh0aGlzLHQsZSxuKX0sdC5wcm90b3R5cGUudW5zb3J0ZWRTZWdtZW50U3VtPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCkseHQudW5zb3J0ZWRTZWdtZW50U3VtKHRoaXMsdCxlKX0sdC5wcm90b3R5cGUuYmF0Y2hUb1NwYWNlTkQ9ZnVuY3Rpb24odCxlKXtyZXR1cm4gdGhpcy50aHJvd0lmRGlzcG9zZWQoKSx4dC5iYXRjaFRvU3BhY2VORCh0aGlzLHQsZSl9LHQucHJvdG90eXBlLnNwYWNlVG9CYXRjaE5EPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCkseHQuc3BhY2VUb0JhdGNoTkQodGhpcyx0LGUpfSx0LnByb3RvdHlwZS50b3BrPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIHZvaWQgMD09PXQmJih0PTEpLHZvaWQgMD09PWUmJihlPSEwKSx0aGlzLnRocm93SWZEaXNwb3NlZCgpLHh0LnRvcGsodGhpcyx0LGUpfSx0LnByb3RvdHlwZS5zdHJpZGVkU2xpY2U9ZnVuY3Rpb24odCxlLG4scixvLGEsaSxzKXtyZXR1cm4gdm9pZCAwPT09ciYmKHI9MCksdm9pZCAwPT09byYmKG89MCksdm9pZCAwPT09YSYmKGE9MCksdm9pZCAwPT09aSYmKGk9MCksdm9pZCAwPT09cyYmKHM9MCksdGhpcy50aHJvd0lmRGlzcG9zZWQoKSx4dC5zdHJpZGVkU2xpY2UodGhpcyx0LGUsbixyLG8sYSxpLHMpfSx0LnByb3RvdHlwZS5kZXB0aFRvU3BhY2U9ZnVuY3Rpb24odCxlKXtyZXR1cm4gdGhpcy50aHJvd0lmRGlzcG9zZWQoKSx4dC5kZXB0aFRvU3BhY2UodGhpcyx0LGUpfSx0LnByb3RvdHlwZS5mZnQ9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy50aHJvd0lmRGlzcG9zZWQoKSx4dC5zcGVjdHJhbC5mZnQodGhpcyl9LHQucHJvdG90eXBlLmlmZnQ9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy50aHJvd0lmRGlzcG9zZWQoKSx4dC5zcGVjdHJhbC5pZmZ0KHRoaXMpfSx0LnByb3RvdHlwZS5yZmZ0PWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCkseHQuc3BlY3RyYWwucmZmdCh0aGlzKX0sdC5wcm90b3R5cGUuaXJmZnQ9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy50aHJvd0lmRGlzcG9zZWQoKSx4dC5zcGVjdHJhbC5pcmZmdCh0aGlzKX0sdH0oKTtPYmplY3QuZGVmaW5lUHJvcGVydHkod3QsU3ltYm9sLmhhc0luc3RhbmNlLHt2YWx1ZTpmdW5jdGlvbih0KXtyZXR1cm4hIXQmJm51bGwhPXQuZGF0YUlkJiZudWxsIT10LnNoYXBlJiZudWxsIT10LmR0eXBlfX0pO3ZhciBDdCxFdCxSdCxJdCxrdCxTdD1mdW5jdGlvbih0KXtmdW5jdGlvbiBuKGUsbixyLG8pe3ZhciBhPXQuY2FsbCh0aGlzLGUuc2hhcGUsZS5kdHlwZSxlLmRhdGFJZCxvKXx8dGhpcztyZXR1cm4gYS50cmFpbmFibGU9bixhLm5hbWU9cixhfXJldHVybiBlKG4sdCksbi5wcm90b3R5cGUuYXNzaWduPWZ1bmN0aW9uKHQpe2lmKHQuZHR5cGUhPT10aGlzLmR0eXBlKXRocm93IG5ldyBFcnJvcihcImR0eXBlIG9mIHRoZSBuZXcgdmFsdWUgKFwiK3QuZHR5cGUrXCIpIGFuZCBwcmV2aW91cyB2YWx1ZSAoXCIrdGhpcy5kdHlwZStcIikgbXVzdCBtYXRjaFwiKTtpZighUyh0LnNoYXBlLHRoaXMuc2hhcGUpKXRocm93IG5ldyBFcnJvcihcInNoYXBlIG9mIHRoZSBuZXcgdmFsdWUgKFwiK3Quc2hhcGUrXCIpIGFuZCBwcmV2aW91cyB2YWx1ZSAoXCIrdGhpcy5zaGFwZStcIikgbXVzdCBtYXRjaFwiKTt5dCgpLmRpc3Bvc2VUZW5zb3IodGhpcyksdGhpcy5kYXRhSWQ9dC5kYXRhSWQseXQoKS5pbmNSZWYodGhpcyxudWxsKX0sbi5wcm90b3R5cGUuZGlzcG9zZT1mdW5jdGlvbigpe3l0KCkuZGlzcG9zZVZhcmlhYmxlKHRoaXMpLHRoaXMuaXNEaXNwb3NlZEludGVybmFsPSEwfSxufSh3dCk7T2JqZWN0LmRlZmluZVByb3BlcnR5KFN0LFN5bWJvbC5oYXNJbnN0YW5jZSx7dmFsdWU6ZnVuY3Rpb24odCl7cmV0dXJuIHQgaW5zdGFuY2VvZiB3dCYmbnVsbCE9dC5hc3NpZ24mJnQuYXNzaWduIGluc3RhbmNlb2YgRnVuY3Rpb259fSksZnVuY3Rpb24odCl7dC5SMD1cIlIwXCIsdC5SMT1cIlIxXCIsdC5SMj1cIlIyXCIsdC5SMz1cIlIzXCIsdC5SND1cIlI0XCIsdC5SNT1cIlI1XCIsdC5SNj1cIlI2XCJ9KEN0fHwoQ3Q9e30pKSxmdW5jdGlvbih0KXt0LmZsb2F0MzI9XCJmbG9hdDMyXCIsdC5pbnQzMj1cImludDMyXCIsdC5ib29sPVwiaW50MzJcIix0LmNvbXBsZXg2ND1cImNvbXBsZXg2NFwifShFdHx8KEV0PXt9KSksZnVuY3Rpb24odCl7dC5mbG9hdDMyPVwiZmxvYXQzMlwiLHQuaW50MzI9XCJpbnQzMlwiLHQuYm9vbD1cImJvb2xcIix0LmNvbXBsZXg2ND1cImNvbXBsZXg2NFwifShSdHx8KFJ0PXt9KSksZnVuY3Rpb24odCl7dC5mbG9hdDMyPVwiZmxvYXQzMlwiLHQuaW50MzI9XCJmbG9hdDMyXCIsdC5ib29sPVwiZmxvYXQzMlwiLHQuY29tcGxleDY0PVwiY29tcGxleDY0XCJ9KEl0fHwoSXQ9e30pKSxmdW5jdGlvbih0KXt0LmZsb2F0MzI9XCJjb21wbGV4NjRcIix0LmludDMyPVwiY29tcGxleDY0XCIsdC5ib29sPVwiY29tcGxleDY0XCIsdC5jb21wbGV4NjQ9XCJjb21wbGV4NjRcIn0oa3R8fChrdD17fSkpO3ZhciBBdD17ZmxvYXQzMjpJdCxpbnQzMjpFdCxib29sOlJ0LGNvbXBsZXg2NDprdH07ZnVuY3Rpb24gRHQodCxlKXtpZihcInN0cmluZ1wiPT09dHx8XCJzdHJpbmdcIj09PWUpe2lmKFwic3RyaW5nXCI9PT10JiZcInN0cmluZ1wiPT09ZSlyZXR1cm5cInN0cmluZ1wiO3Rocm93IG5ldyBFcnJvcihcIkNhbiBub3QgdXBjYXN0IFwiK3QrXCIgd2l0aCBcIitlKX1yZXR1cm4gQXRbdF1bZV19ZnVuY3Rpb24gVHQodCl7cmV0dXJuIER0KHQsXCJpbnQzMlwiKX1mdW5jdGlvbiBOdCh0LGUpe2lmKHQuZHR5cGU9PT1lLmR0eXBlKXJldHVyblt0LGVdO3ZhciBuPUR0KHQuZHR5cGUsZS5kdHlwZSk7cmV0dXJuW3QuY2FzdChuKSxlLmNhc3QobildfWZ1bmN0aW9uIEZ0KHQsZSl7Qyh0LmR0eXBlPT09ZS5kdHlwZSwoZnVuY3Rpb24oKXtyZXR1cm5cIlRoZSBkdHlwZXMgb2YgdGhlIGZpcnN0KFwiK3QuZHR5cGUrXCIpIGFuZCBzZWNvbmQoXCIrZS5kdHlwZStcIikgaW5wdXQgbXVzdCBtYXRjaFwifSkpfWZ1bmN0aW9uIF90KHQpe3ZhciBlPVtdO3JldHVybiBmdW5jdGlvbiB0KGUsbixyKXtpZihudWxsPT1lKXJldHVybjtpZihlIGluc3RhbmNlb2Ygd3QpcmV0dXJuIHZvaWQgbi5wdXNoKGUpO2lmKG89ZSwhQXJyYXkuaXNBcnJheShvKSYmXCJvYmplY3RcIiE9dHlwZW9mIG8pcmV0dXJuO3ZhciBvO3ZhciBhPWU7Zm9yKHZhciBpIGluIGEpe3ZhciBzPWFbaV07ci5oYXMocyl8fChyLmFkZChzKSx0KHMsbixyKSl9fSh0LGUsbmV3IFNldCksZX12YXIgT3QsTXQ9T2JqZWN0LmZyZWV6ZSh7bWFrZVR5cGVzTWF0Y2g6TnQsYXNzZXJ0VHlwZXNNYXRjaDpGdCxpc1RlbnNvckluTGlzdDpmdW5jdGlvbih0LGUpe3JldHVybiBlLnNvbWUoKGZ1bmN0aW9uKGUpe3JldHVybiBlLmlkPT09dC5pZH0pKX0sZ2V0VGVuc29yc0luQ29udGFpbmVyOl90fSksQnQ9ZnVuY3Rpb24oKXtmdW5jdGlvbiB0KCl7dGhpcy5yZWdpc3RlcmVkVmFyaWFibGVzPXt9LHRoaXMubmV4dFRhcGVOb2RlSWQ9MCx0aGlzLm51bUJ5dGVzPTAsdGhpcy5udW1UZW5zb3JzPTAsdGhpcy5udW1TdHJpbmdUZW5zb3JzPTAsdGhpcy5udW1EYXRhQnVmZmVycz0wLHRoaXMuZ3JhZGllbnREZXB0aD0wLHRoaXMua2VybmVsRGVwdGg9MCx0aGlzLnNjb3BlU3RhY2s9W10sdGhpcy5udW1EYXRhTW92ZXNTdGFjaz1bXSx0aGlzLm5leHRTY29wZUlkPTAsdGhpcy50ZW5zb3JJbmZvPW5ldyBXZWFrTWFwLHRoaXMucHJvZmlsaW5nPSExLHRoaXMuYWN0aXZlUHJvZmlsZT17bmV3Qnl0ZXM6MCxuZXdUZW5zb3JzOjAscGVha0J5dGVzOjAsa2VybmVsczpbXSxyZXN1bHQ6bnVsbH19cmV0dXJuIHQucHJvdG90eXBlLmRpc3Bvc2U9ZnVuY3Rpb24oKXtmb3IodmFyIHQgaW4gdGhpcy5yZWdpc3RlcmVkVmFyaWFibGVzKXRoaXMucmVnaXN0ZXJlZFZhcmlhYmxlc1t0XS5kaXNwb3NlKCl9LHR9KCksUHQ9ZnVuY3Rpb24oKXtmdW5jdGlvbiB0KHQpe3RoaXMuRU5WPXQsdGhpcy5yZWdpc3RyeT17fSx0aGlzLnJlZ2lzdHJ5RmFjdG9yeT17fSx0aGlzLnBlbmRpbmdCYWNrZW5kSW5pdElkPTAsdGhpcy5zdGF0ZT1uZXcgQnR9cmV0dXJuIHQucHJvdG90eXBlLnJlYWR5PWZ1bmN0aW9uKCl7cmV0dXJuIG4odGhpcyx2b2lkIDAsdm9pZCAwLChmdW5jdGlvbigpe3ZhciB0LGUsbjtyZXR1cm4gcih0aGlzLChmdW5jdGlvbihyKXtzd2l0Y2goci5sYWJlbCl7Y2FzZSAwOmlmKG51bGwhPXRoaXMucGVuZGluZ0JhY2tlbmRJbml0KXJldHVyblsyLHRoaXMucGVuZGluZ0JhY2tlbmRJbml0LnRoZW4oKGZ1bmN0aW9uKCl7fSkpXTtpZihudWxsIT10aGlzLmJhY2tlbmRJbnN0YW5jZSlyZXR1cm5bMl07dD10aGlzLmdldFNvcnRlZEJhY2tlbmRzKCksZT0wLHIubGFiZWw9MTtjYXNlIDE6cmV0dXJuIGU8dC5sZW5ndGg/KG49dFtlXSxbNCx0aGlzLmluaXRpYWxpemVCYWNrZW5kKG4pLnN1Y2Nlc3NdKTpbMyw1XTtjYXNlIDI6cmV0dXJuIHIuc2VudCgpP1s0LHRoaXMuc2V0QmFja2VuZChuKV06WzMsNF07Y2FzZSAzOnJldHVybiByLnNlbnQoKSxbMl07Y2FzZSA0OnJldHVybiBlKyssWzMsMV07Y2FzZSA1OnRocm93IG5ldyBFcnJvcihcIkNvdWxkIG5vdCBpbml0aWFsaXplIGFueSBiYWNrZW5kcywgYWxsIGJhY2tlbmQgaW5pdGlhbGl6YXRpb25zIGZhaWxlZC5cIil9fSkpfSkpfSxPYmplY3QuZGVmaW5lUHJvcGVydHkodC5wcm90b3R5cGUsXCJiYWNrZW5kXCIse2dldDpmdW5jdGlvbigpe2lmKG51bGwhPXRoaXMucGVuZGluZ0JhY2tlbmRJbml0KXRocm93IG5ldyBFcnJvcihcIkJhY2tlbmQgJ1wiK3RoaXMuYmFja2VuZE5hbWUrXCInIGhhcyBub3QgeWV0IGJlZW4gaW5pdGlhbGl6ZWQuIE1ha2Ugc3VyZSB0byBhd2FpdCB0Zi5yZWFkeSgpIG9yIGF3YWl0IHRmLnNldEJhY2tlbmQoKSBiZWZvcmUgY2FsbGluZyBvdGhlciBtZXRob2RzXCIpO2lmKG51bGw9PXRoaXMuYmFja2VuZEluc3RhbmNlKXt2YXIgdD10aGlzLmluaXRpYWxpemVCYWNrZW5kc0FuZFJldHVybkJlc3QoKSxlPXQubmFtZTtpZih0LmFzeW5jSW5pdCl0aHJvdyBuZXcgRXJyb3IoXCJUaGUgaGlnaGVzdCBwcmlvcml0eSBiYWNrZW5kICdcIitlK1wiJyBoYXMgbm90IHlldCBiZWVuIGluaXRpYWxpemVkLiBNYWtlIHN1cmUgdG8gYXdhaXQgdGYucmVhZHkoKSBvciBhd2FpdCB0Zi5zZXRCYWNrZW5kKCkgYmVmb3JlIGNhbGxpbmcgb3RoZXIgbWV0aG9kc1wiKTt0aGlzLnNldEJhY2tlbmQoZSl9cmV0dXJuIHRoaXMuYmFja2VuZEluc3RhbmNlfSxlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMH0pLHQucHJvdG90eXBlLmJhY2tlbmROYW1lcz1mdW5jdGlvbigpe3JldHVybiBPYmplY3Qua2V5cyh0aGlzLnJlZ2lzdHJ5RmFjdG9yeSl9LHQucHJvdG90eXBlLmZpbmRCYWNrZW5kPWZ1bmN0aW9uKHQpe2lmKCEodCBpbiB0aGlzLnJlZ2lzdHJ5KSl7aWYoISh0IGluIHRoaXMucmVnaXN0cnlGYWN0b3J5KSlyZXR1cm4gbnVsbDtpZih0aGlzLmluaXRpYWxpemVCYWNrZW5kKHQpLmFzeW5jSW5pdClyZXR1cm4gbnVsbH1yZXR1cm4gdGhpcy5yZWdpc3RyeVt0XX0sdC5wcm90b3R5cGUuZmluZEJhY2tlbmRGYWN0b3J5PWZ1bmN0aW9uKHQpe3JldHVybiB0IGluIHRoaXMucmVnaXN0cnlGYWN0b3J5P3RoaXMucmVnaXN0cnlGYWN0b3J5W3RdLmZhY3Rvcnk6bnVsbH0sdC5wcm90b3R5cGUucmVnaXN0ZXJCYWNrZW5kPWZ1bmN0aW9uKHQsZSxuKXtyZXR1cm4gdm9pZCAwPT09biYmKG49MSksdCBpbiB0aGlzLnJlZ2lzdHJ5RmFjdG9yeT8oY29uc29sZS53YXJuKHQrXCIgYmFja2VuZCB3YXMgYWxyZWFkeSByZWdpc3RlcmVkLiBSZXVzaW5nIGV4aXN0aW5nIGJhY2tlbmQgZmFjdG9yeS5cIiksITEpOih0aGlzLnJlZ2lzdHJ5RmFjdG9yeVt0XT17ZmFjdG9yeTplLHByaW9yaXR5Om59LCEwKX0sdC5wcm90b3R5cGUuc2V0QmFja2VuZD1mdW5jdGlvbih0KXtyZXR1cm4gbih0aGlzLHZvaWQgMCx2b2lkIDAsKGZ1bmN0aW9uKCl7dmFyIGUsbixvO3JldHVybiByKHRoaXMsKGZ1bmN0aW9uKHIpe3N3aXRjaChyLmxhYmVsKXtjYXNlIDA6aWYobnVsbD09dGhpcy5yZWdpc3RyeUZhY3RvcnlbdF0pdGhyb3cgbmV3IEVycm9yKFwiQmFja2VuZCBuYW1lICdcIit0K1wiJyBub3QgZm91bmQgaW4gcmVnaXN0cnlcIik7cmV0dXJuIHRoaXMuYmFja2VuZE5hbWU9dCxudWxsIT10aGlzLnJlZ2lzdHJ5W3RdP1szLDRdOih0aGlzLmJhY2tlbmRJbnN0YW5jZT1udWxsLGU9dGhpcy5pbml0aWFsaXplQmFja2VuZCh0KSxuPWUuc3VjY2VzcyxlLmFzeW5jSW5pdD9bNCxuXTpbMywyXSk7Y2FzZSAxOnJldHVybiBvPXIuc2VudCgpLFszLDNdO2Nhc2UgMjpvPW4sci5sYWJlbD0zO2Nhc2UgMzppZighbylyZXR1cm5bMiwhMV07ci5sYWJlbD00O2Nhc2UgNDpyZXR1cm4gdGhpcy5iYWNrZW5kSW5zdGFuY2U9dGhpcy5yZWdpc3RyeVt0XSx0aGlzLnNldHVwUmVnaXN0ZXJlZEtlcm5lbHMoKSx0aGlzLnByb2ZpbGVyPW5ldyB1dCh0aGlzLmJhY2tlbmRJbnN0YW5jZSksWzIsITBdfX0pKX0pKX0sdC5wcm90b3R5cGUuc2V0dXBSZWdpc3RlcmVkS2VybmVscz1mdW5jdGlvbigpe3ZhciB0PXRoaXM7Zih0aGlzLmJhY2tlbmROYW1lKS5mb3JFYWNoKChmdW5jdGlvbihlKXtudWxsIT1lLnNldHVwRnVuYyYmZS5zZXR1cEZ1bmModC5iYWNrZW5kSW5zdGFuY2UpfSkpfSx0LnByb3RvdHlwZS5kaXNwb3NlUmVnaXN0ZXJlZEtlcm5lbHM9ZnVuY3Rpb24odCl7dmFyIGU9dGhpcztmKHQpLmZvckVhY2goKGZ1bmN0aW9uKG4pe251bGwhPW4uZGlzcG9zZUZ1bmMmJm4uZGlzcG9zZUZ1bmMoZS5yZWdpc3RyeVt0XSl9KSl9LHQucHJvdG90eXBlLmluaXRpYWxpemVCYWNrZW5kPWZ1bmN0aW9uKHQpe3ZhciBlPXRoaXMsbj10aGlzLnJlZ2lzdHJ5RmFjdG9yeVt0XTtpZihudWxsPT1uKXRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBpbml0aWFsaXplIGJhY2tlbmQgXCIrdCtcIiwgbm8gcmVnaXN0cmF0aW9uIGZvdW5kLlwiKTt0cnl7dmFyIHI9bi5mYWN0b3J5KCk7aWYoUHJvbWlzZS5yZXNvbHZlKHIpPT09cil7dmFyIG89Kyt0aGlzLnBlbmRpbmdCYWNrZW5kSW5pdElkLGE9ci50aGVuKChmdW5jdGlvbihuKXtyZXR1cm4hKG88ZS5wZW5kaW5nQmFja2VuZEluaXRJZCkmJihlLnJlZ2lzdHJ5W3RdPW4sZS5wZW5kaW5nQmFja2VuZEluaXQ9bnVsbCwhMCl9KSkuY2F0Y2goKGZ1bmN0aW9uKG4pe3JldHVybiEobzxlLnBlbmRpbmdCYWNrZW5kSW5pdElkKSYmKGUucGVuZGluZ0JhY2tlbmRJbml0PW51bGwsY29uc29sZS53YXJuKFwiSW5pdGlhbGl6YXRpb24gb2YgYmFja2VuZCBcIit0K1wiIGZhaWxlZFwiKSxjb25zb2xlLndhcm4obi5zdGFja3x8bi5tZXNzYWdlKSwhMSl9KSk7cmV0dXJuIHRoaXMucGVuZGluZ0JhY2tlbmRJbml0PWEse3N1Y2Nlc3M6YSxhc3luY0luaXQ6ITB9fXJldHVybiB0aGlzLnJlZ2lzdHJ5W3RdPXIse3N1Y2Nlc3M6ITAsYXN5bmNJbml0OiExfX1jYXRjaChlKXtyZXR1cm4gY29uc29sZS53YXJuKFwiSW5pdGlhbGl6YXRpb24gb2YgYmFja2VuZCBcIit0K1wiIGZhaWxlZFwiKSxjb25zb2xlLndhcm4oZS5zdGFja3x8ZS5tZXNzYWdlKSx7c3VjY2VzczohMSxhc3luY0luaXQ6ITF9fX0sdC5wcm90b3R5cGUucmVtb3ZlQmFja2VuZD1mdW5jdGlvbih0KXtpZighKHQgaW4gdGhpcy5yZWdpc3RyeUZhY3RvcnkpKXRocm93IG5ldyBFcnJvcih0K1wiIGJhY2tlbmQgbm90IGZvdW5kIGluIHJlZ2lzdHJ5XCIpO3RoaXMuYmFja2VuZE5hbWU9PT10JiZudWxsIT10aGlzLnBlbmRpbmdCYWNrZW5kSW5pdCYmdGhpcy5wZW5kaW5nQmFja2VuZEluaXRJZCsrLHQgaW4gdGhpcy5yZWdpc3RyeSYmKHRoaXMuZGlzcG9zZVJlZ2lzdGVyZWRLZXJuZWxzKHQpLHRoaXMucmVnaXN0cnlbdF0uZGlzcG9zZSgpLGRlbGV0ZSB0aGlzLnJlZ2lzdHJ5W3RdKSxkZWxldGUgdGhpcy5yZWdpc3RyeUZhY3RvcnlbdF0sdGhpcy5iYWNrZW5kTmFtZT09PXQmJih0aGlzLnBlbmRpbmdCYWNrZW5kSW5pdD1udWxsLHRoaXMuYmFja2VuZE5hbWU9bnVsbCx0aGlzLmJhY2tlbmRJbnN0YW5jZT1udWxsKX0sdC5wcm90b3R5cGUuZ2V0U29ydGVkQmFja2VuZHM9ZnVuY3Rpb24oKXt2YXIgdD10aGlzO2lmKDA9PT1PYmplY3Qua2V5cyh0aGlzLnJlZ2lzdHJ5RmFjdG9yeSkubGVuZ3RoKXRocm93IG5ldyBFcnJvcihcIk5vIGJhY2tlbmQgZm91bmQgaW4gcmVnaXN0cnkuXCIpO3JldHVybiBPYmplY3Qua2V5cyh0aGlzLnJlZ2lzdHJ5RmFjdG9yeSkuc29ydCgoZnVuY3Rpb24oZSxuKXtyZXR1cm4gdC5yZWdpc3RyeUZhY3Rvcnlbbl0ucHJpb3JpdHktdC5yZWdpc3RyeUZhY3RvcnlbZV0ucHJpb3JpdHl9KSl9LHQucHJvdG90eXBlLmluaXRpYWxpemVCYWNrZW5kc0FuZFJldHVybkJlc3Q9ZnVuY3Rpb24oKXtmb3IodmFyIHQ9dGhpcy5nZXRTb3J0ZWRCYWNrZW5kcygpLGU9MDtlPHQubGVuZ3RoO2UrKyl7dmFyIG49dFtlXSxyPXRoaXMuaW5pdGlhbGl6ZUJhY2tlbmQobiksbz1yLnN1Y2Nlc3MsYT1yLmFzeW5jSW5pdDtpZihhfHxvKXJldHVybntuYW1lOm4sYXN5bmNJbml0OmF9fXRocm93IG5ldyBFcnJvcihcIkNvdWxkIG5vdCBpbml0aWFsaXplIGFueSBiYWNrZW5kcywgYWxsIGJhY2tlbmQgaW5pdGlhbGl6YXRpb25zIGZhaWxlZC5cIil9LHQucHJvdG90eXBlLm1vdmVEYXRhPWZ1bmN0aW9uKHQsZSl7dmFyIG49dGhpcy5zdGF0ZS50ZW5zb3JJbmZvLmdldChlKSxyPW4uYmFja2VuZCxvPXRoaXMucmVhZFN5bmMoZSk7ci5kaXNwb3NlRGF0YShlKSxuLmJhY2tlbmQ9dCx0Lm1vdmUoZSxvLG4uc2hhcGUsbi5kdHlwZSksdGhpcy5zaG91bGRDaGVja0Zvck1lbUxlYWtzKCkmJnRoaXMuc3RhdGUubnVtRGF0YU1vdmVzU3RhY2tbdGhpcy5zdGF0ZS5udW1EYXRhTW92ZXNTdGFjay5sZW5ndGgtMV0rK30sdC5wcm90b3R5cGUudGlkeT1mdW5jdGlvbih0LGUpe3ZhciBuLHI9dGhpcyxvPW51bGw7aWYobnVsbD09ZSl7aWYoXCJmdW5jdGlvblwiIT10eXBlb2YgdCl0aHJvdyBuZXcgRXJyb3IoXCJQbGVhc2UgcHJvdmlkZSBhIGZ1bmN0aW9uIHRvIHRpZHkoKVwiKTtlPXR9ZWxzZXtpZihcInN0cmluZ1wiIT10eXBlb2YgdCYmISh0IGluc3RhbmNlb2YgU3RyaW5nKSl0aHJvdyBuZXcgRXJyb3IoXCJXaGVuIGNhbGxpbmcgd2l0aCB0d28gYXJndW1lbnRzLCB0aGUgZmlyc3QgYXJndW1lbnQgdG8gdGlkeSgpIG11c3QgYmUgYSBzdHJpbmdcIik7aWYoXCJmdW5jdGlvblwiIT10eXBlb2YgZSl0aHJvdyBuZXcgRXJyb3IoXCJXaGVuIGNhbGxpbmcgd2l0aCB0d28gYXJndW1lbnRzLCB0aGUgMm5kIGFyZ3VtZW50IHRvIHRpZHkoKSBtdXN0IGJlIGEgZnVuY3Rpb25cIik7bz10fXJldHVybiB0aGlzLnNjb3BlZFJ1bigoZnVuY3Rpb24oKXtyZXR1cm4gci5zdGFydFNjb3BlKG8pfSksKGZ1bmN0aW9uKCl7cmV0dXJuIHIuZW5kU2NvcGUobil9KSwoZnVuY3Rpb24oKXtyZXR1cm4obj1lKCkpaW5zdGFuY2VvZiBQcm9taXNlJiZjb25zb2xlLmVycm9yKFwiQ2Fubm90IHJldHVybiBhIFByb21pc2UgaW5zaWRlIG9mIHRpZHkuXCIpLG59KSl9LHQucHJvdG90eXBlLnNjb3BlZFJ1bj1mdW5jdGlvbih0LGUsbil7dCgpO3RyeXt2YXIgcj1uKCk7cmV0dXJuIGUoKSxyfWNhdGNoKHQpe3Rocm93IGUoKSx0fX0sdC5wcm90b3R5cGUubmV4dFRlbnNvcklkPWZ1bmN0aW9uKCl7cmV0dXJuIHQubmV4dFRlbnNvcklkKyt9LHQucHJvdG90eXBlLm5leHRWYXJpYWJsZUlkPWZ1bmN0aW9uKCl7cmV0dXJuIHQubmV4dFZhcmlhYmxlSWQrK30sdC5wcm90b3R5cGUuY2xvbmU9ZnVuY3Rpb24odCl7dmFyIGU9dGhpcy5tYWtlVGVuc29yRnJvbURhdGFJZCh0LmRhdGFJZCx0LnNoYXBlLHQuZHR5cGUpLG49e3g6dH07cmV0dXJuIHRoaXMuYWRkVGFwZU5vZGUodGhpcy5zdGF0ZS5hY3RpdmVTY29wZS5uYW1lLG4sW2VdLChmdW5jdGlvbih0KXtyZXR1cm57eDpmdW5jdGlvbigpe3JldHVybiB0LnRvRmxvYXQoKX19fSksW10pLGV9LHQucHJvdG90eXBlLnJ1bktlcm5lbD1mdW5jdGlvbih0LGUsbixyLG8pe3JldHVybiB0aGlzLnJ1bktlcm5lbEZ1bmMobnVsbCxlLG51bGwsdCxuLHIsbyl9LHQucHJvdG90eXBlLnNob3VsZENoZWNrRm9yTWVtTGVha3M9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5FTlYuZ2V0Qm9vbChcIklTX1RFU1RcIil9LHQucHJvdG90eXBlLmNoZWNrS2VybmVsRm9yTWVtTGVhaz1mdW5jdGlvbih0LGUsbil7dmFyIHI9dGhpcy5iYWNrZW5kLm51bURhdGFJZHMoKSxvPTA7bi5mb3JFYWNoKChmdW5jdGlvbih0KXtvKz1cImNvbXBsZXg2NFwiPT09dC5kdHlwZT8zOjF9KSk7dmFyIGE9dGhpcy5zdGF0ZS5udW1EYXRhTW92ZXNTdGFja1t0aGlzLnN0YXRlLm51bURhdGFNb3Zlc1N0YWNrLmxlbmd0aC0xXSxpPXItZS1vLWE7aWYoaT4wKXRocm93IG5ldyBFcnJvcihcIkJhY2tlbmQgJ1wiK3RoaXMuYmFja2VuZE5hbWUrXCInIGhhcyBhbiBpbnRlcm5hbCBtZW1vcnkgbGVhayAoXCIraStcIiBkYXRhIGlkcykgYWZ0ZXIgcnVubmluZyAnXCIrdCtcIidcIil9LHQucHJvdG90eXBlLnJ1bktlcm5lbEZ1bmM9ZnVuY3Rpb24odCxlLG4scixvLGEsaSl7dmFyIHMsdT10aGlzO3ZvaWQgMD09PWEmJihhPVtdKSx2b2lkIDA9PT1pJiYoaT1bXSk7dmFyIGM9W10saD10aGlzLmlzVGFwZU9uKCk7bnVsbD09ciYmKHI9bnVsbCE9dGhpcy5zdGF0ZS5hY3RpdmVTY29wZT90aGlzLnN0YXRlLmFjdGl2ZVNjb3BlLm5hbWU6XCJcIik7dmFyIGYsZD1mdW5jdGlvbih0KXtoJiYoYz10Lm1hcCgoZnVuY3Rpb24odCl7cmV0dXJuIHUua2VlcCh1LmNsb25lKHQpKX0pKSl9LHA9dGhpcy5zdGF0ZS5udW1CeXRlcyx2PXRoaXMuc3RhdGUubnVtVGVuc29yczt0aGlzLnNob3VsZENoZWNrRm9yTWVtTGVha3MoKSYmdGhpcy5zdGF0ZS5udW1EYXRhTW92ZXNTdGFjay5wdXNoKDApO3ZhciBtLGc9bChyLHRoaXMuYmFja2VuZE5hbWUpO3JldHVybiBmPW51bGwhPWc/ZnVuY3Rpb24oKXt2YXIgdD11LmJhY2tlbmQubnVtRGF0YUlkcygpO209Zy5rZXJuZWxGdW5jKHtpbnB1dHM6ZSxhdHRyczpvLGJhY2tlbmQ6dS5iYWNrZW5kfSk7dmFyIG49QXJyYXkuaXNBcnJheShtKT9tOlttXTt1LnNob3VsZENoZWNrRm9yTWVtTGVha3MoKSYmdS5jaGVja0tlcm5lbEZvck1lbUxlYWsocix0LG4pO3ZhciBzPW4ubWFwKChmdW5jdGlvbih0KXt2YXIgZT10LmRhdGFJZCxuPXQuc2hhcGUscj10LmR0eXBlO3JldHVybiB1Lm1ha2VUZW5zb3JGcm9tRGF0YUlkKGUsbixyKX0pKSxjPXMuZmlsdGVyKChmdW5jdGlvbih0LGUpe3JldHVybiBpW2VdfSkpO3JldHVybiBkKChhfHxbXSkuc2xpY2UoKS5jb25jYXQoYykpLHN9OmZ1bmN0aW9uKCl7dmFyIGU9dS5iYWNrZW5kLm51bURhdGFJZHMoKTttPXUudGlkeSgoZnVuY3Rpb24oKXtyZXR1cm4gdCh1LmJhY2tlbmQsZCl9KSk7dmFyIG49QXJyYXkuaXNBcnJheShtKT9tOlttXTtyZXR1cm4gdS5zaG91bGRDaGVja0Zvck1lbUxlYWtzKCkmJnUuY2hlY2tLZXJuZWxGb3JNZW1MZWFrKHIsZSxuKSxufSx0aGlzLnNjb3BlZFJ1bigoZnVuY3Rpb24oKXtyZXR1cm4gdS5zdGF0ZS5rZXJuZWxEZXB0aCsrfSksKGZ1bmN0aW9uKCl7cmV0dXJuIHUuc3RhdGUua2VybmVsRGVwdGgtLX0pLChmdW5jdGlvbigpe3M9dS5FTlYuZ2V0Qm9vbChcIkRFQlVHXCIpP3UucHJvZmlsZXIucHJvZmlsZUtlcm5lbChyLGUsKGZ1bmN0aW9uKCl7cmV0dXJuIGYoKX0pKTpmKCl9KSksaCYmdGhpcy5hZGRUYXBlTm9kZShyLGUscyxuLGMpLHRoaXMuc3RhdGUucHJvZmlsaW5nJiZ0aGlzLnN0YXRlLmFjdGl2ZVByb2ZpbGUua2VybmVscy5wdXNoKHtuYW1lOnIsYnl0ZXNBZGRlZDp0aGlzLnN0YXRlLm51bUJ5dGVzLXAsdG90YWxCeXRlc1NuYXBzaG90OnRoaXMuc3RhdGUubnVtQnl0ZXMsdGVuc29yc0FkZGVkOnRoaXMuc3RhdGUubnVtVGVuc29ycy12LHRvdGFsVGVuc29yc1NuYXBzaG90OnRoaXMuc3RhdGUubnVtVGVuc29ycyxpbnB1dFNoYXBlczpPYmplY3Qua2V5cyhlKS5tYXAoKGZ1bmN0aW9uKHQpe3JldHVybiBlW3RdLnNoYXBlfSkpLG91dHB1dFNoYXBlczpzLm1hcCgoZnVuY3Rpb24odCl7cmV0dXJuIHQuc2hhcGV9KSl9KSxBcnJheS5pc0FycmF5KG0pP3M6c1swXX0sdC5wcm90b3R5cGUubWFrZVRlbnNvcj1mdW5jdGlvbih0LGUsbixyKXtpZihudWxsPT10KXRocm93IG5ldyBFcnJvcihcIlZhbHVlcyBwYXNzZWQgdG8gZW5naW5lLm1ha2VUZW5zb3IoKSBhcmUgbnVsbFwiKTtuPW58fFwiZmxvYXQzMlwiLHI9cnx8dGhpcy5iYWNrZW5kO3ZhciBvPXQ7XCJzdHJpbmdcIj09PW4mJkgodFswXSkmJihvPXQubWFwKChmdW5jdGlvbih0KXtyZXR1cm4gcnQodCl9KSkpO3ZhciBhPXIud3JpdGUobyxlLG4pLGk9bmV3IHd0KGUsbixhLHRoaXMubmV4dFRlbnNvcklkKCkpO2lmKHRoaXMuaW5jUmVmKGksciksXCJzdHJpbmdcIj09PW4pe3ZhciBzPXRoaXMuc3RhdGUudGVuc29ySW5mby5nZXQoYSksdT1HKG8pO3RoaXMuc3RhdGUubnVtQnl0ZXMrPXUtcy5ieXRlcyxzLmJ5dGVzPXV9cmV0dXJuIGl9LHQucHJvdG90eXBlLm1ha2VUZW5zb3JGcm9tRGF0YUlkPWZ1bmN0aW9uKHQsZSxuLHIpe3ZhciBvPW5ldyB3dChlLG49bnx8XCJmbG9hdDMyXCIsdCx0aGlzLm5leHRUZW5zb3JJZCgpKTtyZXR1cm4gdGhpcy5pbmNSZWYobyxyKSxvfSx0LnByb3RvdHlwZS5tYWtlVmFyaWFibGU9ZnVuY3Rpb24odCxlLG4scil7dm9pZCAwPT09ZSYmKGU9ITApLG49bnx8dGhpcy5uZXh0VmFyaWFibGVJZCgpLnRvU3RyaW5nKCksbnVsbCE9ciYmciE9PXQuZHR5cGUmJih0PXQuYXNUeXBlKHIpKTt2YXIgbz1uZXcgU3QodCxlLG4sdGhpcy5uZXh0VGVuc29ySWQoKSk7aWYobnVsbCE9dGhpcy5zdGF0ZS5yZWdpc3RlcmVkVmFyaWFibGVzW28ubmFtZV0pdGhyb3cgbmV3IEVycm9yKFwiVmFyaWFibGUgd2l0aCBuYW1lIFwiK28ubmFtZStcIiB3YXMgYWxyZWFkeSByZWdpc3RlcmVkXCIpO3JldHVybiB0aGlzLnN0YXRlLnJlZ2lzdGVyZWRWYXJpYWJsZXNbby5uYW1lXT1vLHRoaXMuaW5jUmVmKG8sdGhpcy5iYWNrZW5kKSxvfSx0LnByb3RvdHlwZS5pbmNSZWY9ZnVuY3Rpb24odCxlKXt2YXIgbj10aGlzLnN0YXRlLnRlbnNvckluZm8uaGFzKHQuZGF0YUlkKT90aGlzLnN0YXRlLnRlbnNvckluZm8uZ2V0KHQuZGF0YUlkKS5yZWZDb3VudDowO2lmKHRoaXMuc3RhdGUubnVtVGVuc29ycysrLFwic3RyaW5nXCI9PT10LmR0eXBlJiZ0aGlzLnN0YXRlLm51bVN0cmluZ1RlbnNvcnMrKywwPT09bil7dGhpcy5zdGF0ZS5udW1EYXRhQnVmZmVycysrO3ZhciByPTA7XCJjb21wbGV4NjRcIiE9PXQuZHR5cGUmJlwic3RyaW5nXCIhPT10LmR0eXBlJiYocj10LnNpemUqeih0LmR0eXBlKSksdGhpcy5zdGF0ZS50ZW5zb3JJbmZvLnNldCh0LmRhdGFJZCx7YmFja2VuZDplfHx0aGlzLmJhY2tlbmQsZHR5cGU6dC5kdHlwZSxzaGFwZTp0LnNoYXBlLGJ5dGVzOnIscmVmQ291bnQ6MH0pLHRoaXMuc3RhdGUubnVtQnl0ZXMrPXJ9dGhpcy5zdGF0ZS50ZW5zb3JJbmZvLmdldCh0LmRhdGFJZCkucmVmQ291bnQrKyx0IGluc3RhbmNlb2YgU3R8fHRoaXMudHJhY2sodCl9LHQucHJvdG90eXBlLmRpc3Bvc2VUZW5zb3I9ZnVuY3Rpb24odCl7aWYodGhpcy5zdGF0ZS50ZW5zb3JJbmZvLmhhcyh0LmRhdGFJZCkpe3RoaXMuc3RhdGUubnVtVGVuc29ycy0tLFwic3RyaW5nXCI9PT10LmR0eXBlJiZ0aGlzLnN0YXRlLm51bVN0cmluZ1RlbnNvcnMtLTt2YXIgZT10aGlzLnN0YXRlLnRlbnNvckluZm8uZ2V0KHQuZGF0YUlkKTtlLnJlZkNvdW50PD0xPyhcImNvbXBsZXg2NFwiIT09dC5kdHlwZSYmKHRoaXMuc3RhdGUubnVtQnl0ZXMtPWUuYnl0ZXMpLHRoaXMuc3RhdGUubnVtRGF0YUJ1ZmZlcnMtLSxlLmJhY2tlbmQuZGlzcG9zZURhdGEodC5kYXRhSWQpLHRoaXMuc3RhdGUudGVuc29ySW5mby5kZWxldGUodC5kYXRhSWQpKTp0aGlzLnN0YXRlLnRlbnNvckluZm8uZ2V0KHQuZGF0YUlkKS5yZWZDb3VudC0tfX0sdC5wcm90b3R5cGUuZGlzcG9zZVZhcmlhYmxlcz1mdW5jdGlvbigpe2Zvcih2YXIgdCBpbiB0aGlzLnN0YXRlLnJlZ2lzdGVyZWRWYXJpYWJsZXMpe3ZhciBlPXRoaXMuc3RhdGUucmVnaXN0ZXJlZFZhcmlhYmxlc1t0XTt0aGlzLmRpc3Bvc2VWYXJpYWJsZShlKX19LHQucHJvdG90eXBlLmRpc3Bvc2VWYXJpYWJsZT1mdW5jdGlvbih0KXt0aGlzLmRpc3Bvc2VUZW5zb3IodCksbnVsbCE9dGhpcy5zdGF0ZS5yZWdpc3RlcmVkVmFyaWFibGVzW3QubmFtZV0mJmRlbGV0ZSB0aGlzLnN0YXRlLnJlZ2lzdGVyZWRWYXJpYWJsZXNbdC5uYW1lXX0sdC5wcm90b3R5cGUubWVtb3J5PWZ1bmN0aW9uKCl7dmFyIHQ9dGhpcy5iYWNrZW5kLm1lbW9yeSgpO3JldHVybiB0Lm51bVRlbnNvcnM9dGhpcy5zdGF0ZS5udW1UZW5zb3JzLHQubnVtRGF0YUJ1ZmZlcnM9dGhpcy5zdGF0ZS5udW1EYXRhQnVmZmVycyx0Lm51bUJ5dGVzPXRoaXMuc3RhdGUubnVtQnl0ZXMsdGhpcy5zdGF0ZS5udW1TdHJpbmdUZW5zb3JzPjAmJih0LnVucmVsaWFibGU9ITAsbnVsbD09dC5yZWFzb25zJiYodC5yZWFzb25zPVtdKSx0LnJlYXNvbnMucHVzaChcIk1lbW9yeSB1c2FnZSBieSBzdHJpbmcgdGVuc29ycyBpcyBhcHByb3hpbWF0ZSAoMiBieXRlcyBwZXIgY2hhcmFjdGVyKVwiKSksdH0sdC5wcm90b3R5cGUucHJvZmlsZT1mdW5jdGlvbih0KXtyZXR1cm4gbih0aGlzLHZvaWQgMCx2b2lkIDAsKGZ1bmN0aW9uKCl7dmFyIGUsbjtyZXR1cm4gcih0aGlzLChmdW5jdGlvbihyKXtyZXR1cm4gdGhpcy5zdGF0ZS5wcm9maWxpbmc9ITAsZT10aGlzLnN0YXRlLm51bUJ5dGVzLG49dGhpcy5zdGF0ZS5udW1UZW5zb3JzLHRoaXMuc3RhdGUuYWN0aXZlUHJvZmlsZS5rZXJuZWxzPVtdLHRoaXMuc3RhdGUuYWN0aXZlUHJvZmlsZS5yZXN1bHQ9dCgpLHRoaXMuc3RhdGUucHJvZmlsaW5nPSExLHRoaXMuc3RhdGUuYWN0aXZlUHJvZmlsZS5wZWFrQnl0ZXM9TWF0aC5tYXguYXBwbHkoTWF0aCx0aGlzLnN0YXRlLmFjdGl2ZVByb2ZpbGUua2VybmVscy5tYXAoKGZ1bmN0aW9uKHQpe3JldHVybiB0LnRvdGFsQnl0ZXNTbmFwc2hvdH0pKSksdGhpcy5zdGF0ZS5hY3RpdmVQcm9maWxlLm5ld0J5dGVzPXRoaXMuc3RhdGUubnVtQnl0ZXMtZSx0aGlzLnN0YXRlLmFjdGl2ZVByb2ZpbGUubmV3VGVuc29ycz10aGlzLnN0YXRlLm51bVRlbnNvcnMtbixbMix0aGlzLnN0YXRlLmFjdGl2ZVByb2ZpbGVdfSkpfSkpfSx0LnByb3RvdHlwZS5pc1RhcGVPbj1mdW5jdGlvbigpe3JldHVybiB0aGlzLnN0YXRlLmdyYWRpZW50RGVwdGg+MCYmMD09PXRoaXMuc3RhdGUua2VybmVsRGVwdGh9LHQucHJvdG90eXBlLmFkZFRhcGVOb2RlPWZ1bmN0aW9uKHQsZSxuLHIsbyl7dmFyIGE9dGhpcyxpPXtpZDp0aGlzLnN0YXRlLm5leHRUYXBlTm9kZUlkKyssa2VybmVsTmFtZTp0LGlucHV0czplLG91dHB1dHM6bixzYXZlZDpvfSxzPWgodCk7bnVsbCE9cyYmKHI9cy5ncmFkRnVuYyksbnVsbCE9ciYmKGkuZ3JhZGllbnQ9ZnVuY3Rpb24odCl7cmV0dXJuIHQ9dC5tYXAoKGZ1bmN0aW9uKHQsZSl7aWYobnVsbD09dCl7dmFyIHI9bltlXSxvPXR0KHIuc2l6ZSxyLmR0eXBlKTtyZXR1cm4gYS5tYWtlVGVuc29yKG8sci5zaGFwZSxyLmR0eXBlKX1yZXR1cm4gdH0pKSxyKHQubGVuZ3RoPjE/dDp0WzBdLG8pfSksdGhpcy5zdGF0ZS5hY3RpdmVUYXBlLnB1c2goaSl9LHQucHJvdG90eXBlLmtlZXA9ZnVuY3Rpb24odCl7cmV0dXJuIHQua2VwdD0hMCx0fSx0LnByb3RvdHlwZS5zdGFydFRhcGU9ZnVuY3Rpb24oKXswPT09dGhpcy5zdGF0ZS5ncmFkaWVudERlcHRoJiYodGhpcy5zdGF0ZS5hY3RpdmVUYXBlPVtdKSx0aGlzLnN0YXRlLmdyYWRpZW50RGVwdGgrK30sdC5wcm90b3R5cGUuZW5kVGFwZT1mdW5jdGlvbigpe3RoaXMuc3RhdGUuZ3JhZGllbnREZXB0aC0tfSx0LnByb3RvdHlwZS5zdGFydFNjb3BlPWZ1bmN0aW9uKHQpe3ZhciBlPXt0cmFjazpbXSxuYW1lOlwidW5uYW1lZCBzY29wZVwiLGlkOnRoaXMuc3RhdGUubmV4dFNjb3BlSWQrK307dCYmKGUubmFtZT10KSx0aGlzLnN0YXRlLnNjb3BlU3RhY2sucHVzaChlKSx0aGlzLnN0YXRlLmFjdGl2ZVNjb3BlPWV9LHQucHJvdG90eXBlLmVuZFNjb3BlPWZ1bmN0aW9uKHQpe2Zvcih2YXIgZT10aGlzLG49X3QodCkscj1uZXcgU2V0KG4ubWFwKChmdW5jdGlvbih0KXtyZXR1cm4gdC5pZH0pKSksbz0wO288dGhpcy5zdGF0ZS5hY3RpdmVTY29wZS50cmFjay5sZW5ndGg7bysrKXt2YXIgYT10aGlzLnN0YXRlLmFjdGl2ZVNjb3BlLnRyYWNrW29dO2Eua2VwdHx8ci5oYXMoYS5pZCl8fGEuZGlzcG9zZSgpfXZhciBpPXRoaXMuc3RhdGUuc2NvcGVTdGFjay5wb3AoKTt0aGlzLnN0YXRlLmFjdGl2ZVNjb3BlPTA9PT10aGlzLnN0YXRlLnNjb3BlU3RhY2subGVuZ3RoP251bGw6dGhpcy5zdGF0ZS5zY29wZVN0YWNrW3RoaXMuc3RhdGUuc2NvcGVTdGFjay5sZW5ndGgtMV0sbi5mb3JFYWNoKChmdW5jdGlvbih0KXt0LmtlcHR8fHQuc2NvcGVJZCE9PWkuaWR8fGUudHJhY2sodCl9KSl9LHQucHJvdG90eXBlLmdyYWRpZW50cz1mdW5jdGlvbih0LGUsbixyKXt2YXIgbz10aGlzO2lmKHZvaWQgMD09PXImJihyPSExKSxDKGUubGVuZ3RoPjAsKGZ1bmN0aW9uKCl7cmV0dXJuXCJncmFkaWVudHMoKSByZWNlaXZlZCBhbiBlbXB0eSBsaXN0IG9mIHhzLlwifSkpLG51bGwhPW4mJlwiZmxvYXQzMlwiIT09bi5kdHlwZSl0aHJvdyBuZXcgRXJyb3IoXCJkeSBtdXN0IGhhdmUgJ2Zsb2F0MzInIGR0eXBlLCBidXQgaGFzICdcIituLmR0eXBlK1wiJ1wiKTt2YXIgYT10aGlzLnNjb3BlZFJ1bigoZnVuY3Rpb24oKXtyZXR1cm4gby5zdGFydFRhcGUoKX0pLChmdW5jdGlvbigpe3JldHVybiBvLmVuZFRhcGUoKX0pLChmdW5jdGlvbigpe3JldHVybiBvLnRpZHkoXCJmb3J3YXJkXCIsdCl9KSk7QyhhIGluc3RhbmNlb2Ygd3QsKGZ1bmN0aW9uKCl7cmV0dXJuXCJUaGUgcmVzdWx0IHkgcmV0dXJuZWQgYnkgZigpIG11c3QgYmUgYSB0ZW5zb3IuXCJ9KSk7dmFyIGk9ZnVuY3Rpb24odCxlLG4pe2Zvcih2YXIgcj17fSxvPXt9LGE9MDthPGUubGVuZ3RoO2ErKylyW2VbYV0uaWRdPSEwO2ZvcihhPTA7YTx0Lmxlbmd0aDthKyspe3ZhciBpPShwPXRbYV0pLmlucHV0cztmb3IodmFyIHMgaW4gaSl7Zm9yKHZhciB1PWlbc10sYz0hMSxsPTA7bDxlLmxlbmd0aDtsKyspaWYoclt1LmlkXSl7cC5vdXRwdXRzLmZvckVhY2goKGZ1bmN0aW9uKHQpe3JldHVybiByW3QuaWRdPSEwfSkpLGM9ITAsb1twLmlkXT0hMDticmVha31pZihjKWJyZWFrfX12YXIgaD17fTtoW24uaWRdPSEwO3ZhciBmPXt9O2ZvcihhPXQubGVuZ3RoLTE7YT49MDthLS0pZm9yKGk9KHA9dFthXSkuaW5wdXRzLGw9MDtsPHAub3V0cHV0cy5sZW5ndGg7bCsrKWlmKGhbcC5vdXRwdXRzW2xdLmlkXSl7Zm9yKHZhciBzIGluIGkpaFtpW3NdLmlkXT0hMCxmW3AuaWRdPSEwO2JyZWFrfXZhciBkPVtdO2ZvcihhPTA7YTx0Lmxlbmd0aDthKyspe3ZhciBwO2lmKG9bKHA9dFthXSkuaWRdJiZmW3AuaWRdKXt2YXIgdj17fTtmb3IodmFyIHMgaW4gcC5pbnB1dHMpe3ZhciBtPXAuaW5wdXRzW3NdO3JbbS5pZF0mJih2W3NdPW0pfXZhciBnPU9iamVjdC5hc3NpZ24oe30scCk7Zy5pbnB1dHM9dixnLm91dHB1dHM9cC5vdXRwdXRzLGQucHVzaChnKX19cmV0dXJuIGR9KHRoaXMuc3RhdGUuYWN0aXZlVGFwZSxlLGEpO2lmKCFyJiYwPT09aS5sZW5ndGgmJmUubGVuZ3RoPjApdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGNvbXB1dGUgZ3JhZGllbnQgb2YgeT1mKHgpIHdpdGggcmVzcGVjdCB0byB4LiBNYWtlIHN1cmUgdGhhdCB0aGUgZiB5b3UgcGFzc2VkIGVuY2xvc2VzIGFsbCBvcGVyYXRpb25zIHRoYXQgbGVhZCBmcm9tIHggdG8geS5cIik7cmV0dXJuIHRoaXMudGlkeShcImJhY2t3YXJkXCIsKGZ1bmN0aW9uKCl7dmFyIHQscixzPXt9O3NbYS5pZF09bnVsbD09bj8odD1hLnNoYXBlLHI9WihrKHQpLFwiZmxvYXQzMlwiKSxMdC5tYWtlVGVuc29yKHIsdCxcImZsb2F0MzJcIikpOm4sZnVuY3Rpb24odCxlLG4pe2Zvcih2YXIgcj1mdW5jdGlvbihyKXt2YXIgbz1lW3JdLGE9W107aWYoby5vdXRwdXRzLmZvckVhY2goKGZ1bmN0aW9uKGUpe3ZhciBuPXRbZS5pZF07bnVsbCE9bj9hLnB1c2gobik6YS5wdXNoKG51bGwpfSkpLG51bGw9PW8uZ3JhZGllbnQpdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGNvbXB1dGUgZ3JhZGllbnQ6IGdyYWRpZW50IGZ1bmN0aW9uIG5vdCBmb3VuZCBmb3IgXCIrby5rZXJuZWxOYW1lK1wiLlwiKTt2YXIgaT1vLmdyYWRpZW50KGEpLHM9ZnVuY3Rpb24oZSl7aWYoIShlIGluIGkpKXRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBiYWNrcHJvcCB0aHJvdWdoIGlucHV0IFwiK2UrXCIuIEF2YWlsYWJsZSBncmFkaWVudHMgZm91bmQ6IFwiK09iamVjdC5rZXlzKGkpK1wiLlwiKTt2YXIgcj1uKChmdW5jdGlvbigpe3JldHVybiBpW2VdKCl9KSk7aWYoXCJmbG9hdDMyXCIhPT1yLmR0eXBlKXRocm93IG5ldyBFcnJvcihcIkVycm9yIGluIGdyYWRpZW50IGZvciBvcCBcIitvLmtlcm5lbE5hbWUrXCIuIFRoZSBncmFkaWVudCBvZiBpbnB1dCBcIitlK1wiIG11c3QgaGF2ZSAnZmxvYXQzMicgZHR5cGUsIGJ1dCBoYXMgJ1wiK3IuZHR5cGUrXCInXCIpO3ZhciBhPW8uaW5wdXRzW2VdO2lmKCFTKHIuc2hhcGUsYS5zaGFwZSkpdGhyb3cgbmV3IEVycm9yKFwiRXJyb3IgaW4gZ3JhZGllbnQgZm9yIG9wIFwiK28ua2VybmVsTmFtZStcIi4gVGhlIGdyYWRpZW50IG9mIGlucHV0ICdcIitlK1wiJyBoYXMgc2hhcGUgJ1wiK3Iuc2hhcGUrXCInLCB3aGljaCBkb2VzIG5vdCBtYXRjaCB0aGUgc2hhcGUgb2YgdGhlIGlucHV0ICdcIithLnNoYXBlK1wiJ1wiKTtpZihudWxsPT10W2EuaWRdKXRbYS5pZF09cjtlbHNle3ZhciBzPXRbYS5pZF07dFthLmlkXT1zLmFkZChyKSxzLmRpc3Bvc2UoKX19O2Zvcih2YXIgdSBpbiBvLmlucHV0cylzKHUpfSxvPWUubGVuZ3RoLTE7bz49MDtvLS0pcihvKX0ocyxpLChmdW5jdGlvbih0KXtyZXR1cm4gby50aWR5KHQpfSkpO3ZhciB1PWUubWFwKChmdW5jdGlvbih0KXtyZXR1cm4gc1t0LmlkXX0pKTtyZXR1cm4gMD09PW8uc3RhdGUuZ3JhZGllbnREZXB0aCYmKG8uc3RhdGUuYWN0aXZlVGFwZS5mb3JFYWNoKChmdW5jdGlvbih0KXtmb3IodmFyIGU9MCxuPXQuc2F2ZWQ7ZTxuLmxlbmd0aDtlKyspe25bZV0uZGlzcG9zZSgpfX0pKSxvLnN0YXRlLmFjdGl2ZVRhcGU9bnVsbCkse3ZhbHVlOmEsZ3JhZHM6dX19KSl9LHQucHJvdG90eXBlLmN1c3RvbUdyYWQ9ZnVuY3Rpb24odCl7dmFyIGU9dGhpcztyZXR1cm4gQyhYKHQpLChmdW5jdGlvbigpe3JldHVyblwiVGhlIGYgcGFzc2VkIGluIGN1c3RvbUdyYWQoZikgbXVzdCBiZSBhIGZ1bmN0aW9uLlwifSkpLGZ1bmN0aW9uKCl7Zm9yKHZhciBuLHI9W10sbz0wO288YXJndW1lbnRzLmxlbmd0aDtvKyspcltvXT1hcmd1bWVudHNbb107QyhyLmV2ZXJ5KChmdW5jdGlvbih0KXtyZXR1cm4gdCBpbnN0YW5jZW9mIHd0fSkpLChmdW5jdGlvbigpe3JldHVyblwiVGhlIGFyZ3MgcGFzc2VkIGluIGN1c3RvbUdyYWQoZikoeDEsIHgyLC4uLikgbXVzdCBhbGwgYmUgdGVuc29yc1wifSkpO3ZhciBhPXt9O3JldHVybiByLmZvckVhY2goKGZ1bmN0aW9uKHQsZSl7YVtlXT10fSkpLGUucnVuS2VybmVsRnVuYygoZnVuY3Rpb24oZSxvKXtyZXR1cm4gQygobj10LmFwcGx5KHZvaWQgMCxyLmNvbmNhdChbb10pKSkudmFsdWUgaW5zdGFuY2VvZiB3dCwoZnVuY3Rpb24oKXtyZXR1cm5cIlRoZSBmdW5jdGlvbiBmIHBhc3NlZCBpbiBjdXN0b21HcmFkKGYpIG11c3QgcmV0dXJuIGFuIG9iamVjdCB3aGVyZSBgb2JqLnZhbHVlYCBpcyBhIHRlbnNvclwifSkpLEMoWChuLmdyYWRGdW5jKSwoZnVuY3Rpb24oKXtyZXR1cm5cIlRoZSBmdW5jdGlvbiBmIHBhc3NlZCBpbiBjdXN0b21HcmFkKGYpIG11c3QgcmV0dXJuIGFuIG9iamVjdCB3aGVyZSBgb2JqLmdyYWRGdW5jYCBpcyBhIGZ1bmN0aW9uLlwifSkpLG4udmFsdWV9KSxhLChmdW5jdGlvbih0LGUpe3ZhciBvPW4uZ3JhZEZ1bmModCxlKSxhPUFycmF5LmlzQXJyYXkobyk/bzpbb107QyhhLmxlbmd0aD09PXIubGVuZ3RoLChmdW5jdGlvbigpe3JldHVyblwiVGhlIGZ1bmN0aW9uIGYgcGFzc2VkIGluIGN1c3RvbUdyYWQoZikgbXVzdCByZXR1cm4gYW4gb2JqZWN0IHdoZXJlIGBvYmouZ3JhZEZ1bmNgIGlzIGEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIHRoZSBzYW1lIG51bWJlciBvZiB0ZW5zb3JzIGFzIGlucHV0cyBwYXNzZWQgdG8gZiguLi4pLlwifSkpLEMoYS5ldmVyeSgoZnVuY3Rpb24odCl7cmV0dXJuIHQgaW5zdGFuY2VvZiB3dH0pKSwoZnVuY3Rpb24oKXtyZXR1cm5cIlRoZSBmdW5jdGlvbiBmIHBhc3NlZCBpbiBjdXN0b21HcmFkKGYpIG11c3QgcmV0dXJuIGFuIG9iamVjdCB3aGVyZSBgb2JqLmdyYWRGdW5jYCBpcyBhIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBhIGxpc3Qgb2Ygb25seSB0ZW5zb3JzLlwifSkpO3ZhciBpPXt9O3JldHVybiBhLmZvckVhY2goKGZ1bmN0aW9uKHQsZSl7aVtlXT1mdW5jdGlvbigpe3JldHVybiB0fX0pKSxpfSkpfX0sdC5wcm90b3R5cGUucmVhZFN5bmM9ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMuc3RhdGUudGVuc29ySW5mby5nZXQodCkuYmFja2VuZC5yZWFkU3luYyh0KX0sdC5wcm90b3R5cGUucmVhZD1mdW5jdGlvbih0KXtyZXR1cm4gdGhpcy5zdGF0ZS50ZW5zb3JJbmZvLmdldCh0KS5iYWNrZW5kLnJlYWQodCl9LHQucHJvdG90eXBlLnRpbWU9ZnVuY3Rpb24odCl7cmV0dXJuIG4odGhpcyx2b2lkIDAsdm9pZCAwLChmdW5jdGlvbigpe3ZhciBlLG47cmV0dXJuIHIodGhpcywoZnVuY3Rpb24ocil7c3dpdGNoKHIubGFiZWwpe2Nhc2UgMDpyZXR1cm4gZT1ldCgpLFs0LHRoaXMuYmFja2VuZC50aW1lKHQpXTtjYXNlIDE6cmV0dXJuKG49ci5zZW50KCkpLndhbGxNcz1ldCgpLWUsWzIsbl19fSkpfSkpfSx0LnByb3RvdHlwZS50cmFjaz1mdW5jdGlvbih0KXtyZXR1cm4gbnVsbCE9dGhpcy5zdGF0ZS5hY3RpdmVTY29wZSYmKHQuc2NvcGVJZD10aGlzLnN0YXRlLmFjdGl2ZVNjb3BlLmlkLHRoaXMuc3RhdGUuYWN0aXZlU2NvcGUudHJhY2sucHVzaCh0KSksdH0sT2JqZWN0LmRlZmluZVByb3BlcnR5KHQucHJvdG90eXBlLFwicmVnaXN0ZXJlZFZhcmlhYmxlc1wiLHtnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5zdGF0ZS5yZWdpc3RlcmVkVmFyaWFibGVzfSxlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMH0pLHQucHJvdG90eXBlLnJlc2V0PWZ1bmN0aW9uKCl7Zm9yKHZhciB0IGluIHRoaXMucGVuZGluZ0JhY2tlbmRJbml0SWQrKyx0aGlzLnN0YXRlLmRpc3Bvc2UoKSx0aGlzLkVOVi5yZXNldCgpLHRoaXMuc3RhdGU9bmV3IEJ0LHRoaXMucmVnaXN0cnkpdGhpcy5kaXNwb3NlUmVnaXN0ZXJlZEtlcm5lbHModCksdGhpcy5yZWdpc3RyeVt0XS5kaXNwb3NlKCksZGVsZXRlIHRoaXMucmVnaXN0cnlbdF07dGhpcy5iYWNrZW5kTmFtZT1udWxsLHRoaXMuYmFja2VuZEluc3RhbmNlPW51bGwsdGhpcy5wZW5kaW5nQmFja2VuZEluaXQ9bnVsbH0sdC5uZXh0VGVuc29ySWQ9MCx0Lm5leHRWYXJpYWJsZUlkPTAsdH0oKTt2YXIgTHQ9ZnVuY3Rpb24oKXt2YXIgdD1mdW5jdGlvbigpe2lmKG51bGw9PU90KXt2YXIgdD12b2lkIDA7aWYoXCJ1bmRlZmluZWRcIiE9dHlwZW9mIHdpbmRvdyl0PXdpbmRvdztlbHNlIGlmKFwidW5kZWZpbmVkXCIhPXR5cGVvZiBnbG9iYWwpdD1nbG9iYWw7ZWxzZSBpZihcInVuZGVmaW5lZFwiIT10eXBlb2YgcHJvY2Vzcyl0PXByb2Nlc3M7ZWxzZXtpZihcInVuZGVmaW5lZFwiPT10eXBlb2Ygc2VsZil0aHJvdyBuZXcgRXJyb3IoXCJDb3VsZCBub3QgZmluZCBhIGdsb2JhbCBvYmplY3RcIik7dD1zZWxmfU90PXR9cmV0dXJuIE90fSgpO2lmKG51bGw9PXQuX3RmZW5naW5lKXt2YXIgZT1uZXcgbyh0KTt0Ll90ZmVuZ2luZT1uZXcgUHQoZSl9cmV0dXJuIGZ1bmN0aW9uKHQpe3M9dH0odC5fdGZlbmdpbmUuRU5WKSx5dD1mdW5jdGlvbigpe3JldHVybiB0Ll90ZmVuZ2luZX0sdC5fdGZlbmdpbmV9KCk7ZnVuY3Rpb24gV3QoKXtyZXR1cm5cInVuZGVmaW5lZFwiIT10eXBlb2Ygd2luZG93JiZudWxsIT13aW5kb3cuZG9jdW1lbnR8fFwidW5kZWZpbmVkXCIhPXR5cGVvZiBXb3JrZXJHbG9iYWxTY29wZX12YXIgVXQ9aSgpO1V0LnJlZ2lzdGVyRmxhZyhcIkRFQlVHXCIsKGZ1bmN0aW9uKCl7cmV0dXJuITF9KSwoZnVuY3Rpb24odCl7dCYmY29uc29sZS53YXJuKFwiRGVidWdnaW5nIG1vZGUgaXMgT04uIFRoZSBvdXRwdXQgb2YgZXZlcnkgbWF0aCBjYWxsIHdpbGwgYmUgZG93bmxvYWRlZCB0byBDUFUgYW5kIGNoZWNrZWQgZm9yIE5hTnMuIFRoaXMgc2lnbmlmaWNhbnRseSBpbXBhY3RzIHBlcmZvcm1hbmNlLlwiKX0pKSxVdC5yZWdpc3RlckZsYWcoXCJJU19CUk9XU0VSXCIsKGZ1bmN0aW9uKCl7cmV0dXJuIFd0KCl9KSksVXQucmVnaXN0ZXJGbGFnKFwiSVNfTk9ERVwiLChmdW5jdGlvbigpe3JldHVyblwidW5kZWZpbmVkXCIhPXR5cGVvZiBwcm9jZXNzJiZ2b2lkIDAhPT1wcm9jZXNzLnZlcnNpb25zJiZ2b2lkIDAhPT1wcm9jZXNzLnZlcnNpb25zLm5vZGV9KSksVXQucmVnaXN0ZXJGbGFnKFwiSVNfQ0hST01FXCIsKGZ1bmN0aW9uKCl7cmV0dXJuXCJ1bmRlZmluZWRcIiE9dHlwZW9mIG5hdmlnYXRvciYmbnVsbCE9bmF2aWdhdG9yJiZudWxsIT1uYXZpZ2F0b3IudXNlckFnZW50JiYvQ2hyb21lLy50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpJiYvR29vZ2xlIEluYy8udGVzdChuYXZpZ2F0b3IudmVuZG9yKX0pKSxVdC5yZWdpc3RlckZsYWcoXCJQUk9EXCIsKGZ1bmN0aW9uKCl7cmV0dXJuITF9KSksVXQucmVnaXN0ZXJGbGFnKFwiVEVOU09STElLRV9DSEVDS19TSEFQRV9DT05TSVNURU5DWVwiLChmdW5jdGlvbigpe3JldHVybiBVdC5nZXRCb29sKFwiREVCVUdcIil9KSksVXQucmVnaXN0ZXJGbGFnKFwiREVQUkVDQVRJT05fV0FSTklOR1NfRU5BQkxFRFwiLChmdW5jdGlvbigpe3JldHVybiEwfSkpLFV0LnJlZ2lzdGVyRmxhZyhcIklTX1RFU1RcIiwoZnVuY3Rpb24oKXtyZXR1cm4hMX0pKTt2YXIgVnQsenQsR3QsSHQ9e30scXQ9e2FscGhhOiExLGFudGlhbGlhczohMSxwcmVtdWx0aXBsaWVkQWxwaGE6ITEscHJlc2VydmVEcmF3aW5nQnVmZmVyOiExLGRlcHRoOiExLHN0ZW5jaWw6ITEsZmFpbElmTWFqb3JQZXJmb3JtYW5jZUNhdmVhdDohMH07ZnVuY3Rpb24gS3QodCxlKXtIdFt0XT1lfWZ1bmN0aW9uIGp0KHQpe3QgaW4gSHR8fChIdFt0XT1mdW5jdGlvbih0KXtpZigxIT09dCYmMiE9PXQpdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGdldCBXZWJHTCByZW5kZXJpbmcgY29udGV4dCwgV2ViR0wgaXMgZGlzYWJsZWQuXCIpO3ZhciBlPWZ1bmN0aW9uKHQpe2lmKFwidW5kZWZpbmVkXCIhPXR5cGVvZiBPZmZzY3JlZW5DYW52YXMmJjI9PT10KXJldHVybiBuZXcgT2Zmc2NyZWVuQ2FudmFzKDMwMCwxNTApO2lmKFwidW5kZWZpbmVkXCIhPXR5cGVvZiBkb2N1bWVudClyZXR1cm4gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImNhbnZhc1wiKTt0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgY3JlYXRlIGEgY2FudmFzIGluIHRoaXMgY29udGV4dFwiKX0odCk7aWYoZS5hZGRFdmVudExpc3RlbmVyKFwid2ViZ2xjb250ZXh0bG9zdFwiLChmdW5jdGlvbihlKXtlLnByZXZlbnREZWZhdWx0KCksZGVsZXRlIEh0W3RdfSksITEpLDE9PT10KXJldHVybiBlLmdldENvbnRleHQoXCJ3ZWJnbFwiLHF0KXx8ZS5nZXRDb250ZXh0KFwiZXhwZXJpbWVudGFsLXdlYmdsXCIscXQpO3JldHVybiBlLmdldENvbnRleHQoXCJ3ZWJnbDJcIixxdCl9KHQpKTt2YXIgZT1IdFt0XTtyZXR1cm4gZS5pc0NvbnRleHRMb3N0KCk/KGRlbGV0ZSBIdFt0XSxqdCh0KSk6KGUuZGlzYWJsZShlLkRFUFRIX1RFU1QpLGUuZGlzYWJsZShlLlNURU5DSUxfVEVTVCksZS5kaXNhYmxlKGUuQkxFTkQpLGUuZGlzYWJsZShlLkRJVEhFUiksZS5kaXNhYmxlKGUuUE9MWUdPTl9PRkZTRVRfRklMTCksZS5kaXNhYmxlKGUuU0FNUExFX0NPVkVSQUdFKSxlLmVuYWJsZShlLlNDSVNTT1JfVEVTVCksZS5lbmFibGUoZS5DVUxMX0ZBQ0UpLGUuY3VsbEZhY2UoZS5CQUNLKSxIdFt0XSl9ZnVuY3Rpb24gWHQodCxlKXtyZXR1cm5bZSx0XX1mdW5jdGlvbiBZdCh0KXt2YXIgZT1rKHQpO3JldHVybiBUKE1hdGguY2VpbChlLzQpKX1mdW5jdGlvbiAkdCh0LGUpe3JldHVybltNYXRoLm1heCgxLE1hdGguY2VpbChlLzIpKSxNYXRoLm1heCgxLE1hdGguY2VpbCh0LzIpKV19ZnVuY3Rpb24gUXQodCxlKXt2YXIgbixyLG8sYSxzLHUsYyxsLGgsZj10O3JldHVybiAyPT09aSgpLmdldE51bWJlcihcIldFQkdMX1ZFUlNJT05cIik/KG49Zi5SMzJGLHI9Zi5SMTZGLG89Zi5SR0JBMTZGLGE9Zi5SR0JBMzJGLHM9Zi5SRUQsdT00LGM9MSxsPWYuSEFMRl9GTE9BVCxoPWYuRkxPQVQpOihuPXQuUkdCQSxyPXQuUkdCQSxvPXQuUkdCQSxhPWYuUkdCQSxzPXQuUkdCQSx1PTQsYz00LGw9bnVsbCE9ZT9lLkhBTEZfRkxPQVRfT0VTOm51bGwsaD10LkZMT0FUKSx7aW50ZXJuYWxGb3JtYXRGbG9hdDpuLGludGVybmFsRm9ybWF0SGFsZkZsb2F0OnIsaW50ZXJuYWxGb3JtYXRQYWNrZWRIYWxmRmxvYXQ6byxpbnRlcm5hbEZvcm1hdFBhY2tlZEZsb2F0OmEsdGV4dHVyZUZvcm1hdEZsb2F0OnMsZG93bmxvYWRUZXh0dXJlRm9ybWF0OnQuUkdCQSxkb3dubG9hZFVucGFja051bUNoYW5uZWxzOnUsZGVmYXVsdE51bUNoYW5uZWxzOmMsdGV4dHVyZVR5cGVIYWxmRmxvYXQ6bCx0ZXh0dXJlVHlwZUZsb2F0Omh9fWZ1bmN0aW9uIEp0KHQsZSxuKXt2YXIgcj1uKCk7cmV0dXJuIGUmJmZ1bmN0aW9uKHQpe3ZhciBlPXQuZ2V0RXJyb3IoKTtpZihlIT09dC5OT19FUlJPUil0aHJvdyBuZXcgRXJyb3IoXCJXZWJHTCBFcnJvcjogXCIrbmUodCxlKSl9KHQpLHJ9IWZ1bmN0aW9uKHQpe3RbdC5ERU5TRT0wXT1cIkRFTlNFXCIsdFt0LlNIQVJFRF9CQVRDSD0xXT1cIlNIQVJFRF9CQVRDSFwifShWdHx8KFZ0PXt9KSksZnVuY3Rpb24odCl7dFt0LlJFTkRFUj0wXT1cIlJFTkRFUlwiLHRbdC5VUExPQUQ9MV09XCJVUExPQURcIix0W3QuUElYRUxTPTJdPVwiUElYRUxTXCIsdFt0LkRPV05MT0FEPTNdPVwiRE9XTkxPQURcIn0oenR8fCh6dD17fSkpLGZ1bmN0aW9uKHQpe3RbdC5VTlBBQ0tFRF9GTE9BVDE2PTBdPVwiVU5QQUNLRURfRkxPQVQxNlwiLHRbdC5VTlBBQ0tFRF9GTE9BVDMyPTFdPVwiVU5QQUNLRURfRkxPQVQzMlwiLHRbdC5QQUNLRURfNFgxX1VOU0lHTkVEX0JZVEU9Ml09XCJQQUNLRURfNFgxX1VOU0lHTkVEX0JZVEVcIix0W3QuUEFDS0VEXzJYMl9GTE9BVDMyPTNdPVwiUEFDS0VEXzJYMl9GTE9BVDMyXCIsdFt0LlBBQ0tFRF8yWDJfRkxPQVQxNj00XT1cIlBBQ0tFRF8yWDJfRkxPQVQxNlwifShHdHx8KEd0PXt9KSk7dmFyIFp0PTUuOTZlLTgsdGU9NjU1MDQ7ZnVuY3Rpb24gZWUodCl7cmV0dXJuISEoaSgpLmdldEJvb2woXCJXRUJHTF9SRU5ERVJfRkxPQVQzMl9FTkFCTEVEXCIpfHwwPT09dHx8WnQ8TWF0aC5hYnModCkmJk1hdGguYWJzKHQpPHRlKX1mdW5jdGlvbiBuZSh0LGUpe3N3aXRjaChlKXtjYXNlIHQuTk9fRVJST1I6cmV0dXJuXCJOT19FUlJPUlwiO2Nhc2UgdC5JTlZBTElEX0VOVU06cmV0dXJuXCJJTlZBTElEX0VOVU1cIjtjYXNlIHQuSU5WQUxJRF9WQUxVRTpyZXR1cm5cIklOVkFMSURfVkFMVUVcIjtjYXNlIHQuSU5WQUxJRF9PUEVSQVRJT046cmV0dXJuXCJJTlZBTElEX09QRVJBVElPTlwiO2Nhc2UgdC5JTlZBTElEX0ZSQU1FQlVGRkVSX09QRVJBVElPTjpyZXR1cm5cIklOVkFMSURfRlJBTUVCVUZGRVJfT1BFUkFUSU9OXCI7Y2FzZSB0Lk9VVF9PRl9NRU1PUlk6cmV0dXJuXCJPVVRfT0ZfTUVNT1JZXCI7Y2FzZSB0LkNPTlRFWFRfTE9TVF9XRUJHTDpyZXR1cm5cIkNPTlRFWFRfTE9TVF9XRUJHTFwiO2RlZmF1bHQ6cmV0dXJuXCJVbmtub3duIGVycm9yIGNvZGUgXCIrZX19ZnVuY3Rpb24gcmUodCxlLG4pe3JldHVybiBrZSh0LGUsKGZ1bmN0aW9uKCl7cmV0dXJuIHQuZ2V0RXh0ZW5zaW9uKG4pfSksJ0V4dGVuc2lvbiBcIicrbisnXCIgbm90IHN1cHBvcnRlZCBvbiB0aGlzIGJyb3dzZXIuJyl9ZnVuY3Rpb24gb2UodCxlLG4pe3ZhciByPWtlKHQsZSwoZnVuY3Rpb24oKXtyZXR1cm4gdC5jcmVhdGVTaGFkZXIodC5WRVJURVhfU0hBREVSKX0pLFwiVW5hYmxlIHRvIGNyZWF0ZSB2ZXJ0ZXggV2ViR0xTaGFkZXIuXCIpO2lmKEp0KHQsZSwoZnVuY3Rpb24oKXtyZXR1cm4gdC5zaGFkZXJTb3VyY2UocixuKX0pKSxKdCh0LGUsKGZ1bmN0aW9uKCl7cmV0dXJuIHQuY29tcGlsZVNoYWRlcihyKX0pKSwhMT09PXQuZ2V0U2hhZGVyUGFyYW1ldGVyKHIsdC5DT01QSUxFX1NUQVRVUykpdGhyb3cgY29uc29sZS5sb2codC5nZXRTaGFkZXJJbmZvTG9nKHIpKSxuZXcgRXJyb3IoXCJGYWlsZWQgdG8gY29tcGlsZSB2ZXJ0ZXggc2hhZGVyLlwiKTtyZXR1cm4gcn1mdW5jdGlvbiBhZSh0LGUsbil7dmFyIHI9a2UodCxlLChmdW5jdGlvbigpe3JldHVybiB0LmNyZWF0ZVNoYWRlcih0LkZSQUdNRU5UX1NIQURFUil9KSxcIlVuYWJsZSB0byBjcmVhdGUgZnJhZ21lbnQgV2ViR0xTaGFkZXIuXCIpO2lmKEp0KHQsZSwoZnVuY3Rpb24oKXtyZXR1cm4gdC5zaGFkZXJTb3VyY2UocixuKX0pKSxKdCh0LGUsKGZ1bmN0aW9uKCl7cmV0dXJuIHQuY29tcGlsZVNoYWRlcihyKX0pKSwhMT09PXQuZ2V0U2hhZGVyUGFyYW1ldGVyKHIsdC5DT01QSUxFX1NUQVRVUykpdGhyb3cgZnVuY3Rpb24odCxlKXt2YXIgbj11ZS5leGVjKGUpO2lmKG51bGw9PW4pcmV0dXJuIGNvbnNvbGUubG9nKFwiQ291bGRuJ3QgcGFyc2UgbGluZSBudW1iZXIgaW4gZXJyb3I6IFwiK2UpLHZvaWQgY29uc29sZS5sb2codCk7Zm9yKHZhciByPStuWzFdLG89dC5zcGxpdChcIlxcblwiKSxhPW8ubGVuZ3RoLnRvU3RyaW5nKCkubGVuZ3RoKzIsaT1vLm1hcCgoZnVuY3Rpb24odCxlKXtyZXR1cm4gTigoZSsxKS50b1N0cmluZygpLGEpK3R9KSkscz0wLHU9MDt1PGkubGVuZ3RoO3UrKylzPU1hdGgubWF4KGlbdV0ubGVuZ3RoLHMpO3ZhciBjPWkuc2xpY2UoMCxyLTEpLGw9aS5zbGljZShyLTEsciksaD1pLnNsaWNlKHIpO2NvbnNvbGUubG9nKGMuam9pbihcIlxcblwiKSksY29uc29sZS5sb2coZS5zcGxpdChcIlxcblwiKVswXSksY29uc29sZS5sb2coXCIlYyBcIitOKGxbMF0scyksXCJib3JkZXI6MXB4IHNvbGlkIHJlZDsgYmFja2dyb3VuZC1jb2xvcjojZTNkMmQyOyBjb2xvcjojYTYxNzE3XCIpLGNvbnNvbGUubG9nKGguam9pbihcIlxcblwiKSl9KG4sdC5nZXRTaGFkZXJJbmZvTG9nKHIpKSxuZXcgRXJyb3IoXCJGYWlsZWQgdG8gY29tcGlsZSBmcmFnbWVudCBzaGFkZXIuXCIpO3JldHVybiByfXZhciBpZSxzZSx1ZT0vRVJST1I6IFswLTldKzooWzAtOV0rKTovZztmdW5jdGlvbiBjZSh0LGUpe3JldHVybiBrZSh0LGUsKGZ1bmN0aW9uKCl7cmV0dXJuIHQuY3JlYXRlUHJvZ3JhbSgpfSksXCJVbmFibGUgdG8gY3JlYXRlIFdlYkdMUHJvZ3JhbS5cIil9ZnVuY3Rpb24gbGUodCxlLG4pe2lmKEp0KHQsZSwoZnVuY3Rpb24oKXtyZXR1cm4gdC5saW5rUHJvZ3JhbShuKX0pKSwhMT09PXQuZ2V0UHJvZ3JhbVBhcmFtZXRlcihuLHQuTElOS19TVEFUVVMpKXRocm93IGNvbnNvbGUubG9nKHQuZ2V0UHJvZ3JhbUluZm9Mb2cobikpLG5ldyBFcnJvcihcIkZhaWxlZCB0byBsaW5rIHZlcnRleCBhbmQgZnJhZ21lbnQgc2hhZGVycy5cIil9ZnVuY3Rpb24gaGUodCxlLG4pe2lmKEp0KHQsZSwoZnVuY3Rpb24oKXtyZXR1cm4gdC52YWxpZGF0ZVByb2dyYW0obil9KSksITE9PT10LmdldFByb2dyYW1QYXJhbWV0ZXIobix0LlZBTElEQVRFX1NUQVRVUykpdGhyb3cgY29uc29sZS5sb2codC5nZXRQcm9ncmFtSW5mb0xvZyhuKSksbmV3IEVycm9yKFwiU2hhZGVyIHByb2dyYW0gdmFsaWRhdGlvbiBmYWlsZWQuXCIpfWZ1bmN0aW9uIGZlKHQsZSxuKXt2YXIgcj1rZSh0LGUsKGZ1bmN0aW9uKCl7cmV0dXJuIHQuY3JlYXRlQnVmZmVyKCl9KSxcIlVuYWJsZSB0byBjcmVhdGUgV2ViR0xCdWZmZXJcIik7cmV0dXJuIEp0KHQsZSwoZnVuY3Rpb24oKXtyZXR1cm4gdC5iaW5kQnVmZmVyKHQuQVJSQVlfQlVGRkVSLHIpfSkpLEp0KHQsZSwoZnVuY3Rpb24oKXtyZXR1cm4gdC5idWZmZXJEYXRhKHQuQVJSQVlfQlVGRkVSLG4sdC5TVEFUSUNfRFJBVyl9KSkscn1mdW5jdGlvbiBkZSh0LGUsbil7dmFyIHI9a2UodCxlLChmdW5jdGlvbigpe3JldHVybiB0LmNyZWF0ZUJ1ZmZlcigpfSksXCJVbmFibGUgdG8gY3JlYXRlIFdlYkdMQnVmZmVyXCIpO3JldHVybiBKdCh0LGUsKGZ1bmN0aW9uKCl7cmV0dXJuIHQuYmluZEJ1ZmZlcih0LkVMRU1FTlRfQVJSQVlfQlVGRkVSLHIpfSkpLEp0KHQsZSwoZnVuY3Rpb24oKXtyZXR1cm4gdC5idWZmZXJEYXRhKHQuRUxFTUVOVF9BUlJBWV9CVUZGRVIsbix0LlNUQVRJQ19EUkFXKX0pKSxyfWZ1bmN0aW9uIHBlKHQsZSl7cmV0dXJuIGtlKHQsZSwoZnVuY3Rpb24oKXtyZXR1cm4gdC5jcmVhdGVUZXh0dXJlKCl9KSxcIlVuYWJsZSB0byBjcmVhdGUgV2ViR0xUZXh0dXJlLlwiKX1mdW5jdGlvbiB2ZSh0LGUpe3ZhciBuPWkoKS5nZXROdW1iZXIoXCJXRUJHTF9NQVhfVEVYVFVSRV9TSVpFXCIpO2lmKHQ8PTB8fGU8PTApe3ZhciByPVwiW1wiK3QrXCJ4XCIrZStcIl1cIjt0aHJvdyBuZXcgRXJyb3IoXCJSZXF1ZXN0ZWQgdGV4dHVyZSBzaXplIFwiK3IrXCIgaXMgaW52YWxpZC5cIil9aWYodD5ufHxlPm4pe3I9XCJbXCIrdCtcInhcIitlK1wiXVwiO3Rocm93IG5ldyBFcnJvcihcIlJlcXVlc3RlZCB0ZXh0dXJlIHNpemUgXCIrcitcIiBncmVhdGVyIHRoYW4gV2ViR0wgbWF4aW11bSBvbiB0aGlzIGJyb3dzZXIgLyBHUFUgXCIrKFwiW1wiK24rXCJ4XCIrbitcIl1cIikrXCIuXCIpfX1mdW5jdGlvbiBtZSh0LGUpe3JldHVybiBrZSh0LGUsKGZ1bmN0aW9uKCl7cmV0dXJuIHQuY3JlYXRlRnJhbWVidWZmZXIoKX0pLFwiVW5hYmxlIHRvIGNyZWF0ZSBXZWJHTEZyYW1lYnVmZmVyLlwiKX1mdW5jdGlvbiBnZSh0LGUsbixyLG8sYSxpLHMpe3ZhciB1PXQuZ2V0QXR0cmliTG9jYXRpb24obixyKTtyZXR1cm4tMSE9PXUmJihKdCh0LGUsKGZ1bmN0aW9uKCl7cmV0dXJuIHQuYmluZEJ1ZmZlcih0LkFSUkFZX0JVRkZFUixvKX0pKSxKdCh0LGUsKGZ1bmN0aW9uKCl7cmV0dXJuIHQudmVydGV4QXR0cmliUG9pbnRlcih1LGEsdC5GTE9BVCwhMSxpLHMpfSkpLEp0KHQsZSwoZnVuY3Rpb24oKXtyZXR1cm4gdC5lbmFibGVWZXJ0ZXhBdHRyaWJBcnJheSh1KX0pKSwhMCl9ZnVuY3Rpb24geWUodCxlLG4scil7U2UodCxyKSxKdCh0LGUsKGZ1bmN0aW9uKCl7cmV0dXJuIHQuYWN0aXZlVGV4dHVyZSh0LlRFWFRVUkUwK3IpfSkpLEp0KHQsZSwoZnVuY3Rpb24oKXtyZXR1cm4gdC5iaW5kVGV4dHVyZSh0LlRFWFRVUkVfMkQsbil9KSl9ZnVuY3Rpb24geGUodCxlLG4scil7cmV0dXJuIGtlKHQsZSwoZnVuY3Rpb24oKXtyZXR1cm4gdC5nZXRVbmlmb3JtTG9jYXRpb24obixyKX0pLCd1bmlmb3JtIFwiJytyKydcIiBub3QgcHJlc2VudCBpbiBwcm9ncmFtLicpfWZ1bmN0aW9uIGJlKHQsZSxuKXtyZXR1cm4gdC5nZXRVbmlmb3JtTG9jYXRpb24oZSxuKX1mdW5jdGlvbiB3ZSh0LGUsbixyLG8sYSl7SnQodCxlLChmdW5jdGlvbigpe3JldHVybiB5ZSh0LGUscixhKX0pKSxKdCh0LGUsKGZ1bmN0aW9uKCl7cmV0dXJuIHQudW5pZm9ybTFpKG8sYSl9KSl9ZnVuY3Rpb24gQ2UodCxlLG4scil7SnQodCxlLChmdW5jdGlvbigpe3JldHVybiB0LmJpbmRGcmFtZWJ1ZmZlcih0LkZSQU1FQlVGRkVSLHIpfSkpLEp0KHQsZSwoZnVuY3Rpb24oKXtyZXR1cm4gdC5mcmFtZWJ1ZmZlclRleHR1cmUyRCh0LkZSQU1FQlVGRkVSLHQuQ09MT1JfQVRUQUNITUVOVDAsdC5URVhUVVJFXzJELG4sMCl9KSl9ZnVuY3Rpb24gRWUodCxlLG4pe0p0KHQsZSwoZnVuY3Rpb24oKXtyZXR1cm4gdC5iaW5kRnJhbWVidWZmZXIodC5GUkFNRUJVRkZFUixuKX0pKSxKdCh0LGUsKGZ1bmN0aW9uKCl7cmV0dXJuIHQuZnJhbWVidWZmZXJUZXh0dXJlMkQodC5GUkFNRUJVRkZFUix0LkNPTE9SX0FUVEFDSE1FTlQwLHQuVEVYVFVSRV8yRCxudWxsLDApfSkpfWZ1bmN0aW9uIFJlKHQpe3ZhciBlPXQuY2hlY2tGcmFtZWJ1ZmZlclN0YXR1cyh0LkZSQU1FQlVGRkVSKTtpZihlIT09dC5GUkFNRUJVRkZFUl9DT01QTEVURSl0aHJvdyBuZXcgRXJyb3IoXCJFcnJvciBiaW5kaW5nIGZyYW1lYnVmZmVyOiBcIitJZSh0LGUpKX1mdW5jdGlvbiBJZSh0LGUpe3N3aXRjaChlKXtjYXNlIHQuRlJBTUVCVUZGRVJfSU5DT01QTEVURV9BVFRBQ0hNRU5UOnJldHVyblwiRlJBTUVCVUZGRVJfSU5DT01QTEVURV9BVFRBQ0hNRU5UXCI7Y2FzZSB0LkZSQU1FQlVGRkVSX0lOQ09NUExFVEVfTUlTU0lOR19BVFRBQ0hNRU5UOnJldHVyblwiRlJBTUVCVUZGRVJfSU5DT01QTEVURV9NSVNTSU5HX0FUVEFDSE1FTlRcIjtjYXNlIHQuRlJBTUVCVUZGRVJfSU5DT01QTEVURV9ESU1FTlNJT05TOnJldHVyblwiRlJBTUVCVUZGRVJfSU5DT01QTEVURV9ESU1FTlNJT05TXCI7Y2FzZSB0LkZSQU1FQlVGRkVSX1VOU1VQUE9SVEVEOnJldHVyblwiRlJBTUVCVUZGRVJfVU5TVVBQT1JURURcIjtkZWZhdWx0OnJldHVyblwidW5rbm93biBlcnJvciBcIitlfX1mdW5jdGlvbiBrZSh0LGUsbixyKXt2YXIgbz1KdCh0LGUsKGZ1bmN0aW9uKCl7cmV0dXJuIG4oKX0pKTtpZihudWxsPT1vKXRocm93IG5ldyBFcnJvcihyKTtyZXR1cm4gb31mdW5jdGlvbiBTZSh0LGUpe3ZhciBuPXQuTUFYX0NPTUJJTkVEX1RFWFRVUkVfSU1BR0VfVU5JVFMtMSxyPWUrdC5URVhUVVJFMDtpZihyPHQuVEVYVFVSRTB8fHI+bil0aHJvdyBuZXcgRXJyb3IoXCJ0ZXh0dXJlVW5pdCBtdXN0IGJlIGluIFwiKyhcIltnbC5URVhUVVJFMCwgZ2wuVEVYVFVSRVwiK24rXCJdXCIpK1wiLlwiKX1mdW5jdGlvbiBBZSh0LGUpe3JldHVybiB2b2lkIDA9PT1lJiYoZT0yKSxrKHQuc2xpY2UoMCx0Lmxlbmd0aC1lKSl9ZnVuY3Rpb24gRGUodCl7aWYoMD09PXQubGVuZ3RoKXRocm93IEVycm9yKFwiQ2Fubm90IGdldCByb3dzIGFuZCBjb2x1bW5zIG9mIGFuIGVtcHR5IHNoYXBlIGFycmF5LlwiKTtyZXR1cm5bdC5sZW5ndGg+MT90W3QubGVuZ3RoLTJdOjEsdFt0Lmxlbmd0aC0xXV19ZnVuY3Rpb24gVGUodCl7dmFyIGU9WzEsMSwxXTtyZXR1cm4gMD09PXQubGVuZ3RofHwxPT09dC5sZW5ndGgmJjE9PT10WzBdfHwoZT1bQWUodCldLmNvbmNhdChEZSh0KSkpLGV9ZnVuY3Rpb24gTmUodCxlKXt2YXIgbjt2b2lkIDA9PT1lJiYoZT0hMSk7dmFyIHI9aSgpLmdldE51bWJlcihcIldFQkdMX01BWF9URVhUVVJFX1NJWkVcIik7aWYoZSYmKHIqPTIsMT09PSh0PXQubWFwKChmdW5jdGlvbihlLG4pe3JldHVybiBuPj10Lmxlbmd0aC0yP2IodFtuXSk6dFtuXX0pKSkubGVuZ3RoJiYodD1bMix0WzBdXSkpLDIhPT10Lmxlbmd0aCl7dmFyIG89TSh0KTt0PW8ubmV3U2hhcGV9dmFyIGE9ayh0KTtpZih0Lmxlbmd0aDw9MSYmYTw9cilyZXR1cm5bMSxhXTtpZigyPT09dC5sZW5ndGgmJnRbMF08PXImJnRbMV08PXIpcmV0dXJuIHQ7aWYoMz09PXQubGVuZ3RoJiZ0WzBdKnRbMV08PXImJnRbMl08PXIpcmV0dXJuW3RbMF0qdFsxXSx0WzJdXTtpZigzPT09dC5sZW5ndGgmJnRbMF08PXImJnRbMV0qdFsyXTw9cilyZXR1cm5bdFswXSx0WzFdKnRbMl1dO2lmKDQ9PT10Lmxlbmd0aCYmdFswXSp0WzFdKnRbMl08PXImJnRbM108PXIpcmV0dXJuW3RbMF0qdFsxXSp0WzJdLHRbM11dO2lmKDQ9PT10Lmxlbmd0aCYmdFswXTw9ciYmdFsxXSp0WzJdKnRbM108PXIpcmV0dXJuW3RbMF0sdFsxXSp0WzJdKnRbM11dO2lmKGUpe3ZhciBzPUFlKHQpLHU9MixjPTI7cmV0dXJuIHQubGVuZ3RoJiYodT0obj1EZSh0KSlbMF0sYz1uWzFdKSxUKGE9cyoodS8yKSooYy8yKSkubWFwKChmdW5jdGlvbih0KXtyZXR1cm4gMip0fSkpfXJldHVybiBUKGEpfWZ1bmN0aW9uIEZlKHQpe3JldHVybiB0JTI9PTB9ZnVuY3Rpb24gX2UodCxlKXtpZihTKHQ9dC5zbGljZSgtMiksZT1lLnNsaWNlKC0yKSkpcmV0dXJuITA7aWYoIXQubGVuZ3RofHwhZS5sZW5ndGgpcmV0dXJuITA7aWYoMD09PXRbMF18fDA9PT10WzFdfHwwPT09ZVswXXx8MD09PWVbMV0pcmV0dXJuITA7aWYodC5sZW5ndGghPT1lLmxlbmd0aCl7dmFyIG49dC5zbGljZSgtMSlbMF0scj1lLnNsaWNlKC0xKVswXTtpZihuPT09cilyZXR1cm4hMDtpZihGZShuKSYmRmUocikmJigxPT09dFswXXx8MT09PWVbMF0pKXJldHVybiEwfXJldHVybiB0WzFdPT09ZVsxXSYmRmUodFswXSkmJkZlKGVbMF0pfWZ1bmN0aW9uIE9lKHQpe2lmKG51bGw9PWllKXt2YXIgZT1qdCh0KTtpZT1lLmdldFBhcmFtZXRlcihlLk1BWF9URVhUVVJFX1NJWkUpfXJldHVybiBpZX1mdW5jdGlvbiBNZSh0KXtpZihudWxsPT1zZSl7dmFyIGU9anQodCk7c2U9ZS5nZXRQYXJhbWV0ZXIoZS5NQVhfVEVYVFVSRV9JTUFHRV9VTklUUyl9cmV0dXJuIE1hdGgubWluKDE2LHNlKX1mdW5jdGlvbiBCZSh0KXtpZigwPT09dClyZXR1cm4gMDt2YXIgZT1qdCh0KTtyZXR1cm4gUGUoZSxcIkVYVF9kaXNqb2ludF90aW1lcl9xdWVyeV93ZWJnbDJcIikmJjI9PT10PzI6UGUoZSxcIkVYVF9kaXNqb2ludF90aW1lcl9xdWVyeVwiKT8xOjB9ZnVuY3Rpb24gUGUodCxlKXtyZXR1cm4gbnVsbCE9dC5nZXRFeHRlbnNpb24oZSl9ZnVuY3Rpb24gTGUodCl7dHJ5e2lmKG51bGwhPWp0KHQpKXJldHVybiEwfWNhdGNoKHQpe3JldHVybiExfXJldHVybiExfWZ1bmN0aW9uIFdlKHQpe2lmKDA9PT10KXJldHVybiExO3ZhciBlPWp0KHQpO2lmKDE9PT10KXtpZighUGUoZSxcIk9FU190ZXh0dXJlX2Zsb2F0XCIpKXJldHVybiExfWVsc2UgaWYoIVBlKGUsXCJFWFRfY29sb3JfYnVmZmVyX2Zsb2F0XCIpKXJldHVybiExO3JldHVybiBWZShlKX1mdW5jdGlvbiBVZSh0KXtpZigwPT09dClyZXR1cm4hMTt2YXIgZT1qdCh0KTtpZigxIT09dCl7aWYoUGUoZSxcIkVYVF9jb2xvcl9idWZmZXJfZmxvYXRcIikpcmV0dXJuIFZlKGUpO2lmKFBlKGUsXCJFWFRfY29sb3JfYnVmZmVyX2hhbGZfZmxvYXRcIikpe3ZhciBuPWUuZ2V0RXh0ZW5zaW9uKFwiRVhUX2NvbG9yX2J1ZmZlcl9oYWxmX2Zsb2F0XCIpO3JldHVybiBmdW5jdGlvbih0LGUpe3ZhciBuPVF0KHQsZSkscj10LmNyZWF0ZVRleHR1cmUoKTt0LmJpbmRUZXh0dXJlKHQuVEVYVFVSRV8yRCxyKTt0LnRleEltYWdlMkQodC5URVhUVVJFXzJELDAsbi5pbnRlcm5hbEZvcm1hdEhhbGZGbG9hdCwxLDEsMCxuLnRleHR1cmVGb3JtYXRGbG9hdCxuLnRleHR1cmVUeXBlSGFsZkZsb2F0LG51bGwpO3ZhciBvPXQuY3JlYXRlRnJhbWVidWZmZXIoKTt0LmJpbmRGcmFtZWJ1ZmZlcih0LkZSQU1FQlVGRkVSLG8pLHQuZnJhbWVidWZmZXJUZXh0dXJlMkQodC5GUkFNRUJVRkZFUix0LkNPTE9SX0FUVEFDSE1FTlQwLHQuVEVYVFVSRV8yRCxyLDApO3ZhciBhPXQuY2hlY2tGcmFtZWJ1ZmZlclN0YXR1cyh0LkZSQU1FQlVGRkVSKT09PXQuRlJBTUVCVUZGRVJfQ09NUExFVEU7cmV0dXJuIHQuYmluZFRleHR1cmUodC5URVhUVVJFXzJELG51bGwpLHQuYmluZEZyYW1lYnVmZmVyKHQuRlJBTUVCVUZGRVIsbnVsbCksdC5kZWxldGVUZXh0dXJlKHIpLHQuZGVsZXRlRnJhbWVidWZmZXIobyksYX0oZSxuKX1yZXR1cm4hMX1yZXR1cm4hIVBlKGUsXCJPRVNfdGV4dHVyZV9mbG9hdFwiKSYmKCEhUGUoZSxcIldFQkdMX2NvbG9yX2J1ZmZlcl9mbG9hdFwiKSYmVmUoZSkpfWZ1bmN0aW9uIFZlKHQpe3ZhciBlPVF0KHQpLG49dC5jcmVhdGVUZXh0dXJlKCk7dC5iaW5kVGV4dHVyZSh0LlRFWFRVUkVfMkQsbik7dC50ZXhJbWFnZTJEKHQuVEVYVFVSRV8yRCwwLGUuaW50ZXJuYWxGb3JtYXRGbG9hdCwxLDEsMCxlLnRleHR1cmVGb3JtYXRGbG9hdCxlLnRleHR1cmVUeXBlRmxvYXQsbnVsbCk7dmFyIHI9dC5jcmVhdGVGcmFtZWJ1ZmZlcigpO3QuYmluZEZyYW1lYnVmZmVyKHQuRlJBTUVCVUZGRVIsciksdC5mcmFtZWJ1ZmZlclRleHR1cmUyRCh0LkZSQU1FQlVGRkVSLHQuQ09MT1JfQVRUQUNITUVOVDAsdC5URVhUVVJFXzJELG4sMCk7dmFyIG89dC5jaGVja0ZyYW1lYnVmZmVyU3RhdHVzKHQuRlJBTUVCVUZGRVIpPT09dC5GUkFNRUJVRkZFUl9DT01QTEVURTtyZXR1cm4gdC5iaW5kVGV4dHVyZSh0LlRFWFRVUkVfMkQsbnVsbCksdC5iaW5kRnJhbWVidWZmZXIodC5GUkFNRUJVRkZFUixudWxsKSx0LmRlbGV0ZVRleHR1cmUobiksdC5kZWxldGVGcmFtZWJ1ZmZlcihyKSxvfWZ1bmN0aW9uIHplKHQpe3JldHVybiAyPT09dCYmbnVsbCE9anQodCkuZmVuY2VTeW5jfXZhciBHZT1PYmplY3QuZnJlZXplKHtjYWxsQW5kQ2hlY2s6SnQsY2FuQmVSZXByZXNlbnRlZDplZSxnZXRXZWJHTEVycm9yTWVzc2FnZTpuZSxnZXRFeHRlbnNpb25PclRocm93OnJlLGNyZWF0ZVZlcnRleFNoYWRlcjpvZSxjcmVhdGVGcmFnbWVudFNoYWRlcjphZSxjcmVhdGVQcm9ncmFtOmNlLGxpbmtQcm9ncmFtOmxlLHZhbGlkYXRlUHJvZ3JhbTpoZSxjcmVhdGVTdGF0aWNWZXJ0ZXhCdWZmZXI6ZmUsY3JlYXRlU3RhdGljSW5kZXhCdWZmZXI6ZGUsZ2V0TnVtQ2hhbm5lbHM6ZnVuY3Rpb24oKXtyZXR1cm4gMj09PWkoKS5nZXROdW1iZXIoXCJXRUJHTF9WRVJTSU9OXCIpPzE6NH0sY3JlYXRlVGV4dHVyZTpwZSx2YWxpZGF0ZVRleHR1cmVTaXplOnZlLGNyZWF0ZUZyYW1lYnVmZmVyOm1lLGJpbmRWZXJ0ZXhCdWZmZXJUb1Byb2dyYW1BdHRyaWJ1dGU6Z2UsYmluZFRleHR1cmVVbml0OnllLHVuYmluZFRleHR1cmVVbml0OmZ1bmN0aW9uKHQsZSxuKXtTZSh0LG4pLEp0KHQsZSwoZnVuY3Rpb24oKXtyZXR1cm4gdC5hY3RpdmVUZXh0dXJlKHQuVEVYVFVSRTArbil9KSksSnQodCxlLChmdW5jdGlvbigpe3JldHVybiB0LmJpbmRUZXh0dXJlKHQuVEVYVFVSRV8yRCxudWxsKX0pKX0sZ2V0UHJvZ3JhbVVuaWZvcm1Mb2NhdGlvbk9yVGhyb3c6eGUsZ2V0UHJvZ3JhbVVuaWZvcm1Mb2NhdGlvbjpiZSxiaW5kVGV4dHVyZVRvUHJvZ3JhbVVuaWZvcm1TYW1wbGVyOndlLGJpbmRDYW52YXNUb0ZyYW1lYnVmZmVyOmZ1bmN0aW9uKHQsZSl7SnQodCxlLChmdW5jdGlvbigpe3JldHVybiB0LmJpbmRGcmFtZWJ1ZmZlcih0LkZSQU1FQlVGRkVSLG51bGwpfSkpLEp0KHQsZSwoZnVuY3Rpb24oKXtyZXR1cm4gdC52aWV3cG9ydCgwLDAsdC5jYW52YXMud2lkdGgsdC5jYW52YXMuaGVpZ2h0KX0pKSxKdCh0LGUsKGZ1bmN0aW9uKCl7cmV0dXJuIHQuc2Npc3NvcigwLDAsdC5jYW52YXMud2lkdGgsdC5jYW52YXMuaGVpZ2h0KX0pKX0sYmluZENvbG9yVGV4dHVyZVRvRnJhbWVidWZmZXI6Q2UsdW5iaW5kQ29sb3JUZXh0dXJlRnJvbUZyYW1lYnVmZmVyOkVlLHZhbGlkYXRlRnJhbWVidWZmZXI6UmUsZ2V0RnJhbWVidWZmZXJFcnJvck1lc3NhZ2U6SWUsZ2V0QmF0Y2hEaW06QWUsZ2V0Um93c0NvbHM6RGUsZ2V0U2hhcGVBczNEOlRlLGdldFRleHR1cmVTaGFwZUZyb21Mb2dpY2FsU2hhcGU6TmUsaXNSZXNoYXBlRnJlZTpfZSxnZXRXZWJHTE1heFRleHR1cmVTaXplOk9lLHJlc2V0TWF4VGV4dHVyZVNpemU6ZnVuY3Rpb24oKXtpZT1udWxsfSxyZXNldE1heFRleHR1cmVzSW5TaGFkZXI6ZnVuY3Rpb24oKXtzZT1udWxsfSxnZXRNYXhUZXh0dXJlc0luU2hhZGVyOk1lLGdldFdlYkdMRGlzam9pbnRRdWVyeVRpbWVyVmVyc2lvbjpCZSxoYXNFeHRlbnNpb246UGUsaXNXZWJHTFZlcnNpb25FbmFibGVkOkxlLGlzQ2FwYWJsZU9mUmVuZGVyaW5nVG9GbG9hdFRleHR1cmU6V2UsaXNEb3dubG9hZEZsb2F0VGV4dHVyZUVuYWJsZWQ6VWUsaXNXZWJHTEZlbmNlRW5hYmxlZDp6ZX0pLEhlPWkoKTtmdW5jdGlvbiBxZSgpe2koKS5zZXQoXCJQUk9EXCIsITApfWZ1bmN0aW9uIEtlKCl7aSgpLnNldChcIkRFQlVHXCIsITApfWZ1bmN0aW9uIGplKCl7aSgpLnNldChcIkRFUFJFQ0FUSU9OX1dBUk5JTkdTX0VOQUJMRURcIiwhMSksY29uc29sZS53YXJuKFwiVGVuc29yRmxvdy5qcyBkZXByZWNhdGlvbiB3YXJuaW5ncyBoYXZlIGJlZW4gZGlzYWJsZWQuXCIpfWZ1bmN0aW9uIFhlKHQpe2koKS5nZXRCb29sKFwiREVQUkVDQVRJT05fV0FSTklOR1NfRU5BQkxFRFwiKSYmY29uc29sZS53YXJuKHQrXCIgWW91IGNhbiBkaXNhYmxlIGRlcHJlY2F0aW9uIHdhcm5pbmdzIHdpdGggdGYuZGlzYWJsZURlcHJlY2F0aW9uV2FybmluZ3MoKS5cIil9ZnVuY3Rpb24gWWUoKXtMdC5kaXNwb3NlVmFyaWFibGVzKCl9ZnVuY3Rpb24gJGUoKXtyZXR1cm4gTHR9ZnVuY3Rpb24gUWUoKXtyZXR1cm4gTHQubWVtb3J5KCl9ZnVuY3Rpb24gSmUodCl7cmV0dXJuIEx0LnByb2ZpbGUodCl9ZnVuY3Rpb24gWmUodCxlKXtyZXR1cm4gTHQudGlkeSh0LGUpfWZ1bmN0aW9uIHRuKHQpe190KHQpLmZvckVhY2goKGZ1bmN0aW9uKHQpe3JldHVybiB0LmRpc3Bvc2UoKX0pKX1mdW5jdGlvbiBlbih0KXtyZXR1cm4gTHQua2VlcCh0KX1mdW5jdGlvbiBubih0KXtyZXR1cm4gTHQudGltZSh0KX1mdW5jdGlvbiBybih0KXtyZXR1cm4gTHQuc2V0QmFja2VuZCh0KX1mdW5jdGlvbiBvbigpe3JldHVybiBMdC5yZWFkeSgpfWZ1bmN0aW9uIGFuKCl7cmV0dXJuIEx0LmJhY2tlbmROYW1lfWZ1bmN0aW9uIHNuKHQpe0x0LnJlbW92ZUJhY2tlbmQodCl9ZnVuY3Rpb24gdW4odCl7cmV0dXJuIEx0LmZpbmRCYWNrZW5kKHQpfWZ1bmN0aW9uIGNuKHQpe3JldHVybiBMdC5maW5kQmFja2VuZEZhY3RvcnkodCl9ZnVuY3Rpb24gbG4odCxlLG4pe3JldHVybiB2b2lkIDA9PT1uJiYobj0xKSxMdC5yZWdpc3RlckJhY2tlbmQodCxlLG4pfWZ1bmN0aW9uIGhuKCl7cmV0dXJuIEx0LmJhY2tlbmR9ZnVuY3Rpb24gZm4odCxlKXtpKCkuc2V0UGxhdGZvcm0odCxlKX1mdW5jdGlvbiBkbigpe2Zvcih2YXIgdD1bXSxlPTA7ZTxhcmd1bWVudHMubGVuZ3RoO2UrKyl0W2VdPWFyZ3VtZW50c1tlXTtpKCkuZ2V0Qm9vbChcIklTX1RFU1RcIil8fGNvbnNvbGUud2Fybi5hcHBseShjb25zb2xlLHQpfWZ1bmN0aW9uIHBuKHQsZSl7dmFyIG49dDtpZihWKHQpKXJldHVyblwic3RyaW5nXCI9PT1lP1tdOlt0Lmxlbmd0aF07aWYoIUFycmF5LmlzQXJyYXkodCkpcmV0dXJuW107Zm9yKHZhciByPVtdO0FycmF5LmlzQXJyYXkobil8fFYobikmJlwic3RyaW5nXCIhPT1lOylyLnB1c2gobi5sZW5ndGgpLG49blswXTtyZXR1cm4gQXJyYXkuaXNBcnJheSh0KSYmaSgpLmdldEJvb2woXCJURU5TT1JMSUtFX0NIRUNLX1NIQVBFX0NPTlNJU1RFTkNZXCIpJiZmdW5jdGlvbiB0KGUsbixyKXtpZihyPXJ8fFtdLCFBcnJheS5pc0FycmF5KGUpJiYhVihlKSlyZXR1cm4gdm9pZCBDKDA9PT1uLmxlbmd0aCwoZnVuY3Rpb24oKXtyZXR1cm5cIkVsZW1lbnQgYXJyW1wiK3Iuam9pbihcIl1bXCIpK1wiXSBpcyBhIHByaW1pdGl2ZSwgYnV0IHNob3VsZCBiZSBhbiBhcnJheS9UeXBlZEFycmF5IG9mIFwiK25bMF0rXCIgZWxlbWVudHNcIn0pKTtDKG4ubGVuZ3RoPjAsKGZ1bmN0aW9uKCl7cmV0dXJuXCJFbGVtZW50IGFycltcIityLmpvaW4oXCJdW1wiKStcIl0gc2hvdWxkIGJlIGEgcHJpbWl0aXZlLCBidXQgaXMgYW4gYXJyYXkgb2YgXCIrZS5sZW5ndGgrXCIgZWxlbWVudHNcIn0pKSxDKGUubGVuZ3RoPT09blswXSwoZnVuY3Rpb24oKXtyZXR1cm5cIkVsZW1lbnQgYXJyW1wiK3Iuam9pbihcIl1bXCIpK1wiXSBzaG91bGQgaGF2ZSBcIituWzBdK1wiIGVsZW1lbnRzLCBidXQgaGFzIFwiK2UubGVuZ3RoK1wiIGVsZW1lbnRzXCJ9KSk7Zm9yKHZhciBvPW4uc2xpY2UoMSksYT0wO2E8ZS5sZW5ndGg7KythKXQoZVthXSxvLHIuY29uY2F0KGEpKX0odCxyLFtdKSxyfWZ1bmN0aW9uIHZuKHQsZSxuLHIpe2lmKG51bGwhPXQmJihcIm51bWVyaWNcIiE9PXQmJnQhPT1lfHxcIm51bWVyaWNcIj09PXQmJlwic3RyaW5nXCI9PT1lKSl0aHJvdyBuZXcgRXJyb3IoXCJBcmd1bWVudCAnXCIrbitcIicgcGFzc2VkIHRvICdcIityK1wiJyBtdXN0IGJlIFwiK3QrXCIgdGVuc29yLCBidXQgZ290IFwiK2UrXCIgdGVuc29yXCIpfWZ1bmN0aW9uIG1uKHQsZSxuLHIpe2lmKHZvaWQgMD09PXImJihyPVwibnVtZXJpY1wiKSx0IGluc3RhbmNlb2Ygd3QpcmV0dXJuIHZuKHIsdC5kdHlwZSxlLG4pLHQ7dmFyIG89aih0KTtpZihcInN0cmluZ1wiIT09byYmW1wiYm9vbFwiLFwiaW50MzJcIixcImZsb2F0MzJcIl0uaW5kZXhPZihyKT49MCYmKG89ciksdm4ocixvLGUsbiksbnVsbD09dHx8IVYodCkmJiFBcnJheS5pc0FycmF5KHQpJiZcIm51bWJlclwiIT10eXBlb2YgdCYmXCJib29sZWFuXCIhPXR5cGVvZiB0JiZcInN0cmluZ1wiIT10eXBlb2YgdCl7dmFyIGE9bnVsbD09dD9cIm51bGxcIjp0LmNvbnN0cnVjdG9yLm5hbWU7dGhyb3cgbmV3IEVycm9yKFwiQXJndW1lbnQgJ1wiK2UrXCInIHBhc3NlZCB0byAnXCIrbitcIicgbXVzdCBiZSBhIFRlbnNvciBvciBUZW5zb3JMaWtlLCBidXQgZ290ICdcIithK1wiJ1wiKX12YXIgcz1wbih0LG8pO1YodCl8fEFycmF5LmlzQXJyYXkodCl8fCh0PVt0XSk7dmFyIHU9XCJzdHJpbmdcIiE9PW8/USh0LG8saSgpLmdldEJvb2woXCJERUJVR1wiKSk6SSh0LFtdLCEwKTtyZXR1cm4gTHQubWFrZVRlbnNvcih1LHMsbyl9ZnVuY3Rpb24gZ24odCxlLG4scil7aWYodm9pZCAwPT09ciYmKHI9XCJudW1lcmljXCIpLCFBcnJheS5pc0FycmF5KHQpKXRocm93IG5ldyBFcnJvcihcIkFyZ3VtZW50IFwiK2UrXCIgcGFzc2VkIHRvIFwiK24rXCIgbXVzdCBiZSBhIGBUZW5zb3JbXWAgb3IgYFRlbnNvckxpa2VbXWBcIik7cmV0dXJuIHQubWFwKChmdW5jdGlvbih0LHIpe3JldHVybiBtbih0LGUrXCJbXCIrcitcIl1cIixuKX0pLHIpfWZ1bmN0aW9uIHluKHQsZSl7Zm9yKHZhciBuPTA7bjx0Lmxlbmd0aDsrK24paWYodFt0Lmxlbmd0aC1uLTFdIT09ZS0xLW4pcmV0dXJuITE7cmV0dXJuITB9ZnVuY3Rpb24geG4odCxlLG4pe2Zvcih2YXIgcj10Lmxlbmd0aCtlLmxlbmd0aCxvPVtdLGE9MCxpPTAscz0wO3M8cjtzKyspLTE9PT1uLmluZGV4T2Yocyk/by5wdXNoKHRbYSsrXSk6by5wdXNoKGVbaSsrXSk7cmV0dXJuIG99ZnVuY3Rpb24gYm4odCxlKXtmb3IodmFyIG49W10scj10Lmxlbmd0aCxvPTA7bzxyO28rKyktMT09PWUuaW5kZXhPZihvKSYmbi5wdXNoKHRbb10pO3JldHVybltuLGUubWFwKChmdW5jdGlvbihlKXtyZXR1cm4gdFtlXX0pKV19ZnVuY3Rpb24gd24odCxlKXtyZXR1cm4geG4odCxlLm1hcCgoZnVuY3Rpb24odCl7cmV0dXJuIDF9KSksZSl9ZnVuY3Rpb24gQ24odCxlLG4pe0MoeW4oZSxuKSwoZnVuY3Rpb24oKXtyZXR1cm4gdCtcIiBzdXBwb3J0cyBvbmx5IGlubmVyLW1vc3QgYXhlcyBmb3Igbm93LiBHb3QgYXhlcyBcIitlK1wiIGFuZCByYW5rLVwiK24rXCIgaW5wdXQuXCJ9KSl9ZnVuY3Rpb24gRW4odCxlKXtpZih5bih0LGUpKXJldHVybiBudWxsO2Zvcih2YXIgbj1bXSxyPTA7cjxlOysrciktMT09PXQuaW5kZXhPZihyKSYmbi5wdXNoKHIpO3JldHVybiB0LmZvckVhY2goKGZ1bmN0aW9uKHQpe3JldHVybiBuLnB1c2godCl9KSksbn1mdW5jdGlvbiBSbih0KXtyZXR1cm4gdC5tYXAoKGZ1bmN0aW9uKHQsZSl7cmV0dXJuW2UsdF19KSkuc29ydCgoZnVuY3Rpb24odCxlKXtyZXR1cm4gdFsxXS1lWzFdfSkpLm1hcCgoZnVuY3Rpb24odCl7cmV0dXJuIHRbMF19KSl9ZnVuY3Rpb24gSW4odCxlKXtmb3IodmFyIG49W10scj1lLXQ7cjxlOysrciluLnB1c2gocik7cmV0dXJuIG59ZnVuY3Rpb24ga24odCxlKXt2YXIgbj10WzBdLmxlbmd0aDt0LmZvckVhY2goKGZ1bmN0aW9uKHQsZSl7Qyh0Lmxlbmd0aD09PW4sKGZ1bmN0aW9uKCl7cmV0dXJuXCJFcnJvciBpbiBjb25jYXRcIituK1wiRDogcmFuayBvZiB0ZW5zb3JzW1wiK2UrXCJdIG11c3QgYmUgdGhlIHNhbWUgYXMgdGhlIHJhbmsgb2YgdGhlIHJlc3QgKFwiK24rXCIpXCJ9KSl9KSksQyhlPj0wJiZlPG4sKGZ1bmN0aW9uKCl7cmV0dXJuXCJFcnJvciBpbiBjb25jYXRcIituK1wiRDogYXhpcyBtdXN0IGJlIGJldHdlZW4gMCBhbmQgXCIrKG4tMSkrXCIuXCJ9KSk7dmFyIHI9dFswXTt0LmZvckVhY2goKGZ1bmN0aW9uKHQsbyl7Zm9yKHZhciBhPTA7YTxuO2ErKylDKGE9PT1lfHx0W2FdPT09clthXSwoZnVuY3Rpb24oKXtyZXR1cm5cIkVycm9yIGluIGNvbmNhdFwiK24rXCJEOiBTaGFwZSBvZiB0ZW5zb3JzW1wiK28rXCJdIChcIit0K1wiKSBkb2VzIG5vdCBtYXRjaCB0aGUgc2hhcGUgb2YgdGhlIHJlc3QgKFwiK3IrXCIpIGFsb25nIHRoZSBub24tY29uY2F0ZW5hdGVkIGF4aXMgXCIrbytcIi5cIn0pKX0pKX1mdW5jdGlvbiBTbih0LGUpe2Zvcih2YXIgbj10WzBdLnNsaWNlKCkscj0xO3I8dC5sZW5ndGg7cisrKW5bZV0rPXRbcl1bZV07cmV0dXJuIG59ZnVuY3Rpb24gQW4odCl7dmFyIGU9T2JqZWN0LmtleXModCk7aWYoMSE9PWUubGVuZ3RoKXRocm93IG5ldyBFcnJvcihcIlBsZWFzZSBwcm92aWRlIGFuIG9iamVjdCB3aXRoIGEgc2luZ2xlIGtleSAob3BlcmF0aW9uIG5hbWUpIG1hcHBpbmcgdG8gYSBmdW5jdGlvbi4gR290IGFuIG9iamVjdCB3aXRoIFwiK2UubGVuZ3RoK1wiIGtleXMuXCIpO3ZhciBuPWVbMF0scj10W25dO24uZW5kc1dpdGgoXCJfXCIpJiYobj1uLnN1YnN0cmluZygwLG4ubGVuZ3RoLTEpKTt2YXIgbz1mdW5jdGlvbigpe2Zvcih2YXIgdD1bXSxlPTA7ZTxhcmd1bWVudHMubGVuZ3RoO2UrKyl0W2VdPWFyZ3VtZW50c1tlXTtMdC5zdGFydFNjb3BlKG4pO3RyeXt2YXIgbz1yLmFwcGx5KHZvaWQgMCx0KTtyZXR1cm4gbyBpbnN0YW5jZW9mIFByb21pc2UmJmNvbnNvbGUuZXJyb3IoXCJDYW5ub3QgcmV0dXJuIGEgUHJvbWlzZSBpbnNpZGUgb2YgdGlkeS5cIiksTHQuZW5kU2NvcGUobyksb31jYXRjaCh0KXt0aHJvdyBMdC5lbmRTY29wZShudWxsKSx0fX07cmV0dXJuIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLFwibmFtZVwiLHt2YWx1ZTpuLGNvbmZpZ3VyYWJsZTohMH0pLG99SGUucmVnaXN0ZXJGbGFnKFwiSEFTX1dFQkdMXCIsKGZ1bmN0aW9uKCl7cmV0dXJuIEhlLmdldE51bWJlcihcIldFQkdMX1ZFUlNJT05cIik+MH0pKSxIZS5yZWdpc3RlckZsYWcoXCJXRUJHTF9WRVJTSU9OXCIsKGZ1bmN0aW9uKCl7cmV0dXJuIExlKDIpPzI6TGUoMSk/MTowfSkpLEhlLnJlZ2lzdGVyRmxhZyhcIldFQkdMX0JVRkZFUl9TVVBQT1JURURcIiwoZnVuY3Rpb24oKXtyZXR1cm4gMj09PUhlLmdldChcIldFQkdMX1ZFUlNJT05cIil9KSksSGUucmVnaXN0ZXJGbGFnKFwiV0VCR0xfQ1BVX0ZPUldBUkRcIiwoZnVuY3Rpb24oKXtyZXR1cm4hMH0pKSxIZS5yZWdpc3RlckZsYWcoXCJXRUJHTF9GT1JDRV9GMTZfVEVYVFVSRVNcIiwoZnVuY3Rpb24oKXtyZXR1cm4hMX0pKSxIZS5yZWdpc3RlckZsYWcoXCJXRUJHTF9QQUNLXCIsKGZ1bmN0aW9uKCl7cmV0dXJuIEhlLmdldEJvb2woXCJIQVNfV0VCR0xcIil9KSksSGUucmVnaXN0ZXJGbGFnKFwiV0VCR0xfUEFDS19OT1JNQUxJWkFUSU9OXCIsKGZ1bmN0aW9uKCl7cmV0dXJuIEhlLmdldEJvb2woXCJXRUJHTF9QQUNLXCIpfSkpLEhlLnJlZ2lzdGVyRmxhZyhcIldFQkdMX1BBQ0tfQ0xJUFwiLChmdW5jdGlvbigpe3JldHVybiBIZS5nZXRCb29sKFwiV0VCR0xfUEFDS1wiKX0pKSxIZS5yZWdpc3RlckZsYWcoXCJXRUJHTF9QQUNLX0RFUFRIV0lTRUNPTlZcIiwoZnVuY3Rpb24oKXtyZXR1cm4hMX0pKSxIZS5yZWdpc3RlckZsYWcoXCJXRUJHTF9QQUNLX0JJTkFSWV9PUEVSQVRJT05TXCIsKGZ1bmN0aW9uKCl7cmV0dXJuIEhlLmdldEJvb2woXCJXRUJHTF9QQUNLXCIpfSkpLEhlLnJlZ2lzdGVyRmxhZyhcIldFQkdMX1BBQ0tfVU5BUllfT1BFUkFUSU9OU1wiLChmdW5jdGlvbigpe3JldHVybiBIZS5nZXRCb29sKFwiV0VCR0xfUEFDS1wiKX0pKSxIZS5yZWdpc3RlckZsYWcoXCJXRUJHTF9QQUNLX0FSUkFZX09QRVJBVElPTlNcIiwoZnVuY3Rpb24oKXtyZXR1cm4gSGUuZ2V0Qm9vbChcIldFQkdMX1BBQ0tcIil9KSksSGUucmVnaXN0ZXJGbGFnKFwiV0VCR0xfUEFDS19JTUFHRV9PUEVSQVRJT05TXCIsKGZ1bmN0aW9uKCl7cmV0dXJuIEhlLmdldEJvb2woXCJXRUJHTF9QQUNLXCIpfSkpLEhlLnJlZ2lzdGVyRmxhZyhcIldFQkdMX1BBQ0tfUkVEVUNFXCIsKGZ1bmN0aW9uKCl7cmV0dXJuIEhlLmdldEJvb2woXCJXRUJHTF9QQUNLXCIpfSkpLEhlLnJlZ2lzdGVyRmxhZyhcIldFQkdMX0xBWklMWV9VTlBBQ0tcIiwoZnVuY3Rpb24oKXtyZXR1cm4gSGUuZ2V0Qm9vbChcIldFQkdMX1BBQ0tcIil9KSksSGUucmVnaXN0ZXJGbGFnKFwiV0VCR0xfQ09OVl9JTTJDT0xcIiwoZnVuY3Rpb24oKXtyZXR1cm4gSGUuZ2V0Qm9vbChcIldFQkdMX1BBQ0tcIil9KSksSGUucmVnaXN0ZXJGbGFnKFwiV0VCR0xfTUFYX1RFWFRVUkVfU0laRVwiLChmdW5jdGlvbigpe3JldHVybiBPZShIZS5nZXROdW1iZXIoXCJXRUJHTF9WRVJTSU9OXCIpKX0pKSxIZS5yZWdpc3RlckZsYWcoXCJXRUJHTF9NQVhfVEVYVFVSRVNfSU5fU0hBREVSXCIsKGZ1bmN0aW9uKCl7cmV0dXJuIE1lKEhlLmdldE51bWJlcihcIldFQkdMX1ZFUlNJT05cIikpfSkpLEhlLnJlZ2lzdGVyRmxhZyhcIldFQkdMX0RJU0pPSU5UX1FVRVJZX1RJTUVSX0VYVEVOU0lPTl9WRVJTSU9OXCIsKGZ1bmN0aW9uKCl7dmFyIHQ9SGUuZ2V0TnVtYmVyKFwiV0VCR0xfVkVSU0lPTlwiKTtyZXR1cm4gMD09PXQ/MDpCZSh0KX0pKSxIZS5yZWdpc3RlckZsYWcoXCJXRUJHTF9ESVNKT0lOVF9RVUVSWV9USU1FUl9FWFRFTlNJT05fUkVMSUFCTEVcIiwoZnVuY3Rpb24oKXtyZXR1cm4gSGUuZ2V0TnVtYmVyKFwiV0VCR0xfRElTSk9JTlRfUVVFUllfVElNRVJfRVhURU5TSU9OX1ZFUlNJT05cIik+MCYmKHQ9bmF2aWdhdG9yLnVzZXJBZ2VudHx8bmF2aWdhdG9yLnZlbmRvcnx8d2luZG93Lm9wZXJhLCEoLyhhbmRyb2lkfGJiXFxkK3xtZWVnbykuK21vYmlsZXxhdmFudGdvfGJhZGFcXC98YmxhY2tiZXJyeXxibGF6ZXJ8Y29tcGFsfGVsYWluZXxmZW5uZWN8aGlwdG9wfGllbW9iaWxlfGlwKGhvbmV8b2QpfGlyaXN8a2luZGxlfGxnZSB8bWFlbW98bWlkcHxtbXB8bW9iaWxlLitmaXJlZm94fG5ldGZyb250fG9wZXJhIG0ob2J8aW4paXxwYWxtKCBvcyk/fHBob25lfHAoaXhpfHJlKVxcL3xwbHVja2VyfHBvY2tldHxwc3B8c2VyaWVzKDR8NikwfHN5bWJpYW58dHJlb3x1cFxcLihicm93c2VyfGxpbmspfHZvZGFmb25lfHdhcHx3aW5kb3dzIGNlfHhkYXx4aWluby9pLnRlc3QodCl8fC8xMjA3fDYzMTB8NjU5MHwzZ3NvfDR0aHB8NTBbMS02XWl8Nzcwc3w4MDJzfGEgd2F8YWJhY3xhYyhlcnxvb3xzXFwtKXxhaShrb3xybil8YWwoYXZ8Y2F8Y28pfGFtb2l8YW4oZXh8bnl8eXcpfGFwdHV8YXIoY2h8Z28pfGFzKHRlfHVzKXxhdHR3fGF1KGRpfFxcLW18ciB8cyApfGF2YW58YmUoY2t8bGx8bnEpfGJpKGxifHJkKXxibChhY3xheil8YnIoZXx2KXd8YnVtYnxid1xcLShufHUpfGM1NVxcL3xjYXBpfGNjd2F8Y2RtXFwtfGNlbGx8Y2h0bXxjbGRjfGNtZFxcLXxjbyhtcHxuZCl8Y3Jhd3xkYShpdHxsbHxuZyl8ZGJ0ZXxkY1xcLXN8ZGV2aXxkaWNhfGRtb2J8ZG8oY3xwKW98ZHMoMTJ8XFwtZCl8ZWwoNDl8YWkpfGVtKGwyfHVsKXxlcihpY3xrMCl8ZXNsOHxleihbNC03XTB8b3N8d2F8emUpfGZldGN8Zmx5KFxcLXxfKXxnMSB1fGc1NjB8Z2VuZXxnZlxcLTV8Z1xcLW1vfGdvKFxcLnd8b2QpfGdyKGFkfHVuKXxoYWllfGhjaXR8aGRcXC0obXxwfHQpfGhlaVxcLXxoaShwdHx0YSl8aHAoIGl8aXApfGhzXFwtY3xodChjKFxcLXwgfF98YXxnfHB8c3x0KXx0cCl8aHUoYXd8dGMpfGlcXC0oMjB8Z298bWEpfGkyMzB8aWFjKCB8XFwtfFxcLyl8aWJyb3xpZGVhfGlnMDF8aWtvbXxpbTFrfGlubm98aXBhcXxpcmlzfGphKHR8dilhfGpicm98amVtdXxqaWdzfGtkZGl8a2VqaXxrZ3QoIHxcXC8pfGtsb258a3B0IHxrd2NcXC18a3lvKGN8ayl8bGUobm98eGkpfGxnKCBnfFxcLyhrfGx8dSl8NTB8NTR8XFwtW2Etd10pfGxpYnd8bHlueHxtMVxcLXd8bTNnYXxtNTBcXC98bWEodGV8dWl8eG8pfG1jKDAxfDIxfGNhKXxtXFwtY3J8bWUocmN8cmkpfG1pKG84fG9hfHRzKXxtbWVmfG1vKDAxfDAyfGJpfGRlfGRvfHQoXFwtfCB8b3x2KXx6eil8bXQoNTB8cDF8diApfG13YnB8bXl3YXxuMTBbMC0yXXxuMjBbMi0zXXxuMzAoMHwyKXxuNTAoMHwyfDUpfG43KDAoMHwxKXwxMCl8bmUoKGN8bSlcXC18b258dGZ8d2Z8d2d8d3QpfG5vayg2fGkpfG56cGh8bzJpbXxvcCh0aXx3dil8b3Jhbnxvd2cxfHA4MDB8cGFuKGF8ZHx0KXxwZHhnfHBnKDEzfFxcLShbMS04XXxjKSl8cGhpbHxwaXJlfHBsKGF5fHVjKXxwblxcLTJ8cG8oY2t8cnR8c2UpfHByb3h8cHNpb3xwdFxcLWd8cWFcXC1hfHFjKDA3fDEyfDIxfDMyfDYwfFxcLVsyLTddfGlcXC0pfHF0ZWt8cjM4MHxyNjAwfHJha3N8cmltOXxybyh2ZXx6byl8czU1XFwvfHNhKGdlfG1hfG1tfG1zfG55fHZhKXxzYygwMXxoXFwtfG9vfHBcXC0pfHNka1xcL3xzZShjKFxcLXwwfDEpfDQ3fG1jfG5kfHJpKXxzZ2hcXC18c2hhcnxzaWUoXFwtfG0pfHNrXFwtMHxzbCg0NXxpZCl8c20oYWx8YXJ8YjN8aXR8dDUpfHNvKGZ0fG55KXxzcCgwMXxoXFwtfHZcXC18diApfHN5KDAxfG1iKXx0MigxOHw1MCl8dDYoMDB8MTB8MTgpfHRhKGd0fGxrKXx0Y2xcXC18dGRnXFwtfHRlbChpfG0pfHRpbVxcLXx0XFwtbW98dG8ocGx8c2gpfHRzKDcwfG1cXC18bTN8bTUpfHR4XFwtOXx1cChcXC5ifGcxfHNpKXx1dHN0fHY0MDB8djc1MHx2ZXJpfHZpKHJnfHRlKXx2ayg0MHw1WzAtM118XFwtdil8dm00MHx2b2RhfHZ1bGN8dngoNTJ8NTN8NjB8NjF8NzB8ODB8ODF8ODN8ODV8OTgpfHczYyhcXC18ICl8d2ViY3x3aGl0fHdpKGcgfG5jfG53KXx3bWxifHdvbnV8eDcwMHx5YXNcXC18eW91cnx6ZXRvfHp0ZVxcLS9pLnRlc3QodC5zdWJzdHIoMCw0KSkpKTt2YXIgdH0pKSxIZS5yZWdpc3RlckZsYWcoXCJXRUJHTF9SRU5ERVJfRkxPQVQzMl9DQVBBQkxFXCIsKGZ1bmN0aW9uKCl7cmV0dXJuIFdlKEhlLmdldE51bWJlcihcIldFQkdMX1ZFUlNJT05cIikpfSkpLEhlLnJlZ2lzdGVyRmxhZyhcIldFQkdMX1JFTkRFUl9GTE9BVDMyX0VOQUJMRURcIiwoZnVuY3Rpb24oKXtyZXR1cm4hSGUuZ2V0Qm9vbChcIldFQkdMX0ZPUkNFX0YxNl9URVhUVVJFU1wiKSYmSGUuZ2V0Qm9vbChcIldFQkdMX1JFTkRFUl9GTE9BVDMyX0NBUEFCTEVcIil9KSksSGUucmVnaXN0ZXJGbGFnKFwiV0VCR0xfRE9XTkxPQURfRkxPQVRfRU5BQkxFRFwiLChmdW5jdGlvbigpe3JldHVybiBVZShIZS5nZXROdW1iZXIoXCJXRUJHTF9WRVJTSU9OXCIpKX0pKSxIZS5yZWdpc3RlckZsYWcoXCJXRUJHTF9GRU5DRV9BUElfRU5BQkxFRFwiLChmdW5jdGlvbigpe3JldHVybiB6ZShIZS5nZXROdW1iZXIoXCJXRUJHTF9WRVJTSU9OXCIpKX0pKSxIZS5yZWdpc3RlckZsYWcoXCJXRUJHTF9TSVpFX1VQTE9BRF9VTklGT1JNXCIsKGZ1bmN0aW9uKCl7cmV0dXJuIEhlLmdldEJvb2woXCJXRUJHTF9SRU5ERVJfRkxPQVQzMl9FTkFCTEVEXCIpPzQ6MH0pKSxidD1YZTt2YXIgRG49QW4oe2NvbXBsZXhfOmZ1bmN0aW9uKHQsZSl7dmFyIG49bW4odCxcInJlYWxcIixcImNvbXBsZXhcIikscj1tbihlLFwiaW1hZ1wiLFwiY29tcGxleFwiKTtyZXR1cm4gRShuLnNoYXBlLHIuc2hhcGUsXCJyZWFsIGFuZCBpbWFnIHNoYXBlcywgXCIrbi5zaGFwZStcIiBhbmQgXCIrci5zaGFwZStcIiwgbXVzdCBtYXRjaCBpbiBjYWxsIHRvIHRmLmNvbXBsZXgoKS5cIiksTHQucnVuS2VybmVsRnVuYygoZnVuY3Rpb24odCl7cmV0dXJuIHQuY29tcGxleChuLHIpfSkseyRyZWFsOm4sJGltYWc6cn0pfX0pLFRuPUFuKHtyZWFsXzpmdW5jdGlvbih0KXt2YXIgZT1tbih0LFwiaW5wdXRcIixcInJlYWxcIik7cmV0dXJuIEx0LnJ1bktlcm5lbEZ1bmMoKGZ1bmN0aW9uKHQpe3JldHVybiB0LnJlYWwoZSl9KSx7JGlucHV0OmV9KX19KSxObj1Bbih7aW1hZ186ZnVuY3Rpb24odCl7dmFyIGU9bW4odCxcImlucHV0XCIsXCJpbWFnXCIpO3JldHVybiBMdC5ydW5LZXJuZWxGdW5jKChmdW5jdGlvbih0KXtyZXR1cm4gdC5pbWFnKGUpfSkseyRpbnB1dDplfSl9fSk7ZnVuY3Rpb24gRm4odCxlLG4pe3JldHVybiBfbih0LGUscG4odCxuKSxuKX1mdW5jdGlvbiBfbih0LGUsbixyKXtpZihudWxsPT1yJiYocj1qKHQpKSxcImNvbXBsZXg2NFwiPT09cil0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgY29uc3RydWN0IGEgY29tcGxleDY0IHRlbnNvciBkaXJlY3RseS4gUGxlYXNlIHVzZSB0Zi5jb21wbGV4KHJlYWwsIGltYWcpLlwiKTtpZighVih0KSYmIUFycmF5LmlzQXJyYXkodCkmJlwibnVtYmVyXCIhPXR5cGVvZiB0JiZcImJvb2xlYW5cIiE9dHlwZW9mIHQmJlwic3RyaW5nXCIhPXR5cGVvZiB0KXRocm93IG5ldyBFcnJvcihcInZhbHVlcyBwYXNzZWQgdG8gdGVuc29yKHZhbHVlcykgbXVzdCBiZSBhIG51bWJlci9ib29sZWFuL3N0cmluZyBvciBhbiBhcnJheSBvZiBudW1iZXJzL2Jvb2xlYW5zL3N0cmluZ3MsIG9yIGEgVHlwZWRBcnJheVwiKTtpZihudWxsIT1lKXtudChlKTt2YXIgbz1rKGUpLGE9ayhuKTtDKG89PT1hLChmdW5jdGlvbigpe3JldHVyblwiQmFzZWQgb24gdGhlIHByb3ZpZGVkIHNoYXBlLCBbXCIrZStcIl0sIHRoZSB0ZW5zb3Igc2hvdWxkIGhhdmUgXCIrbytcIiB2YWx1ZXMgYnV0IGhhcyBcIithfSkpO2Zvcih2YXIgcz0wO3M8bi5sZW5ndGg7KytzKXt2YXIgdT1uW3NdLGM9cyE9PW4ubGVuZ3RoLTF8fHUhPT1rKGUuc2xpY2UocykpO0MobltzXT09PWVbc118fCFjLChmdW5jdGlvbigpe3JldHVyblwiRXJyb3IgY3JlYXRpbmcgYSBuZXcgVGVuc29yLiBJbmZlcnJlZCBzaGFwZSAoXCIrbitcIikgZG9lcyBub3QgbWF0Y2ggdGhlIHByb3ZpZGVkIHNoYXBlIChcIitlK1wiKS4gXCJ9KSl9fXJldHVybiBWKHQpfHxBcnJheS5pc0FycmF5KHQpfHwodD1bdF0pLGU9ZXx8bix0PVwic3RyaW5nXCIhPT1yP1EodCxyLGkoKS5nZXRCb29sKFwiREVCVUdcIikpOkkodCxbXSwhMCksTHQubWFrZVRlbnNvcih0LGUscil9ZnVuY3Rpb24gT24odCxlKXtpZigoVih0KSYmXCJzdHJpbmdcIiE9PWV8fEFycmF5LmlzQXJyYXkodCkpJiZcImNvbXBsZXg2NFwiIT09ZSl0aHJvdyBuZXcgRXJyb3IoXCJFcnJvciBjcmVhdGluZyBhIG5ldyBTY2FsYXI6IHZhbHVlIG11c3QgYmUgYSBwcmltaXRpdmUgKG51bWJlcnxib29sZWFufHN0cmluZylcIik7aWYoXCJzdHJpbmdcIj09PWUmJlYodCkmJiEodCBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpKXRocm93IG5ldyBFcnJvcihcIldoZW4gbWFraW5nIGEgc2NhbGFyIGZyb20gZW5jb2RlZCBzdHJpbmcsIHRoZSB2YWx1ZSBtdXN0IGJlIGBVaW50OEFycmF5YC5cIik7cmV0dXJuIF9uKHQsW10sW10sZSl9ZnVuY3Rpb24gTW4odCxlKXtSKHQpO3ZhciBuPXBuKHQsZSk7aWYoMSE9PW4ubGVuZ3RoKXRocm93IG5ldyBFcnJvcihcInRlbnNvcjFkKCkgcmVxdWlyZXMgdmFsdWVzIHRvIGJlIGEgZmxhdC9UeXBlZEFycmF5XCIpO3JldHVybiBfbih0LG51bGwsbixlKX1mdW5jdGlvbiBCbih0LGUsbil7aWYoUih0KSxudWxsIT1lJiYyIT09ZS5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwidGVuc29yMmQoKSByZXF1aXJlcyBzaGFwZSB0byBoYXZlIHR3byBudW1iZXJzXCIpO3ZhciByPXBuKHQsbik7aWYoMiE9PXIubGVuZ3RoJiYxIT09ci5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwidGVuc29yMmQoKSByZXF1aXJlcyB2YWx1ZXMgdG8gYmUgbnVtYmVyW11bXSBvciBmbGF0L1R5cGVkQXJyYXlcIik7aWYoMT09PXIubGVuZ3RoJiZudWxsPT1lKXRocm93IG5ldyBFcnJvcihcInRlbnNvcjJkKCkgcmVxdWlyZXMgc2hhcGUgdG8gYmUgcHJvdmlkZWQgd2hlbiBgdmFsdWVzYCBhcmUgYSBmbGF0L1R5cGVkQXJyYXlcIik7cmV0dXJuIF9uKHQsZSxyLG4pfWZ1bmN0aW9uIFBuKHQsZSxuKXtpZihSKHQpLG51bGwhPWUmJjMhPT1lLmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJ0ZW5zb3IzZCgpIHJlcXVpcmVzIHNoYXBlIHRvIGhhdmUgdGhyZWUgbnVtYmVyc1wiKTt2YXIgcj1wbih0LG4pO2lmKDMhPT1yLmxlbmd0aCYmMSE9PXIubGVuZ3RoKXRocm93IG5ldyBFcnJvcihcInRlbnNvcjNkKCkgcmVxdWlyZXMgdmFsdWVzIHRvIGJlIG51bWJlcltdW11bXSBvciBmbGF0L1R5cGVkQXJyYXlcIik7aWYoMT09PXIubGVuZ3RoJiZudWxsPT1lKXRocm93IG5ldyBFcnJvcihcInRlbnNvcjNkKCkgcmVxdWlyZXMgc2hhcGUgdG8gYmUgcHJvdmlkZWQgd2hlbiBgdmFsdWVzYCBhcmUgYSBmbGF0IGFycmF5XCIpO3JldHVybiBfbih0LGUscixuKX1mdW5jdGlvbiBMbih0LGUsbil7aWYoUih0KSxudWxsIT1lJiY0IT09ZS5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwidGVuc29yNGQoKSByZXF1aXJlcyBzaGFwZSB0byBoYXZlIGZvdXIgbnVtYmVyc1wiKTt2YXIgcj1wbih0LG4pO2lmKDQhPT1yLmxlbmd0aCYmMSE9PXIubGVuZ3RoKXRocm93IG5ldyBFcnJvcihcInRlbnNvcjRkKCkgcmVxdWlyZXMgdmFsdWVzIHRvIGJlIG51bWJlcltdW11bXVtdIG9yIGZsYXQvVHlwZWRBcnJheVwiKTtpZigxPT09ci5sZW5ndGgmJm51bGw9PWUpdGhyb3cgbmV3IEVycm9yKFwidGVuc29yNGQoKSByZXF1aXJlcyBzaGFwZSB0byBiZSBwcm92aWRlZCB3aGVuIGB2YWx1ZXNgIGFyZSBhIGZsYXQgYXJyYXlcIik7cmV0dXJuIF9uKHQsZSxyLG4pfWZ1bmN0aW9uIFduKHQsZSxuKXtpZihSKHQpLG51bGwhPWUmJjUhPT1lLmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJ0ZW5zb3I1ZCgpIHJlcXVpcmVzIHNoYXBlIHRvIGhhdmUgZml2ZSBudW1iZXJzXCIpO3ZhciByPXBuKHQsbik7aWYoNSE9PXIubGVuZ3RoJiYxIT09ci5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwidGVuc29yNWQoKSByZXF1aXJlcyB2YWx1ZXMgdG8gYmUgbnVtYmVyW11bXVtdW11bXSBvciBmbGF0L1R5cGVkQXJyYXlcIik7aWYoMT09PXIubGVuZ3RoJiZudWxsPT1lKXRocm93IG5ldyBFcnJvcihcInRlbnNvcjVkKCkgcmVxdWlyZXMgc2hhcGUgdG8gYmUgcHJvdmlkZWQgd2hlbiBgdmFsdWVzYCBhcmUgYSBmbGF0IGFycmF5XCIpO3JldHVybiBfbih0LGUscixuKX1mdW5jdGlvbiBVbih0LGUsbil7aWYoUih0KSxudWxsIT1lJiY2IT09ZS5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwidGVuc29yNmQoKSByZXF1aXJlcyBzaGFwZSB0byBoYXZlIHNpeCBudW1iZXJzXCIpO3ZhciByPXBuKHQsbik7aWYoNiE9PXIubGVuZ3RoJiYxIT09ci5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwidGVuc29yNmQoKSByZXF1aXJlcyB2YWx1ZXMgdG8gYmUgbnVtYmVyW11bXVtdW11bXVtdIG9yIGZsYXQvVHlwZWRBcnJheVwiKTtpZigxPT09ci5sZW5ndGgmJm51bGw9PWUpdGhyb3cgbmV3IEVycm9yKFwidGVuc29yNmQoKSByZXF1aXJlcyBzaGFwZSB0byBiZSBwcm92aWRlZCB3aGVuIGB2YWx1ZXNgIGFyZSBhIGZsYXQgYXJyYXlcIik7cmV0dXJuIF9uKHQsZT1lfHxyLHIsbil9ZnVuY3Rpb24gVm4odCxlLG4scil7cmV0dXJuIHZvaWQgMD09PWUmJihlPSEwKSxMdC5tYWtlVmFyaWFibGUodCxlLG4scil9ZnVuY3Rpb24gem4odCxlKXtpZih2b2lkIDA9PT1lJiYoZT1cImZsb2F0MzJcIiksXCJjb21wbGV4NjRcIj09PWUpe3ZhciBuPXpuKHQsXCJmbG9hdDMyXCIpLHI9R24odCxcImZsb2F0MzJcIik7cmV0dXJuIERuKG4scil9dmFyIG89WihrKHQpLGUpO3JldHVybiBMdC5tYWtlVGVuc29yKG8sdCxlKX1mdW5jdGlvbiBHbih0LGUpe2lmKHZvaWQgMD09PWUmJihlPVwiZmxvYXQzMlwiKSxcImNvbXBsZXg2NFwiPT09ZSl7dmFyIG49R24odCxcImZsb2F0MzJcIikscj1Hbih0LFwiZmxvYXQzMlwiKTtyZXR1cm4gRG4obixyKX12YXIgbz10dChrKHQpLGUpO3JldHVybiBMdC5tYWtlVGVuc29yKG8sdCxlKX1mdW5jdGlvbiBIbih0LGUsbil7cmV0dXJuIEx0LnJ1bktlcm5lbEZ1bmMoKGZ1bmN0aW9uKHIpe3JldHVybiByLmZpbGwodCxlLG4pfSkse30pfWZ1bmN0aW9uIHFuKHQsZSxuKXtpZihuPD0wKXRocm93IG5ldyBFcnJvcihcIlRoZSBudW1iZXIgb2YgdmFsdWVzIHNob3VsZCBiZSBwb3NpdGl2ZS5cIik7cmV0dXJuIEx0LnJ1bktlcm5lbEZ1bmMoKGZ1bmN0aW9uKHIpe3JldHVybiByLmxpbnNwYWNlKHQsZSxuKX0pLHt9KX1mdW5jdGlvbiBLbih0LGUsbixyKXtpZih2b2lkIDA9PT1uJiYobj0xKSx2b2lkIDA9PT1yJiYocj1cImZsb2F0MzJcIiksMD09PW4pdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGhhdmUgYSBzdGVwIG9mIHplcm9cIik7aWYodD09PWV8fHQ8ZSYmbjwwfHxlPHQmJm4+MSlyZXR1cm4gR24oWzBdLHIpO3ZhciBvPXR0KE1hdGguYWJzKE1hdGguY2VpbCgoZS10KS9uKSkscik7ZTx0JiYxPT09biYmKG49LTEpLG9bMF09dDtmb3IodmFyIGE9MTthPG8ubGVuZ3RoO2ErKylvW2FdPW9bYS0xXStuO3JldHVybiBNbihvLHIpfXZhciBqbj1Bbih7b25lc0xpa2VfOmZ1bmN0aW9uKHQpe3ZhciBlPW1uKHQsXCJ4XCIsXCJvbmVzTGlrZVwiKTtpZihcImNvbXBsZXg2NFwiPT09ZS5kdHlwZSl7dmFyIG49am4oVG4oZSkpLHI9WG4oTm4oZSkpO3JldHVybiBEbihuLHIpfXJldHVybiBMdC5ydW5LZXJuZWxGdW5jKChmdW5jdGlvbih0KXtyZXR1cm4gdC5vbmVzTGlrZShlKX0pLHskeDplfSwoZnVuY3Rpb24odCxlKXtyZXR1cm57JHg6ZnVuY3Rpb24oKXtyZXR1cm4gWG4odCl9fX0pKX19KSxYbj1Bbih7emVyb3NMaWtlXzpmdW5jdGlvbih0KXt2YXIgZT1tbih0LFwieFwiLFwiemVyb3NMaWtlXCIpO3JldHVybiBMdC5ydW5LZXJuZWxGdW5jKChmdW5jdGlvbih0KXtyZXR1cm4gdC56ZXJvc0xpa2UoZSl9KSx7JHg6ZX0sKGZ1bmN0aW9uKHQsZSl7cmV0dXJueyR4OmZ1bmN0aW9uKCl7cmV0dXJuIFhuKHQpfX19KSl9fSk7dmFyIFluPUFuKHtjb25jYXRfOmZ1bmN0aW9uKHQsZSl7dm9pZCAwPT09ZSYmKGU9MCksQyh0Lmxlbmd0aD49MSwoZnVuY3Rpb24oKXtyZXR1cm5cIlBhc3MgYXQgbGVhc3Qgb25lIHRlbnNvciB0byBjb25jYXRcIn0pKTt2YXIgbj1nbih0LFwidGVuc29yc1wiLFwiY29uY2F0XCIpO1wiY29tcGxleDY0XCI9PT1uWzBdLmR0eXBlJiZuLmZvckVhY2goKGZ1bmN0aW9uKHQpe2lmKFwiY29tcGxleDY0XCIhPT10LmR0eXBlKXRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBjb25jYXRlbmF0ZSBjb21wbGV4NjQgdGVuc29ycyB3aXRoIGEgdGVuc29yXFxuICAgICAgICAgIHdpdGggZHR5cGUgXCIrdC5kdHlwZStcIi4gXCIpfSkpLGU9TyhlLG5bMF0uc2hhcGUpWzBdO3ZhciByPVNuKG4ubWFwKChmdW5jdGlvbih0KXtyZXR1cm4gdC5zaGFwZX0pKSxlKTtpZigwPT09ayhyKSlyZXR1cm4gRm4oW10scik7aWYoMT09PShuPW4uZmlsdGVyKChmdW5jdGlvbih0KXtyZXR1cm4gdC5zaXplPjB9KSkpLmxlbmd0aClyZXR1cm4gblswXTt2YXIgbz1uLm1hcCgoZnVuY3Rpb24odCl7cmV0dXJuIHQuc2hhcGV9KSk7a24obyxlKTt2YXIgYT1uLGk9e2F4aXM6ZX07cmV0dXJuIEx0LnJ1bktlcm5lbEZ1bmMoKGZ1bmN0aW9uKHQpe3JldHVybiB0LmNvbmNhdChuLGUpfSksYSwoZnVuY3Rpb24odCl7dmFyIG49by5tYXAoKGZ1bmN0aW9uKHQpe3JldHVybiB0W2VdfSkpO3JldHVybiB0cih0LG4sZSkubWFwKChmdW5jdGlvbih0KXtyZXR1cm4gZnVuY3Rpb24oKXtyZXR1cm4gdH19KSl9KSxcIkNvbmNhdFwiLGkpfX0pLCRuPUFuKHtjb25jYXQxZF86ZnVuY3Rpb24odCl7cmV0dXJuIFluKHQsMCl9fSksUW49QW4oe2NvbmNhdDJkXzpmdW5jdGlvbih0LGUpe3JldHVybiBZbih0LGUpfX0pLEpuPUFuKHtjb25jYXQzZF86ZnVuY3Rpb24odCxlKXtyZXR1cm4gWW4odCxlKX19KSxabj1Bbih7Y29uY2F0NGRfOmZ1bmN0aW9uKHQsZSl7cmV0dXJuIFluKHQsZSl9fSksdHI9QW4oe3NwbGl0XzpmdW5jdGlvbih0LGUsbil7dm9pZCAwPT09biYmKG49MCk7dmFyIHIsbz1tbih0LFwieFwiLFwic3BsaXRcIik7cmV0dXJuIG49TyhuLG8uc2hhcGUpWzBdLFwibnVtYmVyXCI9PXR5cGVvZiBlPyhDKG8uc2hhcGVbbl0lZT09MCwoZnVuY3Rpb24oKXtyZXR1cm5cIk51bWJlciBvZiBzcGxpdHMgbXVzdCBldmVubHkgZGl2aWRlIHRoZSBheGlzLlwifSkpLHI9bmV3IEFycmF5KGUpLmZpbGwoby5zaGFwZVtuXS9lKSk6KEMoby5zaGFwZVtuXT09PWUucmVkdWNlKChmdW5jdGlvbih0LGUpe3JldHVybiB0K2V9KSksKGZ1bmN0aW9uKCl7cmV0dXJuXCJUaGUgc3VtIG9mIHNpemVzIG11c3QgbWF0Y2ggdGhlIHNpemUgb2YgdGhlIGF4aXMgZGltZW5zaW9uLlwifSkpLHI9ZSksTHQucnVuS2VybmVsRnVuYygoZnVuY3Rpb24odCl7cmV0dXJuIHQuc3BsaXQobyxyLG4pfSkseyR4Om99LChmdW5jdGlvbih0KXtyZXR1cm57JHg6ZnVuY3Rpb24oKXtyZXR1cm4gWW4odCxuKX19fSkpfX0pO1widW5kZWZpbmVkXCIhPXR5cGVvZiBnbG9iYWxUaGlzP2dsb2JhbFRoaXM6XCJ1bmRlZmluZWRcIiE9dHlwZW9mIHdpbmRvdz93aW5kb3c6XCJ1bmRlZmluZWRcIiE9dHlwZW9mIGdsb2JhbD9nbG9iYWw6XCJ1bmRlZmluZWRcIiE9dHlwZW9mIHNlbGYmJnNlbGY7ZnVuY3Rpb24gZXIodCxlKXtyZXR1cm4gdChlPXtleHBvcnRzOnt9fSxlLmV4cG9ydHMpLGUuZXhwb3J0c312YXIgbnI9ZXIoKGZ1bmN0aW9uKHQpeyFmdW5jdGlvbih0LGUsbil7ZnVuY3Rpb24gcih0KXt2YXIgZSxuPXRoaXMscj0oZT00MDIyODcxMTk3LGZ1bmN0aW9uKHQpe3Q9dC50b1N0cmluZygpO2Zvcih2YXIgbj0wO248dC5sZW5ndGg7bisrKXt2YXIgcj0uMDI1MTk2MDMyODI0MTY5MzgqKGUrPXQuY2hhckNvZGVBdChuKSk7ci09ZT1yPj4+MCxlPShyKj1lKT4+PjAsZSs9NDI5NDk2NzI5Niooci09ZSl9cmV0dXJuIDIuMzI4MzA2NDM2NTM4Njk2M2UtMTAqKGU+Pj4wKX0pO24ubmV4dD1mdW5jdGlvbigpe3ZhciB0PTIwOTE2Mzkqbi5zMCsyLjMyODMwNjQzNjUzODY5NjNlLTEwKm4uYztyZXR1cm4gbi5zMD1uLnMxLG4uczE9bi5zMixuLnMyPXQtKG4uYz0wfHQpfSxuLmM9MSxuLnMwPXIoXCIgXCIpLG4uczE9cihcIiBcIiksbi5zMj1yKFwiIFwiKSxuLnMwLT1yKHQpLG4uczA8MCYmKG4uczArPTEpLG4uczEtPXIodCksbi5zMTwwJiYobi5zMSs9MSksbi5zMi09cih0KSxuLnMyPDAmJihuLnMyKz0xKSxyPW51bGx9ZnVuY3Rpb24gbyh0LGUpe3JldHVybiBlLmM9dC5jLGUuczA9dC5zMCxlLnMxPXQuczEsZS5zMj10LnMyLGV9ZnVuY3Rpb24gYSh0LGUpe3ZhciBuPW5ldyByKHQpLGE9ZSYmZS5zdGF0ZSxpPW4ubmV4dDtyZXR1cm4gaS5pbnQzMj1mdW5jdGlvbigpe3JldHVybiA0Mjk0OTY3Mjk2Km4ubmV4dCgpfDB9LGkuZG91YmxlPWZ1bmN0aW9uKCl7cmV0dXJuIGkoKSsxMTEwMjIzMDI0NjI1MTU2NWUtMzIqKDIwOTcxNTIqaSgpfDApfSxpLnF1aWNrPWksYSYmKFwib2JqZWN0XCI9PXR5cGVvZiBhJiZvKGEsbiksaS5zdGF0ZT1mdW5jdGlvbigpe3JldHVybiBvKG4se30pfSksaX1lJiZlLmV4cG9ydHM/ZS5leHBvcnRzPWE6biYmbi5hbWQ/bigoZnVuY3Rpb24oKXtyZXR1cm4gYX0pKTp0aGlzLmFsZWE9YX0oMCx0LCExKX0pKSxycj1lcigoZnVuY3Rpb24odCl7IWZ1bmN0aW9uKHQsZSxuKXtmdW5jdGlvbiByKHQpe3ZhciBlPXRoaXMsbj1cIlwiO2UueD0wLGUueT0wLGUuej0wLGUudz0wLGUubmV4dD1mdW5jdGlvbigpe3ZhciB0PWUueF5lLng8PDExO3JldHVybiBlLng9ZS55LGUueT1lLnosZS56PWUudyxlLndePWUudz4+PjE5XnRedD4+Pjh9LHQ9PT0oMHx0KT9lLng9dDpuKz10O2Zvcih2YXIgcj0wO3I8bi5sZW5ndGgrNjQ7cisrKWUueF49MHxuLmNoYXJDb2RlQXQociksZS5uZXh0KCl9ZnVuY3Rpb24gbyh0LGUpe3JldHVybiBlLng9dC54LGUueT10LnksZS56PXQueixlLnc9dC53LGV9ZnVuY3Rpb24gYSh0LGUpe3ZhciBuPW5ldyByKHQpLGE9ZSYmZS5zdGF0ZSxpPWZ1bmN0aW9uKCl7cmV0dXJuKG4ubmV4dCgpPj4+MCkvNDI5NDk2NzI5Nn07cmV0dXJuIGkuZG91YmxlPWZ1bmN0aW9uKCl7ZG97dmFyIHQ9KChuLm5leHQoKT4+PjExKSsobi5uZXh0KCk+Pj4wKS80Mjk0OTY3Mjk2KS8oMTw8MjEpfXdoaWxlKDA9PT10KTtyZXR1cm4gdH0saS5pbnQzMj1uLm5leHQsaS5xdWljaz1pLGEmJihcIm9iamVjdFwiPT10eXBlb2YgYSYmbyhhLG4pLGkuc3RhdGU9ZnVuY3Rpb24oKXtyZXR1cm4gbyhuLHt9KX0pLGl9ZSYmZS5leHBvcnRzP2UuZXhwb3J0cz1hOm4mJm4uYW1kP24oKGZ1bmN0aW9uKCl7cmV0dXJuIGF9KSk6dGhpcy54b3IxMjg9YX0oMCx0LCExKX0pKSxvcj1lcigoZnVuY3Rpb24odCl7IWZ1bmN0aW9uKHQsZSxuKXtmdW5jdGlvbiByKHQpe3ZhciBlPXRoaXMsbj1cIlwiO2UubmV4dD1mdW5jdGlvbigpe3ZhciB0PWUueF5lLng+Pj4yO3JldHVybiBlLng9ZS55LGUueT1lLnosZS56PWUudyxlLnc9ZS52LChlLmQ9ZS5kKzM2MjQzN3wwKSsoZS52PWUudl5lLnY8PDRedF50PDwxKXwwfSxlLng9MCxlLnk9MCxlLno9MCxlLnc9MCxlLnY9MCx0PT09KDB8dCk/ZS54PXQ6bis9dDtmb3IodmFyIHI9MDtyPG4ubGVuZ3RoKzY0O3IrKyllLnhePTB8bi5jaGFyQ29kZUF0KHIpLHI9PW4ubGVuZ3RoJiYoZS5kPWUueDw8MTBeZS54Pj4+NCksZS5uZXh0KCl9ZnVuY3Rpb24gbyh0LGUpe3JldHVybiBlLng9dC54LGUueT10LnksZS56PXQueixlLnc9dC53LGUudj10LnYsZS5kPXQuZCxlfWZ1bmN0aW9uIGEodCxlKXt2YXIgbj1uZXcgcih0KSxhPWUmJmUuc3RhdGUsaT1mdW5jdGlvbigpe3JldHVybihuLm5leHQoKT4+PjApLzQyOTQ5NjcyOTZ9O3JldHVybiBpLmRvdWJsZT1mdW5jdGlvbigpe2Rve3ZhciB0PSgobi5uZXh0KCk+Pj4xMSkrKG4ubmV4dCgpPj4+MCkvNDI5NDk2NzI5NikvKDE8PDIxKX13aGlsZSgwPT09dCk7cmV0dXJuIHR9LGkuaW50MzI9bi5uZXh0LGkucXVpY2s9aSxhJiYoXCJvYmplY3RcIj09dHlwZW9mIGEmJm8oYSxuKSxpLnN0YXRlPWZ1bmN0aW9uKCl7cmV0dXJuIG8obix7fSl9KSxpfWUmJmUuZXhwb3J0cz9lLmV4cG9ydHM9YTpuJiZuLmFtZD9uKChmdW5jdGlvbigpe3JldHVybiBhfSkpOnRoaXMueG9yd293PWF9KDAsdCwhMSl9KSksYXI9ZXIoKGZ1bmN0aW9uKHQpeyFmdW5jdGlvbih0LGUsbil7ZnVuY3Rpb24gcih0KXt2YXIgZT10aGlzO2UubmV4dD1mdW5jdGlvbigpe3ZhciB0LG4scj1lLngsbz1lLmk7cmV0dXJuIHQ9cltvXSxuPSh0Xj10Pj4+NyledDw8MjQsbl49KHQ9cltvKzEmN10pXnQ+Pj4xMCxuXj0odD1yW28rMyY3XSledD4+PjMsbl49KHQ9cltvKzQmN10pXnQ8PDcsdD1yW28rNyY3XSxuXj0odF49dDw8MTMpXnQ8PDkscltvXT1uLGUuaT1vKzEmNyxufSxmdW5jdGlvbih0LGUpe3ZhciBuLHI9W107aWYoZT09PSgwfGUpKXJbMF09ZTtlbHNlIGZvcihlPVwiXCIrZSxuPTA7bjxlLmxlbmd0aDsrK24pcls3Jm5dPXJbNyZuXTw8MTVeZS5jaGFyQ29kZUF0KG4pK3JbbisxJjddPDwxMztmb3IoO3IubGVuZ3RoPDg7KXIucHVzaCgwKTtmb3Iobj0wO248OCYmMD09PXJbbl07KytuKTtmb3IoOD09bj9yWzddPS0xOnJbbl0sdC54PXIsdC5pPTAsbj0yNTY7bj4wOy0tbil0Lm5leHQoKX0oZSx0KX1mdW5jdGlvbiBvKHQsZSl7cmV0dXJuIGUueD10Lnguc2xpY2UoKSxlLmk9dC5pLGV9ZnVuY3Rpb24gYSh0LGUpe251bGw9PXQmJih0PStuZXcgRGF0ZSk7dmFyIG49bmV3IHIodCksYT1lJiZlLnN0YXRlLGk9ZnVuY3Rpb24oKXtyZXR1cm4obi5uZXh0KCk+Pj4wKS80Mjk0OTY3Mjk2fTtyZXR1cm4gaS5kb3VibGU9ZnVuY3Rpb24oKXtkb3t2YXIgdD0oKG4ubmV4dCgpPj4+MTEpKyhuLm5leHQoKT4+PjApLzQyOTQ5NjcyOTYpLygxPDwyMSl9d2hpbGUoMD09PXQpO3JldHVybiB0fSxpLmludDMyPW4ubmV4dCxpLnF1aWNrPWksYSYmKGEueCYmbyhhLG4pLGkuc3RhdGU9ZnVuY3Rpb24oKXtyZXR1cm4gbyhuLHt9KX0pLGl9ZSYmZS5leHBvcnRzP2UuZXhwb3J0cz1hOm4mJm4uYW1kP24oKGZ1bmN0aW9uKCl7cmV0dXJuIGF9KSk6dGhpcy54b3JzaGlmdDc9YX0oMCx0LCExKX0pKSxpcj1lcigoZnVuY3Rpb24odCl7IWZ1bmN0aW9uKHQsZSxuKXtmdW5jdGlvbiByKHQpe3ZhciBlPXRoaXM7ZS5uZXh0PWZ1bmN0aW9uKCl7dmFyIHQsbixyPWUudyxvPWUuWCxhPWUuaTtyZXR1cm4gZS53PXI9cisxNjQwNTMxNTI3fDAsbj1vW2ErMzQmMTI3XSx0PW9bYT1hKzEmMTI3XSxuXj1uPDwxMyx0Xj10PDwxNyxuXj1uPj4+MTUsdF49dD4+PjEyLG49b1thXT1uXnQsZS5pPWEsbisocl5yPj4+MTYpfDB9LGZ1bmN0aW9uKHQsZSl7dmFyIG4scixvLGEsaSxzPVtdLHU9MTI4O2ZvcihlPT09KDB8ZSk/KHI9ZSxlPW51bGwpOihlKz1cIlxcMFwiLHI9MCx1PU1hdGgubWF4KHUsZS5sZW5ndGgpKSxvPTAsYT0tMzI7YTx1OysrYSllJiYocl49ZS5jaGFyQ29kZUF0KChhKzMyKSVlLmxlbmd0aCkpLDA9PT1hJiYoaT1yKSxyXj1yPDwxMCxyXj1yPj4+MTUscl49cjw8NCxyXj1yPj4+MTMsYT49MCYmKGk9aSsxNjQwNTMxNTI3fDAsbz0wPT0obj1zWzEyNyZhXV49citpKT9vKzE6MCk7Zm9yKG8+PTEyOCYmKHNbMTI3JihlJiZlLmxlbmd0aHx8MCldPS0xKSxvPTEyNyxhPTUxMjthPjA7LS1hKXI9c1tvKzM0JjEyN10sbj1zW289bysxJjEyN10scl49cjw8MTMsbl49bjw8MTcscl49cj4+PjE1LG5ePW4+Pj4xMixzW29dPXJebjt0Lnc9aSx0Llg9cyx0Lmk9b30oZSx0KX1mdW5jdGlvbiBvKHQsZSl7cmV0dXJuIGUuaT10LmksZS53PXQudyxlLlg9dC5YLnNsaWNlKCksZX1mdW5jdGlvbiBhKHQsZSl7bnVsbD09dCYmKHQ9K25ldyBEYXRlKTt2YXIgbj1uZXcgcih0KSxhPWUmJmUuc3RhdGUsaT1mdW5jdGlvbigpe3JldHVybihuLm5leHQoKT4+PjApLzQyOTQ5NjcyOTZ9O3JldHVybiBpLmRvdWJsZT1mdW5jdGlvbigpe2Rve3ZhciB0PSgobi5uZXh0KCk+Pj4xMSkrKG4ubmV4dCgpPj4+MCkvNDI5NDk2NzI5NikvKDE8PDIxKX13aGlsZSgwPT09dCk7cmV0dXJuIHR9LGkuaW50MzI9bi5uZXh0LGkucXVpY2s9aSxhJiYoYS5YJiZvKGEsbiksaS5zdGF0ZT1mdW5jdGlvbigpe3JldHVybiBvKG4se30pfSksaX1lJiZlLmV4cG9ydHM/ZS5leHBvcnRzPWE6biYmbi5hbWQ/bigoZnVuY3Rpb24oKXtyZXR1cm4gYX0pKTp0aGlzLnhvcjQwOTY9YX0oMCx0LCExKX0pKSxzcj1lcigoZnVuY3Rpb24odCl7IWZ1bmN0aW9uKHQsZSxuKXtmdW5jdGlvbiByKHQpe3ZhciBlPXRoaXMsbj1cIlwiO2UubmV4dD1mdW5jdGlvbigpe3ZhciB0PWUuYixuPWUuYyxyPWUuZCxvPWUuYTtyZXR1cm4gdD10PDwyNV50Pj4+N15uLG49bi1yfDAscj1yPDwyNF5yPj4+OF5vLG89by10fDAsZS5iPXQ9dDw8MjBedD4+PjEyXm4sZS5jPW49bi1yfDAsZS5kPXI8PDE2Xm4+Pj4xNl5vLGUuYT1vLXR8MH0sZS5hPTAsZS5iPTAsZS5jPS0xNjQwNTMxNTI3LGUuZD0xMzY3MTMwNTUxLHQ9PT1NYXRoLmZsb29yKHQpPyhlLmE9dC80Mjk0OTY3Mjk2fDAsZS5iPTB8dCk6bis9dDtmb3IodmFyIHI9MDtyPG4ubGVuZ3RoKzIwO3IrKyllLmJePTB8bi5jaGFyQ29kZUF0KHIpLGUubmV4dCgpfWZ1bmN0aW9uIG8odCxlKXtyZXR1cm4gZS5hPXQuYSxlLmI9dC5iLGUuYz10LmMsZS5kPXQuZCxlfWZ1bmN0aW9uIGEodCxlKXt2YXIgbj1uZXcgcih0KSxhPWUmJmUuc3RhdGUsaT1mdW5jdGlvbigpe3JldHVybihuLm5leHQoKT4+PjApLzQyOTQ5NjcyOTZ9O3JldHVybiBpLmRvdWJsZT1mdW5jdGlvbigpe2Rve3ZhciB0PSgobi5uZXh0KCk+Pj4xMSkrKG4ubmV4dCgpPj4+MCkvNDI5NDk2NzI5NikvKDE8PDIxKX13aGlsZSgwPT09dCk7cmV0dXJuIHR9LGkuaW50MzI9bi5uZXh0LGkucXVpY2s9aSxhJiYoXCJvYmplY3RcIj09dHlwZW9mIGEmJm8oYSxuKSxpLnN0YXRlPWZ1bmN0aW9uKCl7cmV0dXJuIG8obix7fSl9KSxpfWUmJmUuZXhwb3J0cz9lLmV4cG9ydHM9YTpuJiZuLmFtZD9uKChmdW5jdGlvbigpe3JldHVybiBhfSkpOnRoaXMudHljaGVpPWF9KDAsdCwhMSl9KSksdXI9ZXIoKGZ1bmN0aW9uKHQpeyFmdW5jdGlvbihlLG4pe3ZhciByLG89dGhpcyxhPTI1NixpPTYscz1cInJhbmRvbVwiLHU9bi5wb3coYSxpKSxjPW4ucG93KDIsNTIpLGw9MipjLGg9YS0xO2Z1bmN0aW9uIGYodCxoLGYpe3ZhciBnPVtdLHk9dihmdW5jdGlvbiB0KGUsbil7dmFyIHIsbz1bXSxhPXR5cGVvZiBlO2lmKG4mJlwib2JqZWN0XCI9PWEpZm9yKHIgaW4gZSl0cnl7by5wdXNoKHQoZVtyXSxuLTEpKX1jYXRjaCh0KXt9cmV0dXJuIG8ubGVuZ3RoP286XCJzdHJpbmdcIj09YT9lOmUrXCJcXDBcIn0oKGg9MT09aD97ZW50cm9weTohMH06aHx8e30pLmVudHJvcHk/W3QsbShlKV06bnVsbD09dD9mdW5jdGlvbigpe3RyeXt2YXIgdDtyZXR1cm4gciYmKHQ9ci5yYW5kb21CeXRlcyk/dD10KGEpOih0PW5ldyBVaW50OEFycmF5KGEpLChvLmNyeXB0b3x8by5tc0NyeXB0bykuZ2V0UmFuZG9tVmFsdWVzKHQpKSxtKHQpfWNhdGNoKHQpe3ZhciBuPW8ubmF2aWdhdG9yLGk9biYmbi5wbHVnaW5zO3JldHVyblsrbmV3IERhdGUsbyxpLG8uc2NyZWVuLG0oZSldfX0oKTp0LDMpLGcpLHg9bmV3IGQoZyksYj1mdW5jdGlvbigpe2Zvcih2YXIgdD14LmcoaSksZT11LG49MDt0PGM7KXQ9KHQrbikqYSxlKj1hLG49eC5nKDEpO2Zvcig7dD49bDspdC89MixlLz0yLG4+Pj49MTtyZXR1cm4odCtuKS9lfTtyZXR1cm4gYi5pbnQzMj1mdW5jdGlvbigpe3JldHVybiAwfHguZyg0KX0sYi5xdWljaz1mdW5jdGlvbigpe3JldHVybiB4LmcoNCkvNDI5NDk2NzI5Nn0sYi5kb3VibGU9Yix2KG0oeC5TKSxlKSwoaC5wYXNzfHxmfHxmdW5jdGlvbih0LGUscixvKXtyZXR1cm4gbyYmKG8uUyYmcChvLHgpLHQuc3RhdGU9ZnVuY3Rpb24oKXtyZXR1cm4gcCh4LHt9KX0pLHI/KG5bc109dCxlKTp0fSkoYix5LFwiZ2xvYmFsXCJpbiBoP2guZ2xvYmFsOnRoaXM9PW4saC5zdGF0ZSl9ZnVuY3Rpb24gZCh0KXt2YXIgZSxuPXQubGVuZ3RoLHI9dGhpcyxvPTAsaT1yLmk9ci5qPTAscz1yLlM9W107Zm9yKG58fCh0PVtuKytdKTtvPGE7KXNbb109bysrO2ZvcihvPTA7bzxhO28rKylzW29dPXNbaT1oJmkrdFtvJW5dKyhlPXNbb10pXSxzW2ldPWU7KHIuZz1mdW5jdGlvbih0KXtmb3IodmFyIGUsbj0wLG89ci5pLGk9ci5qLHM9ci5TO3QtLTspZT1zW289aCZvKzFdLG49biphK3NbaCYoc1tvXT1zW2k9aCZpK2VdKSsoc1tpXT1lKV07cmV0dXJuIHIuaT1vLHIuaj1pLG59KShhKX1mdW5jdGlvbiBwKHQsZSl7cmV0dXJuIGUuaT10LmksZS5qPXQuaixlLlM9dC5TLnNsaWNlKCksZX1mdW5jdGlvbiB2KHQsZSl7Zm9yKHZhciBuLHI9dCtcIlwiLG89MDtvPHIubGVuZ3RoOyllW2gmb109aCYobl49MTkqZVtoJm9dKStyLmNoYXJDb2RlQXQobysrKTtyZXR1cm4gbShlKX1mdW5jdGlvbiBtKHQpe3JldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KDAsdCl9aWYobltcInNlZWRcIitzXT1mLHYobi5yYW5kb20oKSxlKSx0LmV4cG9ydHMpe3QuZXhwb3J0cz1mO3RyeXtyPXJlcXVpcmUoXCJjcnlwdG9cIil9Y2F0Y2godCl7fX19KFtdLE1hdGgpfSkpO3VyLmFsZWE9bnIsdXIueG9yMTI4PXJyLHVyLnhvcndvdz1vcix1ci54b3JzaGlmdDc9YXIsdXIueG9yNDA5Nj1pcix1ci50eWNoZWk9c3I7dmFyIGNyPXVyLmFsZWEsbHI9ZnVuY3Rpb24oKXtmdW5jdGlvbiB0KHQsZSxuLHIsbyl7dGhpcy5tZWFuPXQsdGhpcy5zdGREZXY9ZSx0aGlzLmR0eXBlPW4sdGhpcy5uZXh0VmFsPU5hTix0aGlzLnRydW5jYXRlZD1yLHRoaXMudHJ1bmNhdGVkJiYodGhpcy51cHBlcj10aGlzLm1lYW4rMip0aGlzLnN0ZERldix0aGlzLmxvd2VyPXRoaXMubWVhbi0yKnRoaXMuc3RkRGV2KTt2YXIgYT1vfHxNYXRoLnJhbmRvbSgpO3RoaXMucmFuZG9tPWNyKGEudG9TdHJpbmcoKSl9cmV0dXJuIHQucHJvdG90eXBlLm5leHRWYWx1ZT1mdW5jdGlvbigpe2lmKCFpc05hTih0aGlzLm5leHRWYWwpKXt2YXIgdD10aGlzLm5leHRWYWw7cmV0dXJuIHRoaXMubmV4dFZhbD1OYU4sdH1mb3IodmFyIGUsbixyPSExOyFyOyl7dmFyIG89dm9pZCAwLGE9dm9pZCAwLGk9dm9pZCAwO2Rve2k9KG89Mip0aGlzLnJhbmRvbSgpLTEpKm8rKGE9Mip0aGlzLnJhbmRvbSgpLTEpKmF9d2hpbGUoaT49MXx8MD09PWkpO3ZhciBzPU1hdGguc3FydCgtMipNYXRoLmxvZyhpKS9pKTtlPXRoaXMubWVhbit0aGlzLnN0ZERldipvKnMsbj10aGlzLm1lYW4rdGhpcy5zdGREZXYqYSpzLHRoaXMudHJ1bmNhdGVkJiYhdGhpcy5pc1ZhbGlkVHJ1bmNhdGVkKGUpfHwocj0hMCl9cmV0dXJuIHRoaXMudHJ1bmNhdGVkJiYhdGhpcy5pc1ZhbGlkVHJ1bmNhdGVkKG4pfHwodGhpcy5uZXh0VmFsPXRoaXMuY29udmVydFZhbHVlKG4pKSx0aGlzLmNvbnZlcnRWYWx1ZShlKX0sdC5wcm90b3R5cGUuY29udmVydFZhbHVlPWZ1bmN0aW9uKHQpe3JldHVybiBudWxsPT10aGlzLmR0eXBlfHxcImZsb2F0MzJcIj09PXRoaXMuZHR5cGU/dDpNYXRoLnJvdW5kKHQpfSx0LnByb3RvdHlwZS5pc1ZhbGlkVHJ1bmNhdGVkPWZ1bmN0aW9uKHQpe3JldHVybiB0PD10aGlzLnVwcGVyJiZ0Pj10aGlzLmxvd2VyfSx0fSgpLGhyPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gdCh0LGUsbixyKXt0aGlzLmFscGhhPXQsdGhpcy5iZXRhPTEvZSx0aGlzLmR0eXBlPW47dmFyIG89cnx8TWF0aC5yYW5kb20oKTt0aGlzLnJhbmR1PWNyKG8udG9TdHJpbmcoKSksdGhpcy5yYW5kbj1uZXcgbHIoMCwxLG4sITEsdGhpcy5yYW5kdSgpKSx0aGlzLmQ9dDwxP3QrMi8zOnQtMS8zLHRoaXMuYz0xL01hdGguc3FydCg5KnRoaXMuZCl9cmV0dXJuIHQucHJvdG90eXBlLm5leHRWYWx1ZT1mdW5jdGlvbigpe2Zvcih2YXIgdCxlLG4scixvLGE7Oyl7ZG97cj10aGlzLnJhbmRuLm5leHRWYWx1ZSgpLGE9MSt0aGlzLmMqcn13aGlsZShhPD0wKTtpZihhKj1hKmEsZT0xLS4zMzEqKHQ9cipyKSp0LG49LjUqdCt0aGlzLmQqKDEtYStNYXRoLmxvZyhhKSksKG89dGhpcy5yYW5kdSgpKTxlfHxNYXRoLmxvZyhvKTxuKWJyZWFrfXJldHVybiBhPTEvdGhpcy5iZXRhKnRoaXMuZCphLHRoaXMuYWxwaGE8MSYmKGEqPU1hdGgucG93KHRoaXMucmFuZHUoKSwxL3RoaXMuYWxwaGEpKSx0aGlzLmNvbnZlcnRWYWx1ZShhKX0sdC5wcm90b3R5cGUuY29udmVydFZhbHVlPWZ1bmN0aW9uKHQpe3JldHVyblwiZmxvYXQzMlwiPT09dGhpcy5kdHlwZT90Ok1hdGgucm91bmQodCl9LHR9KCksZnI9ZnVuY3Rpb24oKXtmdW5jdGlvbiB0KHQsZSxuLHIpe3ZhciBvPXRoaXM7aWYodm9pZCAwPT09dCYmKHQ9MCksdm9pZCAwPT09ZSYmKGU9MSksdGhpcy5jYW5SZXR1cm5GbG9hdD1mdW5jdGlvbigpe3JldHVybiBudWxsPT1vLmR0eXBlfHxcImZsb2F0MzJcIj09PW8uZHR5cGV9LHRoaXMubWluPXQsdGhpcy5yYW5nZT1lLXQsdGhpcy5kdHlwZT1uLG51bGw9PXImJihyPU1hdGgucmFuZG9tKCkpLFwibnVtYmVyXCI9PXR5cGVvZiByJiYocj1yLnRvU3RyaW5nKCkpLCF0aGlzLmNhblJldHVybkZsb2F0KCkmJnRoaXMucmFuZ2U8PTEpdGhyb3cgbmV3IEVycm9yKFwiVGhlIGRpZmZlcmVuY2UgYmV0d2VlbiBcIit0K1wiIC0gXCIrZStcIiA8PSAxIGFuZCBkdHlwZSBpcyBub3QgZmxvYXRcIik7dGhpcy5yYW5kb209Y3Iocil9cmV0dXJuIHQucHJvdG90eXBlLmNvbnZlcnRWYWx1ZT1mdW5jdGlvbih0KXtyZXR1cm4gdGhpcy5jYW5SZXR1cm5GbG9hdCgpP3Q6TWF0aC5yb3VuZCh0KX0sdC5wcm90b3R5cGUubmV4dFZhbHVlPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuY29udmVydFZhbHVlKHRoaXMubWluK3RoaXMucmFuZ2UqdGhpcy5yYW5kb20oKSl9LHR9KCk7ZnVuY3Rpb24gZHIodCxlLG4pe3JldHVybiB2b2lkIDA9PT1lJiYoZT1cImZsb2F0MzJcIiksZT1lfHxcImZsb2F0MzJcIixudCh0KSxuZXcgZ3QodCxlLG4pfWZ1bmN0aW9uIHByKHQsZSl7dm9pZCAwPT09ZSYmKGU9ITEpLGNvbnNvbGUubG9nKHQudG9TdHJpbmcoZSkpfXZhciB2cj1Bbih7YmF0Y2hUb1NwYWNlTkRfOmZ1bmN0aW9uKHQsZSxuKXt2YXIgcj1tbih0LFwieFwiLFwiYmF0Y2hUb1NwYWNlTkRcIiksbz1lLnJlZHVjZSgoZnVuY3Rpb24odCxlKXtyZXR1cm4gdCplfSkpO3JldHVybiBDKHIucmFuaz49MStlLmxlbmd0aCwoZnVuY3Rpb24oKXtyZXR1cm5cImlucHV0IHJhbmsgaXMgXCIrci5yYW5rK1wiIGJ1dCBzaG91bGQgYmUgPiB0aGFuIGJsb2NrU2hhcGUubGVuZ3RoIFwiK2UubGVuZ3RofSkpLEMobi5sZW5ndGg9PT1lLmxlbmd0aCwoZnVuY3Rpb24oKXtyZXR1cm5cImNyb3BzLmxlbmd0aCBpcyBcIituLmxlbmd0aCtcIiBidXQgc2hvdWxkIGJlIGVxdWFsIHRvIGJsb2NrU2hhcGUubGVuZ3RoICBcIitlLmxlbmd0aH0pKSxDKHIuc2hhcGVbMF0lbz09MCwoZnVuY3Rpb24oKXtyZXR1cm5cImlucHV0IHRlbnNvciBiYXRjaCBpcyBcIityLnNoYXBlWzBdK1wiIGJ1dCBpcyBub3QgZGl2aXNpYmxlIGJ5IHRoZSBwcm9kdWN0IG9mIHRoZSBlbGVtZW50cyBvZiBibG9ja1NoYXBlIFwiK2Uuam9pbihcIiAqIFwiKStcIiA9PT0gXCIrb30pKSxMdC5ydW5LZXJuZWxGdW5jKChmdW5jdGlvbih0KXtyZXR1cm4gdC5iYXRjaFRvU3BhY2VORChyLGUsbil9KSx7JHg6cn0sKGZ1bmN0aW9uKHQpe3JldHVybnskeDpmdW5jdGlvbigpe3JldHVybiB0LnNwYWNlVG9CYXRjaE5EKGUsbil9fX0pKX19KSxtcj1Bbih7YnJvYWRjYXN0VG9fOmZ1bmN0aW9uKHQsZSl7dmFyIG49bW4odCxcImJyb2FkY2FzdFRvXCIsXCJ4XCIpLHI9bi5zaGFwZTtpZihlLnNvbWUoKGZ1bmN0aW9uKHQpe3JldHVybiEodD4wKXx8dCUxIT0wfSkpKXRocm93IG5ldyBFcnJvcihcImJyb2FkY2FzdFRvKCk6IEludmFsaWQgYnJvYWRjYXN0IHNoYXBlIFtcIitlK1wiXS5cIik7aWYoZS5sZW5ndGg8bi5yYW5rKXRocm93IG5ldyBFcnJvcihcImJyb2FkY2FzdFRvKCk6IHNoYXBlLmxlbmd0aD1cIitlLmxlbmd0aCtcIiA8IGlucHV0LnJhbms9XCIrbi5yYW5rK1wiLlwiKTtpZihlLmxlbmd0aD5uLnJhbmspe2Zvcih2YXIgbz1uLnNoYXBlLnNsaWNlKCk7by5sZW5ndGg8ZS5sZW5ndGg7KW8udW5zaGlmdCgxKTtuPW4ucmVzaGFwZShvKX1mb3IodmFyIGE9QXJyYXkuZnJvbShlKSxpPWUubGVuZ3RoLTE7aT49MDtpLS0paWYobi5zaGFwZVtpXT09PWVbaV0pYVtpXT0xO2Vsc2UgaWYoMSE9PW4uc2hhcGVbaV0pdGhyb3cgbmV3IEVycm9yKFwiYnJvYWRjYXN0VG8oKTogW1wiK3IrXCJdIGNhbm5vdCBiZSBicm9hZGNhc3QgdG8gW1wiK2UrXCJdLlwiKTt2YXIgcz1hLm1hcCgoZnVuY3Rpb24odCxlKXtyZXR1cm4gdD4xP2U6LTF9KSkuZmlsdGVyKChmdW5jdGlvbih0KXtyZXR1cm4gdD49MH0pKTtyZXR1cm4gMD09PXMubGVuZ3RoP24uY2xvbmUoKTpMdC5ydW5LZXJuZWxGdW5jKChmdW5jdGlvbih0KXtyZXR1cm4gdC50aWxlKG4sYSl9KSx7aW5wdXQ6bn0sKGZ1bmN0aW9uKHQpe3JldHVybntpbnB1dDpmdW5jdGlvbigpe3JldHVybiB0LnN1bShzLCEwKX19fSkpfX0pLGdyPUFuKHtjYXN0XzpmdW5jdGlvbih0LGUpe3ZhciBuPW1uKHQsXCJ4XCIsXCJjYXN0XCIpO2lmKCFXKGUpKXRocm93IG5ldyBFcnJvcihcIkZhaWxlZCB0byBjYXN0IHRvIHVua25vd24gZHR5cGUgXCIrZSk7aWYoXCJzdHJpbmdcIj09PWUmJlwic3RyaW5nXCIhPT1uLmR0eXBlfHxcInN0cmluZ1wiIT09ZSYmXCJzdHJpbmdcIj09PW4uZHR5cGUpdGhyb3cgbmV3IEVycm9yKFwiT25seSBzdHJpbmdzIGNhbiBiZSBjYXN0ZWQgdG8gc3RyaW5nc1wiKTt2YXIgcj17ZHR5cGU6ZX07cmV0dXJuIEx0LnJ1bktlcm5lbEZ1bmMoKGZ1bmN0aW9uKHQpe3JldHVybiB0LmNhc3QobixlKX0pLHt4Om59LChmdW5jdGlvbih0KXtyZXR1cm57eDpmdW5jdGlvbigpe3JldHVybiB0LmNsb25lKCl9fX0pLFwiQ2FzdFwiLHIpfX0pLHlyPUFuKHtjbG9uZV86ZnVuY3Rpb24odCl7dmFyIGU9bW4odCxcInhcIixcImNsb25lXCIsbnVsbCk7cmV0dXJuIEx0LnJ1bktlcm5lbEZ1bmMoKGZ1bmN0aW9uKCl7cmV0dXJuIEx0Lm1ha2VUZW5zb3JGcm9tRGF0YUlkKGUuZGF0YUlkLGUuc2hhcGUsZS5kdHlwZSl9KSx7JHg6ZX0sKGZ1bmN0aW9uKHQpe3JldHVybnskeDpmdW5jdGlvbigpe3JldHVybiB0LnRvRmxvYXQoKX19fSkpfX0pLHhyPUFuKHtjdW1zdW1fOmZ1bmN0aW9uKHQsZSxuLHIpe3ZvaWQgMD09PWUmJihlPTApLHZvaWQgMD09PW4mJihuPSExKSx2b2lkIDA9PT1yJiYocj0hMSk7dmFyIG89bW4odCxcInhcIixcImN1bXN1bVwiKSxhPUVuKFtlfD0wXSxvLnJhbmspLGk9bztudWxsIT1hJiYoaT1vLnRyYW5zcG9zZShhKSk7dmFyIHM9SW4oMSxvLnJhbmspWzBdLHU9THQucnVuS2VybmVsRnVuYygoZnVuY3Rpb24odCl7cmV0dXJuIHQuY3Vtc3VtKGkscyxuLHIpfSkse3Blcm11dGVkWDppfSwoZnVuY3Rpb24odCl7cmV0dXJue3Blcm11dGVkWDpmdW5jdGlvbigpe3JldHVybiB0LmN1bXN1bShlLG4sIXIpfX19KSk7cmV0dXJuIG51bGwhPWEmJih1PXUudHJhbnNwb3NlKGEpKSx1fX0pLGJyPUFuKHtkZXB0aFRvU3BhY2VfOmZ1bmN0aW9uKHQsZSxuKXt2b2lkIDA9PT1uJiYobj1cIk5IV0NcIik7dmFyIHI9bW4odCxcInhcIixcImRlcHRoVG9TcGFjZVwiKSxvPVwiTkhXQ1wiPT09bj9yLnNoYXBlWzFdOnIuc2hhcGVbMl0sYT1cIk5IV0NcIj09PW4/ci5zaGFwZVsyXTpyLnNoYXBlWzNdLGk9XCJOSFdDXCI9PT1uP3Iuc2hhcGVbM106ci5zaGFwZVsxXTtyZXR1cm4gQyhvKmU+PTAsKGZ1bmN0aW9uKCl7cmV0dXJuXCJOZWdhdGl2ZSBkaW1lbnNpb24gc2l6ZSBjYXVzZWQgYnkgb3ZlcmZsb3cgd2hlbiBtdWx0aXBseWluZ1xcbiAgICAgIFwiK28rXCIgYW5kIFwiK2UrXCIgIGZvciBkZXB0aFRvU3BhY2Ugd2l0aCBpbnB1dCBzaGFwZVxcbiAgICAgIFwiK3Iuc2hhcGV9KSksQyhhKmU+PTAsKGZ1bmN0aW9uKCl7cmV0dXJuXCJOZWdhdGl2ZSBkaW1lbnNpb24gc2l6ZSBjYXVzZWQgYnkgb3ZlcmZsb3cgd2hlbiBtdWx0aXBseWluZ1xcbiAgICAgIFwiK2ErXCIgYW5kIFwiK2UrXCIgZm9yIGRlcHRoVG9TcGFjZSB3aXRoIGlucHV0IHNoYXBlXFxuICAgICAgICAgIFwiK3Iuc2hhcGV9KSksQyhpJShlKmUpPT0wLChmdW5jdGlvbigpe3JldHVyblwiRGltZW5zaW9uIHNpemUgbXVzdCBiZSBldmVubHkgZGl2aXNpYmxlIGJ5IFwiK2UqZStcIiBidXQgaXMgXCIraStcIiBmb3IgZGVwdGhUb1NwYWNlIHdpdGggaW5wdXQgc2hhcGUgXCIrci5zaGFwZX0pKSxMdC5ydW5LZXJuZWxGdW5jKChmdW5jdGlvbih0KXtyZXR1cm4gdC5kZXB0aFRvU3BhY2UocixlLG4pfSkseyR4OnJ9KX19KSx3cj1Bbih7ZXhwYW5kRGltc186ZnVuY3Rpb24odCxlKXt2b2lkIDA9PT1lJiYoZT0wKTt2YXIgbj1tbih0LFwieFwiLFwiZXhwYW5kRGltc1wiLG51bGwpO0MoZTw9bi5yYW5rLChmdW5jdGlvbigpe3JldHVyblwiQXhpcyBtdXN0IGJlIDw9IHJhbmsgb2YgdGhlIHRlbnNvclwifSkpO3ZhciByPW4uc2hhcGUuc2xpY2UoKTtyZXR1cm4gZTwwJiYoQygtKG4ucmFuaysxKTw9ZSwoZnVuY3Rpb24oKXtyZXR1cm5cIkF4aXMgbXVzdCBiZSBpbiB0aGUgaW50ZXJ2YWwgW1wiKy0obi5yYW5rKzEpK1wiLCBcIituLnJhbmsrXCJdXCJ9KSksZT1uLnJhbmsrZSsxKSxyLnNwbGljZShlLDAsMSksT3IobixyKX19KSxDcj1Bbih7ZXllXzpmdW5jdGlvbih0LGUsbixyKXt2b2lkIDA9PT1yJiYocj1cImZsb2F0MzJcIiksbnVsbD09ZSYmKGU9dCk7Zm9yKHZhciBvPWRyKFt0LGVdLHIpLGE9dDw9ZT90OmUsaT0wO2k8YTsrK2kpby5zZXQoMSxpLGkpO3ZhciBzPW8udG9UZW5zb3IoKS5hczJEKHQsZSk7aWYobnVsbD09bilyZXR1cm4gcztpZigxPT09bi5sZW5ndGgpcmV0dXJuIExyKHdyKHMsMCksW25bMF0sMSwxXSk7aWYoMj09PW4ubGVuZ3RoKXJldHVybiBMcih3cih3cihzLDApLDApLFtuWzBdLG5bMV0sMSwxXSk7aWYoMz09PW4ubGVuZ3RoKXJldHVybiBMcih3cih3cih3cihzLDApLDApLDApLFtuWzBdLG5bMV0sblsyXSwxLDFdKTt0aHJvdyBuZXcgRXJyb3IoXCJleWUoKSBjdXJyZW50bHkgc3VwcG9ydHMgb25seSAxRCBhbmQgMkQgYmF0Y2hTaGFwZXMsIGJ1dCByZWNlaXZlZCBcIituLmxlbmd0aCtcIkQuXCIpfX0pLEVyPUFuKHttdWx0aW5vbWlhbF86ZnVuY3Rpb24odCxlLG4scil7dm9pZCAwPT09ciYmKHI9ITEpO3ZhciBvPW1uKHQsXCJsb2dpdHNcIixcIm11bHRpbm9taWFsXCIpLGE9by5zaXplLGk9by5yYW5rO2lmKGE8Mil0aHJvdyBuZXcgRXJyb3IoXCJFcnJvciBpbiBtdWx0aW5vbWlhbDogeW91IG5lZWQgYXQgbGVhc3QgMiBvdXRjb21lcywgYnV0IGdvdCBcIithK1wiLlwiKTtpZihpPjIpdGhyb3cgbmV3IEVycm9yKFwiUmFuayBvZiBwcm9iYWJpbGl0aWVzIG11c3QgYmUgMSBvciAyLCBidXQgaXMgXCIraSk7bj1ufHxNYXRoLnJhbmRvbSgpO3ZhciBzPTE9PT1pP28uYXMyRCgxLC0xKTpvLHU9THQucnVuS2VybmVsRnVuYygoZnVuY3Rpb24odCl7cmV0dXJuIHQubXVsdGlub21pYWwocyxyLGUsbil9KSx7bG9naXRzMkQ6c30pO3JldHVybiAxPT09aT91LmFzMUQoKTp1fX0pLFJyPUFuKHtvbmVIb3RfOmZ1bmN0aW9uKHQsZSxuLHIpe2lmKHZvaWQgMD09PW4mJihuPTEpLHZvaWQgMD09PXImJihyPTApLGU8Mil0aHJvdyBuZXcgRXJyb3IoXCJFcnJvciBpbiBvbmVIb3Q6IGRlcHRoIG11c3QgYmUgPj0yLCBidXQgaXQgaXMgXCIrZSk7dmFyIG89bW4odCxcImluZGljZXNcIixcIm9uZUhvdFwiLFwiaW50MzJcIiksYT1vLnNoYXBlLmNvbmNhdChbZV0pO3JldHVybiBvPW8uZmxhdHRlbigpLEx0LnJ1bktlcm5lbEZ1bmMoKGZ1bmN0aW9uKHQpe3JldHVybiB0Lm9uZUhvdChvLGUsbixyKX0pLHskaW5kaWNlczpvfSwoZnVuY3Rpb24odCl7cmV0dXJueyRpbmRpY2VzOmZ1bmN0aW9uKCl7cmV0dXJuIEduKG8uc2hhcGUsXCJmbG9hdDMyXCIpfX19KSkucmVzaGFwZShhKX19KSxJcj1Bbih7cGFkXzpmdW5jdGlvbih0LGUsbil7dm9pZCAwPT09biYmKG49MCk7dmFyIHI9bW4odCxcInhcIixcInBhZFwiKTtpZigwPT09ci5yYW5rKXRocm93IG5ldyBFcnJvcihcInBhZChzY2FsYXIpIGlzIG5vdCBkZWZpbmVkLiBQYXNzIG5vbi1zY2FsYXIgdG8gcGFkXCIpO3ZhciBvPXtwYWRkaW5nczplLGNvbnN0YW50VmFsdWU6bn07cmV0dXJuIEx0LnJ1bktlcm5lbEZ1bmMoKGZ1bmN0aW9uKHQpe3JldHVybiB0LnBhZChyLGUsbil9KSx7eDpyfSwoZnVuY3Rpb24odCl7dmFyIG49ZS5tYXAoKGZ1bmN0aW9uKHQpe3JldHVybiB0WzBdfSkpO3JldHVybnt4OmZ1bmN0aW9uKCl7cmV0dXJuIHQuc2xpY2UobixyLnNoYXBlKX19fSksXCJQYWRWMlwiLG8pfX0pLGtyPUFuKHtwYWQxZF86ZnVuY3Rpb24odCxlLG4pe3JldHVybiB2b2lkIDA9PT1uJiYobj0wKSxDKDI9PT1lLmxlbmd0aCwoZnVuY3Rpb24oKXtyZXR1cm5cIkludmFsaWQgbnVtYmVyIG9mIHBhZGRpbmdzLiBNdXN0IGJlIGxlbmd0aCBvZiAyLlwifSkpLElyKHQsW2VdLG4pfX0pLFNyPUFuKHtwYWQyZF86ZnVuY3Rpb24odCxlLG4pe3JldHVybiB2b2lkIDA9PT1uJiYobj0wKSxDKDI9PT1lLmxlbmd0aCYmMj09PWVbMF0ubGVuZ3RoJiYyPT09ZVsxXS5sZW5ndGgsKGZ1bmN0aW9uKCl7cmV0dXJuXCJJbnZhbGlkIG51bWJlciBvZiBwYWRkaW5ncy4gTXVzdCBiZSBsZW5ndGggb2YgMiBlYWNoLlwifSkpLElyKHQsZSxuKX19KSxBcj1Bbih7cGFkM2RfOmZ1bmN0aW9uKHQsZSxuKXtyZXR1cm4gdm9pZCAwPT09biYmKG49MCksQygzPT09ZS5sZW5ndGgmJjI9PT1lWzBdLmxlbmd0aCYmMj09PWVbMV0ubGVuZ3RoJiYyPT09ZVsyXS5sZW5ndGgsKGZ1bmN0aW9uKCl7cmV0dXJuXCJJbnZhbGlkIG51bWJlciBvZiBwYWRkaW5ncy4gTXVzdCBiZSBsZW5ndGggb2YgMiBlYWNoLlwifSkpLElyKHQsZSxuKX19KSxEcj1Bbih7cGFkNGRfOmZ1bmN0aW9uKHQsZSxuKXtyZXR1cm4gdm9pZCAwPT09biYmKG49MCksQyg0PT09ZS5sZW5ndGgmJjI9PT1lWzBdLmxlbmd0aCYmMj09PWVbMV0ubGVuZ3RoJiYyPT09ZVsyXS5sZW5ndGgmJjI9PT1lWzNdLmxlbmd0aCwoZnVuY3Rpb24oKXtyZXR1cm5cIkludmFsaWQgbnVtYmVyIG9mIHBhZGRpbmdzLiBNdXN0IGJlIGxlbmd0aCBvZiAyIGVhY2guXCJ9KSksSXIodCxlLG4pfX0pLFRyPUFuKHtyYW5kXzpmdW5jdGlvbih0LGUsbil7dmFyIHI9ayh0KSxvPW51bGw7aWYobnVsbD09bnx8XCJmbG9hdDMyXCI9PT1uKW89bmV3IEZsb2F0MzJBcnJheShyKTtlbHNlIGlmKFwiaW50MzJcIj09PW4pbz1uZXcgSW50MzJBcnJheShyKTtlbHNle2lmKFwiYm9vbFwiIT09bil0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIGRhdGEgdHlwZSBcIituKTtvPW5ldyBVaW50OEFycmF5KHIpfWZvcih2YXIgYT0wO2E8cjthKyspb1thXT1lKCk7cmV0dXJuIEx0Lm1ha2VUZW5zb3Iobyx0LG4pfX0pLE5yPUFuKHtyYW5kb21Ob3JtYWxfOmZ1bmN0aW9uKHQsZSxuLHIsbyl7aWYodm9pZCAwPT09ZSYmKGU9MCksdm9pZCAwPT09biYmKG49MSksbnVsbCE9ciYmXCJib29sXCI9PT1yKXRocm93IG5ldyBFcnJvcihcIlVuc3VwcG9ydGVkIGRhdGEgdHlwZSBcIityKTtmb3IodmFyIGE9bmV3IGxyKGUsbixyLCExLG8pLGk9ZHIodCxyKSxzPTA7czxpLnZhbHVlcy5sZW5ndGg7cysrKWkudmFsdWVzW3NdPWEubmV4dFZhbHVlKCk7cmV0dXJuIGkudG9UZW5zb3IoKX19KSxGcj1Bbih7cmFuZG9tR2FtbWFfOmZ1bmN0aW9uKHQsZSxuLHIsbyl7aWYodm9pZCAwPT09biYmKG49MSksdm9pZCAwPT09ciYmKHI9XCJmbG9hdDMyXCIpLG51bGw9PW4mJihuPTEpLG51bGw9PXImJihyPVwiZmxvYXQzMlwiKSxcImZsb2F0MzJcIiE9PXImJlwiaW50MzJcIiE9PXIpdGhyb3cgbmV3IEVycm9yKFwiVW5zdXBwb3J0ZWQgZGF0YSB0eXBlIFwiK3IpO2Zvcih2YXIgYT1uZXcgaHIoZSxuLHIsbyksaT1kcih0LHIpLHM9MDtzPGkudmFsdWVzLmxlbmd0aDtzKyspaS52YWx1ZXNbc109YS5uZXh0VmFsdWUoKTtyZXR1cm4gaS50b1RlbnNvcigpfX0pLF9yPUFuKHtyYW5kb21Vbmlmb3JtXzpmdW5jdGlvbih0LGUsbixyLG8pe3ZvaWQgMD09PWUmJihlPTApLHZvaWQgMD09PW4mJihuPTEpLHZvaWQgMD09PXImJihyPVwiZmxvYXQzMlwiKTtmb3IodmFyIGE9ZHIodCxyKSxpPW5ldyBmcihlLG4sbnVsbCxvKSxzPTA7czxhLnZhbHVlcy5sZW5ndGg7cysrKWEudmFsdWVzW3NdPWkubmV4dFZhbHVlKCk7cmV0dXJuIGEudG9UZW5zb3IoKX19KSxPcj1Bbih7cmVzaGFwZV86ZnVuY3Rpb24odCxlKXt2YXIgbj1tbih0LFwieFwiLFwicmVzaGFwZVwiLG51bGwpO2U9XyhlLG4uc2l6ZSksQyhuLnNpemU9PT1rKGUpLChmdW5jdGlvbigpe3JldHVyblwibmV3IHNoYXBlIGFuZCBvbGQgc2hhcGUgbXVzdCBoYXZlIHRoZSBzYW1lIG51bWJlciBvZiBlbGVtZW50cy5cIn0pKTt2YXIgcj17c2hhcGU6ZX07cmV0dXJuIEx0LnJ1bktlcm5lbEZ1bmMoKGZ1bmN0aW9uKHQpe3JldHVybiB0LnJlc2hhcGUobixlKX0pLHt4Om59LChmdW5jdGlvbih0KXtyZXR1cm57eDpmdW5jdGlvbigpe3JldHVybiB0LnJlc2hhcGUobi5zaGFwZSl9fX0pLFwiUmVzaGFwZVwiLHIpfX0pLE1yPUFuKHtzcGFjZVRvQmF0Y2hORF86ZnVuY3Rpb24odCxlLG4pe3ZhciByPW1uKHQsXCJ4XCIsXCJzcGFjZVRvQmF0Y2hORFwiKTtyZXR1cm4gQyhyLnJhbms+PTErZS5sZW5ndGgsKGZ1bmN0aW9uKCl7cmV0dXJuXCJpbnB1dCByYW5rIFwiK3IucmFuaytcIiBzaG91bGQgYmUgPiB0aGFuIFtibG9ja1NoYXBlXSBcIitlLmxlbmd0aH0pKSxDKG4ubGVuZ3RoPT09ZS5sZW5ndGgsKGZ1bmN0aW9uKCl7cmV0dXJuXCJwYWRkaW5ncy5zaGFwZVswXSBcIituLmxlbmd0aCtcIiBtdXN0IGJlIGVxdWFsIHRvIFtibG9ja1NoYXBlXSBcIitlLmxlbmd0aH0pKSxDKHIuc2hhcGUucmVkdWNlKChmdW5jdGlvbih0LHIsbyl7cmV0dXJuIG8+MCYmbzw9ZS5sZW5ndGg/dCYmKHIrbltvLTFdWzBdK25bby0xXVsxXSklZVtvLTFdPT0wOnR9KSwhMCksKGZ1bmN0aW9uKCl7cmV0dXJuXCJpbnB1dCBzcGF0aWFsIGRpbWVuc2lvbnMgXCIrci5zaGFwZS5zbGljZSgxKStcIiB3aXRoIHBhZGRpbmdzIFwiK24udG9TdHJpbmcoKStcIiBtdXN0IGJlIGRpdmlzaWJsZSBieSBibG9ja1NoYXBlcyBcIitlLnRvU3RyaW5nKCl9KSksTHQucnVuS2VybmVsRnVuYygoZnVuY3Rpb24odCl7cmV0dXJuIHQuc3BhY2VUb0JhdGNoTkQocixlLG4pfSkseyR4OnJ9LChmdW5jdGlvbih0KXtyZXR1cm57JHg6ZnVuY3Rpb24oKXtyZXR1cm4gdC5iYXRjaFRvU3BhY2VORChlLG4pfX19KSl9fSksQnI9QW4oe3NxdWVlemVfOmZ1bmN0aW9uKHQsZSl7dmFyIG49bW4odCxcInhcIixcInNxdWVlemVcIik7cmV0dXJuIE9yKG4sTShuLnNoYXBlLGUpLm5ld1NoYXBlKX19KSxQcj1Bbih7c3RhY2tfOmZ1bmN0aW9uKHQsZSl7dm9pZCAwPT09ZSYmKGU9MCk7dmFyIG49Z24odCxcInRlbnNvcnNcIixcInN0YWNrXCIpO2lmKEMobi5sZW5ndGg+PTEsKGZ1bmN0aW9uKCl7cmV0dXJuXCJQYXNzIGF0IGxlYXN0IG9uZSB0ZW5zb3IgdG8gdGYuc3RhY2tcIn0pKSwxPT09bi5sZW5ndGgpcmV0dXJuIG5bMF0uZXhwYW5kRGltcyhlKTt2YXIgcj1uWzBdLnJhbmssbz1uWzBdLnNoYXBlLGE9blswXS5kdHlwZTtDKGU8PXIsKGZ1bmN0aW9uKCl7cmV0dXJuXCJBeGlzIG11c3QgYmUgPD0gcmFuayBvZiB0aGUgdGVuc29yXCJ9KSksbi5mb3JFYWNoKChmdW5jdGlvbih0KXtFKG8sdC5zaGFwZSxcIkFsbCB0ZW5zb3JzIHBhc3NlZCB0byBzdGFjayBtdXN0IGhhdmUgbWF0Y2hpbmcgc2hhcGVzXCIpfSkpLG4uZm9yRWFjaCgoZnVuY3Rpb24odCl7QyhhPT09dC5kdHlwZSwoZnVuY3Rpb24oKXtyZXR1cm5cIkFsbCB0ZW5zb3JzIHBhc3NlZCB0byBzdGFjayBtdXN0IGhhdmUgbWF0Y2hpbmcgZHR5cGVzXCJ9KSl9KSk7dmFyIGk9bi5tYXAoKGZ1bmN0aW9uKHQpe3JldHVybiB0LmV4cGFuZERpbXMoZSl9KSk7cmV0dXJuIFluKGksZSl9fSksTHI9QW4oe3RpbGVfOmZ1bmN0aW9uKHQsZSl7dmFyIG49bW4odCxcInhcIixcInRpbGVcIixudWxsKTtDKG4ucmFuaz09PWUubGVuZ3RoLChmdW5jdGlvbigpe3JldHVyblwiRXJyb3IgaW4gdHJhbnNwb3NlOiByYW5rIG9mIGlucHV0IFwiK24ucmFuaytcIiBtdXN0IG1hdGNoIGxlbmd0aCBvZiByZXBzIFwiK2UrXCIuXCJ9KSk7dmFyIHI9W25dLG89e3JlcHM6ZX07cmV0dXJuIEx0LnJ1bktlcm5lbEZ1bmMoKGZ1bmN0aW9uKHQscil7dmFyIG89dC50aWxlKG4sZSk7cmV0dXJuIHIoW25dKSxvfSkse3g6bn0sKGZ1bmN0aW9uKHQsbil7dmFyIHI9blswXTtyZXR1cm57eDpmdW5jdGlvbigpe3ZhciBuPVhuKHIpO2lmKDE9PT1yLnJhbmspZm9yKHZhciBvPTA7bzxlWzBdOysrbyluPW4uYWRkKHQuc2xpY2UoW28qci5zaGFwZVswXV0sW3Iuc2hhcGVbMF1dKSk7ZWxzZSBpZigyPT09ci5yYW5rKWZvcihvPTA7bzxlWzBdOysrbylmb3IodmFyIGE9MDthPGVbMV07KythKW49bi5hZGQodC5zbGljZShbbypyLnNoYXBlWzBdLGEqci5zaGFwZVsxXV0sW3Iuc2hhcGVbMF0sci5zaGFwZVsxXV0pKTtlbHNlIGlmKDM9PT1yLnJhbmspZm9yKG89MDtvPGVbMF07KytvKWZvcihhPTA7YTxlWzFdOysrYSlmb3IodmFyIGk9MDtpPGVbMl07KytpKW49bi5hZGQodC5zbGljZShbbypyLnNoYXBlWzBdLGEqci5zaGFwZVsxXSxpKnIuc2hhcGVbMl1dLFtyLnNoYXBlWzBdLHIuc2hhcGVbMV0sci5zaGFwZVsyXV0pKTtlbHNle2lmKDQhPT1yLnJhbmspdGhyb3cgbmV3IEVycm9yKFwiR3JhZGllbnQgZm9yIHRpbGUgb3BlcmF0aW9uIGlzIG5vdCBpbXBsZW1lbnRlZCBmb3IgcmFuay1cIityLnJhbmsrXCIgdGVuc29ycyB5ZXQuXCIpO2ZvcihvPTA7bzxlWzBdOysrbylmb3IoYT0wO2E8ZVsxXTsrK2EpZm9yKGk9MDtpPGVbMl07KytpKWZvcih2YXIgcz0wO3M8ZVszXTsrK3Mpbj1uLmFkZCh0LnNsaWNlKFtvKnIuc2hhcGVbMF0sYSpyLnNoYXBlWzFdLGkqci5zaGFwZVsyXSxzKnIuc2hhcGVbM11dLFtyLnNoYXBlWzBdLHIuc2hhcGVbMV0sci5zaGFwZVsyXSxyLnNoYXBlWzNdXSkpfXJldHVybiBufX19KSxcIlRpbGVcIixvLHIpfX0pLFdyPUFuKHt0cnVuY2F0ZWROb3JtYWxfOmZ1bmN0aW9uKHQsZSxuLHIsbyl7aWYodm9pZCAwPT09ZSYmKGU9MCksdm9pZCAwPT09biYmKG49MSksbnVsbCE9ciYmXCJib29sXCI9PT1yKXRocm93IG5ldyBFcnJvcihcIlVuc3VwcG9ydGVkIGRhdGEgdHlwZSBcIityKTtmb3IodmFyIGE9bmV3IGxyKGUsbixyLCEwLG8pLGk9ZHIodCxyKSxzPTA7czxpLnZhbHVlcy5sZW5ndGg7cysrKWkudmFsdWVzW3NdPWEubmV4dFZhbHVlKCk7cmV0dXJuIGkudG9UZW5zb3IoKX19KSxVcj1Bbih7dW5zdGFja186ZnVuY3Rpb24odCxlKXt2b2lkIDA9PT1lJiYoZT0wKSxlPWV8fDA7dmFyIG49bW4odCxcInhcIixcInVuc3RhY2tcIik7QyhlPj0tbi5zaGFwZS5sZW5ndGgmJmU8bi5zaGFwZS5sZW5ndGgsKGZ1bmN0aW9uKCl7cmV0dXJuXCJBeGlzID0gXCIrZStcIiBpcyBub3QgaW4gWy1cIituLnNoYXBlLmxlbmd0aCtcIiwgXCIrbi5zaGFwZS5sZW5ndGgrXCIpXCJ9KSksZTwwJiYoZSs9bi5zaGFwZS5sZW5ndGgpO3ZhciByPXtheGlzOmV9O3JldHVybiBMdC5ydW5LZXJuZWxGdW5jKChmdW5jdGlvbih0KXtyZXR1cm4gdC51bnN0YWNrKG4sZSl9KSx7eDpufSwoZnVuY3Rpb24odCl7cmV0dXJue3g6ZnVuY3Rpb24oKXtyZXR1cm4gUHIodCxlKX19fSksXCJVbnBhY2tcIixyKX19KSxWcj1mdW5jdGlvbih0LGUpe3JldHVybiBuKHRoaXMsdm9pZCAwLHZvaWQgMCwoZnVuY3Rpb24oKXt2YXIgbixvLGEsaSxzLHUsYyxsLGgsZjtyZXR1cm4gcih0aGlzLChmdW5jdGlvbihyKXtzd2l0Y2goci5sYWJlbCl7Y2FzZSAwOnJldHVybiBuPW1uKHQsXCJ4XCIsXCJzZXRkaWZmMWRcIiksbz1tbihlLFwieVwiLFwic2V0ZGlmZjFkXCIpLEMobi5kdHlwZT09PW8uZHR5cGUsKGZ1bmN0aW9uKCl7cmV0dXJuXCJ4IGFuZCB5IHNob3VsZCBoYXZlIHRoZSBzYW1lIGR0eXBlLCBidXQgZ290IHggKFwiK24uZHR5cGUrXCIpIGFuZCB5IChcIitvLmR0eXBlK1wiKS5cIn0pKSxDKDE9PT1uLnJhbmssKGZ1bmN0aW9uKCl7cmV0dXJuXCJ4IHNob3VsZCBiZSAxRCB0ZW5zb3IsIGJ1dCBnb3QgeCAoXCIrbi5zaGFwZStcIikuXCJ9KSksQygxPT09by5yYW5rLChmdW5jdGlvbigpe3JldHVyblwieSBzaG91bGQgYmUgMUQgdGVuc29yLCBidXQgZ290IHkgKFwiK28uc2hhcGUrXCIpLlwifSkpLFs0LG4uZGF0YSgpXTtjYXNlIDE6cmV0dXJuIGE9ci5zZW50KCksWzQsby5kYXRhKCldO2Nhc2UgMjpmb3IoaT1yLnNlbnQoKSxzPW5ldyBTZXQoaSksdT0wLGg9MDtoPGEubGVuZ3RoO2grKylzLmhhcyhhW2hdKXx8dSsrO2ZvcihjPW5ldyBndChbdV0sbi5kdHlwZSksbD1uZXcgZ3QoW3VdLFwiaW50MzJcIiksaD0wLGY9MDtoPGEubGVuZ3RoO2grKylzLmhhcyhhW2hdKXx8KGMudmFsdWVzW2ZdPWFbaF0sbC52YWx1ZXNbZl09aCxmKyspO3JldHVyblsyLFtjLnRvVGVuc29yKCksbC50b1RlbnNvcigpXV19fSkpfSkpfTtmdW5jdGlvbiB6cih0LGUsbixyKXt2b2lkIDA9PT1yJiYocj0hMCk7dmFyIG89W107aWYocikobz1vLmNvbmNhdChlLnNsaWNlKDApKSkucHVzaCh0WzBdL24pLG89by5jb25jYXQodC5zbGljZSgxKSk7ZWxzZXtvPW8uY29uY2F0KHRbMF0pO2Zvcih2YXIgYT1lLmxlbmd0aCxpPTA7aTxhOysraSlvPW8uY29uY2F0KFt0W2krMV0vZVtpXSxlW2ldXSk7bz1vLmNvbmNhdCh0LnNsaWNlKGErMSkpfXJldHVybiBvfWZ1bmN0aW9uIEdyKHQsZSxuKXt2b2lkIDA9PT1uJiYobj0hMCk7dmFyIHI9W107aWYobil7ci5wdXNoKGUpO2Zvcih2YXIgbz1lKzE7bzx0OysrbylvPD0yKmU/KHIucHVzaChvKSxyLnB1c2goby0oZSsxKSkpOnIucHVzaChvKX1lbHNle3ZhciBhPVtdLGk9W107Zm9yKG89MTtvPHQ7KytvKW8+PTIqZSsxfHxvJTI9PTE/aS5wdXNoKG8pOmEucHVzaChvKTtyLnB1c2guYXBwbHkocixhKSxyLnB1c2goMCksci5wdXNoLmFwcGx5KHIsaSl9cmV0dXJuIHJ9ZnVuY3Rpb24gSHIodCxlLG4scil7dm9pZCAwPT09ciYmKHI9ITApO3ZhciBvPVtdO3I/by5wdXNoKHRbMF0vbik6by5wdXNoKHRbMF0qbik7Zm9yKHZhciBhPTE7YTx0Lmxlbmd0aDsrK2EpYTw9ZS5sZW5ndGg/cj9vLnB1c2goZVthLTFdKnRbYV0pOm8ucHVzaCh0W2FdL2VbYS0xXSk6by5wdXNoKHRbYV0pO3JldHVybiBvfWZ1bmN0aW9uIHFyKHQsZSl7Zm9yKHZhciBuPVswXSxyPTA7cjxlOysrciluLnB1c2godFtyXVswXSk7cmV0dXJuIG59ZnVuY3Rpb24gS3IodCxlLG4pe2Zvcih2YXIgcj10LnNsaWNlKDAsMSksbz0wO288bjsrK28pci5wdXNoKHRbbysxXS1lW29dWzBdLWVbb11bMV0pO3JldHVybiByfWZ1bmN0aW9uIGpyKHQsZSl7aWYodC5yYW5rPDEpdGhyb3cgbmV3IEVycm9yKFwidGYuZ2F0aGVyTkQoKSBleHBlY3RzIHRoZSBpbnB1dCB0byBiZSByYW5rIDEgb3IgaGlnaGVyLCBidXQgdGhlIHJhbmsgd2FzIFwiK3QucmFuaytcIi5cIik7aWYoZS5yYW5rPDEpdGhyb3cgbmV3IEVycm9yKFwidGYuZ2F0aGVyTkQoKSBleHBlY3RzIHRoZSBpbmRpY2VzIHRvIGJlIHJhbmsgMSBvciBoaWdoZXIsIGJ1dCB0aGUgcmFuayB3YXMgXCIrZS5yYW5rK1wiLlwiKTtpZihcImludDMyXCIhPT1lLmR0eXBlKXRocm93IG5ldyBFcnJvcihcInRmLmdhdGhlck5EKCkgZXhwZWN0cyB0aGUgaW5kaWNlcyB0byBiZSBpbnQzMiB0eXBlLCBidXQgdGhlIGR0eXBlIHdhcyBcIitlLmR0eXBlK1wiLlwiKTtpZihlLnNoYXBlW2UucmFuay0xXT50LnJhbmspdGhyb3cgbmV3IEVycm9yKFwiaW5kZXggaW5uZXJtb3N0IGRpbWVuc2lvbiBsZW5ndGggbXVzdCBiZSA8PSB0ZW5zb3IgcmFuazsgc2F3OiBcIitlLnNoYXBlW2UucmFuay0xXStcIiB2cy4gXCIrdC5yYW5rKTtpZigwPT09dC5zaXplKXRocm93IG5ldyBFcnJvcihcIlJlcXVlc3RlZCBtb3JlIHRoYW4gMCBlbnRyaWVzLCBidXQgaW5wdXQgaXMgZW1wdHkuIElucHV0IHNoYXBlOiBcIit0LnNoYXBlK1wiLlwiKTtmb3IodmFyIG49ZS5zaGFwZSxyPW5bbi5sZW5ndGgtMV0sbz0xLGE9MDthPG4ubGVuZ3RoLTE7KythKW8qPW5bYV07dmFyIGk9dC5zaGFwZSxzPW4uc2xpY2UoKTtzLnBvcCgpO3ZhciB1PTE7Zm9yKGE9cjthPHQucmFuazsrK2EpdSo9aVthXSxzLnB1c2goaVthXSk7dmFyIGM9JCh0LnNoYXBlKS5tYXAoKGZ1bmN0aW9uKHQpe3JldHVybiB0L3V9KSkuY29uY2F0KFsxXSkuc2xpY2UoMCxyKTtyZXR1cm5bcyxvLHUsY119dmFyIFhyPU9iamVjdC5mcmVlemUoe3ByZXBhcmVBbmRWYWxpZGF0ZTpqcn0pLFlyPTMwO2Z1bmN0aW9uICRyKHQpe3JldHVybiB0PD1Zcj90OlkodCxNYXRoLmZsb29yKE1hdGguc3FydCh0KSkpfWZ1bmN0aW9uIFFyKHQsZSxuKXt2YXIgcj1lLnJhbms+MT9lLnNoYXBlW2UucmFuay0xXToxLG89ZS5yYW5rPjE/ZS5yYW5rLTE6MSxhPVwiTXVzdCBoYXZlIHVwZGF0ZXMuc2hhcGUgPSBpbmRpY2VzLnNoYXBlWzpiYXRjaERpbV0gKyBzaGFwZVtzbGljZURpbTpdLCBnb3QgdXBkYXRlcy5zaGFwZTogXCIrbi5zaGFwZStcIiwgaW5kaWNlcy5zaGFwZTogXCIrZS5zaGFwZStcIiwgc2hhcGU6IFwiK3QrXCIsIHNsaWNlRGltOiBcIityK1wiLCBhbmQgYmF0Y2hEaW06IFwiK28rXCIuXCI7aWYobi5yYW5rPG8pdGhyb3cgbmV3IEVycm9yKGErXCIgdXBkYXRlLnJhbmsgPCBcIitvK1wiLiBcIik7aWYodC5sZW5ndGg8cisobi5yYW5rLW8pKXRocm93IG5ldyBFcnJvcihhK1wiIE91dHB1dCBzaGFwZSBsZW5ndGggPCBcIisocisobi5yYW5rLW8pKSk7aWYobi5yYW5rIT09byt0Lmxlbmd0aC1yKXRocm93IG5ldyBFcnJvcihhK1wiIHVwZGF0ZS5yYW5rICE9IFwiKyhvK3QubGVuZ3RoLXIpKTtmb3IodmFyIGk9MDtpPG87KytpKWlmKG4uc2hhcGVbaV0hPT1lLnNoYXBlW2ldKXRocm93IG5ldyBFcnJvcihhK1wiIHVwZGF0ZXMuc2hhcGVbXCIraStcIl0gKFwiK24uc2hhcGVbaV0rXCIpICE9IGluZGljZXMuc2hhcGVbXCIraStcIl0gKFwiK2Uuc2hhcGVbaV0rXCIpLlwiKTtmb3IoaT0wO2k8bi5yYW5rLW87KytpKWlmKG4uc2hhcGVbaStvXSE9PXRbaStyXSl0aHJvdyBuZXcgRXJyb3IoYStcIiB1cGRhdGVzLnNoYXBlW1wiKyhpK28pK1wiXSAoXCIrbi5zaGFwZVtpK29dK1wiKSAhPSBzaGFwZVtcIisoaStvKStcIl0gKFwiK3RbaStvXStcIilcIil9ZnVuY3Rpb24gSnIodCxlLG4pe2lmKGUucmFuazwxKXRocm93IG5ldyBFcnJvcihcInRmLnNjYXR0ZXJORCgpIGV4cGVjdHMgdGhlIGluZGljZXMgdG8gYmUgcmFuayAxIG9yIGhpZ2hlciwgYnV0IHRoZSByYW5rIHdhcyBcIitlLnJhbmsrXCIuXCIpO2lmKHQucmFuazwxKXRocm93IG5ldyBFcnJvcihcInRmLnNjYXR0ZXJORCgpIGV4cGVjdHMgdGhlIHVwZGF0ZXMgdG8gYmUgcmFuayAxIG9yIGhpZ2hlciwgYnV0IHRoZSByYW5rIHdhcyBcIit0LnJhbmsrXCIuXCIpO2lmKFwiaW50MzJcIiE9PWUuZHR5cGUpdGhyb3cgbmV3IEVycm9yKFwiVGhlIGR0eXBlIG9mICdpbmRpY2VzJyBzaG91bGQgYmUgaW50MzIsIGJ1dCBnb3QgZHR5cGU6IFwiK2UuZHR5cGUpO2lmKG4ubGVuZ3RoPDEpdGhyb3cgbmV3IEVycm9yKFwiT3V0cHV0IHJhbmsgbXVzdCBiZSBncmVhdGVyIG9yIGVxdWFsIHRvIDEsIGJ1dCBnb3Qgc2hhcGU6IFwiK24pO2lmKDA9PT1uLmxlbmd0aCl7aWYoMD09PWUuc2l6ZSl0aHJvdyBuZXcgRXJyb3IoXCJJbmRpY2VzIHNwZWNpZmllZCBmb3IgZW1wdHkgb3V0cHV0LiBpbmRpY2VzIHNoYXBlOiBcIitlLnNoYXBlKTtpZigwPT09dC5zaXplKXRocm93IG5ldyBFcnJvcihcIlVwZGF0ZXMgc3BlY2lmaWVkIGZvciBlbXB0eSBvdXRwdXQuIHVwZGF0ZXMgc2hhcGU6IFwiK3Quc2hhcGUpfVFyKG4sZSx0KX1mdW5jdGlvbiBacih0LGUsbil7Zm9yKHZhciByPWUuc2hhcGUubGVuZ3RoLG89cj4xP2Uuc2hhcGVbci0xXToxLGE9bi5sZW5ndGgsaT0xLHM9bztzPGE7KytzKWkqPW5bc107dmFyIHU9bzwxPzE6bztyZXR1cm57c2xpY2VSYW5rOm8sbnVtVXBkYXRlczprKGUuc2hhcGUpL3Usc2xpY2VTaXplOmksc3RyaWRlczokKG4uc2xpY2UoMCxvKSkuY29uY2F0KFsxXSksb3V0cHV0U2l6ZTprKG4pfX12YXIgdG89T2JqZWN0LmZyZWV6ZSh7dmFsaWRhdGVVcGRhdGVTaGFwZTpRcix2YWxpZGF0ZUlucHV0OkpyLGNhbGN1bGF0ZVNoYXBlczpacn0pO2Z1bmN0aW9uIGVvKHQsZSxuKXtDKHQucmFuaz09PWUubGVuZ3RoLChmdW5jdGlvbigpe3JldHVyblwiRXJyb3IgaW4gc2xpY2VcIit0LnJhbmsrXCJEOiBMZW5ndGggb2YgYmVnaW4gXCIrZStcIiBtdXN0IG1hdGNoIHRoZSByYW5rIG9mIHRoZSBhcnJheSAoXCIrdC5yYW5rK1wiKS5cIn0pKSxDKHQucmFuaz09PW4ubGVuZ3RoLChmdW5jdGlvbigpe3JldHVyblwiRXJyb3IgaW4gc2xpY2VcIit0LnJhbmsrXCJEOiBMZW5ndGggb2Ygc2l6ZSBcIituK1wiIG11c3QgbWF0Y2ggdGhlIHJhbmsgb2YgdGhlIGFycmF5IChcIit0LnJhbmsrXCIpLlwifSkpO2Zvcih2YXIgcj1mdW5jdGlvbihyKXtDKGVbcl0rbltyXTw9dC5zaGFwZVtyXSwoZnVuY3Rpb24oKXtyZXR1cm5cIkVycm9yIGluIHNsaWNlXCIrdC5yYW5rK1wiRDogYmVnaW5bXCIrcitcIl0gKyBzaXplW1wiK3IrXCJdIChcIisoZVtyXStuW3JdKStcIikgd291bGQgb3ZlcmZsb3cgaW5wdXQuc2hhcGVbXCIrcitcIl0gKFwiK3Quc2hhcGVbcl0rXCIpXCJ9KSl9LG89MDtvPHQucmFuazsrK28pcihvKX1mdW5jdGlvbiBubyh0KXtmb3IodmFyIGU9W10sbj0wO3Q+MDspMSZ0JiZlLnB1c2gobiksdC89MixuKys7cmV0dXJuIGV9ZnVuY3Rpb24gcm8odCxlLG4pe2Zvcih2YXIgcj1bXSxvPTA7bzx0Lmxlbmd0aDtvKyspcltvXT1NYXRoLmNlaWwoKGVbb10tdFtvXSkvbltvXSk7cmV0dXJuIHJ9ZnVuY3Rpb24gb28odCxlLG4scixvKXt2YXIgYT1lW29dLGk9bltvXXx8MTsodCYxPDxvfHxudWxsPT1hKSYmKGE9aT4wP051bWJlci5NSU5fU0FGRV9JTlRFR0VSOk51bWJlci5NQVhfU0FGRV9JTlRFR0VSKTt2YXIgcz1yW29dO3JldHVybiBhPDAmJihhKz1zKSxhPXgoMCxhLHMtMSl9ZnVuY3Rpb24gYW8odCxlLG4scixvKXt2YXIgYT1lW29dLGk9bltvXXx8MTsodCYxPDxvfHxudWxsPT1hKSYmKGE9aT4wP051bWJlci5NQVhfU0FGRV9JTlRFR0VSOk51bWJlci5NSU5fU0FGRV9JTlRFR0VSKTt2YXIgcz1yW29dO3JldHVybiBhPDAmJihhKz1zKSxhPWk+MD94KDAsYSxzKTp4KC0xLGEscy0xKX1mdW5jdGlvbiBpbyh0LGUsbil7Zm9yKHZhciByPW4ubGVuZ3RoLG89MDtvPG4ubGVuZ3RoO28rKylpZihuW29dPjEpe3I9bzticmVha31mb3Iobz1yKzE7bzxuLmxlbmd0aDtvKyspaWYoZVtvXT4wfHxuW29dIT09dFtvXSlyZXR1cm4hMTtyZXR1cm4hMH1mdW5jdGlvbiBzbyh0LGUpe2Zvcih2YXIgbj10Lmxlbmd0aD4wP3RbdC5sZW5ndGgtMV06MSxyPTA7cjx0Lmxlbmd0aC0xO3IrKyluKz10W3JdKmVbcl07cmV0dXJuIG59dmFyIHVvPU9iamVjdC5mcmVlemUoe2Fzc2VydFBhcmFtc1ZhbGlkOmVvLG1hc2tUb0F4ZXM6bm8sY29tcHV0ZU91dFNoYXBlOnJvLHN0YXJ0Rm9yQXhpczpvbyxzdG9wRm9yQXhpczphbyxpc1NsaWNlQ29udGlub3VzOmlvLGNvbXB1dGVGbGF0T2Zmc2V0OnNvfSk7ZnVuY3Rpb24gY28odCl7cmV0dXJuIEMoWCh0KSwoZnVuY3Rpb24oKXtyZXR1cm5cIlRoZSBmIHBhc3NlZCBpbiBncmFkKGYpIG11c3QgYmUgYSBmdW5jdGlvblwifSkpLGZ1bmN0aW9uKGUsbil7dmFyIHI9bW4oZSxcInhcIixcInRmLmdyYWRcIixudWxsKSxvPW51bGwhPW4/bW4obixcImR5XCIsXCJ0Zi5ncmFkXCIpOm51bGw7cmV0dXJuIEx0LnRpZHkoKGZ1bmN0aW9uKCl7dmFyIGU9THQuZ3JhZGllbnRzKChmdW5jdGlvbigpe3JldHVybiB0KHIpfSksW3JdLG8pLG49ZS52YWx1ZSxhPWUuZ3JhZHM7cmV0dXJuIG51bGwhPW8mJkUobi5zaGFwZSxvLnNoYXBlLFwiVGhlIHNoYXBlIG9mIGR5IHBhc3NlZCBpbiBncmFkKGYpKHgsIGR5KSBtdXN0IG1hdGNoIHRoZSBzaGFwZSByZXR1cm5lZCBieSBmKHgpXCIpLG1vKGEpLGFbMF19KSl9fWZ1bmN0aW9uIGxvKHQpe3JldHVybiBDKFgodCksKGZ1bmN0aW9uKCl7cmV0dXJuXCJUaGUgZiBwYXNzZWQgaW4gZ3JhZHMoZikgbXVzdCBiZSBhIGZ1bmN0aW9uXCJ9KSksZnVuY3Rpb24oZSxuKXtDKEFycmF5LmlzQXJyYXkoZSksKGZ1bmN0aW9uKCl7cmV0dXJuXCJUaGUgYXJncyBwYXNzZWQgaW4gZ3JhZHMoZikoYXJncykgbXVzdCBiZSBhbiBhcnJheSBvZiBgVGVuc29yYHMgb3IgYFRlbnNvckxpa2Vgc1wifSkpO3ZhciByPWduKGUsXCJhcmdzXCIsXCJ0Zi5ncmFkc1wiLG51bGwpLG89bnVsbCE9bj9tbihuLFwiZHlcIixcInRmLmdyYWRzXCIpOm51bGw7cmV0dXJuIEx0LnRpZHkoKGZ1bmN0aW9uKCl7dmFyIGU9THQuZ3JhZGllbnRzKChmdW5jdGlvbigpe3JldHVybiB0LmFwcGx5KHZvaWQgMCxyKX0pLHIsbyksbj1lLnZhbHVlLGE9ZS5ncmFkcztyZXR1cm4gbnVsbCE9byYmRShuLnNoYXBlLG8uc2hhcGUsXCJUaGUgc2hhcGUgb2YgZHkgcGFzc2VkIGluIGdyYWRzKGYpKFt4MSwuLi5dLCBkeSkgbXVzdCBtYXRjaCB0aGUgc2hhcGUgcmV0dXJuZWQgYnkgZihbeDEsLi4uXSlcIiksbW8oYSksYX0pKX19ZnVuY3Rpb24gaG8odCl7cmV0dXJuIEMoWCh0KSwoZnVuY3Rpb24oKXtyZXR1cm5cIlRoZSBmIHBhc3NlZCBpbiB2YWx1ZUFuZEdyYWQoZikgbXVzdCBiZSBhIGZ1bmN0aW9uXCJ9KSksZnVuY3Rpb24oZSxuKXtDKGUgaW5zdGFuY2VvZiB3dCwoZnVuY3Rpb24oKXtyZXR1cm5cIlRoZSB4IHBhc3NlZCBpbiB2YWx1ZUFuZEdyYWQoZikoeCkgbXVzdCBiZSBhIHRlbnNvclwifSkpLEMobnVsbD09bnx8biBpbnN0YW5jZW9mIHd0LChmdW5jdGlvbigpe3JldHVyblwiVGhlIGR5IHBhc3NlZCBpbiB2YWx1ZUFuZEdyYWQoZikoeCwgZHkpIG11c3QgYmUgYSB0ZW5zb3JcIn0pKTt2YXIgcj1MdC5ncmFkaWVudHMoKGZ1bmN0aW9uKCl7cmV0dXJuIHQoZSl9KSxbZV0sbiksbz1yLmdyYWRzLGE9ci52YWx1ZTtyZXR1cm4gbW8obykse2dyYWQ6b1swXSx2YWx1ZTphfX19ZnVuY3Rpb24gZm8odCl7cmV0dXJuIEMoWCh0KSwoZnVuY3Rpb24oKXtyZXR1cm5cIlRoZSBmIHBhc3NlZCBpbiB2YWx1ZUFuZEdyYWRzKGYpIG11c3QgYmUgYSBmdW5jdGlvblwifSkpLGZ1bmN0aW9uKGUsbil7QyhBcnJheS5pc0FycmF5KGUpJiZlLmV2ZXJ5KChmdW5jdGlvbih0KXtyZXR1cm4gdCBpbnN0YW5jZW9mIHd0fSkpLChmdW5jdGlvbigpe3JldHVyblwiVGhlIGFyZ3MgcGFzc2VkIGluIHZhbHVlQW5kR3JhZHMoZikoYXJncykgbXVzdCBiZSBhcnJheSBvZiB0ZW5zb3JzXCJ9KSksQyhudWxsPT1ufHxuIGluc3RhbmNlb2Ygd3QsKGZ1bmN0aW9uKCl7cmV0dXJuXCJUaGUgZHkgcGFzc2VkIGluIHZhbHVlQW5kR3JhZHMoZikoYXJncywgZHkpIG11c3QgYmUgYSB0ZW5zb3JcIn0pKTt2YXIgcj1MdC5ncmFkaWVudHMoKGZ1bmN0aW9uKCl7cmV0dXJuIHQuYXBwbHkodm9pZCAwLGUpfSksZSxuKTtyZXR1cm4gbnVsbCE9biYmRShyLnZhbHVlLnNoYXBlLG4uc2hhcGUsXCJUaGUgc2hhcGUgb2YgZHkgcGFzc2VkIGluIHZhbHVlQW5kR3JhZHMoZikoW3gxLC4uLl0sIGR5KSBtdXN0IG1hdGNoIHRoZSBzaGFwZSByZXR1cm5lZCBieSBmKFt4MSwuLi5dKVwiKSxtbyhyLmdyYWRzKSxyfX1mdW5jdGlvbiBwbyh0LGUpe0MoWCh0KSwoZnVuY3Rpb24oKXtyZXR1cm5cIlRoZSBmIHBhc3NlZCBpbiB2YXJpYWJsZUdyYWRzKGYpIG11c3QgYmUgYSBmdW5jdGlvblwifSkpLEMobnVsbD09ZXx8QXJyYXkuaXNBcnJheShlKSYmZS5ldmVyeSgoZnVuY3Rpb24odCl7cmV0dXJuIHQgaW5zdGFuY2VvZiBTdH0pKSwoZnVuY3Rpb24oKXtyZXR1cm5cIlRoZSB2YXJMaXN0IHBhc3NlZCBpbiB2YXJpYWJsZUdyYWRzKGYsIHZhckxpc3QpIG11c3QgYmUgYW4gYXJyYXkgb2YgdmFyaWFibGVzXCJ9KSk7dmFyIG49bnVsbCE9ZTtpZighbilmb3IodmFyIHIgaW4gZT1bXSxMdC5yZWdpc3RlcmVkVmFyaWFibGVzKWUucHVzaChMdC5yZWdpc3RlcmVkVmFyaWFibGVzW3JdKTt2YXIgbz1uP2UuZmlsdGVyKChmdW5jdGlvbih0KXtyZXR1cm4hdC50cmFpbmFibGV9KSk6bnVsbCxhPWUubGVuZ3RoO0MoKGU9ZS5maWx0ZXIoKGZ1bmN0aW9uKHQpe3JldHVybiB0LnRyYWluYWJsZX0pKSkubGVuZ3RoPjAsKGZ1bmN0aW9uKCl7cmV0dXJuXCJ2YXJpYWJsZUdyYWRzKCkgZXhwZWN0cyBhdCBsZWFzdCBvbmUgb2YgdGhlIGlucHV0IHZhcmlhYmxlcyB0byBiZSB0cmFpbmFibGUsIGJ1dCBub25lIG9mIHRoZSBcIithK1wiIHZhcmlhYmxlcyBpcyB0cmFpbmFibGUuXCJ9KSk7dmFyIGk9THQuZ3JhZGllbnRzKHQsZSxudWxsLCEwKSxzPWkudmFsdWUsdT1pLmdyYWRzO0ModS5zb21lKChmdW5jdGlvbih0KXtyZXR1cm4gbnVsbCE9dH0pKSwoZnVuY3Rpb24oKXtyZXR1cm5cIkNhbm5vdCBmaW5kIGEgY29ubmVjdGlvbiBiZXR3ZWVuIGFueSB2YXJpYWJsZSBhbmQgdGhlIHJlc3VsdCBvZiB0aGUgbG9zcyBmdW5jdGlvbiB5PWYoeCkuIFBsZWFzZSBtYWtlIHN1cmUgdGhlIG9wZXJhdGlvbnMgdGhhdCB1c2UgdmFyaWFibGVzIGFyZSBpbnNpZGUgdGhlIGZ1bmN0aW9uIGYgcGFzc2VkIHRvIG1pbmltaXplKCkuXCJ9KSksQygwPT09cy5yYW5rLChmdW5jdGlvbigpe3JldHVyblwiVGhlIGYgcGFzc2VkIGluIHZhcmlhYmxlR3JhZHMoZikgbXVzdCByZXR1cm4gYSBzY2FsYXIsIGJ1dCBpdCByZXR1cm5lZCBhIHJhbmstXCIrcy5yYW5rK1wiIHRlbnNvclwifSkpO3ZhciBjPXt9O3JldHVybiBlLmZvckVhY2goKGZ1bmN0aW9uKHQsZSl7bnVsbCE9dVtlXSYmKGNbdC5uYW1lXT11W2VdKX0pKSxudWxsIT1vJiZvLmZvckVhY2goKGZ1bmN0aW9uKHQpe3JldHVybiBjW3QubmFtZV09bnVsbH0pKSx7dmFsdWU6cyxncmFkczpjfX1mdW5jdGlvbiB2byh0KXtyZXR1cm4gTHQuY3VzdG9tR3JhZCh0KX1mdW5jdGlvbiBtbyh0KXtpZih0LmZpbHRlcigoZnVuY3Rpb24odCl7cmV0dXJuIG51bGw9PXR9KSkubGVuZ3RoPjApdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGNvbXB1dGUgZ3JhZGllbnQgb2YgeT1mKHgpIHdpdGggcmVzcGVjdCB0byB4LiBNYWtlIHN1cmUgdGhhdFxcbiAgICB0aGUgZiB5b3UgcGFzc2VkIGVuY2xvc2VzIGFsbCBvcGVyYXRpb25zIHRoYXQgbGVhZCBmcm9tIHggdG8geS5cIil9dmFyIGdvPUFuKHtzb2Z0bWF4XzpmdW5jdGlvbih0LGUpe3ZvaWQgMD09PWUmJihlPS0xKTt2YXIgbj1tbih0LFwibG9naXRzXCIsXCJzb2Z0bWF4XCIsXCJmbG9hdDMyXCIpO2lmKC0xPT09ZSYmKGU9bi5yYW5rLTEpLGUhPT1uLnJhbmstMSl0aHJvdyBFcnJvcihcIlNvZnRtYXggYWxvbmcgYSBub24tbGFzdCBkaW1lbnNpb24gaXMgbm90IHlldCBzdXBwb3J0ZWQuIExvZ2l0cyB3YXMgcmFuayBcIituLnJhbmsrXCIgYW5kIGRpbSB3YXMgXCIrZSk7cmV0dXJuIEx0LnJ1bktlcm5lbEZ1bmMoKGZ1bmN0aW9uKHQscil7dmFyIG89dC5zb2Z0bWF4KG4sZSk7cmV0dXJuIHIoW29dKSxvfSkse2xvZ2l0czpufSwoZnVuY3Rpb24odCxuKXt2YXIgcj1uWzBdLG89dC5tdWwocik7cmV0dXJue2xvZ2l0czpmdW5jdGlvbigpe3JldHVybiBvLnN1YihvLnN1bShbZV0sITApLm11bChyKSl9fX0pLFwiU29mdG1heFwiLHtkaW06ZX0sW10sWyEwXSl9fSkseW89QW4oe2xvZ1NvZnRtYXhfOmZ1bmN0aW9uKHQsZSl7dm9pZCAwPT09ZSYmKGU9LTEpO3ZhciBuPW1uKHQsXCJsb2dpdHNcIixcImxvZ1NvZnRtYXhcIik7aWYoLTE9PT1lJiYoZT1uLnJhbmstMSksZSE9PW4ucmFuay0xKXRocm93IEVycm9yKFwiTG9nIFNvZnRtYXggYWxvbmcgYSBub24tbGFzdCBkaW1lbnNpb24gaXMgbm90IHlldCBzdXBwb3J0ZWQuIExvZ2l0cyB3YXMgcmFuayBcIituLnJhbmsrXCIgYW5kIGF4aXMgd2FzIFwiK2UpO3JldHVybiB2bygoZnVuY3Rpb24odCxuKXt2YXIgcj10Lm1heChlLCEwKSxvPXQuc3ViKHIpLGE9by50b0Zsb2F0KCkuc3ViKG8uZXhwKCkuc3VtKGUsITApLmxvZygpKTtuKFthXSk7cmV0dXJue3ZhbHVlOmEsZ3JhZEZ1bmM6ZnVuY3Rpb24odCxuKXt2YXIgcj1uWzBdLmV4cCgpO3JldHVybiB0LnN1Yih0LnN1bShlLCEwKS5tdWwocikpfX19KSkobil9fSkseG89ZnVuY3Rpb24oKXtmdW5jdGlvbiB0KHQsZSl7dGhpcy5iYWNrZW5kPXQsdGhpcy5kYXRhTW92ZXI9ZSx0aGlzLmRhdGE9bmV3IFdlYWtNYXAsdGhpcy5kYXRhSWRzQ291bnQ9MH1yZXR1cm4gdC5wcm90b3R5cGUuZ2V0PWZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLmRhdGEuaGFzKHQpfHx0aGlzLmRhdGFNb3Zlci5tb3ZlRGF0YSh0aGlzLmJhY2tlbmQsdCksdGhpcy5kYXRhLmdldCh0KX0sdC5wcm90b3R5cGUuc2V0PWZ1bmN0aW9uKHQsZSl7dGhpcy5kYXRhSWRzQ291bnQrKyx0aGlzLmRhdGEuc2V0KHQsZSl9LHQucHJvdG90eXBlLmhhcz1mdW5jdGlvbih0KXtyZXR1cm4gdGhpcy5kYXRhLmhhcyh0KX0sdC5wcm90b3R5cGUuZGVsZXRlPWZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLmRhdGFJZHNDb3VudC0tLHRoaXMuZGF0YS5kZWxldGUodCl9LHQucHJvdG90eXBlLm51bURhdGFJZHM9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5kYXRhSWRzQ291bnR9LHR9KCksYm89ZnVuY3Rpb24oKXtmdW5jdGlvbiB0KCl7fXJldHVybiB0LnByb3RvdHlwZS50aW1lPWZ1bmN0aW9uKHQpe3JldHVybiB3byhcInRpbWVcIil9LHQucHJvdG90eXBlLnJlYWQ9ZnVuY3Rpb24odCl7cmV0dXJuIHdvKFwicmVhZFwiKX0sdC5wcm90b3R5cGUucmVhZFN5bmM9ZnVuY3Rpb24odCl7cmV0dXJuIHdvKFwicmVhZFN5bmNcIil9LHQucHJvdG90eXBlLm51bURhdGFJZHM9ZnVuY3Rpb24oKXtyZXR1cm4gd28oXCJudW1EYXRhSWRzXCIpfSx0LnByb3RvdHlwZS5kaXNwb3NlRGF0YT1mdW5jdGlvbih0KXtyZXR1cm4gd28oXCJkaXNwb3NlRGF0YVwiKX0sdC5wcm90b3R5cGUud3JpdGU9ZnVuY3Rpb24odCxlLG4pe3JldHVybiB3byhcIndyaXRlXCIpfSx0LnByb3RvdHlwZS5tb3ZlPWZ1bmN0aW9uKHQsZSxuLHIpe3JldHVybiB3byhcIm1vdmVcIil9LHQucHJvdG90eXBlLm1lbW9yeT1mdW5jdGlvbigpe3JldHVybiB3byhcIm1lbW9yeVwiKX0sdC5wcm90b3R5cGUuZmxvYXRQcmVjaXNpb249ZnVuY3Rpb24oKXtyZXR1cm4gd28oXCJmbG9hdFByZWNpc2lvblwiKX0sdC5wcm90b3R5cGUuZXBzaWxvbj1mdW5jdGlvbigpe3JldHVybiAzMj09PXRoaXMuZmxvYXRQcmVjaXNpb24oKT8xZS03OjFlLTR9LHQucHJvdG90eXBlLmJhdGNoTWF0TXVsPWZ1bmN0aW9uKHQsZSxuLHIpe3JldHVybiB3byhcImJhdGNoTWF0TXVsXCIpfSx0LnByb3RvdHlwZS5mdXNlZEJhdGNoTWF0TXVsPWZ1bmN0aW9uKHQpe3QuYSx0LmIsdC50cmFuc3Bvc2VBLHQudHJhbnNwb3NlQix0LmJpYXMsdC5hY3RpdmF0aW9uLHQucHJlbHVBY3RpdmF0aW9uV2VpZ2h0cztyZXR1cm4gd28oXCJmdXNlZEJhdGNoTWF0TXVsXCIpfSx0LnByb3RvdHlwZS5zbGljZT1mdW5jdGlvbih0LGUsbil7cmV0dXJuIHdvKFwic2xpY2VcIil9LHQucHJvdG90eXBlLnN0cmlkZWRTbGljZT1mdW5jdGlvbih0LGUsbixyKXtyZXR1cm4gd28oXCJzdHJpZGVkU2xpY2VcIil9LHQucHJvdG90eXBlLnVuc3RhY2s9ZnVuY3Rpb24odCxlKXtyZXR1cm4gd28oXCJ1bnN0YWNrXCIpfSx0LnByb3RvdHlwZS5yZXZlcnNlPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIHdvKFwicmV2ZXJzZVwiKX0sdC5wcm90b3R5cGUuY29uY2F0PWZ1bmN0aW9uKHQsZSl7cmV0dXJuIHdvKFwiY29uY2F0XCIpfSx0LnByb3RvdHlwZS5uZWc9ZnVuY3Rpb24odCl7cmV0dXJuIHdvKFwibmVnXCIpfSx0LnByb3RvdHlwZS5hZGQ9ZnVuY3Rpb24odCxlKXtyZXR1cm4gd28oXCJhZGRcIil9LHQucHJvdG90eXBlLmFkZE49ZnVuY3Rpb24odCl7cmV0dXJuIHdvKFwiYWRkTlwiKX0sdC5wcm90b3R5cGUuc3VidHJhY3Q9ZnVuY3Rpb24odCxlKXtyZXR1cm4gd28oXCJzdWJ0cmFjdFwiKX0sdC5wcm90b3R5cGUubXVsdGlwbHk9ZnVuY3Rpb24odCxlKXtyZXR1cm4gd28oXCJtdWx0aXBseVwiKX0sdC5wcm90b3R5cGUucmVhbERpdmlkZT1mdW5jdGlvbih0LGUpe3JldHVybiB3byhcInJlYWxEaXZpZGVcIil9LHQucHJvdG90eXBlLmZsb29yRGl2PWZ1bmN0aW9uKHQsZSl7cmV0dXJuIHdvKFwiZmxvb3JEaXZcIil9LHQucHJvdG90eXBlLnN1bT1mdW5jdGlvbih0LGUpe3JldHVybiB3byhcInN1bVwiKX0sdC5wcm90b3R5cGUucHJvZD1mdW5jdGlvbih0LGUpe3JldHVybiB3byhcInByb2RcIil9LHQucHJvdG90eXBlLnVuc29ydGVkU2VnbWVudFN1bT1mdW5jdGlvbih0LGUsbil7cmV0dXJuIHdvKFwidW5zb3J0ZWRTZWdtZW50U3VtXCIpfSx0LnByb3RvdHlwZS5hcmdNaW49ZnVuY3Rpb24odCxlKXtyZXR1cm4gd28oXCJhcmdNaW5cIil9LHQucHJvdG90eXBlLmFyZ01heD1mdW5jdGlvbih0LGUpe3JldHVybiB3byhcImFyZ01heFwiKX0sdC5wcm90b3R5cGUuZXF1YWw9ZnVuY3Rpb24odCxlKXtyZXR1cm4gd28oXCJlcXVhbFwiKX0sdC5wcm90b3R5cGUubm90RXF1YWw9ZnVuY3Rpb24odCxlKXtyZXR1cm4gd28oXCJub3RFcXVhbFwiKX0sdC5wcm90b3R5cGUubGVzcz1mdW5jdGlvbih0LGUpe3JldHVybiB3byhcImxlc3NcIil9LHQucHJvdG90eXBlLmxlc3NFcXVhbD1mdW5jdGlvbih0LGUpe3JldHVybiB3byhcImxlc3NFcXVhbFwiKX0sdC5wcm90b3R5cGUuZ3JlYXRlcj1mdW5jdGlvbih0LGUpe3JldHVybiB3byhcImdyZWF0ZXJcIil9LHQucHJvdG90eXBlLmdyZWF0ZXJFcXVhbD1mdW5jdGlvbih0LGUpe3JldHVybiB3byhcImdyZWF0ZXJFcXVhbFwiKX0sdC5wcm90b3R5cGUubG9naWNhbE5vdD1mdW5jdGlvbih0KXtyZXR1cm4gd28oXCJsb2dpY2FsTm90XCIpfSx0LnByb3RvdHlwZS5sb2dpY2FsQW5kPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIHdvKFwibG9naWNhbEFuZFwiKX0sdC5wcm90b3R5cGUubG9naWNhbE9yPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIHdvKFwibG9naWNhbE9yXCIpfSx0LnByb3RvdHlwZS53aGVyZT1mdW5jdGlvbih0KXtyZXR1cm4gd28oXCJ3aGVyZVwiKX0sdC5wcm90b3R5cGUuc2VsZWN0PWZ1bmN0aW9uKHQsZSxuKXtyZXR1cm4gd28oXCJzZWxlY3RcIil9LHQucHJvdG90eXBlLnRvcGs9ZnVuY3Rpb24odCxlLG4pe3JldHVybiB3byhcInRvcGtcIil9LHQucHJvdG90eXBlLm1pbj1mdW5jdGlvbih0LGUpe3JldHVybiB3byhcIm1pblwiKX0sdC5wcm90b3R5cGUubWluaW11bT1mdW5jdGlvbih0LGUpe3JldHVybiB3byhcIm1pbmltdW1cIil9LHQucHJvdG90eXBlLm1vZD1mdW5jdGlvbih0LGUpe3JldHVybiB3byhcIm1vZFwiKX0sdC5wcm90b3R5cGUubWF4PWZ1bmN0aW9uKHQsZSl7cmV0dXJuIHdvKFwibWF4XCIpfSx0LnByb3RvdHlwZS5tYXhpbXVtPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIHdvKFwibWF4aW11bVwiKX0sdC5wcm90b3R5cGUuYWxsPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIHdvKFwiYWxsXCIpfSx0LnByb3RvdHlwZS5hbnk9ZnVuY3Rpb24odCxlKXtyZXR1cm4gd28oXCJhbnlcIil9LHQucHJvdG90eXBlLnNxdWFyZWREaWZmZXJlbmNlPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIHdvKFwic3F1YXJlZERpZmZlcmVuY2VcIil9LHQucHJvdG90eXBlLmNlaWw9ZnVuY3Rpb24odCl7cmV0dXJuIHdvKFwiY2VpbFwiKX0sdC5wcm90b3R5cGUuZmxvb3I9ZnVuY3Rpb24odCl7cmV0dXJuIHdvKFwiZmxvb3JcIil9LHQucHJvdG90eXBlLnJvdW5kPWZ1bmN0aW9uKHQpe3JldHVybiB3byhcInJvdW5kXCIpfSx0LnByb3RvdHlwZS5zaWduPWZ1bmN0aW9uKHQpe3JldHVybiB3byhcInNpZ25cIil9LHQucHJvdG90eXBlLmlzTmFOPWZ1bmN0aW9uKHQpe3JldHVybiB3byhcImlzTmFOXCIpfSx0LnByb3RvdHlwZS5pc0luZj1mdW5jdGlvbih0KXtyZXR1cm4gd28oXCJpc0luZlwiKX0sdC5wcm90b3R5cGUuaXNGaW5pdGU9ZnVuY3Rpb24odCl7cmV0dXJuIHdvKFwiaXNGaW5pdGVcIil9LHQucHJvdG90eXBlLnBvdz1mdW5jdGlvbih0LGUpe3JldHVybiB3byhcInBvd1wiKX0sdC5wcm90b3R5cGUuZXhwPWZ1bmN0aW9uKHQpe3JldHVybiB3byhcImV4cFwiKX0sdC5wcm90b3R5cGUuZXhwbTE9ZnVuY3Rpb24odCl7cmV0dXJuIHdvKFwiZXhwbTFcIil9LHQucHJvdG90eXBlLnNvZnRtYXg9ZnVuY3Rpb24odCxlKXtyZXR1cm4gd28oXCJzb2Z0bWF4XCIpfSx0LnByb3RvdHlwZS5sb2c9ZnVuY3Rpb24odCl7cmV0dXJuIHdvKFwibG9nXCIpfSx0LnByb3RvdHlwZS5sb2cxcD1mdW5jdGlvbih0KXtyZXR1cm4gd28oXCJsb2cxcFwiKX0sdC5wcm90b3R5cGUuc3FydD1mdW5jdGlvbih0KXtyZXR1cm4gd28oXCJzcXJ0XCIpfSx0LnByb3RvdHlwZS5yc3FydD1mdW5jdGlvbih0KXtyZXR1cm4gd28oXCJyc3FydFwiKX0sdC5wcm90b3R5cGUuc3F1YXJlPWZ1bmN0aW9uKHQpe3JldHVybiB3byhcInNxdWFyZVwiKX0sdC5wcm90b3R5cGUucmVjaXByb2NhbD1mdW5jdGlvbih0KXtyZXR1cm4gd28oXCJyZWNpcHJvY2FsXCIpfSx0LnByb3RvdHlwZS5yZWx1PWZ1bmN0aW9uKHQpe3JldHVybiB3byhcInJlbHVcIil9LHQucHJvdG90eXBlLnJlbHU2PWZ1bmN0aW9uKHQpe3JldHVybiB3byhcInJlbHU2XCIpfSx0LnByb3RvdHlwZS5wcmVsdT1mdW5jdGlvbih0LGUpe3JldHVybiB3byhcInByZWx1XCIpfSx0LnByb3RvdHlwZS5lbHU9ZnVuY3Rpb24odCl7cmV0dXJuIHdvKFwiZWx1XCIpfSx0LnByb3RvdHlwZS5lbHVEZXI9ZnVuY3Rpb24odCxlKXtyZXR1cm4gd28oXCJlbHVEZXJcIil9LHQucHJvdG90eXBlLnNlbHU9ZnVuY3Rpb24odCl7cmV0dXJuIHdvKFwic2VsdVwiKX0sdC5wcm90b3R5cGUuaW50PWZ1bmN0aW9uKHQpe3JldHVybiB3byhcImludFwiKX0sdC5wcm90b3R5cGUuY2xpcD1mdW5jdGlvbih0LGUsbil7cmV0dXJuIHdvKFwiY2xpcFwiKX0sdC5wcm90b3R5cGUuYWJzPWZ1bmN0aW9uKHQpe3JldHVybiB3byhcImFic1wiKX0sdC5wcm90b3R5cGUuY29tcGxleEFicz1mdW5jdGlvbih0KXtyZXR1cm4gd28oXCJjb21wbGV4QWJzXCIpfSx0LnByb3RvdHlwZS5zaWdtb2lkPWZ1bmN0aW9uKHQpe3JldHVybiB3byhcInNpZ21vaWRcIil9LHQucHJvdG90eXBlLnNvZnRwbHVzPWZ1bmN0aW9uKHQpe3JldHVybiB3byhcInNvZnRwbHVzXCIpfSx0LnByb3RvdHlwZS5zaW49ZnVuY3Rpb24odCl7cmV0dXJuIHdvKFwic2luXCIpfSx0LnByb3RvdHlwZS5jb3M9ZnVuY3Rpb24odCl7cmV0dXJuIHdvKFwiY29zXCIpfSx0LnByb3RvdHlwZS50YW49ZnVuY3Rpb24odCl7cmV0dXJuIHdvKFwidGFuXCIpfSx0LnByb3RvdHlwZS5hc2luPWZ1bmN0aW9uKHQpe3JldHVybiB3byhcImFzaW5cIil9LHQucHJvdG90eXBlLmFjb3M9ZnVuY3Rpb24odCl7cmV0dXJuIHdvKFwiYWNvc1wiKX0sdC5wcm90b3R5cGUuYXRhbj1mdW5jdGlvbih0KXtyZXR1cm4gd28oXCJhdGFuXCIpfSx0LnByb3RvdHlwZS5hdGFuMj1mdW5jdGlvbih0LGUpe3JldHVybiB3byhcImF0YW4yXCIpfSx0LnByb3RvdHlwZS5zaW5oPWZ1bmN0aW9uKHQpe3JldHVybiB3byhcInNpbmhcIil9LHQucHJvdG90eXBlLmNvc2g9ZnVuY3Rpb24odCl7cmV0dXJuIHdvKFwiY29zaFwiKX0sdC5wcm90b3R5cGUudGFuaD1mdW5jdGlvbih0KXtyZXR1cm4gd28oXCJ0YW5oXCIpfSx0LnByb3RvdHlwZS5hc2luaD1mdW5jdGlvbih0KXtyZXR1cm4gd28oXCJhc2luaFwiKX0sdC5wcm90b3R5cGUuYWNvc2g9ZnVuY3Rpb24odCl7cmV0dXJuIHdvKFwiYWNvc2hcIil9LHQucHJvdG90eXBlLmF0YW5oPWZ1bmN0aW9uKHQpe3JldHVybiB3byhcImF0YW5oXCIpfSx0LnByb3RvdHlwZS5lcmY9ZnVuY3Rpb24odCl7cmV0dXJuIHdvKFwiZXJmXCIpfSx0LnByb3RvdHlwZS5zdGVwPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIHdvKFwic3RlcFwiKX0sdC5wcm90b3R5cGUuZnVzZWRDb252MmQ9ZnVuY3Rpb24odCl7dC5pbnB1dCx0LmZpbHRlcix0LmNvbnZJbmZvLHQuYmlhcyx0LmFjdGl2YXRpb24sdC5wcmVsdUFjdGl2YXRpb25XZWlnaHRzO3JldHVybiB3byhcImZ1c2VkQ29udjJkXCIpfSx0LnByb3RvdHlwZS5jb252MmQ9ZnVuY3Rpb24odCxlLG4pe3JldHVybiB3byhcImNvbnYyZFwiKX0sdC5wcm90b3R5cGUuY29udjJkRGVySW5wdXQ9ZnVuY3Rpb24odCxlLG4pe3JldHVybiB3byhcImNvbnYyZERlcklucHV0XCIpfSx0LnByb3RvdHlwZS5jb252MmREZXJGaWx0ZXI9ZnVuY3Rpb24odCxlLG4pe3JldHVybiB3byhcImNvbnYyZERlckZpbHRlclwiKX0sdC5wcm90b3R5cGUuZnVzZWREZXB0aHdpc2VDb252MkQ9ZnVuY3Rpb24odCl7dC5pbnB1dCx0LmZpbHRlcix0LmNvbnZJbmZvLHQuYmlhcyx0LmFjdGl2YXRpb24sdC5wcmVsdUFjdGl2YXRpb25XZWlnaHRzO3JldHVybiB3byhcImZ1c2VkRGVwdGh3aXNlQ29udjJEXCIpfSx0LnByb3RvdHlwZS5kZXB0aHdpc2VDb252MkQ9ZnVuY3Rpb24odCxlLG4pe3JldHVybiB3byhcImRlcHRod2lzZUNvbnYyRFwiKX0sdC5wcm90b3R5cGUuZGVwdGh3aXNlQ29udjJERGVySW5wdXQ9ZnVuY3Rpb24odCxlLG4pe3JldHVybiB3byhcImRlcHRod2lzZUNvbnYyRERlcklucHV0XCIpfSx0LnByb3RvdHlwZS5kZXB0aHdpc2VDb252MkREZXJGaWx0ZXI9ZnVuY3Rpb24odCxlLG4pe3JldHVybiB3byhcImRlcHRod2lzZUNvbnYyRERlckZpbHRlclwiKX0sdC5wcm90b3R5cGUuY29udjNkPWZ1bmN0aW9uKHQsZSxuKXtyZXR1cm4gd28oXCJjb252M2RcIil9LHQucHJvdG90eXBlLmNvbnYzZERlcklucHV0PWZ1bmN0aW9uKHQsZSxuKXtyZXR1cm4gd28oXCJjb252M2REZXJJbnB1dFwiKX0sdC5wcm90b3R5cGUuY29udjNkRGVyRmlsdGVyPWZ1bmN0aW9uKHQsZSxuKXtyZXR1cm4gd28oXCJjb252M2REZXJGaWx0ZXJcIil9LHQucHJvdG90eXBlLm1heFBvb2w9ZnVuY3Rpb24odCxlKXtyZXR1cm4gd28oXCJtYXhQb29sXCIpfSx0LnByb3RvdHlwZS5tYXhQb29sQmFja3Byb3A9ZnVuY3Rpb24odCxlLG4scil7cmV0dXJuIHdvKFwibWF4UG9vbEJhY2twcm9wXCIpfSx0LnByb3RvdHlwZS5hdmdQb29sPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIHdvKFwiYXZnUG9vbFwiKX0sdC5wcm90b3R5cGUuYXZnUG9vbEJhY2twcm9wPWZ1bmN0aW9uKHQsZSxuKXtyZXR1cm4gd28oXCJhdmdQb29sQmFja3Byb3BcIil9LHQucHJvdG90eXBlLmF2Z1Bvb2wzZD1mdW5jdGlvbih0LGUpe3JldHVybiB3byhcImF2Z1Bvb2wzZFwiKX0sdC5wcm90b3R5cGUuYXZnUG9vbDNkQmFja3Byb3A9ZnVuY3Rpb24odCxlLG4pe3JldHVybiB3byhcImF2Z1Bvb2wzZEJhY2twcm9wXCIpfSx0LnByb3RvdHlwZS5tYXhQb29sM2Q9ZnVuY3Rpb24odCxlKXtyZXR1cm4gd28oXCJtYXhQb29sM2RcIil9LHQucHJvdG90eXBlLm1heFBvb2wzZEJhY2twcm9wPWZ1bmN0aW9uKHQsZSxuLHIpe3JldHVybiB3byhcIm1heFBvb2wzZEJhY2twcm9wXCIpfSx0LnByb3RvdHlwZS5yZXNoYXBlPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIHdvKFwicmVzaGFwZVwiKX0sdC5wcm90b3R5cGUuY2FzdD1mdW5jdGlvbih0LGUpe3JldHVybiB3byhcImNhc3RcIil9LHQucHJvdG90eXBlLnRpbGU9ZnVuY3Rpb24odCxlKXtyZXR1cm4gd28oXCJ0aWxlXCIpfSx0LnByb3RvdHlwZS5wYWQ9ZnVuY3Rpb24odCxlLG4pe3JldHVybiB3byhcInBhZFwiKX0sdC5wcm90b3R5cGUudHJhbnNwb3NlPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIHdvKFwidHJhbnNwb3NlXCIpfSx0LnByb3RvdHlwZS5nYXRoZXI9ZnVuY3Rpb24odCxlLG4pe3JldHVybiB3byhcImdhdGhlclwiKX0sdC5wcm90b3R5cGUuZ2F0aGVyTkQ9ZnVuY3Rpb24odCxlKXtyZXR1cm4gd28oXCJnYXRoZXJORFwiKX0sdC5wcm90b3R5cGUuc2NhdHRlck5EPWZ1bmN0aW9uKHQsZSxuKXtyZXR1cm4gd28oXCJzY2F0dGVyTkRcIil9LHQucHJvdG90eXBlLmJhdGNoVG9TcGFjZU5EPWZ1bmN0aW9uKHQsZSxuKXtyZXR1cm4gd28oXCJiYXRjaFRvU3BhY2VORFwiKX0sdC5wcm90b3R5cGUuc3BhY2VUb0JhdGNoTkQ9ZnVuY3Rpb24odCxlLG4pe3JldHVybiB3byhcInNwYWNlVG9CYXRjaE5EXCIpfSx0LnByb3RvdHlwZS5yZXNpemVCaWxpbmVhcj1mdW5jdGlvbih0LGUsbixyKXtyZXR1cm4gd28oXCJyZXNpemVCaWxpbmVhclwiKX0sdC5wcm90b3R5cGUucmVzaXplQmlsaW5lYXJCYWNrcHJvcD1mdW5jdGlvbih0LGUsbil7cmV0dXJuIHdvKFwicmVzaXplQmlsaW5lYXJCYWNrcHJvcFwiKX0sdC5wcm90b3R5cGUucmVzaXplTmVhcmVzdE5laWdoYm9yPWZ1bmN0aW9uKHQsZSxuLHIpe3JldHVybiB3byhcInJlc2l6ZU5lYXJlc3ROZWlnaGJvclwiKX0sdC5wcm90b3R5cGUucmVzaXplTmVhcmVzdE5laWdoYm9yQmFja3Byb3A9ZnVuY3Rpb24odCxlLG4pe3JldHVybiB3byhcInJlc2l6ZU5lYXJlc3ROZWlnaGJvckJhY2twcm9wXCIpfSx0LnByb3RvdHlwZS5iYXRjaE5vcm1hbGl6YXRpb249ZnVuY3Rpb24odCxlLG4scixvLGEpe3JldHVybiB3byhcImJhdGNoTm9ybWFsaXphdGlvblwiKX0sdC5wcm90b3R5cGUubG9jYWxSZXNwb25zZU5vcm1hbGl6YXRpb240RD1mdW5jdGlvbih0LGUsbixyLG8pe3JldHVybiB3byhcImxvY2FsUmVzcG9uc2VOb3JtYWxpemF0aW9uNERcIil9LHQucHJvdG90eXBlLkxSTkdyYWQ9ZnVuY3Rpb24odCxlLG4scixvLGEsaSl7cmV0dXJuIHdvKFwiTFJOR3JhZFwiKX0sdC5wcm90b3R5cGUubXVsdGlub21pYWw9ZnVuY3Rpb24odCxlLG4scil7cmV0dXJuIHdvKFwibXVsdGlub21pYWxcIil9LHQucHJvdG90eXBlLm9uZUhvdD1mdW5jdGlvbih0LGUsbixyKXtyZXR1cm4gd28oXCJvbmVIb3RcIil9LHQucHJvdG90eXBlLmN1bXN1bT1mdW5jdGlvbih0LGUsbixyKXtyZXR1cm4gd28oXCJjdW1zdW1cIil9LHQucHJvdG90eXBlLm5vbk1heFN1cHByZXNzaW9uPWZ1bmN0aW9uKHQsZSxuLHIsbyl7cmV0dXJuIHdvKFwibm9uTWF4U3VwcHJlc3Npb25cIil9LHQucHJvdG90eXBlLmZmdD1mdW5jdGlvbih0KXtyZXR1cm4gd28oXCJmZnRcIil9LHQucHJvdG90eXBlLmlmZnQ9ZnVuY3Rpb24odCl7cmV0dXJuIHdvKFwiaWZmdFwiKX0sdC5wcm90b3R5cGUuY29tcGxleD1mdW5jdGlvbih0LGUpe3JldHVybiB3byhcImNvbXBsZXhcIil9LHQucHJvdG90eXBlLnJlYWw9ZnVuY3Rpb24odCl7cmV0dXJuIHdvKFwicmVhbFwiKX0sdC5wcm90b3R5cGUuaW1hZz1mdW5jdGlvbih0KXtyZXR1cm4gd28oXCJpbWFnXCIpfSx0LnByb3RvdHlwZS5jcm9wQW5kUmVzaXplPWZ1bmN0aW9uKHQsZSxuLHIsbyxhKXtyZXR1cm4gd28oXCJjcm9wQW5kUmVzaXplXCIpfSx0LnByb3RvdHlwZS5kZXB0aFRvU3BhY2U9ZnVuY3Rpb24odCxlLG4pe3JldHVybiB3byhcImRlcHRoVG9TcGFjZVwiKX0sdC5wcm90b3R5cGUuc3BsaXQ9ZnVuY3Rpb24odCxlLG4pe3JldHVybiB3byhcInNwbGl0XCIpfSx0LnByb3RvdHlwZS5zcGFyc2VUb0RlbnNlPWZ1bmN0aW9uKHQsZSxuLHIpe3JldHVybiB3byhcInNwYXJzZVRvRGVuc2VcIil9LHQucHJvdG90eXBlLmRpYWc9ZnVuY3Rpb24odCl7cmV0dXJuIHdvKFwiZGlhZ1wiKX0sdC5wcm90b3R5cGUuZmlsbD1mdW5jdGlvbih0LGUsbil7cmV0dXJuIHdvKFwiZmlsbFwiKX0sdC5wcm90b3R5cGUub25lc0xpa2U9ZnVuY3Rpb24odCl7cmV0dXJuIHdvKFwib25lc0xpa2VcIil9LHQucHJvdG90eXBlLnplcm9zTGlrZT1mdW5jdGlvbih0KXtyZXR1cm4gd28oXCJ6ZXJvc0xpa2VcIil9LHQucHJvdG90eXBlLmxpbnNwYWNlPWZ1bmN0aW9uKHQsZSxuKXtyZXR1cm4gd28oXCJsaW5zcGFjZVwiKX0sdC5wcm90b3R5cGUuZGlzcG9zZT1mdW5jdGlvbigpe3JldHVybiB3byhcImRpc3Bvc2VcIil9LHR9KCk7ZnVuY3Rpb24gd28odCl7dGhyb3cgbmV3IEVycm9yKFwiJ1wiK3QrXCInIG5vdCB5ZXQgaW1wbGVtZW50ZWQgb3Igbm90IGZvdW5kIGluIHRoZSByZWdpc3RyeS4gRGlkIHlvdSBmb3JnZXQgdG8gaW1wb3J0IHRoZSBrZXJuZWw/XCIpfWZ1bmN0aW9uIENvKHQsZSl7Zm9yKHZhciBuPXQubGVuZ3RoLHI9W10sbz0wO288bjtvKyspe3ZhciBhPW4tMS1vLGk9dFthXXx8MTsoZVtlLmxlbmd0aC0xLW9dfHwxKT4xJiYxPT09aSYmci51bnNoaWZ0KGEpfXJldHVybiByfWZ1bmN0aW9uIEVvKHQsZSl7Zm9yKHZhciBuPVtdLHI9MDtyPGUubGVuZ3RoO3IrKyl7dmFyIG89dFt0Lmxlbmd0aC1yLTFdLGE9ZS5sZW5ndGgtci0xLGk9ZVthXTsobnVsbD09b3x8MT09PW8mJmk+MSkmJm4udW5zaGlmdChhKX1yZXR1cm4gbn1mdW5jdGlvbiBSbyh0LGUpe2Zvcih2YXIgbj1bXSxyPU1hdGgubWF4KHQubGVuZ3RoLGUubGVuZ3RoKSxvPTA7bzxyO28rKyl7dmFyIGE9dFt0Lmxlbmd0aC1vLTFdO251bGw9PWEmJihhPTEpO3ZhciBpPWVbZS5sZW5ndGgtby0xXTtpZihudWxsPT1pJiYoaT0xKSwxPT09YSluLnVuc2hpZnQoaSk7ZWxzZSBpZigxPT09aSluLnVuc2hpZnQoYSk7ZWxzZXtpZihhIT09aSl0aHJvdyBFcnJvcihcIk9wZXJhbmRzIGNvdWxkIG5vdCBiZSBicm9hZGNhc3QgdG9nZXRoZXIgd2l0aCBzaGFwZXMgXCIrdCtcIiBhbmQgXCIrZStcIi5cIik7bi51bnNoaWZ0KGEpfX1yZXR1cm4gbn1mdW5jdGlvbiBJbyh0LGUsbixyLG8sYSxpKXt2b2lkIDA9PT1pJiYoaT1cImNoYW5uZWxzTGFzdFwiKTt2YXIgcyx1PVRvKGUpLGM9dVswXSxsPXVbMV07aWYoXCJjaGFubmVsc0xhc3RcIj09PWkpcz1bYyxsLHRbM10sdFszXV07ZWxzZXtpZihcImNoYW5uZWxzRmlyc3RcIiE9PWkpdGhyb3cgbmV3IEVycm9yKFwiVW5rbm93biBkYXRhRm9ybWF0IFwiK2kpO3M9W2MsbCx0WzFdLHRbMV1dfXJldHVybiBTbyh0LHMsbixyLG8sYSwhMSxpKX1mdW5jdGlvbiBrbyh0LGUsbixyLG8sYSxpKXt2b2lkIDA9PT1pJiYoaT1cIk5ESFdDXCIpO3ZhciBzLHUsYz1ObyhlKSxsPWNbMF0saD1jWzFdLGY9Y1syXTtpZihcIk5ESFdDXCI9PT1pKXU9XCJjaGFubmVsc0xhc3RcIixzPVtsLGgsZix0WzRdLHRbNF1dO2Vsc2V7aWYoXCJOQ0RIV1wiIT09aSl0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIGRhdGFGb3JtYXQgXCIraSk7dT1cImNoYW5uZWxzRmlyc3RcIixzPVtsLGgsZix0WzFdLHRbMV1dfXJldHVybiBBbyh0LHMsbixyLG8sITEsdSxhKX1mdW5jdGlvbiBTbyh0LGUsbixyLG8sYSxpLHMpe3ZvaWQgMD09PWkmJihpPSExKSx2b2lkIDA9PT1zJiYocz1cImNoYW5uZWxzTGFzdFwiKTt2YXIgdT1bLTEsLTEsLTEsLTFdLGM9dVswXSxsPXVbMV0saD11WzJdLGY9dVszXTtpZihcImNoYW5uZWxzTGFzdFwiPT09cyljPXRbMF0sbD10WzFdLGg9dFsyXSxmPXRbM107ZWxzZXtpZihcImNoYW5uZWxzRmlyc3RcIiE9PXMpdGhyb3cgbmV3IEVycm9yKFwiVW5rbm93biBkYXRhRm9ybWF0IFwiK3MpO2M9dFswXSxmPXRbMV0sbD10WzJdLGg9dFszXX12YXIgZCxwPWVbMF0sdj1lWzFdLG09ZVszXSxnPVRvKG4pLHk9Z1swXSx4PWdbMV0sYj1UbyhyKSx3PWJbMF0sRT1iWzFdLFI9Rm8ocCx3KSxJPUZvKHYsRSksaz1mdW5jdGlvbih0LGUsbixyLG8sYSxpLHMpe3ZhciB1LGMsbDtpZihcIm51bWJlclwiPT10eXBlb2YgdCl7dT17dG9wOnQsYm90dG9tOnQsbGVmdDp0LHJpZ2h0OnQsdHlwZTowPT09dD9cIlZBTElEXCI6XCJOVU1CRVJcIn07dmFyIGg9ZnVuY3Rpb24odCxlLG4scixvKXtudWxsPT1yJiYocj1Ebyh0LGUsbikpO3ZhciBhPXRbMF0saT10WzFdLHM9X28oKGEtZSsyKnIpL24rMSxvKTtDKEEocyksKGZ1bmN0aW9uKCl7cmV0dXJuXCJUaGUgb3V0cHV0ICMgb2Ygcm93cyAoXCIrcytcIikgbXVzdCBiZSBhbiBpbnRlZ2VyLiBDaGFuZ2UgdGhlIHN0cmlkZSBhbmQvb3IgemVybyBwYWQgcGFyYW1ldGVyc1wifSkpO3ZhciB1PV9vKChpLWUrMipyKS9uKzEsbyk7cmV0dXJuIEMoQSh1KSwoZnVuY3Rpb24oKXtyZXR1cm5cIlRoZSBvdXRwdXQgIyBvZiBjb2x1bW5zIChcIit1K1wiKSBtdXN0IGJlIGFuIGludGVnZXIuIENoYW5nZSB0aGUgc3RyaWRlIGFuZC9vciB6ZXJvIHBhZCBwYXJhbWV0ZXJzXCJ9KSksW3MsdV19KFtlLG5dLGEscix0LHMpO2M9aFswXSxsPWhbMV19ZWxzZSBpZihcInNhbWVcIj09PXQpe2M9TWF0aC5jZWlsKGUvciksbD1NYXRoLmNlaWwobi9vKTt2YXIgZj1NYXRoLm1heCgwLChjLTEpKnIrYS1lKSxkPU1hdGgubWF4KDAsKGwtMSkqbytpLW4pLHA9TWF0aC5mbG9vcihmLzIpLHY9Zi1wLG09TWF0aC5mbG9vcihkLzIpO3U9e3RvcDpwLGJvdHRvbTp2LGxlZnQ6bSxyaWdodDpkLW0sdHlwZTpcIlNBTUVcIn19ZWxzZXtpZihcInZhbGlkXCIhPT10KXRocm93IEVycm9yKFwiVW5rbm93biBwYWRkaW5nIHBhcmFtZXRlcjogXCIrdCk7dT17dG9wOjAsYm90dG9tOjAsbGVmdDowLHJpZ2h0OjAsdHlwZTpcIlZBTElEXCJ9LGM9TWF0aC5jZWlsKChlLWErMSkvciksbD1NYXRoLmNlaWwoKG4taSsxKS9vKX1yZXR1cm57cGFkSW5mbzp1LG91dEhlaWdodDpjLG91dFdpZHRoOmx9fShvLGwsaCx5LHgsUixJLGEpLFM9ay5wYWRJbmZvLEQ9ay5vdXRIZWlnaHQsVD1rLm91dFdpZHRoLE49aT9tKmY6bTtyZXR1cm5cImNoYW5uZWxzRmlyc3RcIj09PXM/ZD1bYyxOLEQsVF06XCJjaGFubmVsc0xhc3RcIj09PXMmJihkPVtjLEQsVCxOXSkse2JhdGNoU2l6ZTpjLGRhdGFGb3JtYXQ6cyxpbkhlaWdodDpsLGluV2lkdGg6aCxpbkNoYW5uZWxzOmYsb3V0SGVpZ2h0OkQsb3V0V2lkdGg6VCxvdXRDaGFubmVsczpOLHBhZEluZm86UyxzdHJpZGVIZWlnaHQ6eSxzdHJpZGVXaWR0aDp4LGZpbHRlckhlaWdodDpwLGZpbHRlcldpZHRoOnYsZWZmZWN0aXZlRmlsdGVySGVpZ2h0OlIsZWZmZWN0aXZlRmlsdGVyV2lkdGg6SSxkaWxhdGlvbkhlaWdodDp3LGRpbGF0aW9uV2lkdGg6RSxpblNoYXBlOnQsb3V0U2hhcGU6ZCxmaWx0ZXJTaGFwZTplfX1mdW5jdGlvbiBBbyh0LGUsbixyLG8sYSxpLHMpe3ZvaWQgMD09PWEmJihhPSExKSx2b2lkIDA9PT1pJiYoaT1cImNoYW5uZWxzTGFzdFwiKTt2YXIgdT1bLTEsLTEsLTEsLTEsLTFdLGM9dVswXSxsPXVbMV0saD11WzJdLGY9dVszXSxkPXVbNF07aWYoXCJjaGFubmVsc0xhc3RcIj09PWkpYz10WzBdLGw9dFsxXSxoPXRbMl0sZj10WzNdLGQ9dFs0XTtlbHNle2lmKFwiY2hhbm5lbHNGaXJzdFwiIT09aSl0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIGRhdGFGb3JtYXQgXCIraSk7Yz10WzBdLGQ9dFsxXSxsPXRbMl0saD10WzNdLGY9dFs0XX12YXIgcCx2PWVbMF0sbT1lWzFdLGc9ZVsyXSx5PWVbNF0seD1ObyhuKSxiPXhbMF0sdz14WzFdLEU9eFsyXSxSPU5vKHIpLEk9UlswXSxrPVJbMV0sUz1SWzJdLEQ9Rm8odixJKSxUPUZvKG0sayksTj1GbyhnLFMpLEY9ZnVuY3Rpb24odCxlLG4scixvLGEsaSxzLHUsYyxsKXt2YXIgaCxmLGQscDtpZihcIm51bWJlclwiPT10eXBlb2YgdCl7aD17dG9wOnQsYm90dG9tOnQsbGVmdDp0LHJpZ2h0OnQsZnJvbnQ6dCxiYWNrOnQsdHlwZTowPT09dD9cIlZBTElEXCI6XCJOVU1CRVJcIn07dmFyIHY9ZnVuY3Rpb24odCxlLG4scixvLGEpe251bGw9PW8mJihvPURvKHQsZSxyKSk7dmFyIGk9dFswXSxzPXRbMV0sdT10WzJdLGM9X28oKGktZSsyKm8pL3IrMSxhKTtDKEEoYyksKGZ1bmN0aW9uKCl7cmV0dXJuXCJUaGUgb3V0cHV0ICMgb2YgZGVwdGhzIChcIitjK1wiKSBtdXN0IGJlIGFuIGludGVnZXIuIENoYW5nZSB0aGUgc3RyaWRlIGFuZC9vciB6ZXJvIHBhZCBwYXJhbWV0ZXJzXCJ9KSk7dmFyIGw9X28oKHMtZSsyKm8pL3IrMSxhKTtDKEEobCksKGZ1bmN0aW9uKCl7cmV0dXJuXCJUaGUgb3V0cHV0ICMgb2Ygcm93cyAoXCIrbCtcIikgbXVzdCBiZSBhbiBpbnRlZ2VyLiBDaGFuZ2UgdGhlIHN0cmlkZSBhbmQvb3IgemVybyBwYWQgcGFyYW1ldGVyc1wifSkpO3ZhciBoPV9vKCh1LWUrMipvKS9yKzEsYSk7cmV0dXJuIEMoQShoKSwoZnVuY3Rpb24oKXtyZXR1cm5cIlRoZSBvdXRwdXQgIyBvZiBjb2x1bW5zIChcIitoK1wiKSBtdXN0IGJlIGFuIGludGVnZXIuIENoYW5nZSB0aGUgc3RyaWRlIGFuZC9vciB6ZXJvIHBhZCBwYXJhbWV0ZXJzXCJ9KSksW2MsbCxoLG5dfShbZSxuLHIsMV0scywxLG8sdCxsKTtmPXZbMF0sZD12WzFdLHA9dlsyXX1lbHNlIGlmKFwic2FtZVwiPT09dCl7Zj1NYXRoLmNlaWwoZS9vKSxkPU1hdGguY2VpbChuL2EpLHA9TWF0aC5jZWlsKHIvaSk7dmFyIG09KGYtMSkqbytzLWUsZz0oZC0xKSphK3Utbix5PShwLTEpKmkrYy1yLHg9TWF0aC5mbG9vcihtLzIpLGI9bS14LHc9TWF0aC5mbG9vcihnLzIpLEU9Zy13LFI9TWF0aC5mbG9vcih5LzIpO2g9e3RvcDp3LGJvdHRvbTpFLGxlZnQ6UixyaWdodDp5LVIsZnJvbnQ6eCxiYWNrOmIsdHlwZTpcIlNBTUVcIn19ZWxzZXtpZihcInZhbGlkXCIhPT10KXRocm93IEVycm9yKFwiVW5rbm93biBwYWRkaW5nIHBhcmFtZXRlcjogXCIrdCk7aD17dG9wOjAsYm90dG9tOjAsbGVmdDowLHJpZ2h0OjAsZnJvbnQ6MCxiYWNrOjAsdHlwZTpcIlZBTElEXCJ9LGY9TWF0aC5jZWlsKChlLXMrMSkvbyksZD1NYXRoLmNlaWwoKG4tdSsxKS9hKSxwPU1hdGguY2VpbCgoci1jKzEpL2kpfXJldHVybntwYWRJbmZvOmgsb3V0RGVwdGg6ZixvdXRIZWlnaHQ6ZCxvdXRXaWR0aDpwfX0obyxsLGgsZixiLHcsRSxELFQsTixzKSxfPUYucGFkSW5mbyxPPUYub3V0RGVwdGgsTT1GLm91dEhlaWdodCxCPUYub3V0V2lkdGgsUD1hP3kqZDp5O3JldHVyblwiY2hhbm5lbHNGaXJzdFwiPT09aT9wPVtjLFAsTyxNLEJdOlwiY2hhbm5lbHNMYXN0XCI9PT1pJiYocD1bYyxPLE0sQixQXSkse2JhdGNoU2l6ZTpjLGRhdGFGb3JtYXQ6aSxpbkRlcHRoOmwsaW5IZWlnaHQ6aCxpbldpZHRoOmYsaW5DaGFubmVsczpkLG91dERlcHRoOk8sb3V0SGVpZ2h0Ok0sb3V0V2lkdGg6QixvdXRDaGFubmVsczpQLHBhZEluZm86XyxzdHJpZGVEZXB0aDpiLHN0cmlkZUhlaWdodDp3LHN0cmlkZVdpZHRoOkUsZmlsdGVyRGVwdGg6dixmaWx0ZXJIZWlnaHQ6bSxmaWx0ZXJXaWR0aDpnLGVmZmVjdGl2ZUZpbHRlckRlcHRoOkQsZWZmZWN0aXZlRmlsdGVySGVpZ2h0OlQsZWZmZWN0aXZlRmlsdGVyV2lkdGg6TixkaWxhdGlvbkRlcHRoOkksZGlsYXRpb25IZWlnaHQ6ayxkaWxhdGlvbldpZHRoOlMsaW5TaGFwZTp0LG91dFNoYXBlOnAsZmlsdGVyU2hhcGU6ZX19ZnVuY3Rpb24gRG8odCxlLG4scil7dm9pZCAwPT09ciYmKHI9MSk7dmFyIG89Rm8oZSxyKTtyZXR1cm4gTWF0aC5mbG9vcigodFswXSoobi0xKS1uK28pLzIpfWZ1bmN0aW9uIFRvKHQpe3JldHVyblwibnVtYmVyXCI9PXR5cGVvZiB0P1t0LHQsdF06Mj09PXQubGVuZ3RoP1t0WzBdLHRbMV0sMV06dH1mdW5jdGlvbiBObyh0KXtyZXR1cm5cIm51bWJlclwiPT10eXBlb2YgdD9bdCx0LHRdOnR9ZnVuY3Rpb24gRm8odCxlKXtyZXR1cm4gZTw9MT90OnQrKHQtMSkqKGUtMSl9ZnVuY3Rpb24gX28odCxlKXtpZighZSlyZXR1cm4gdDtzd2l0Y2goZSl7Y2FzZVwicm91bmRcIjpyZXR1cm4gTWF0aC5yb3VuZCh0KTtjYXNlXCJjZWlsXCI6cmV0dXJuIE1hdGguY2VpbCh0KTtjYXNlXCJmbG9vclwiOnJldHVybiBNYXRoLmZsb29yKHQpO2RlZmF1bHQ6dGhyb3cgbmV3IEVycm9yKFwiVW5rbm93biByb3VuZGluZ01vZGUgXCIrZSl9fWZ1bmN0aW9uIE9vKHQpe3ZhciBlPVRvKHQpLG49ZVswXSxyPWVbMV0sbz1lWzJdO3JldHVybiAxPT09biYmMT09PXImJjE9PT1vfWZ1bmN0aW9uIE1vKHQsZSl7cmV0dXJuIE9vKHQpfHxPbyhlKX1mdW5jdGlvbiBCbyh0KXtpZihcIk5IV0NcIj09PXQpcmV0dXJuXCJjaGFubmVsc0xhc3RcIjtpZihcIk5DSFdcIj09PXQpcmV0dXJuXCJjaGFubmVsc0ZpcnN0XCI7dGhyb3cgbmV3IEVycm9yKFwiVW5rbm93biBkYXRhRm9ybWF0IFwiK3QpfWZ1bmN0aW9uIFBvKHQsZSxuKXtpZihcImNvbXBsZXg2NFwiPT09ZSl7aWYoXCJjb21wbGV4NjRcIj09PXQuZHR5cGUpcmV0dXJuIHQuY2xvbmUoKTt2YXIgcj1Hbih0LnNoYXBlKSxvPXQudG9GbG9hdCgpLGE9bi5jb21wbGV4KG8scik7cmV0dXJuIHIuZGlzcG9zZSgpLG8uZGlzcG9zZSgpLGF9aWYoIVUodC5kdHlwZSxlKSlyZXR1cm4gTHQubWFrZVRlbnNvckZyb21EYXRhSWQodC5kYXRhSWQsdC5zaGFwZSxlKTtpZihcImNvbXBsZXg2NFwiPT09dC5kdHlwZSl7dmFyIGk9bi5yZWFsKHQpO2E9aS5jYXN0KGUpO3JldHVybiBpLmRpc3Bvc2UoKSxhfWlmKFwiaW50MzJcIj09PWUpcmV0dXJuIG4uaW50KHQpO2lmKFwiYm9vbFwiPT09ZSl7dmFyIHM9T24oMCx0LmR0eXBlKTthPW4ubm90RXF1YWwodCxzKTtyZXR1cm4gcy5kaXNwb3NlKCksYX10aHJvdyBuZXcgRXJyb3IoXCJFcnJvciBpbiBDYXN0OiBmYWlsZWQgdG8gY2FzdCBcIit0LmR0eXBlK1wiIHRvIFwiK2UpfWZ1bmN0aW9uIExvKHQsZSl7cmV0dXJuIEx0Lm1ha2VUZW5zb3JGcm9tRGF0YUlkKHQuZGF0YUlkLGUsdC5kdHlwZSl9ZnVuY3Rpb24gV28odCxlLG4pe3ZhciByPShlLXQpLyhuLTEpLG89dHQobixcImZsb2F0MzJcIik7b1swXT10O2Zvcih2YXIgYT0xO2E8by5sZW5ndGg7YSsrKW9bYV09b1thLTFdK3I7cmV0dXJuIE1uKG8sXCJmbG9hdDMyXCIpfXZhciBVbz1PYmplY3QuZnJlZXplKHtjYXN0VGVuc29yOlBvLHJlc2hhcGVUZW5zb3I6TG8sbGluc3BhY2VJbXBsOldvLHVwY2FzdFR5cGU6RHQsYXhlc0FyZUlubmVyTW9zdERpbXM6eW4sY29tYmluZUxvY2F0aW9uczp4bixjb21wdXRlT3V0QW5kUmVkdWNlU2hhcGVzOmJuLGV4cGFuZFNoYXBlVG9LZWVwRGltOnduLGFzc2VydEF4ZXNBcmVJbm5lck1vc3REaW1zOkNuLGdldEF4ZXNQZXJtdXRhdGlvbjpFbixnZXRVbmRvQXhlc1Blcm11dGF0aW9uOlJuLGdldElubmVyTW9zdEF4ZXM6SW4sZ2V0QnJvYWRjYXN0RGltczpDbyxnZXRSZWR1Y3Rpb25BeGVzOkVvLGFzc2VydEFuZEdldEJyb2FkY2FzdFNoYXBlOlJvLGFzc2VydFBhcmFtc0NvbnNpc3RlbnQ6a24sY29tcHV0ZU91dFNoYXBlOlNuLGNvbXB1dGVQb29sMkRJbmZvOklvLGNvbXB1dGVQb29sM0RJbmZvOmtvLGNvbXB1dGVDb252MkRJbmZvOlNvLGNvbXB1dGVDb252M0RJbmZvOkFvLGNvbXB1dGVEZWZhdWx0UGFkOkRvLHR1cGxlVmFsdWVzQXJlT25lOk9vLGVpdGhlclN0cmlkZXNPckRpbGF0aW9uc0FyZU9uZTpNbyxjb252ZXJ0Q29udjJERGF0YUZvcm1hdDpCbyxQQVJBTExFTElaRV9USFJFU0hPTEQ6WXIsY29tcHV0ZU9wdGltYWxXaW5kb3dTaXplOiRyfSk7ZnVuY3Rpb24gVm8odCxlKXtpZih0Lmxlbmd0aCE9PWUubGVuZ3RoKXRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBtZXJnZSByZWFsIGFuZCBpbWFnIGFycmF5cyBvZiBkaWZmZXJlbnQgbGVuZ3Rocy4gcmVhbDpcIit0Lmxlbmd0aCtcIiwgaW1hZzogXCIrZS5sZW5ndGgrXCIuXCIpO2Zvcih2YXIgbj1uZXcgRmxvYXQzMkFycmF5KDIqdC5sZW5ndGgpLHI9MDtyPG4ubGVuZ3RoO3IrPTIpbltyXT10W3IvMl0sbltyKzFdPWVbci8yXTtyZXR1cm4gbn1mdW5jdGlvbiB6byh0LGUpe3JldHVybntyZWFsOnRbMiplXSxpbWFnOnRbMiplKzFdfX1mdW5jdGlvbiBHbyh0LGUsbixyKXt0WzIqcl09ZSx0WzIqcisxXT1ufWZ1bmN0aW9uIEhvKHQsZSxuKXt2YXIgcj0obj8yOi0yKSpNYXRoLlBJKih0L2UpO3JldHVybntyZWFsOk1hdGguY29zKHIpLGltYWc6TWF0aC5zaW4ocil9fWZ1bmN0aW9uIHFvKHQsZSxuKXt2YXIgcj1mdW5jdGlvbih0LGUsbil7cmV0dXJuIGZ1bmN0aW9uKHQsZSxuKXt2YXIgcj0wLG89dC5sZW5ndGgsYT0wLGk9ITE7Zm9yKDtyPG87KXt2YXIgcz1uKGUsdFthPXIrKG8tcj4+PjEpXSk7cz4wP3I9YSsxOihvPWEsaT0hcyl9cmV0dXJuIGk/cjotci0xfSh0LGUsbnx8S28pfSh0LGUsbiksbz1yPDA/LShyKzEpOnI7dC5zcGxpY2UobywwLGUpfWZ1bmN0aW9uIEtvKHQsZSl7cmV0dXJuIHQ+ZT8xOnQ8ZT8tMTowfWZ1bmN0aW9uIGpvKHQsZSxuLHIsbyl7cmV0dXJuIFlvKHQsZSxuLHIsbywwKS5zZWxlY3RlZEluZGljZXN9ZnVuY3Rpb24gWG8odCxlLG4scixvLGEpe3ZhciBpPVlvKHQsZSxuLHIsbyxhLCEwKTtyZXR1cm4gaS5udW1WYWxpZE91dHB1dHMuZGlzcG9zZSgpLHtzZWxlY3RlZEluZGljZXM6aS5zZWxlY3RlZEluZGljZXMsc2VsZWN0ZWRTY29yZXM6aS5zZWxlY3RlZFNjb3Jlc319ZnVuY3Rpb24gWW8odCxlLG4scixvLGEsaSxzKXt2b2lkIDA9PT1pJiYoaT0hMSksdm9pZCAwPT09cyYmKHM9ITEpO2Zvcih2YXIgdT1BcnJheS5mcm9tKGUpLm1hcCgoZnVuY3Rpb24odCxlKXtyZXR1cm57c2NvcmU6dCxib3hJbmRleDplLHN1cHByZXNzQmVnaW5JbmRleDowfX0pKS5maWx0ZXIoKGZ1bmN0aW9uKHQpe3JldHVybiB0LnNjb3JlPm99KSkuc29ydChKbyksYz1hPjA/LS41L2E6MCxsPVtdLGg9W107bC5sZW5ndGg8biYmdS5sZW5ndGg+MDspe3ZhciBmPXUucG9wKCksZD1mLnNjb3JlLHA9Zi5ib3hJbmRleCx2PWYuc3VwcHJlc3NCZWdpbkluZGV4O2lmKGQ8bylicmVhaztmb3IodmFyIG09ITEsZz1sLmxlbmd0aC0xO2c+PXY7LS1nKXt2YXIgeT0kbyh0LHAsbFtnXSk7aWYoeT49cil7bT0hMDticmVha31pZihmLnNjb3JlPWYuc2NvcmUqUW8ocixjLHkpLGYuc2NvcmU8PW8pYnJlYWt9Zi5zdXBwcmVzc0JlZ2luSW5kZXg9bC5sZW5ndGgsbXx8KGYuc2NvcmU9PT1kPyhsLnB1c2gocCksaC5wdXNoKGYuc2NvcmUpKTpmLnNjb3JlPm8mJnFvKHUsZixKbykpfXZhciB4PWwubGVuZ3RoO3JldHVybiBzJiYobC5maWxsKDAseCksaC5maWxsKDAseCkpLHtzZWxlY3RlZEluZGljZXM6TW4obCxcImludDMyXCIpLHNlbGVjdGVkU2NvcmVzOk1uKGgsXCJmbG9hdDMyXCIpLG51bVZhbGlkT3V0cHV0czpPbih4LFwiaW50MzJcIil9fWZ1bmN0aW9uICRvKHQsZSxuKXt2YXIgcj10LnN1YmFycmF5KDQqZSw0KmUrNCksbz10LnN1YmFycmF5KDQqbiw0Km4rNCksYT1NYXRoLm1pbihyWzBdLHJbMl0pLGk9TWF0aC5taW4oclsxXSxyWzNdKSxzPU1hdGgubWF4KHJbMF0sclsyXSksdT1NYXRoLm1heChyWzFdLHJbM10pLGM9TWF0aC5taW4ob1swXSxvWzJdKSxsPU1hdGgubWluKG9bMV0sb1szXSksaD1NYXRoLm1heChvWzBdLG9bMl0pLGY9TWF0aC5tYXgob1sxXSxvWzNdKSxkPShzLWEpKih1LWkpLHA9KGgtYykqKGYtbCk7aWYoZDw9MHx8cDw9MClyZXR1cm4gMDt2YXIgdj1NYXRoLm1heChhLGMpLG09TWF0aC5tYXgoaSxsKSxnPU1hdGgubWluKHMsaCkseT1NYXRoLm1pbih1LGYpLHg9TWF0aC5tYXgoZy12LDApKk1hdGgubWF4KHktbSwwKTtyZXR1cm4geC8oZCtwLXgpfWZ1bmN0aW9uIFFvKHQsZSxuKXt2YXIgcj1NYXRoLmV4cChlKm4qbik7cmV0dXJuIG48PXQ/cjowfWZ1bmN0aW9uIEpvKHQsZSl7cmV0dXJuIHQuc2NvcmUtZS5zY29yZXx8dC5zY29yZT09PWUuc2NvcmUmJmUuYm94SW5kZXgtdC5ib3hJbmRleH1mdW5jdGlvbiBabyh0LGUsbil7dmFyIHI9bmV3IEFycmF5KHQucmFuaykuZmlsbCgwKSxvPXQuc2hhcGUuc2xpY2UoKTtyZXR1cm4gZS5tYXAoKGZ1bmN0aW9uKGUpe29bbl09ZTt2YXIgYT10LnNsaWNlKHIsbyk7cmV0dXJuIHJbbl0rPWUsYX0pKX1mdW5jdGlvbiB0YSh0LGUpe2Zvcih2YXIgbj1uZXcgQXJyYXkodC5yYW5rKSxyPTA7cjxuLmxlbmd0aDtyKyspbltyXT10LnNoYXBlW3JdKmVbcl07dmFyIG89ZHIobix0LmR0eXBlKTtmb3Iocj0wO3I8by52YWx1ZXMubGVuZ3RoOysrcil7Zm9yKHZhciBhPW8uaW5kZXhUb0xvYyhyKSxpPW5ldyBBcnJheSh0LnJhbmspLHM9MDtzPGkubGVuZ3RoO3MrKylpW3NdPWFbc10ldC5zaGFwZVtzXTt2YXIgdT10LmxvY1RvSW5kZXgoaSk7by52YWx1ZXNbcl09dC52YWx1ZXNbdV19cmV0dXJuIG8udG9UZW5zb3IoKX1mdW5jdGlvbiBlYSh0LGUsbixyLG8pe2Zvcih2YXIgYT1lW2UubGVuZ3RoLTFdLGk9W3QubGVuZ3RoL2EsYV0scz1pWzBdLHU9aVsxXSxjPUIobixzKnIpLGw9QihcImludDMyXCIscypyKSxoPTA7aDxzO2grKyl7Zm9yKHZhciBmPWgqdSxkPXQuc3ViYXJyYXkoZixmK3UpLHA9W10sdj0wO3Y8ZC5sZW5ndGg7disrKXAucHVzaCh7dmFsdWU6ZFt2XSxpbmRleDp2fSk7cC5zb3J0KChmdW5jdGlvbih0LGUpe3JldHVybiBlLnZhbHVlLXQudmFsdWV9KSk7dmFyIG09aCpyLGc9Yy5zdWJhcnJheShtLG0rcikseT1sLnN1YmFycmF5KG0sbStyKTtmb3Iodj0wO3Y8cjt2KyspZ1t2XT1wW3ZdLnZhbHVlLHlbdl09cFt2XS5pbmRleH12YXIgeD1lLnNsaWNlKCk7cmV0dXJuIHhbeC5sZW5ndGgtMV09cixbRm4oYyx4LG4pLEZuKGwseCxcImludDMyXCIpXX1mdW5jdGlvbiBuYSh0LGUpe2Zvcih2YXIgbj1bXSxyPTA7cjxlLmxlbmd0aDtyKyspZVtyXSYmbi5wdXNoKHIpO3ZhciBvPWRyKHQsXCJpbnQzMlwiKSxhPWRyKFtuLmxlbmd0aCx0Lmxlbmd0aF0sXCJpbnQzMlwiKTtmb3Iocj0wO3I8bi5sZW5ndGg7cisrKXt2YXIgaT1vLmluZGV4VG9Mb2MobltyXSkscz1yKnQubGVuZ3RoO2EudmFsdWVzLnNldChpLHMpfXJldHVybiBhLnRvVGVuc29yKCl9dmFyIHJhPWZ1bmN0aW9uKHQsZSl7dGhpcy5vdXRwdXRTaGFwZT1bXSx0aGlzLm91dHB1dFNoYXBlPXQsdGhpcy52YXJpYWJsZU5hbWVzPWUubWFwKChmdW5jdGlvbih0LGUpe3JldHVyblwiVFwiK2V9KSk7dmFyIG49W107dGhpcy52YXJpYWJsZU5hbWVzLmZvckVhY2goKGZ1bmN0aW9uKHQpe24ucHVzaChcImZsb2F0IHZcIit0K1wiID0gZ2V0XCIrdCtcIkF0T3V0Q29vcmRzKCk7XCIpfSkpO3ZhciByPXRoaXMudmFyaWFibGVOYW1lcy5tYXAoKGZ1bmN0aW9uKHQpe3JldHVyblwidlwiK3R9KSkuam9pbihcIiArIFwiKTt0aGlzLnVzZXJDb2RlPVwiXFxuICAgICAgdm9pZCBtYWluKCkge1xcbiAgICAgICAgXCIrbi5qb2luKFwiXFxuICAgICAgICBcIikrXCJcXG5cXG4gICAgICAgIGZsb2F0IHJlc3VsdCA9IFwiK3IrXCI7XFxuICAgICAgICBzZXRPdXRwdXQocmVzdWx0KTtcXG4gICAgICB9XFxuICAgIFwifSxvYT1mdW5jdGlvbih0LGUpe3RoaXMub3V0cHV0U2hhcGU9W10sdGhpcy5wYWNrZWRJbnB1dHM9ITAsdGhpcy5wYWNrZWRPdXRwdXQ9ITAsdGhpcy5vdXRwdXRTaGFwZT10LHRoaXMudmFyaWFibGVOYW1lcz1lLm1hcCgoZnVuY3Rpb24odCxlKXtyZXR1cm5cIlRcIitlfSkpO3ZhciBuPVtdO3RoaXMudmFyaWFibGVOYW1lcy5mb3JFYWNoKChmdW5jdGlvbih0KXtuLnB1c2goXCJ2ZWM0IHZcIit0K1wiID0gZ2V0XCIrdCtcIkF0T3V0Q29vcmRzKCk7XCIpfSkpO3ZhciByPXRoaXMudmFyaWFibGVOYW1lcy5tYXAoKGZ1bmN0aW9uKHQpe3JldHVyblwidlwiK3R9KSkuam9pbihcIiArIFwiKTt0aGlzLnVzZXJDb2RlPVwiXFxuICAgICAgdm9pZCBtYWluKCkge1xcbiAgICAgICAgXCIrbi5qb2luKFwiXFxuICAgICAgICBcIikrXCJcXG5cXG4gICAgICAgIHZlYzQgcmVzdWx0ID0gXCIrcitcIjtcXG4gICAgICAgIHNldE91dHB1dChyZXN1bHQpO1xcbiAgICAgIH1cXG4gICAgXCJ9LGFhPWZ1bmN0aW9uKHQsZSxuKXt0aGlzLnZhcmlhYmxlTmFtZXM9W1wiQVwiXTt2YXIgcj10LndpbmRvd1NpemUsbz10LmJhdGNoU2l6ZSxhPXQuaW5TaXplLGk9TWF0aC5jZWlsKGEvcik7bnx8dGhpcy52YXJpYWJsZU5hbWVzLnB1c2goXCJiZXN0SW5kaWNlc0FcIiksdGhpcy5vdXRwdXRTaGFwZT1bbyxpXTt2YXIgcz1cIm1heFwiPT09ZT9cIj5cIjpcIjxcIix1PW4/XCJpbk9mZnNldCArIGk7XCI6XCJyb3VuZChnZXRCZXN0SW5kaWNlc0EoYmF0Y2gsIGluT2Zmc2V0ICsgaSkpO1wiO3RoaXMudXNlckNvZGU9XCJcXG4gICAgICB2b2lkIG1haW4oKSB7XFxuICAgICAgICBpdmVjMiBjb29yZHMgPSBnZXRPdXRwdXRDb29yZHMoKTtcXG4gICAgICAgIGludCBiYXRjaCA9IGNvb3Jkc1swXTtcXG4gICAgICAgIGludCBvdXRJZHggPSBjb29yZHNbMV07XFxuICAgICAgICBpbnQgaW5PZmZzZXQgPSBvdXRJZHggKiBcIityK1wiO1xcblxcbiAgICAgICAgaW50IGJlc3RJbmRleCA9IGluT2Zmc2V0O1xcbiAgICAgICAgZmxvYXQgYmVzdFZhbHVlID0gZ2V0QShiYXRjaCwgYmVzdEluZGV4KTtcXG5cXG4gICAgICAgIGZvciAoaW50IGkgPSAwOyBpIDwgXCIrcitcIjsgaSsrKSB7XFxuICAgICAgICAgIGludCBpbklkeCA9IFwiK3UrXCI7XFxuICAgICAgICAgIGZsb2F0IGNhbmRpZGF0ZSA9IGdldEEoYmF0Y2gsIGluSWR4KTtcXG4gICAgICAgICAgaWYgKGNhbmRpZGF0ZSBcIitzK1wiIGJlc3RWYWx1ZSkge1xcbiAgICAgICAgICAgIGJlc3RWYWx1ZSA9IGNhbmRpZGF0ZTtcXG4gICAgICAgICAgICBiZXN0SW5kZXggPSBpbklkeDtcXG4gICAgICAgICAgfVxcbiAgICAgICAgfVxcbiAgICAgICAgc2V0T3V0cHV0KGZsb2F0KGJlc3RJbmRleCkpO1xcbiAgICAgIH1cXG4gICAgXCJ9O2Z1bmN0aW9uIGlhKHQsZSl7cmV0dXJuW1wieFwiLFwieVwiLFwielwiLFwid1wiLFwidVwiLFwidlwiXS5zbGljZSgwLGUpLm1hcCgoZnVuY3Rpb24oZSl7cmV0dXJuIHQrXCIuXCIrZX0pKX1mdW5jdGlvbiBzYSh0LGUpe3JldHVybiAxPT09ZT9bdF06aWEodCxlKX1mdW5jdGlvbiB1YSgpe3ZhciB0LGUsbixyLG8sYSxzLHUsYyxsO3JldHVybiAyPT09aSgpLmdldE51bWJlcihcIldFQkdMX1ZFUlNJT05cIik/KHQ9XCIjdmVyc2lvbiAzMDAgZXNcIixlPVwiaW5cIixuPVwib3V0XCIscj1cImluXCIsbz1cInRleHR1cmVcIixhPVwib3V0cHV0Q29sb3JcIixzPVwib3V0IHZlYzQgb3V0cHV0Q29sb3I7XCIsdT1cIlxcbiAgICAgIGJvb2wgaXNuYW5fY3VzdG9tKGZsb2F0IHZhbCkge1xcbiAgICAgICAgcmV0dXJuICh2YWwgPiAwLjAgfHwgdmFsIDwgMC4wKSA/IGZhbHNlIDogdmFsICE9IDAuMDtcXG4gICAgICB9XFxuXFxuICAgICAgYnZlYzQgaXNuYW5fY3VzdG9tKHZlYzQgdmFsKSB7XFxuICAgICAgICByZXR1cm4gYnZlYzQoaXNuYW5fY3VzdG9tKHZhbC54KSxcXG4gICAgICAgICAgaXNuYW5fY3VzdG9tKHZhbC55KSwgaXNuYW5fY3VzdG9tKHZhbC56KSwgaXNuYW5fY3VzdG9tKHZhbC53KSk7XFxuICAgICAgfVxcblxcbiAgICAgICNkZWZpbmUgaXNuYW4odmFsdWUpIGlzbmFuX2N1c3RvbSh2YWx1ZSlcXG4gICAgXCIsYz1cIlwiLGw9XCJcXG4gICAgICAjZGVmaW5lIHJvdW5kKHZhbHVlKSBuZXdSb3VuZCh2YWx1ZSlcXG4gICAgICBpbnQgbmV3Um91bmQoZmxvYXQgdmFsdWUpIHtcXG4gICAgICAgIHJldHVybiBpbnQoZmxvb3IodmFsdWUgKyAwLjUpKTtcXG4gICAgICB9XFxuXFxuICAgICAgaXZlYzQgbmV3Um91bmQodmVjNCB2YWx1ZSkge1xcbiAgICAgICAgcmV0dXJuIGl2ZWM0KGZsb29yKHZhbHVlICsgdmVjNCgwLjUpKSk7XFxuICAgICAgfVxcbiAgICBcIik6KHQ9XCJcIixlPVwiYXR0cmlidXRlXCIsbj1cInZhcnlpbmdcIixyPVwidmFyeWluZ1wiLG89XCJ0ZXh0dXJlMkRcIixhPVwiZ2xfRnJhZ0NvbG9yXCIscz1cIlwiLHU9XCJcXG4gICAgICAjZGVmaW5lIGlzbmFuKHZhbHVlKSBpc25hbl9jdXN0b20odmFsdWUpXFxuICAgICAgYm9vbCBpc25hbl9jdXN0b20oZmxvYXQgdmFsKSB7XFxuICAgICAgICByZXR1cm4gKHZhbCA+IDAuIHx8IHZhbCA8IDEuIHx8IHZhbCA9PSAwLikgPyBmYWxzZSA6IHRydWU7XFxuICAgICAgfVxcbiAgICAgIGJ2ZWM0IGlzbmFuX2N1c3RvbSh2ZWM0IHZhbCkge1xcbiAgICAgICAgcmV0dXJuIGJ2ZWM0KGlzbmFuKHZhbC54KSwgaXNuYW4odmFsLnkpLCBpc25hbih2YWwueiksIGlzbmFuKHZhbC53KSk7XFxuICAgICAgfVxcbiAgICBcIixjPVwiXFxuICAgICAgdW5pZm9ybSBmbG9hdCBJTkZJTklUWTtcXG5cXG4gICAgICBib29sIGlzaW5mKGZsb2F0IHZhbCkge1xcbiAgICAgICAgcmV0dXJuIGFicyh2YWwpID09IElORklOSVRZO1xcbiAgICAgIH1cXG4gICAgICBidmVjNCBpc2luZih2ZWM0IHZhbCkge1xcbiAgICAgICAgcmV0dXJuIGVxdWFsKGFicyh2YWwpLCB2ZWM0KElORklOSVRZKSk7XFxuICAgICAgfVxcbiAgICBcIixsPVwiXFxuICAgICAgaW50IHJvdW5kKGZsb2F0IHZhbHVlKSB7XFxuICAgICAgICByZXR1cm4gaW50KGZsb29yKHZhbHVlICsgMC41KSk7XFxuICAgICAgfVxcblxcbiAgICAgIGl2ZWM0IHJvdW5kKHZlYzQgdmFsdWUpIHtcXG4gICAgICAgIHJldHVybiBpdmVjNChmbG9vcih2YWx1ZSArIHZlYzQoMC41KSkpO1xcbiAgICAgIH1cXG4gICAgXCIpLHt2ZXJzaW9uOnQsYXR0cmlidXRlOmUsdmFyeWluZ1ZzOm4sdmFyeWluZ0ZzOnIsdGV4dHVyZTJEOm8sb3V0cHV0OmEsZGVmaW5lT3V0cHV0OnMsZGVmaW5lU3BlY2lhbE5hTjp1LGRlZmluZVNwZWNpYWxJbmY6YyxkZWZpbmVSb3VuZDpsfX1mdW5jdGlvbiBjYSh0LGUsbil7dm9pZCAwPT09biYmKG49XCJpbmRleFwiKTt2YXIgcj0kKGUpO3JldHVybiByLm1hcCgoZnVuY3Rpb24oZSxvKXtyZXR1cm5cImludCBcIit0W29dK1wiID0gXCIrbitcIiAvIFwiK2UrXCI7IFwiKyhvPT09ci5sZW5ndGgtMT9cImludCBcIit0W28rMV0rXCIgPSBcIituK1wiIC0gXCIrdFtvXStcIiAqIFwiK2U6XCJpbmRleCAtPSBcIit0W29dK1wiICogXCIrZSkrXCI7XCJ9KSkuam9pbihcIlwiKX1mdW5jdGlvbiBsYSh0KXt2YXIgZT0kKHQpLm1hcCgoZnVuY3Rpb24odCl7cmV0dXJuIHQudG9TdHJpbmcoKX0pKTtyZXR1cm5cIlxcbiAgaW50IGdldEZsYXRJbmRleChpdmVjMyBjb29yZHMpIHtcXG4gICAgcmV0dXJuIGNvb3Jkcy54ICogXCIrZVswXStcIiArIGNvb3Jkcy55ICogXCIrZVsxXStcIiArIGNvb3Jkcy56O1xcbiAgfVxcblwifXZhciBoYT1cIlxcbiAgY29uc3QgZmxvYXQgRkxPQVRfTUFYID0gMS43MDE0MTE4NGUzODtcXG4gIGNvbnN0IGZsb2F0IEZMT0FUX01JTiA9IDEuMTc1NDk0MzVlLTM4O1xcblxcbiAgbG93cCB2ZWM0IGVuY29kZV9mbG9hdChoaWdocCBmbG9hdCB2KSB7XFxuICAgIGlmIChpc25hbih2KSkge1xcbiAgICAgIHJldHVybiB2ZWM0KDI1NSwgMjU1LCAyNTUsIDI1NSk7XFxuICAgIH1cXG5cXG4gICAgaGlnaHAgZmxvYXQgYXYgPSBhYnModik7XFxuXFxuICAgIGlmKGF2IDwgRkxPQVRfTUlOKSB7XFxuICAgICAgcmV0dXJuIHZlYzQoMC4wLCAwLjAsIDAuMCwgMC4wKTtcXG4gICAgfSBlbHNlIGlmKHYgPiBGTE9BVF9NQVgpIHtcXG4gICAgICByZXR1cm4gdmVjNCgwLjAsIDAuMCwgMTI4LjAsIDEyNy4wKSAvIDI1NS4wO1xcbiAgICB9IGVsc2UgaWYodiA8IC1GTE9BVF9NQVgpIHtcXG4gICAgICByZXR1cm4gdmVjNCgwLjAsIDAuMCwgIDEyOC4wLCAyNTUuMCkgLyAyNTUuMDtcXG4gICAgfVxcblxcbiAgICBoaWdocCB2ZWM0IGMgPSB2ZWM0KDAsMCwwLDApO1xcblxcbiAgICBoaWdocCBmbG9hdCBlID0gZmxvb3IobG9nMihhdikpO1xcbiAgICBoaWdocCBmbG9hdCBtID0gZXhwMihmcmFjdChsb2cyKGF2KSkpIC0gMS4wO1xcblxcbiAgICBjWzJdID0gZmxvb3IoMTI4LjAgKiBtKTtcXG4gICAgbSAtPSBjWzJdIC8gMTI4LjA7XFxuICAgIGNbMV0gPSBmbG9vcigzMjc2OC4wICogbSk7XFxuICAgIG0gLT0gY1sxXSAvIDMyNzY4LjA7XFxuICAgIGNbMF0gPSBmbG9vcig4Mzg4NjA4LjAgKiBtKTtcXG5cXG4gICAgaGlnaHAgZmxvYXQgZWJpYXMgPSBlICsgMTI3LjA7XFxuICAgIGNbM10gPSBmbG9vcihlYmlhcyAvIDIuMCk7XFxuICAgIGViaWFzIC09IGNbM10gKiAyLjA7XFxuICAgIGNbMl0gKz0gZmxvb3IoZWJpYXMpICogMTI4LjA7XFxuXFxuICAgIGNbM10gKz0gMTI4LjAgKiBzdGVwKDAuMCwgLXYpO1xcblxcbiAgICByZXR1cm4gYyAvIDI1NS4wO1xcbiAgfVxcblwiO2Z1bmN0aW9uIGZhKHQsZSxuLHIpe3ZhciBvPVtdO3QuZm9yRWFjaCgoZnVuY3Rpb24odCl7dmFyIGU9ayh0LnNoYXBlSW5mby5sb2dpY2FsU2hhcGUpO3Quc2hhcGVJbmZvLmlzVW5pZm9ybT9vLnB1c2goXCJ1bmlmb3JtIGZsb2F0IFwiK3QubmFtZSsoZT4xP1wiW1wiK2UrXCJdXCI6XCJcIikrXCI7XCIpOihvLnB1c2goXCJ1bmlmb3JtIHNhbXBsZXIyRCBcIit0Lm5hbWUrXCI7XCIpLG8ucHVzaChcInVuaWZvcm0gaW50IG9mZnNldFwiK3QubmFtZStcIjtcIikpfSkpO3ZhciBhLGkscz1vLmpvaW4oXCJcXG5cIiksdT10Lm1hcCgoZnVuY3Rpb24odCl7cmV0dXJuIGZ1bmN0aW9uKHQsZSxuKXt2b2lkIDA9PT1uJiYobj0hMSk7dmFyIHI9XCJcIjtyKz1uP3BhKHQpOmRhKHQpO3ZhciBvPXQuc2hhcGVJbmZvLmxvZ2ljYWxTaGFwZSxhPWUubG9naWNhbFNoYXBlO28ubGVuZ3RoPD1hLmxlbmd0aCYmKHIrPW4/ZnVuY3Rpb24odCxlKXt2YXIgbixyPXQubmFtZSxvPXIuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkrci5zbGljZSgxKSxhPVwiZ2V0XCIrbytcIkF0T3V0Q29vcmRzXCIsaT10LnNoYXBlSW5mby5sb2dpY2FsU2hhcGUubGVuZ3RoLHM9ZS5sb2dpY2FsU2hhcGUubGVuZ3RoLHU9Q28odC5zaGFwZUluZm8ubG9naWNhbFNoYXBlLGUubG9naWNhbFNoYXBlKSxjPXdhKHMpLGw9cy1pLGg9W1wieFwiLFwieVwiLFwielwiLFwid1wiLFwidVwiLFwidlwiXTtuPTA9PT1pP1wiXCI6czwyJiZ1Lmxlbmd0aD49MT9cImNvb3JkcyA9IDA7XCI6dS5tYXAoKGZ1bmN0aW9uKHQpe3JldHVyblwiY29vcmRzLlwiK2hbdCtsXStcIiA9IDA7XCJ9KSkuam9pbihcIlxcblwiKTt2YXIgZj1cIlwiO2Y9czwyJiZpPjA/XCJjb29yZHNcIjp0LnNoYXBlSW5mby5sb2dpY2FsU2hhcGUubWFwKChmdW5jdGlvbih0LGUpe3JldHVyblwiY29vcmRzLlwiK2hbZStsXX0pKS5qb2luKFwiLCBcIik7dmFyIGQ9XCJyZXR1cm4gb3V0cHV0VmFsdWU7XCIscD0xPT09ayh0LnNoYXBlSW5mby5sb2dpY2FsU2hhcGUpLHY9MT09PWsoZS5sb2dpY2FsU2hhcGUpO2lmKDEhPT1pfHxwfHx2KXtpZihwJiYhdilkPTE9PT1zP1wiXFxuICAgICAgICByZXR1cm4gdmVjNChvdXRwdXRWYWx1ZS54LCBvdXRwdXRWYWx1ZS54LCAwLiwgMC4pO1xcbiAgICAgIFwiOlwiXFxuICAgICAgICByZXR1cm4gdmVjNChvdXRwdXRWYWx1ZS54KTtcXG4gICAgICBcIjtlbHNlIGlmKHUubGVuZ3RoKXt2YXIgbT1pLTIsZz1pLTE7dS5pbmRleE9mKG0pPi0xJiZ1LmluZGV4T2YoZyk+LTE/ZD1cInJldHVybiB2ZWM0KG91dHB1dFZhbHVlLngpO1wiOnUuaW5kZXhPZihtKT4tMT9kPVwicmV0dXJuIHZlYzQob3V0cHV0VmFsdWUueCwgb3V0cHV0VmFsdWUueSwgb3V0cHV0VmFsdWUueCwgb3V0cHV0VmFsdWUueSk7XCI6dS5pbmRleE9mKGcpPi0xJiYoZD1cInJldHVybiB2ZWM0KG91dHB1dFZhbHVlLnh4LCBvdXRwdXRWYWx1ZS56eik7XCIpfX1lbHNlIGQ9XCJcXG4gICAgICByZXR1cm4gdmVjNChvdXRwdXRWYWx1ZS54eSwgb3V0cHV0VmFsdWUueHkpO1xcbiAgICBcIjtyZXR1cm5cIlxcbiAgICB2ZWM0IFwiK2ErXCIoKSB7XFxuICAgICAgXCIrYytcIiBjb29yZHMgPSBnZXRPdXRwdXRDb29yZHMoKTtcXG4gICAgICBcIituK1wiXFxuICAgICAgdmVjNCBvdXRwdXRWYWx1ZSA9IGdldFwiK28rXCIoXCIrZitcIik7XFxuICAgICAgXCIrZCtcIlxcbiAgICB9XFxuICBcIn0odCxlKTpmdW5jdGlvbih0LGUpe3ZhciBuPXQubmFtZSxyPW4uY2hhckF0KDApLnRvVXBwZXJDYXNlKCkrbi5zbGljZSgxKSxvPVwiZ2V0XCIrcitcIkF0T3V0Q29vcmRzXCIsYT1lLnRleFNoYXBlLGk9dC5zaGFwZUluZm8udGV4U2hhcGUscz10LnNoYXBlSW5mby5sb2dpY2FsU2hhcGUubGVuZ3RoLHU9ZS5sb2dpY2FsU2hhcGUubGVuZ3RoO2lmKCF0LnNoYXBlSW5mby5pc1VuaWZvcm0mJnM9PT11JiZudWxsPT10LnNoYXBlSW5mby5mbGF0T2Zmc2V0JiZTKGksYSkpcmV0dXJuXCJcXG4gICAgICBmbG9hdCBcIitvK1wiKCkge1xcbiAgICAgICAgcmV0dXJuIHNhbXBsZVRleHR1cmUoXCIrbitcIiwgcmVzdWx0VVYpO1xcbiAgICAgIH1cXG4gICAgXCI7dmFyIGMsbD13YSh1KSxoPUNvKHQuc2hhcGVJbmZvLmxvZ2ljYWxTaGFwZSxlLmxvZ2ljYWxTaGFwZSksZj11LXMsZD1bXCJ4XCIsXCJ5XCIsXCJ6XCIsXCJ3XCIsXCJ1XCIsXCJ2XCJdO2M9MD09PXM/XCJcIjp1PDImJmgubGVuZ3RoPj0xP1wiY29vcmRzID0gMDtcIjpoLm1hcCgoZnVuY3Rpb24odCl7cmV0dXJuXCJjb29yZHMuXCIrZFt0K2ZdK1wiID0gMDtcIn0pKS5qb2luKFwiXFxuXCIpO3ZhciBwPVwiXCI7cD11PDImJnM+MD9cImNvb3Jkc1wiOnQuc2hhcGVJbmZvLmxvZ2ljYWxTaGFwZS5tYXAoKGZ1bmN0aW9uKHQsZSl7cmV0dXJuXCJjb29yZHMuXCIrZFtlK2ZdfSkpLmpvaW4oXCIsIFwiKTtyZXR1cm5cIlxcbiAgICBmbG9hdCBcIitvK1wiKCkge1xcbiAgICAgIFwiK2wrXCIgY29vcmRzID0gZ2V0T3V0cHV0Q29vcmRzKCk7XFxuICAgICAgXCIrYytcIlxcbiAgICAgIHJldHVybiBnZXRcIityK1wiKFwiK3ArXCIpO1xcbiAgICB9XFxuICBcIn0odCxlKSk7cmV0dXJuIHJ9KHQsZSxyKX0pKS5qb2luKFwiXFxuXCIpLGM9ZS50ZXhTaGFwZSxsPXVhKCksaD1mdW5jdGlvbih0KXtyZXR1cm5cIlxcbiAgICBmbG9hdCBzYW1wbGVUZXh0dXJlKHNhbXBsZXIyRCB0ZXh0dXJlU2FtcGxlciwgdmVjMiB1dikge1xcbiAgICAgIHJldHVybiBcIit0LnRleHR1cmUyRCtcIih0ZXh0dXJlU2FtcGxlciwgdXYpLnI7XFxuICAgIH1cXG4gIFwifShsKSxmPWZ1bmN0aW9uKHQpe3JldHVybiB0LnZlcnNpb24rXCJcXG4gICAgcHJlY2lzaW9uIGhpZ2hwIGZsb2F0O1xcbiAgICBwcmVjaXNpb24gaGlnaHAgaW50O1xcbiAgICBwcmVjaXNpb24gaGlnaHAgc2FtcGxlcjJEO1xcbiAgICBcIit0LnZhcnlpbmdGcytcIiB2ZWMyIHJlc3VsdFVWO1xcbiAgICBcIit0LmRlZmluZU91dHB1dCtcIlxcbiAgICBjb25zdCB2ZWMyIGhhbGZDUiA9IHZlYzIoMC41LCAwLjUpO1xcblxcbiAgICBzdHJ1Y3QgaXZlYzVcXG4gICAge1xcbiAgICAgIGludCB4O1xcbiAgICAgIGludCB5O1xcbiAgICAgIGludCB6O1xcbiAgICAgIGludCB3O1xcbiAgICAgIGludCB1O1xcbiAgICB9O1xcblxcbiAgICBzdHJ1Y3QgaXZlYzZcXG4gICAge1xcbiAgICAgIGludCB4O1xcbiAgICAgIGludCB5O1xcbiAgICAgIGludCB6O1xcbiAgICAgIGludCB3O1xcbiAgICAgIGludCB1O1xcbiAgICAgIGludCB2O1xcbiAgICB9O1xcblxcbiAgICB1bmlmb3JtIGZsb2F0IE5BTjtcXG4gICAgXCIrdC5kZWZpbmVTcGVjaWFsTmFOK1wiXFxuICAgIFwiK3QuZGVmaW5lU3BlY2lhbEluZitcIlxcbiAgICBcIit0LmRlZmluZVJvdW5kK1wiXFxuXFxuICAgIGludCBpbW9kKGludCB4LCBpbnQgeSkge1xcbiAgICAgIHJldHVybiB4IC0geSAqICh4IC8geSk7XFxuICAgIH1cXG5cXG4gICAgaW50IGlkaXYoaW50IGEsIGludCBiLCBmbG9hdCBzaWduKSB7XFxuICAgICAgaW50IHJlcyA9IGEgLyBiO1xcbiAgICAgIGludCBtb2QgPSBpbW9kKGEsIGIpO1xcbiAgICAgIGlmIChzaWduIDwgMC4gJiYgbW9kICE9IDApIHtcXG4gICAgICAgIHJlcyAtPSAxO1xcbiAgICAgIH1cXG4gICAgICByZXR1cm4gcmVzO1xcbiAgICB9XFxuXFxuICAgIC8vQmFzZWQgb24gdGhlIHdvcmsgb2YgRGF2ZSBIb3NraW5zXFxuICAgIC8vaHR0cHM6Ly93d3cuc2hhZGVydG95LmNvbS92aWV3LzRkalNSV1xcbiAgICAjZGVmaW5lIEhBU0hTQ0FMRTEgNDQzLjg5NzVcXG4gICAgZmxvYXQgcmFuZG9tKGZsb2F0IHNlZWQpe1xcbiAgICAgIHZlYzIgcCA9IHJlc3VsdFVWICogc2VlZDtcXG4gICAgICB2ZWMzIHAzICA9IGZyYWN0KHZlYzMocC54eXgpICogSEFTSFNDQUxFMSk7XFxuICAgICAgcDMgKz0gZG90KHAzLCBwMy55enggKyAxOS4xOSk7XFxuICAgICAgcmV0dXJuIGZyYWN0KChwMy54ICsgcDMueSkgKiBwMy56KTtcXG4gICAgfVxcblxcbiAgICBcIit2YStcIlxcbiAgICBcIittYStcIlxcbiAgICBcIitnYStcIlxcbiAgXCJ9KGwpO3JldHVybiBlLmlzUGFja2VkPyhhPWZ1bmN0aW9uKHQsZSl7c3dpdGNoKHQubGVuZ3RoKXtjYXNlIDA6cmV0dXJuXCJcXG4gICAgaW50IGdldE91dHB1dENvb3JkcygpIHtcXG4gICAgICByZXR1cm4gMDtcXG4gICAgfVxcbiAgXCI7Y2FzZSAxOnJldHVybiBmdW5jdGlvbih0LGUpe3ZhciBuPVtNYXRoLmNlaWwoZVswXS8yKSxNYXRoLmNlaWwoZVsxXS8yKV07aWYoMT09PW5bMF0pcmV0dXJuXCJcXG4gICAgICBpbnQgZ2V0T3V0cHV0Q29vcmRzKCkge1xcbiAgICAgICAgcmV0dXJuIDIgKiBpbnQocmVzdWx0VVYueCAqIFwiK25bMV0rXCIuMCk7XFxuICAgICAgfVxcbiAgICBcIjtpZigxPT09blsxXSlyZXR1cm5cIlxcbiAgICAgIGludCBnZXRPdXRwdXRDb29yZHMoKSB7XFxuICAgICAgICByZXR1cm4gMiAqIGludChyZXN1bHRVVi55ICogXCIrblswXStcIi4wKTtcXG4gICAgICB9XFxuICAgIFwiO3JldHVyblwiXFxuICAgIGludCBnZXRPdXRwdXRDb29yZHMoKSB7XFxuICAgICAgaXZlYzIgcmVzVGV4UkMgPSBpdmVjMihyZXN1bHRVVi55eCAqXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2ZWMyKFwiK25bMF0rXCIsIFwiK25bMV0rXCIpKTtcXG4gICAgICByZXR1cm4gMiAqIChyZXNUZXhSQy54ICogXCIrblsxXStcIiArIHJlc1RleFJDLnkpO1xcbiAgICB9XFxuICBcIn0oMCxlKTtjYXNlIDI6cmV0dXJuIGZ1bmN0aW9uKHQsZSl7dmFyIG49W01hdGguY2VpbChlWzBdLzIpLE1hdGguY2VpbChlWzFdLzIpXTtpZihTKHQsZSkpcmV0dXJuXCJcXG4gICAgICBpdmVjMiBnZXRPdXRwdXRDb29yZHMoKSB7XFxuICAgICAgICByZXR1cm4gMiAqIGl2ZWMyKHJlc3VsdFVWLnl4ICogdmVjMihcIituWzBdK1wiLCBcIituWzFdK1wiKSk7XFxuICAgICAgfVxcbiAgICBcIjt2YXIgcj1NYXRoLmNlaWwodFsxXS8yKTtyZXR1cm5cIlxcbiAgICBpdmVjMiBnZXRPdXRwdXRDb29yZHMoKSB7XFxuICAgICAgaXZlYzIgcmVzVGV4UkMgPSBpdmVjMihyZXN1bHRVVi55eCAqXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2ZWMyKFwiK25bMF0rXCIsIFwiK25bMV0rXCIpKTtcXG5cXG4gICAgICBpbnQgaW5kZXggPSByZXNUZXhSQy54ICogXCIrblsxXStcIiArIHJlc1RleFJDLnk7XFxuICAgICAgaW50IHIgPSAyICogKGluZGV4IC8gXCIrcitcIik7XFxuICAgICAgaW50IGMgPSBpbW9kKGluZGV4LCBcIityK1wiKSAqIDI7XFxuXFxuICAgICAgcmV0dXJuIGl2ZWMyKHIsIGMpO1xcbiAgICB9XFxuICBcIn0odCxlKTtjYXNlIDM6cmV0dXJuIG49dCxyPWUsbz1bTWF0aC5jZWlsKHJbMF0vMiksTWF0aC5jZWlsKHJbMV0vMildLGE9TWF0aC5jZWlsKG5bMl0vMiksaT1hKk1hdGguY2VpbChuWzFdLzIpLFwiXFxuICAgIGl2ZWMzIGdldE91dHB1dENvb3JkcygpIHtcXG4gICAgICBpdmVjMiByZXNUZXhSQyA9IGl2ZWMyKHJlc3VsdFVWLnl4ICpcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZlYzIoXCIrb1swXStcIiwgXCIrb1sxXStcIikpO1xcbiAgICAgIGludCBpbmRleCA9IHJlc1RleFJDLnggKiBcIitvWzFdK1wiICsgcmVzVGV4UkMueTtcXG5cXG4gICAgICBpbnQgYiA9IGluZGV4IC8gXCIraStcIjtcXG4gICAgICBpbmRleCAtPSBiICogXCIraStcIjtcXG5cXG4gICAgICBpbnQgciA9IDIgKiAoaW5kZXggLyBcIithK1wiKTtcXG4gICAgICBpbnQgYyA9IGltb2QoaW5kZXgsIFwiK2ErXCIpICogMjtcXG5cXG4gICAgICByZXR1cm4gaXZlYzMoYiwgciwgYyk7XFxuICAgIH1cXG4gIFwiO2RlZmF1bHQ6cmV0dXJuIGZ1bmN0aW9uKHQsZSl7Zm9yKHZhciBuPVtNYXRoLmNlaWwoZVswXS8yKSxNYXRoLmNlaWwoZVsxXS8yKV0scj1NYXRoLmNlaWwodFt0Lmxlbmd0aC0xXS8yKSxvPXIqTWF0aC5jZWlsKHRbdC5sZW5ndGgtMl0vMiksYT1vLGk9XCJcIixzPVwiYiwgciwgY1wiLHU9Mjt1PHQubGVuZ3RoLTE7dSsrKWEqPXRbdC5sZW5ndGgtdS0xXSxpPVwiXFxuICAgICAgaW50IGJcIit1K1wiID0gaW5kZXggLyBcIithK1wiO1xcbiAgICAgIGluZGV4IC09IGJcIit1K1wiICogXCIrYStcIjtcXG4gICAgXCIraSxzPVwiYlwiK3UrXCIsIFwiK3M7cmV0dXJuXCJcXG4gICAgaXZlY1wiK3QubGVuZ3RoK1wiIGdldE91dHB1dENvb3JkcygpIHtcXG4gICAgICBpdmVjMiByZXNUZXhSQyA9IGl2ZWMyKHJlc3VsdFVWLnl4ICpcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZlYzIoXCIrblswXStcIiwgXCIrblsxXStcIikpO1xcbiAgICAgIGludCBpbmRleCA9IHJlc1RleFJDLnggKiBcIituWzFdK1wiICsgcmVzVGV4UkMueTtcXG5cXG4gICAgICBcIitpK1wiXFxuXFxuICAgICAgaW50IGIgPSBpbmRleCAvIFwiK28rXCI7XFxuICAgICAgaW5kZXggLT0gYiAqIFwiK28rXCI7XFxuXFxuICAgICAgaW50IHIgPSAyICogKGluZGV4IC8gXCIrcitcIik7XFxuICAgICAgaW50IGMgPSBpbW9kKGluZGV4LCBcIityK1wiKSAqIDI7XFxuXFxuICAgICAgcmV0dXJuIGl2ZWNcIit0Lmxlbmd0aCtcIihcIitzK1wiKTtcXG4gICAgfVxcbiAgXCJ9KHQsZSl9dmFyIG4scixvLGEsaX0oZS5sb2dpY2FsU2hhcGUsYyksaT1mdW5jdGlvbih0KXtyZXR1cm5cIlxcbiAgICB2b2lkIHNldE91dHB1dCh2ZWM0IHZhbCkge1xcbiAgICAgIFwiK3Qub3V0cHV0K1wiID0gdmFsO1xcbiAgICB9XFxuICBcIn0obCkpOihhPWZ1bmN0aW9uKHQsZSl7c3dpdGNoKHQubGVuZ3RoKXtjYXNlIDA6cmV0dXJuXCJcXG4gICAgaW50IGdldE91dHB1dENvb3JkcygpIHtcXG4gICAgICByZXR1cm4gMDtcXG4gICAgfVxcbiAgXCI7Y2FzZSAxOnJldHVybiBmdW5jdGlvbih0LGUpe2lmKDE9PT1lWzBdKXJldHVyblwiXFxuICAgICAgaW50IGdldE91dHB1dENvb3JkcygpIHtcXG4gICAgICAgIHJldHVybiBpbnQocmVzdWx0VVYueCAqIFwiK2VbMV0rXCIuMCk7XFxuICAgICAgfVxcbiAgICBcIjtpZigxPT09ZVsxXSlyZXR1cm5cIlxcbiAgICAgIGludCBnZXRPdXRwdXRDb29yZHMoKSB7XFxuICAgICAgICByZXR1cm4gaW50KHJlc3VsdFVWLnkgKiBcIitlWzBdK1wiLjApO1xcbiAgICAgIH1cXG4gICAgXCI7cmV0dXJuXCJcXG4gICAgaW50IGdldE91dHB1dENvb3JkcygpIHtcXG4gICAgICBpdmVjMiByZXNUZXhSQyA9IGl2ZWMyKHJlc3VsdFVWLnl4ICpcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZlYzIoXCIrZVswXStcIiwgXCIrZVsxXStcIikpO1xcbiAgICAgIHJldHVybiByZXNUZXhSQy54ICogXCIrZVsxXStcIiArIHJlc1RleFJDLnk7XFxuICAgIH1cXG4gIFwifSgwLGUpO2Nhc2UgMjpyZXR1cm4gZnVuY3Rpb24odCxlKXtpZihTKHQsZSkpcmV0dXJuXCJcXG4gICAgICBpdmVjMiBnZXRPdXRwdXRDb29yZHMoKSB7XFxuICAgICAgICByZXR1cm4gaXZlYzIocmVzdWx0VVYueXggKiB2ZWMyKFwiK2VbMF0rXCIsIFwiK2VbMV0rXCIpKTtcXG4gICAgICB9XFxuICAgIFwiO2lmKDE9PT10WzFdKXJldHVyblwiXFxuICAgICAgaXZlYzIgZ2V0T3V0cHV0Q29vcmRzKCkge1xcbiAgICAgICAgaXZlYzIgcmVzVGV4UkMgPSBpdmVjMihyZXN1bHRVVi55eCAqXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZlYzIoXCIrZVswXStcIiwgXCIrZVsxXStcIikpO1xcbiAgICAgICAgaW50IGluZGV4ID0gcmVzVGV4UkMueCAqIFwiK2VbMV0rXCIgKyByZXNUZXhSQy55O1xcbiAgICAgICAgcmV0dXJuIGl2ZWMyKGluZGV4LCAwKTtcXG4gICAgICB9XFxuICAgIFwiO2lmKDE9PT10WzBdKXJldHVyblwiXFxuICAgICAgaXZlYzIgZ2V0T3V0cHV0Q29vcmRzKCkge1xcbiAgICAgICAgaXZlYzIgcmVzVGV4UkMgPSBpdmVjMihyZXN1bHRVVi55eCAqXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZlYzIoXCIrZVswXStcIiwgXCIrZVsxXStcIikpO1xcbiAgICAgICAgaW50IGluZGV4ID0gcmVzVGV4UkMueCAqIFwiK2VbMV0rXCIgKyByZXNUZXhSQy55O1xcbiAgICAgICAgcmV0dXJuIGl2ZWMyKDAsIGluZGV4KTtcXG4gICAgICB9XFxuICAgIFwiO3JldHVyblwiXFxuICAgIGl2ZWMyIGdldE91dHB1dENvb3JkcygpIHtcXG4gICAgICBpdmVjMiByZXNUZXhSQyA9IGl2ZWMyKHJlc3VsdFVWLnl4ICpcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZlYzIoXCIrZVswXStcIiwgXCIrZVsxXStcIikpO1xcbiAgICAgIGludCBpbmRleCA9IHJlc1RleFJDLnggKiBcIitlWzFdK1wiICsgcmVzVGV4UkMueTtcXG4gICAgICBpbnQgciA9IGluZGV4IC8gXCIrdFsxXStcIjtcXG4gICAgICBpbnQgYyA9IGluZGV4IC0gciAqIFwiK3RbMV0rXCI7XFxuICAgICAgcmV0dXJuIGl2ZWMyKHIsIGMpO1xcbiAgICB9XFxuICBcIn0odCxlKTtjYXNlIDM6cmV0dXJuIG49ZSxyPWNhKFtcInJcIixcImNcIixcImRcIl0sdCksXCJcXG4gICAgaXZlYzMgZ2V0T3V0cHV0Q29vcmRzKCkge1xcbiAgICAgIGl2ZWMyIHJlc1RleFJDID0gaXZlYzIocmVzdWx0VVYueXggKlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmVjMihcIituWzBdK1wiLCBcIituWzFdK1wiKSk7XFxuICAgICAgaW50IGluZGV4ID0gcmVzVGV4UkMueCAqIFwiK25bMV0rXCIgKyByZXNUZXhSQy55O1xcbiAgICAgIFwiK3IrXCJcXG4gICAgICByZXR1cm4gaXZlYzMociwgYywgZCk7XFxuICAgIH1cXG4gIFwiO2Nhc2UgNDpyZXR1cm4gZnVuY3Rpb24odCxlKXt2YXIgbj1jYShbXCJyXCIsXCJjXCIsXCJkXCIsXCJkMlwiXSx0KTtyZXR1cm5cIlxcbiAgICBpdmVjNCBnZXRPdXRwdXRDb29yZHMoKSB7XFxuICAgICAgaXZlYzIgcmVzVGV4UkMgPSBpdmVjMihyZXN1bHRVVi55eCAqXFxuICAgICAgICB2ZWMyKFwiK2VbMF0rXCIsIFwiK2VbMV0rXCIpKTtcXG4gICAgICBpbnQgaW5kZXggPSByZXNUZXhSQy54ICogXCIrZVsxXStcIiArIHJlc1RleFJDLnk7XFxuICAgICAgXCIrbitcIlxcbiAgICAgIHJldHVybiBpdmVjNChyLCBjLCBkLCBkMik7XFxuICAgIH1cXG4gIFwifSh0LGUpO2Nhc2UgNTpyZXR1cm4gZnVuY3Rpb24odCxlKXt2YXIgbj1jYShbXCJyXCIsXCJjXCIsXCJkXCIsXCJkMlwiLFwiZDNcIl0sdCk7cmV0dXJuXCJcXG4gICAgaXZlYzUgZ2V0T3V0cHV0Q29vcmRzKCkge1xcbiAgICAgIGl2ZWMyIHJlc1RleFJDID0gaXZlYzIocmVzdWx0VVYueXggKiB2ZWMyKFwiK2VbMF0rXCIsXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIitlWzFdK1wiKSk7XFxuXFxuICAgICAgaW50IGluZGV4ID0gcmVzVGV4UkMueCAqIFwiK2VbMV0rXCIgKyByZXNUZXhSQy55O1xcblxcbiAgICAgIFwiK24rXCJcXG5cXG4gICAgICBpdmVjNSBvdXRTaGFwZSA9IGl2ZWM1KHIsIGMsIGQsIGQyLCBkMyk7XFxuICAgICAgcmV0dXJuIG91dFNoYXBlO1xcbiAgICB9XFxuICBcIn0odCxlKTtjYXNlIDY6cmV0dXJuIGZ1bmN0aW9uKHQsZSl7dmFyIG49Y2EoW1wiclwiLFwiY1wiLFwiZFwiLFwiZDJcIixcImQzXCIsXCJkNFwiXSx0KTtyZXR1cm5cIlxcbiAgICBpdmVjNiBnZXRPdXRwdXRDb29yZHMoKSB7XFxuICAgICAgaXZlYzIgcmVzVGV4UkMgPSBpdmVjMihyZXN1bHRVVi55eCAqXFxuICAgICAgICB2ZWMyKFwiK2VbMF0rXCIsIFwiK2VbMV0rXCIpKTtcXG4gICAgICBpbnQgaW5kZXggPSByZXNUZXhSQy54ICogXCIrZVsxXStcIiArIHJlc1RleFJDLnk7XFxuXFxuICAgICAgXCIrbitcIlxcblxcbiAgICAgIGl2ZWM2IHJlc3VsdCA9IGl2ZWM2KHIsIGMsIGQsIGQyLCBkMywgZDQpO1xcbiAgICAgIHJldHVybiByZXN1bHQ7XFxuICAgIH1cXG4gIFwifSh0LGUpO2RlZmF1bHQ6dGhyb3cgbmV3IEVycm9yKHQubGVuZ3RoK1wiLUQgb3V0cHV0IHNhbXBsaW5nIGlzIG5vdCB5ZXQgc3VwcG9ydGVkXCIpfXZhciBuLHJ9KGUubG9naWNhbFNoYXBlLGMpLGk9ZnVuY3Rpb24odCl7cmV0dXJuXCJcXG4gICAgdm9pZCBzZXRPdXRwdXQoZmxvYXQgdmFsKSB7XFxuICAgICAgXCIrdC5vdXRwdXQrXCIgPSB2ZWM0KHZhbCwgMCwgMCwgMCk7XFxuICAgIH1cXG4gIFwifShsKSksciYmKGYrPXlhKSxbZixoLGkscyxhLHUsbl0uam9pbihcIlxcblwiKX1mdW5jdGlvbiBkYSh0KXt2YXIgZT10LnNoYXBlSW5mby5sb2dpY2FsU2hhcGU7c3dpdGNoKGUubGVuZ3RoKXtjYXNlIDA6cmV0dXJuIGZ1bmN0aW9uKHQpe3ZhciBlPXQubmFtZSxuPVwiZ2V0XCIrZS5jaGFyQXQoMCkudG9VcHBlckNhc2UoKStlLnNsaWNlKDEpO2lmKHQuc2hhcGVJbmZvLmlzVW5pZm9ybSlyZXR1cm5cImZsb2F0IFwiK24rXCIoKSB7cmV0dXJuIFwiK2UrXCI7fVwiO3ZhciByPXQuc2hhcGVJbmZvLnRleFNoYXBlLG89clswXSxhPXJbMV07aWYoMT09PW8mJjE9PT1hKXJldHVyblwiXFxuICAgICAgZmxvYXQgXCIrbitcIigpIHtcXG4gICAgICAgIHJldHVybiBzYW1wbGVUZXh0dXJlKFwiK2UrXCIsIGhhbGZDUik7XFxuICAgICAgfVxcbiAgICBcIjt2YXIgaT10LnNoYXBlSW5mby50ZXhTaGFwZSxzPWlbMF0sdT1pWzFdLGM9eGEoZSk7cmV0dXJuXCJcXG4gICAgZmxvYXQgXCIrbitcIigpIHtcXG4gICAgICB2ZWMyIHV2ID0gdXZGcm9tRmxhdChcIitzK1wiLCBcIit1K1wiLCBcIitjK1wiKTtcXG4gICAgICByZXR1cm4gc2FtcGxlVGV4dHVyZShcIitlK1wiLCB1dik7XFxuICAgIH1cXG4gIFwifSh0KTtjYXNlIDE6cmV0dXJuIGZ1bmN0aW9uKHQpe3ZhciBlPXQubmFtZSxuPVwiZ2V0XCIrZS5jaGFyQXQoMCkudG9VcHBlckNhc2UoKStlLnNsaWNlKDEpO2lmKHQuc2hhcGVJbmZvLmlzVW5pZm9ybSlyZXR1cm5cIlxcbiAgICAgIGZsb2F0IFwiK24rXCIoaW50IGluZGV4KSB7XFxuICAgICAgICBcIitiYSh0KStcIlxcbiAgICAgIH1cXG4gICAgXCI7dmFyIHI9dC5zaGFwZUluZm8udGV4U2hhcGUsbz1yWzBdLGE9clsxXTtpZigxPT09YSYmMT09PW8pcmV0dXJuXCJcXG4gICAgICBmbG9hdCBcIituK1wiKGludCBpbmRleCkge1xcbiAgICAgICAgcmV0dXJuIHNhbXBsZVRleHR1cmUoXCIrZStcIiwgaGFsZkNSKTtcXG4gICAgICB9XFxuICAgIFwiO3ZhciBpPXhhKGUpO2lmKDE9PT1hKXJldHVyblwiXFxuICAgICAgZmxvYXQgXCIrbitcIihpbnQgaW5kZXgpIHtcXG4gICAgICAgIHZlYzIgdXYgPSB2ZWMyKDAuNSwgKGZsb2F0KGluZGV4ICsgXCIraStcIikgKyAwLjUpIC8gXCIrbytcIi4wKTtcXG4gICAgICAgIHJldHVybiBzYW1wbGVUZXh0dXJlKFwiK2UrXCIsIHV2KTtcXG4gICAgICB9XFxuICAgIFwiO2lmKDE9PT1vKXJldHVyblwiXFxuICAgICAgZmxvYXQgXCIrbitcIihpbnQgaW5kZXgpIHtcXG4gICAgICAgIHZlYzIgdXYgPSB2ZWMyKChmbG9hdChpbmRleCArIFwiK2krXCIpICsgMC41KSAvIFwiK2ErXCIuMCwgMC41KTtcXG4gICAgICAgIHJldHVybiBzYW1wbGVUZXh0dXJlKFwiK2UrXCIsIHV2KTtcXG4gICAgICB9XFxuICAgIFwiO3JldHVyblwiXFxuICAgIGZsb2F0IFwiK24rXCIoaW50IGluZGV4KSB7XFxuICAgICAgdmVjMiB1diA9IHV2RnJvbUZsYXQoXCIrbytcIiwgXCIrYStcIiwgaW5kZXggKyBcIitpK1wiKTtcXG4gICAgICByZXR1cm4gc2FtcGxlVGV4dHVyZShcIitlK1wiLCB1dik7XFxuICAgIH1cXG4gIFwifSh0KTtjYXNlIDI6cmV0dXJuIGZ1bmN0aW9uKHQpe3ZhciBlPXQuc2hhcGVJbmZvLmxvZ2ljYWxTaGFwZSxuPXQubmFtZSxyPVwiZ2V0XCIrbi5jaGFyQXQoMCkudG9VcHBlckNhc2UoKStuLnNsaWNlKDEpLG89dC5zaGFwZUluZm8udGV4U2hhcGU7aWYobnVsbCE9byYmUyhlLG8pKXt2YXIgYT1vWzBdLGk9b1sxXTtyZXR1cm5cIlxcbiAgICBmbG9hdCBcIityK1wiKGludCByb3csIGludCBjb2wpIHtcXG4gICAgICB2ZWMyIHV2ID0gKHZlYzIoY29sLCByb3cpICsgaGFsZkNSKSAvIHZlYzIoXCIraStcIi4wLCBcIithK1wiLjApO1xcbiAgICAgIHJldHVybiBzYW1wbGVUZXh0dXJlKFwiK24rXCIsIHV2KTtcXG4gICAgfVxcbiAgXCJ9dmFyIHM9TShlKSx1PXMubmV3U2hhcGUsYz1zLmtlcHREaW1zLGw9dTtpZihsLmxlbmd0aDxlLmxlbmd0aCl7dmFyIGg9Q2EodCxsKTtyZXR1cm5cIlxcbiAgICAgIFwiK2RhKGgpK1wiXFxuICAgICAgZmxvYXQgXCIrcitcIihpbnQgcm93LCBpbnQgY29sKSB7XFxuICAgICAgICByZXR1cm4gXCIrcitcIihcIitFYShbXCJyb3dcIixcImNvbFwiXSxjKStcIik7XFxuICAgICAgfVxcbiAgICBcIn1pZih0LnNoYXBlSW5mby5pc1VuaWZvcm0pcmV0dXJuXCJcXG4gICAgICBmbG9hdCBcIityK1wiKGludCByb3csIGludCBjb2wpIHtcXG4gICAgICAgIGludCBpbmRleCA9IHJvdW5kKGRvdCh2ZWMyKHJvdywgY29sKSwgdmVjMihcIitlWzFdK1wiLCAxKSkpO1xcbiAgICAgICAgXCIrYmEodCkrXCJcXG4gICAgICB9XFxuICAgIFwiO3ZhciBmPW9bMF0sZD1vWzFdLHA9eGEobik7aWYoMT09PWQpcmV0dXJuXCJcXG4gICAgZmxvYXQgXCIrcitcIihpbnQgcm93LCBpbnQgY29sKSB7XFxuICAgICAgZmxvYXQgaW5kZXggPSBkb3QodmVjMyhyb3csIGNvbCwgXCIrcCtcIiksIHZlYzMoXCIrZVsxXStcIiwgMSwgMSkpO1xcbiAgICAgIHZlYzIgdXYgPSB2ZWMyKDAuNSwgKGluZGV4ICsgMC41KSAvIFwiK2YrXCIuMCk7XFxuICAgICAgcmV0dXJuIHNhbXBsZVRleHR1cmUoXCIrbitcIiwgdXYpO1xcbiAgICB9XFxuICBcIjtpZigxPT09ZilyZXR1cm5cIlxcbiAgICBmbG9hdCBcIityK1wiKGludCByb3csIGludCBjb2wpIHtcXG4gICAgICBmbG9hdCBpbmRleCA9IGRvdCh2ZWMzKHJvdywgY29sLCBcIitwK1wiKSwgdmVjMyhcIitlWzFdK1wiLCAxLCAxKSk7XFxuICAgICAgdmVjMiB1diA9IHZlYzIoKGluZGV4ICsgMC41KSAvIFwiK2QrXCIuMCwgMC41KTtcXG4gICAgICByZXR1cm4gc2FtcGxlVGV4dHVyZShcIituK1wiLCB1dik7XFxuICAgIH1cXG4gIFwiO3JldHVyblwiXFxuICBmbG9hdCBcIityK1wiKGludCByb3csIGludCBjb2wpIHtcXG4gICAgLy8gRXhwbGljaXRseSB1c2UgaW50ZWdlciBvcGVyYXRpb25zIGFzIGRvdCgpIG9ubHkgd29ya3Mgb24gZmxvYXRzLlxcbiAgICBpbnQgaW5kZXggPSByb3cgKiBcIitlWzFdK1wiICsgY29sICsgXCIrcCtcIjtcXG4gICAgdmVjMiB1diA9IHV2RnJvbUZsYXQoXCIrZitcIiwgXCIrZCtcIiwgaW5kZXgpO1xcbiAgICByZXR1cm4gc2FtcGxlVGV4dHVyZShcIituK1wiLCB1dik7XFxuICB9XFxuXCJ9KHQpO2Nhc2UgMzpyZXR1cm4gZnVuY3Rpb24odCl7dmFyIGU9dC5zaGFwZUluZm8ubG9naWNhbFNoYXBlLG49dC5uYW1lLHI9XCJnZXRcIituLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpK24uc2xpY2UoMSksbz1lWzFdKmVbMl0sYT1lWzJdLGk9TShlKSxzPWkubmV3U2hhcGUsdT1pLmtlcHREaW1zLGM9cztpZihjLmxlbmd0aDxlLmxlbmd0aCl7dmFyIGw9Q2EodCxjKTtyZXR1cm5cIlxcbiAgICAgICAgXCIrZGEobCkrXCJcXG4gICAgICAgIGZsb2F0IFwiK3IrXCIoaW50IHJvdywgaW50IGNvbCwgaW50IGRlcHRoKSB7XFxuICAgICAgICAgIHJldHVybiBcIityK1wiKFwiK0VhKFtcInJvd1wiLFwiY29sXCIsXCJkZXB0aFwiXSx1KStcIik7XFxuICAgICAgICB9XFxuICAgICAgXCJ9aWYodC5zaGFwZUluZm8uaXNVbmlmb3JtKXJldHVyblwiXFxuICAgICAgZmxvYXQgXCIrcitcIihpbnQgcm93LCBpbnQgY29sLCBpbnQgZGVwdGgpIHtcXG4gICAgICAgIGludCBpbmRleCA9IHJvdW5kKGRvdCh2ZWMzKHJvdywgY29sLCBkZXB0aCksXFxuICAgICAgICAgICAgICAgICAgICAgICAgICB2ZWMzKFwiK28rXCIsIFwiK2ErXCIsIDEpKSk7XFxuICAgICAgICBcIitiYSh0KStcIlxcbiAgICAgIH1cXG4gICAgXCI7dmFyIGg9dC5zaGFwZUluZm8udGV4U2hhcGUsZj1oWzBdLGQ9aFsxXSxwPXQuc2hhcGVJbmZvLmZsYXRPZmZzZXQ7aWYoZD09PW8mJm51bGw9PXApcmV0dXJuXCJcXG4gICAgICAgIGZsb2F0IFwiK3IrXCIoaW50IHJvdywgaW50IGNvbCwgaW50IGRlcHRoKSB7XFxuICAgICAgICAgIGZsb2F0IHRleFIgPSBmbG9hdChyb3cpO1xcbiAgICAgICAgICBmbG9hdCB0ZXhDID0gZG90KHZlYzIoY29sLCBkZXB0aCksIHZlYzIoXCIrYStcIiwgMSkpO1xcbiAgICAgICAgICB2ZWMyIHV2ID0gKHZlYzIodGV4QywgdGV4UikgKyBoYWxmQ1IpIC9cXG4gICAgICAgICAgICAgICAgICAgICB2ZWMyKFwiK2QrXCIuMCwgXCIrZitcIi4wKTtcXG4gICAgICAgICAgcmV0dXJuIHNhbXBsZVRleHR1cmUoXCIrbitcIiwgdXYpO1xcbiAgICAgICAgfVxcbiAgICAgIFwiO2lmKGQ9PT1hJiZudWxsPT1wKXJldHVyblwiXFxuICAgIGZsb2F0IFwiK3IrXCIoaW50IHJvdywgaW50IGNvbCwgaW50IGRlcHRoKSB7XFxuICAgICAgZmxvYXQgdGV4UiA9IGRvdCh2ZWMyKHJvdywgY29sKSwgdmVjMihcIitlWzFdK1wiLCAxKSk7XFxuICAgICAgZmxvYXQgdGV4QyA9IGZsb2F0KGRlcHRoKTtcXG4gICAgICB2ZWMyIHV2ID0gKHZlYzIodGV4QywgdGV4UikgKyBoYWxmQ1IpIC8gdmVjMihcIitkK1wiLjAsIFwiK2YrXCIuMCk7XFxuICAgICAgcmV0dXJuIHNhbXBsZVRleHR1cmUoXCIrbitcIiwgdXYpO1xcbiAgICB9XFxuICBcIjt2YXIgdj14YShuKTtyZXR1cm5cIlxcbiAgICAgIGZsb2F0IFwiK3IrXCIoaW50IHJvdywgaW50IGNvbCwgaW50IGRlcHRoKSB7XFxuICAgICAgICAvLyBFeHBsaWNpdGx5IHVzZSBpbnRlZ2VyIG9wZXJhdGlvbnMgYXMgZG90KCkgb25seSB3b3JrcyBvbiBmbG9hdHMuXFxuICAgICAgICBpbnQgaW5kZXggPSByb3cgKiBcIitvK1wiICsgY29sICogXCIrYStcIiArIGRlcHRoICsgXCIrditcIjtcXG4gICAgICAgIHZlYzIgdXYgPSB1dkZyb21GbGF0KFwiK2YrXCIsIFwiK2QrXCIsIGluZGV4KTtcXG4gICAgICAgIHJldHVybiBzYW1wbGVUZXh0dXJlKFwiK24rXCIsIHV2KTtcXG4gICAgICB9XFxuICBcIn0odCk7Y2FzZSA0OnJldHVybiBmdW5jdGlvbih0KXt2YXIgZT10LnNoYXBlSW5mby5sb2dpY2FsU2hhcGUsbj10Lm5hbWUscj1cImdldFwiK24uY2hhckF0KDApLnRvVXBwZXJDYXNlKCkrbi5zbGljZSgxKSxvPWVbM10sYT1lWzJdKm8saT1lWzFdKmEscz1NKGUpLHU9cy5uZXdTaGFwZSxjPXMua2VwdERpbXM7aWYodS5sZW5ndGg8ZS5sZW5ndGgpe3ZhciBsPUNhKHQsdSk7cmV0dXJuXCJcXG4gICAgICBcIitkYShsKStcIlxcbiAgICAgIGZsb2F0IFwiK3IrXCIoaW50IHJvdywgaW50IGNvbCwgaW50IGRlcHRoLCBpbnQgZGVwdGgyKSB7XFxuICAgICAgICByZXR1cm4gXCIrcitcIihcIitFYShbXCJyb3dcIixcImNvbFwiLFwiZGVwdGhcIixcImRlcHRoMlwiXSxjKStcIik7XFxuICAgICAgfVxcbiAgICBcIn1pZih0LnNoYXBlSW5mby5pc1VuaWZvcm0pcmV0dXJuXCJcXG4gICAgICBmbG9hdCBcIityK1wiKGludCByb3csIGludCBjb2wsIGludCBkZXB0aCwgaW50IGRlcHRoMikge1xcbiAgICAgICAgaW50IGluZGV4ID0gcm91bmQoZG90KHZlYzQocm93LCBjb2wsIGRlcHRoLCBkZXB0aDIpLFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgdmVjNChcIitpK1wiLCBcIithK1wiLCBcIitvK1wiLCAxKSkpO1xcbiAgICAgICAgXCIrYmEodCkrXCJcXG4gICAgICB9XFxuICAgIFwiO3ZhciBoPXQuc2hhcGVJbmZvLmZsYXRPZmZzZXQsZj10LnNoYXBlSW5mby50ZXhTaGFwZSxkPWZbMF0scD1mWzFdO2lmKHA9PT1pJiZudWxsPT1oKXJldHVyblwiXFxuICAgICAgZmxvYXQgXCIrcitcIihpbnQgcm93LCBpbnQgY29sLCBpbnQgZGVwdGgsIGludCBkZXB0aDIpIHtcXG4gICAgICAgIGZsb2F0IHRleFIgPSBmbG9hdChyb3cpO1xcbiAgICAgICAgZmxvYXQgdGV4QyA9XFxuICAgICAgICAgICAgZG90KHZlYzMoY29sLCBkZXB0aCwgZGVwdGgyKSxcXG4gICAgICAgICAgICAgICAgdmVjMyhcIithK1wiLCBcIitvK1wiLCAxKSk7XFxuICAgICAgICB2ZWMyIHV2ID0gKHZlYzIodGV4QywgdGV4UikgKyBoYWxmQ1IpIC9cXG4gICAgICAgICAgICAgICAgICAgdmVjMihcIitwK1wiLjAsIFwiK2QrXCIuMCk7XFxuICAgICAgICByZXR1cm4gc2FtcGxlVGV4dHVyZShcIituK1wiLCB1dik7XFxuICAgICAgfVxcbiAgICBcIjtpZihwPT09byYmbnVsbD09aClyZXR1cm5cIlxcbiAgICAgIGZsb2F0IFwiK3IrXCIoaW50IHJvdywgaW50IGNvbCwgaW50IGRlcHRoLCBpbnQgZGVwdGgyKSB7XFxuICAgICAgICBmbG9hdCB0ZXhSID0gZG90KHZlYzMocm93LCBjb2wsIGRlcHRoKSxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgdmVjMyhcIitlWzFdKmVbMl0rXCIsIFwiK2VbMl0rXCIsIDEpKTtcXG4gICAgICAgIGZsb2F0IHRleEMgPSBmbG9hdChkZXB0aDIpO1xcbiAgICAgICAgdmVjMiB1diA9ICh2ZWMyKHRleEMsIHRleFIpICsgaGFsZkNSKSAvXFxuICAgICAgICAgICAgICAgICAgdmVjMihcIitwK1wiLjAsIFwiK2QrXCIuMCk7XFxuICAgICAgICByZXR1cm4gc2FtcGxlVGV4dHVyZShcIituK1wiLCB1dik7XFxuICAgICAgfVxcbiAgICBcIjt2YXIgdj14YShuKTtyZXR1cm5cIlxcbiAgICBmbG9hdCBcIityK1wiKGludCByb3csIGludCBjb2wsIGludCBkZXB0aCwgaW50IGRlcHRoMikge1xcbiAgICAgIC8vIEV4cGxpY2l0bHkgdXNlIGludGVnZXIgb3BlcmF0aW9ucyBhcyBkb3QoKSBvbmx5IHdvcmtzIG9uIGZsb2F0cy5cXG4gICAgICBpbnQgaW5kZXggPSByb3cgKiBcIitpK1wiICsgY29sICogXCIrYStcIiArXFxuICAgICAgICAgIGRlcHRoICogXCIrbytcIiArIGRlcHRoMjtcXG4gICAgICB2ZWMyIHV2ID0gdXZGcm9tRmxhdChcIitkK1wiLCBcIitwK1wiLCBpbmRleCArIFwiK3YrXCIpO1xcbiAgICAgIHJldHVybiBzYW1wbGVUZXh0dXJlKFwiK24rXCIsIHV2KTtcXG4gICAgfVxcbiAgXCJ9KHQpO2Nhc2UgNTpyZXR1cm4gZnVuY3Rpb24odCl7dmFyIGU9dC5zaGFwZUluZm8ubG9naWNhbFNoYXBlLG49dC5uYW1lLHI9XCJnZXRcIituLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpK24uc2xpY2UoMSksbz1lWzRdLGE9ZVszXSpvLGk9ZVsyXSphLHM9ZVsxXSppLHU9TShlKSxjPXUubmV3U2hhcGUsbD11LmtlcHREaW1zO2lmKGMubGVuZ3RoPGUubGVuZ3RoKXt2YXIgaD1DYSh0LGMpO3JldHVyblwiXFxuICAgICAgXCIrZGEoaCkrXCJcXG4gICAgICBmbG9hdCBcIityK1wiKGludCByb3csIGludCBjb2wsIGludCBkZXB0aCwgaW50IGRlcHRoMiwgaW50IGRlcHRoMykge1xcbiAgICAgICAgcmV0dXJuIFwiK3IrXCIoXCIrRWEoW1wicm93XCIsXCJjb2xcIixcImRlcHRoXCIsXCJkZXB0aDJcIixcImRlcHRoM1wiXSxsKStcIik7XFxuICAgICAgfVxcbiAgICBcIn1pZih0LnNoYXBlSW5mby5pc1VuaWZvcm0pcmV0dXJuXCJcXG4gICAgICBmbG9hdCBcIityK1wiKGludCByb3csIGludCBjb2wsIGludCBkZXB0aCwgaW50IGRlcHRoMiwgaW50IGRlcHRoMykge1xcbiAgICAgICAgZmxvYXQgaW5kZXggPSBkb3QoXFxuICAgICAgICAgIHZlYzQocm93LCBjb2wsIGRlcHRoLCBkZXB0aDIpLFxcbiAgICAgICAgICB2ZWM0KFwiK3MrXCIsIFwiK2krXCIsIFwiK2ErXCIsIFwiK28rXCIpKSArXFxuICAgICAgICAgIGRlcHRoMztcXG4gICAgICAgIFwiK2JhKHQpK1wiXFxuICAgICAgfVxcbiAgICBcIjt2YXIgZj10LnNoYXBlSW5mby5mbGF0T2Zmc2V0LGQ9dC5zaGFwZUluZm8udGV4U2hhcGUscD1kWzBdLHY9ZFsxXTtpZih2PT09cyYmbnVsbD09ZilyZXR1cm5cIlxcbiAgICAgIGZsb2F0IFwiK3IrXCIoaW50IHJvdywgaW50IGNvbCwgaW50IGRlcHRoLCBpbnQgZGVwdGgyLCBpbnQgZGVwdGgzKSB7XFxuICAgICAgICBpbnQgdGV4UiA9IHJvdztcXG4gICAgICAgIGZsb2F0IHRleEMgPSBkb3QodmVjNChjb2wsIGRlcHRoLCBkZXB0aDIsIGRlcHRoMyksXFxuICAgICAgICAgICAgICAgICAgICAgICAgIHZlYzQoXCIraStcIiwgXCIrYStcIiwgXCIrbytcIiwgMSkpO1xcbiAgICAgICAgdmVjMiB1diA9ICh2ZWMyKHRleEMsIHRleFIpICsgaGFsZkNSKSAvXFxuICAgICAgICAgICAgICAgICAgIHZlYzIoXCIrditcIi4wLCBcIitwK1wiLjApO1xcbiAgICAgICAgcmV0dXJuIHNhbXBsZVRleHR1cmUoXCIrbitcIiwgdXYpO1xcbiAgICAgIH1cXG4gICAgXCI7aWYodj09PW8mJm51bGw9PWYpcmV0dXJuXCJcXG4gICAgICBmbG9hdCBcIityK1wiKGludCByb3csIGludCBjb2wsIGludCBkZXB0aCwgaW50IGRlcHRoMiwgaW50IGRlcHRoMykge1xcbiAgICAgICAgZmxvYXQgdGV4UiA9IGRvdChcXG4gICAgICAgICAgdmVjNChyb3csIGNvbCwgZGVwdGgsIGRlcHRoMiksXFxuICAgICAgICAgIHZlYzQoXCIrZVsxXSplWzJdKmVbM10rXCIsXFxuICAgICAgICAgICAgICAgXCIrZVsyXSplWzNdK1wiLCBcIitlWzNdK1wiLCAxKSk7XFxuICAgICAgICBpbnQgdGV4QyA9IGRlcHRoMztcXG4gICAgICAgIHZlYzIgdXYgPSAodmVjMih0ZXhDLCB0ZXhSKSArIGhhbGZDUikgL1xcbiAgICAgICAgICAgICAgICAgIHZlYzIoXCIrditcIi4wLCBcIitwK1wiLjApO1xcbiAgICAgICAgcmV0dXJuIHNhbXBsZVRleHR1cmUoXCIrbitcIiwgdXYpO1xcbiAgICAgIH1cXG4gICAgXCI7dmFyIG09eGEobik7cmV0dXJuXCJcXG4gICAgZmxvYXQgXCIrcitcIihpbnQgcm93LCBpbnQgY29sLCBpbnQgZGVwdGgsIGludCBkZXB0aDIsIGludCBkZXB0aDMpIHtcXG4gICAgICAvLyBFeHBsaWNpdGx5IHVzZSBpbnRlZ2VyIG9wZXJhdGlvbnMgYXMgZG90KCkgb25seSB3b3JrcyBvbiBmbG9hdHMuXFxuICAgICAgaW50IGluZGV4ID0gcm93ICogXCIrcytcIiArIGNvbCAqIFwiK2krXCIgKyBkZXB0aCAqIFwiK2ErXCIgK1xcbiAgICAgICAgICBkZXB0aDIgKiBcIitvK1wiICsgZGVwdGgzICsgXCIrbStcIjtcXG4gICAgICB2ZWMyIHV2ID0gdXZGcm9tRmxhdChcIitwK1wiLCBcIit2K1wiLCBpbmRleCk7XFxuICAgICAgcmV0dXJuIHNhbXBsZVRleHR1cmUoXCIrbitcIiwgdXYpO1xcbiAgICB9XFxuICBcIn0odCk7Y2FzZSA2OnJldHVybiBmdW5jdGlvbih0KXt2YXIgZT10LnNoYXBlSW5mby5sb2dpY2FsU2hhcGUsbj10Lm5hbWUscj1cImdldFwiK24uY2hhckF0KDApLnRvVXBwZXJDYXNlKCkrbi5zbGljZSgxKSxvPU0oZSksYT1vLm5ld1NoYXBlLGk9by5rZXB0RGltcztpZihhLmxlbmd0aDxlLmxlbmd0aCl7dmFyIHM9Q2EodCxhKTtyZXR1cm5cIlxcbiAgICAgIFwiK2RhKHMpK1wiXFxuICAgICAgZmxvYXQgXCIrcitcIihpbnQgcm93LCBpbnQgY29sLCBpbnQgZGVwdGgsXFxuICAgICAgICAgICAgICAgICAgICBpbnQgZGVwdGgyLCBpbnQgZGVwdGgzLCBpbnQgZGVwdGg0KSB7XFxuICAgICAgICByZXR1cm4gXCIrcitcIihcIitFYShbXCJyb3dcIixcImNvbFwiLFwiZGVwdGhcIixcImRlcHRoMlwiLFwiZGVwdGgzXCIsXCJkZXB0aDRcIl0saSkrXCIpO1xcbiAgICAgIH1cXG4gICAgXCJ9dmFyIHU9ZVs1XSxjPWVbNF0qdSxsPWVbM10qYyxoPWVbMl0qbCxmPWVbMV0qaDtpZih0LnNoYXBlSW5mby5pc1VuaWZvcm0pcmV0dXJuXCJcXG4gICAgICBmbG9hdCBcIityK1wiKGludCByb3csIGludCBjb2wsIGludCBkZXB0aCxcXG4gICAgICAgICAgICAgICAgICBpbnQgZGVwdGgyLCBpbnQgZGVwdGgzLCBpbnQgZGVwdGg0KSB7XFxuICAgICAgICBpbnQgaW5kZXggPSByb3VuZChkb3QoXFxuICAgICAgICAgIHZlYzQocm93LCBjb2wsIGRlcHRoLCBkZXB0aDIpLFxcbiAgICAgICAgICB2ZWM0KFwiK2YrXCIsIFwiK2grXCIsIFwiK2wrXCIsIFwiK2MrXCIpKSArXFxuICAgICAgICAgIGRvdChcXG4gICAgICAgICAgICB2ZWMyKGRlcHRoMywgZGVwdGg0KSxcXG4gICAgICAgICAgICB2ZWMyKFwiK3UrXCIsIDEpKSk7XFxuICAgICAgICBcIitiYSh0KStcIlxcbiAgICAgIH1cXG4gICAgXCI7dmFyIGQ9dC5zaGFwZUluZm8uZmxhdE9mZnNldCxwPXQuc2hhcGVJbmZvLnRleFNoYXBlLHY9cFswXSxtPXBbMV07aWYobT09PWYmJm51bGw9PWQpcmV0dXJuXCJcXG4gICAgICBmbG9hdCBcIityK1wiKGludCByb3csIGludCBjb2wsIGludCBkZXB0aCxcXG4gICAgICAgICAgICAgICAgICAgIGludCBkZXB0aDIsIGludCBkZXB0aDMsIGludCBkZXB0aDQpIHtcXG4gICAgICAgIGludCB0ZXhSID0gcm93O1xcbiAgICAgICAgZmxvYXQgdGV4QyA9IGRvdCh2ZWM0KGNvbCwgZGVwdGgsIGRlcHRoMiwgZGVwdGgzKSxcXG4gICAgICAgICAgdmVjNChcIitoK1wiLCBcIitsK1wiLCBcIitjK1wiLCBcIit1K1wiKSkgK1xcbiAgICAgICAgICAgICAgIGZsb2F0KGRlcHRoNCk7XFxuICAgICAgICB2ZWMyIHV2ID0gKHZlYzIodGV4QywgdGV4UikgKyBoYWxmQ1IpIC9cXG4gICAgICAgICAgICAgICAgICAgdmVjMihcIittK1wiLjAsIFwiK3YrXCIuMCk7XFxuICAgICAgICByZXR1cm4gc2FtcGxlVGV4dHVyZShcIituK1wiLCB1dik7XFxuICAgICAgfVxcbiAgICBcIjtpZihtPT09dSYmbnVsbD09ZClyZXR1cm5cIlxcbiAgICAgIGZsb2F0IFwiK3IrXCIoaW50IHJvdywgaW50IGNvbCwgaW50IGRlcHRoLFxcbiAgICAgICAgICAgICAgICAgICAgaW50IGRlcHRoMiwgaW50IGRlcHRoMywgaW50IGRlcHRoNCkge1xcbiAgICAgICAgZmxvYXQgdGV4UiA9IGRvdCh2ZWM0KHJvdywgY29sLCBkZXB0aCwgZGVwdGgyKSxcXG4gICAgICAgICAgdmVjNChcIitlWzFdKmVbMl0qZVszXSplWzRdK1wiLFxcbiAgICAgICAgICAgICAgIFwiK2VbMl0qZVszXSplWzRdK1wiLFxcbiAgICAgICAgICAgICAgIFwiK2VbM10qZVs0XStcIixcXG4gICAgICAgICAgICAgICBcIitlWzRdK1wiKSkgKyBmbG9hdChkZXB0aDMpO1xcbiAgICAgICAgaW50IHRleEMgPSBkZXB0aDQ7XFxuICAgICAgICB2ZWMyIHV2ID0gKHZlYzIodGV4QywgdGV4UikgKyBoYWxmQ1IpIC9cXG4gICAgICAgICAgICAgICAgICB2ZWMyKFwiK20rXCIuMCwgXCIrditcIi4wKTtcXG4gICAgICAgIHJldHVybiBzYW1wbGVUZXh0dXJlKFwiK24rXCIsIHV2KTtcXG4gICAgICB9XFxuICAgIFwiO3ZhciBnPXhhKG4pO3JldHVyblwiXFxuICAgIGZsb2F0IFwiK3IrXCIoaW50IHJvdywgaW50IGNvbCwgaW50IGRlcHRoLFxcbiAgICAgICAgICAgICAgICAgIGludCBkZXB0aDIsIGludCBkZXB0aDMsIGludCBkZXB0aDQpIHtcXG4gICAgICAvLyBFeHBsaWNpdGx5IHVzZSBpbnRlZ2VyIG9wZXJhdGlvbnMgYXMgZG90KCkgb25seSB3b3JrcyBvbiBmbG9hdHMuXFxuICAgICAgaW50IGluZGV4ID0gcm93ICogXCIrZitcIiArIGNvbCAqIFwiK2grXCIgKyBkZXB0aCAqIFwiK2wrXCIgK1xcbiAgICAgICAgICBkZXB0aDIgKiBcIitjK1wiICsgZGVwdGgzICogXCIrdStcIiArIGRlcHRoNCArIFwiK2crXCI7XFxuICAgICAgdmVjMiB1diA9IHV2RnJvbUZsYXQoXCIrditcIiwgXCIrbStcIiwgaW5kZXgpO1xcbiAgICAgIHJldHVybiBzYW1wbGVUZXh0dXJlKFwiK24rXCIsIHV2KTtcXG4gICAgfVxcbiAgXCJ9KHQpO2RlZmF1bHQ6dGhyb3cgbmV3IEVycm9yKGUubGVuZ3RoK1wiLUQgaW5wdXQgc2FtcGxpbmcgaXMgbm90IHlldCBzdXBwb3J0ZWRcIil9fWZ1bmN0aW9uIHBhKHQpe3ZhciBlLG4scjtzd2l0Y2godC5zaGFwZUluZm8ubG9naWNhbFNoYXBlLmxlbmd0aCl7Y2FzZSAwOnJldHVybiBlPXQubmFtZSxuPVwiZ2V0XCIrZS5jaGFyQXQoMCkudG9VcHBlckNhc2UoKStlLnNsaWNlKDEpLHI9dWEoKSxcIlxcbiAgICB2ZWM0IFwiK24rXCIoKSB7XFxuICAgICAgcmV0dXJuIFwiK3IudGV4dHVyZTJEK1wiKFwiK2UrXCIsIGhhbGZDUik7XFxuICAgIH1cXG4gIFwiO2Nhc2UgMTpyZXR1cm4gZnVuY3Rpb24odCl7dmFyIGU9dC5uYW1lLG49XCJnZXRcIitlLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpK2Uuc2xpY2UoMSkscj10LnNoYXBlSW5mby50ZXhTaGFwZSxvPVtNYXRoLmNlaWwoclswXS8yKSxNYXRoLmNlaWwoclsxXS8yKV0sYT11YSgpO3JldHVyblwiXFxuICAgIHZlYzQgXCIrbitcIihpbnQgaW5kZXgpIHtcXG4gICAgICB2ZWMyIHV2ID0gcGFja2VkVVZmcm9tMUQoXFxuICAgICAgICBcIitvWzBdK1wiLCBcIitvWzFdK1wiLCBpbmRleCk7XFxuICAgICAgcmV0dXJuIFwiK2EudGV4dHVyZTJEK1wiKFwiK2UrXCIsIHV2KTtcXG4gICAgfVxcbiAgXCJ9KHQpO2Nhc2UgMjpyZXR1cm4gZnVuY3Rpb24odCl7dmFyIGU9dC5zaGFwZUluZm8ubG9naWNhbFNoYXBlLG49dC5uYW1lLHI9XCJnZXRcIituLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpK24uc2xpY2UoMSksbz10LnNoYXBlSW5mby50ZXhTaGFwZSxhPW9bMF0saT1vWzFdLHM9dWEoKTtpZihudWxsIT1vJiZTKGUsbykpcmV0dXJuXCJcXG4gICAgICB2ZWM0IFwiK3IrXCIoaW50IHJvdywgaW50IGNvbCkge1xcbiAgICAgICAgdmVjMiB1diA9ICh2ZWMyKGNvbCwgcm93KSArIGhhbGZDUikgLyB2ZWMyKFwiK2krXCIuMCwgXCIrYStcIi4wKTtcXG5cXG4gICAgICAgIHJldHVybiBcIitzLnRleHR1cmUyRCtcIihcIituK1wiLCB1dik7XFxuICAgICAgfVxcbiAgICBcIjt2YXIgdT1bTWF0aC5jZWlsKG9bMF0vMiksTWF0aC5jZWlsKG9bMV0vMildLGM9TWF0aC5jZWlsKGVbMV0vMik7cmV0dXJuXCJcXG4gICAgdmVjNCBcIityK1wiKGludCByb3csIGludCBjb2wpIHtcXG4gICAgICB2ZWMyIHV2ID0gcGFja2VkVVZmcm9tMkQoXCIrYytcIiwgXCIrdVswXStcIiwgXCIrdVsxXStcIiwgcm93LCBjb2wpO1xcbiAgICAgIHJldHVybiBcIitzLnRleHR1cmUyRCtcIihcIituK1wiLCB1dik7XFxuICAgIH1cXG4gIFwifSh0KTtjYXNlIDM6cmV0dXJuIGZ1bmN0aW9uKHQpe3ZhciBlPXQuc2hhcGVJbmZvLmxvZ2ljYWxTaGFwZSxuPXQubmFtZSxyPVwiZ2V0XCIrbi5jaGFyQXQoMCkudG9VcHBlckNhc2UoKStuLnNsaWNlKDEpLG89dC5zaGFwZUluZm8udGV4U2hhcGUsYT1bTWF0aC5jZWlsKG9bMF0vMiksTWF0aC5jZWlsKG9bMV0vMildO2lmKDE9PT1lWzBdKXt2YXIgaT1lLnNsaWNlKDEpLHM9Q2EodCxpKTtyZXR1cm5cIlxcbiAgICAgICAgXCIrcGEocykrXCJcXG4gICAgICAgIHZlYzQgXCIrcitcIihpbnQgYiwgaW50IHJvdywgaW50IGNvbCkge1xcbiAgICAgICAgICByZXR1cm4gXCIrcitcIihcIitFYShbXCJiXCIsXCJyb3dcIixcImNvbFwiXSxbMSwyXSkrXCIpO1xcbiAgICAgICAgfVxcbiAgICAgIFwifXZhciB1PWFbMF0sYz1hWzFdLGw9TWF0aC5jZWlsKGVbMl0vMiksaD1sKk1hdGguY2VpbChlWzFdLzIpLGY9dWEoKTtyZXR1cm5cIlxcbiAgICB2ZWM0IFwiK3IrXCIoaW50IGIsIGludCByb3csIGludCBjb2wpIHtcXG4gICAgICB2ZWMyIHV2ID0gcGFja2VkVVZmcm9tM0QoXFxuICAgICAgICBcIit1K1wiLCBcIitjK1wiLCBcIitoK1wiLCBcIitsK1wiLCBiLCByb3csIGNvbCk7XFxuICAgICAgcmV0dXJuIFwiK2YudGV4dHVyZTJEK1wiKFwiK24rXCIsIHV2KTtcXG4gICAgfVxcbiAgXCJ9KHQpO2RlZmF1bHQ6cmV0dXJuIGZ1bmN0aW9uKHQpe2Zvcih2YXIgZT10LnNoYXBlSW5mby5sb2dpY2FsU2hhcGUsbj1lLmxlbmd0aCxyPXQubmFtZSxvPVwiZ2V0XCIrci5jaGFyQXQoMCkudG9VcHBlckNhc2UoKStyLnNsaWNlKDEpLGE9dC5zaGFwZUluZm8udGV4U2hhcGUsaT1bTWF0aC5jZWlsKGFbMF0vMiksTWF0aC5jZWlsKGFbMV0vMildLHM9aVswXSx1PWlbMV0sYz1NYXRoLmNlaWwoZVtuLTFdLzIpLGw9YypNYXRoLmNlaWwoZVtuLTJdLzIpLGg9XCJpbnQgYiwgaW50IHJvdywgaW50IGNvbFwiLGY9XCJiICogXCIrbCtcIiArIChyb3cgLyAyKSAqIFwiK2MrXCIgKyAoY29sIC8gMilcIixkPTI7ZDxuLTE7ZCsrKWg9XCJpbnQgYlwiK2QrXCIsIFwiK2gsbCo9ZVtuLWQtMV0sZj1cImJcIitkK1wiICogXCIrbCtcIiArIFwiK2Y7dmFyIHA9dWEoKTtyZXR1cm5cIlxcbiAgICB2ZWM0IFwiK28rXCIoXCIraCtcIikge1xcbiAgICAgIGludCBpbmRleCA9IFwiK2YrXCI7XFxuICAgICAgaW50IHRleFIgPSBpbmRleCAvIFwiK3UrXCI7XFxuICAgICAgaW50IHRleEMgPSBpbmRleCAtIHRleFIgKiBcIit1K1wiO1xcbiAgICAgIHZlYzIgdXYgPSAodmVjMih0ZXhDLCB0ZXhSKSArIGhhbGZDUikgLyB2ZWMyKFwiK3UrXCIsIFwiK3MrXCIpO1xcbiAgICAgIHJldHVybiBcIitwLnRleHR1cmUyRCtcIihcIityK1wiLCB1dik7XFxuICAgIH1cXG4gIFwifSh0KX19dmFyIHZhPVwiXFxudmVjMiB1dkZyb21GbGF0KGludCB0ZXhOdW1SLCBpbnQgdGV4TnVtQywgaW50IGluZGV4KSB7XFxuICBpbnQgdGV4UiA9IGluZGV4IC8gdGV4TnVtQztcXG4gIGludCB0ZXhDID0gaW5kZXggLSB0ZXhSICogdGV4TnVtQztcXG4gIHJldHVybiAodmVjMih0ZXhDLCB0ZXhSKSArIGhhbGZDUikgLyB2ZWMyKHRleE51bUMsIHRleE51bVIpO1xcbn1cXG52ZWMyIHBhY2tlZFVWZnJvbTFEKGludCB0ZXhOdW1SLCBpbnQgdGV4TnVtQywgaW50IGluZGV4KSB7XFxuICBpbnQgdGV4ZWxJbmRleCA9IGluZGV4IC8gMjtcXG4gIGludCB0ZXhSID0gdGV4ZWxJbmRleCAvIHRleE51bUM7XFxuICBpbnQgdGV4QyA9IHRleGVsSW5kZXggLSB0ZXhSICogdGV4TnVtQztcXG4gIHJldHVybiAodmVjMih0ZXhDLCB0ZXhSKSArIGhhbGZDUikgLyB2ZWMyKHRleE51bUMsIHRleE51bVIpO1xcbn1cXG5cIixtYT1cIlxcbnZlYzIgcGFja2VkVVZmcm9tMkQoaW50IHRleGVsc0luTG9naWNhbFJvdywgaW50IHRleE51bVIsXFxuICBpbnQgdGV4TnVtQywgaW50IHJvdywgaW50IGNvbCkge1xcbiAgaW50IHRleGVsSW5kZXggPSAocm93IC8gMikgKiB0ZXhlbHNJbkxvZ2ljYWxSb3cgKyAoY29sIC8gMik7XFxuICBpbnQgdGV4UiA9IHRleGVsSW5kZXggLyB0ZXhOdW1DO1xcbiAgaW50IHRleEMgPSB0ZXhlbEluZGV4IC0gdGV4UiAqIHRleE51bUM7XFxuICByZXR1cm4gKHZlYzIodGV4QywgdGV4UikgKyBoYWxmQ1IpIC8gdmVjMih0ZXhOdW1DLCB0ZXhOdW1SKTtcXG59XFxuXCIsZ2E9XCJcXG52ZWMyIHBhY2tlZFVWZnJvbTNEKGludCB0ZXhOdW1SLCBpbnQgdGV4TnVtQyxcXG4gICAgaW50IHRleGVsc0luQmF0Y2gsIGludCB0ZXhlbHNJbkxvZ2ljYWxSb3csIGludCBiLFxcbiAgICBpbnQgcm93LCBpbnQgY29sKSB7XFxuICBpbnQgaW5kZXggPSBiICogdGV4ZWxzSW5CYXRjaCArIChyb3cgLyAyKSAqIHRleGVsc0luTG9naWNhbFJvdyArIChjb2wgLyAyKTtcXG4gIGludCB0ZXhSID0gaW5kZXggLyB0ZXhOdW1DO1xcbiAgaW50IHRleEMgPSBpbmRleCAtIHRleFIgKiB0ZXhOdW1DO1xcbiAgcmV0dXJuICh2ZWMyKHRleEMsIHRleFIpICsgaGFsZkNSKSAvIHZlYzIodGV4TnVtQywgdGV4TnVtUik7XFxufVxcblwiLHlhPVwiXFxuICBmbG9hdCBnZXRDaGFubmVsKHZlYzQgZnJhZywgdmVjMiBpbm5lckRpbXMpIHtcXG4gICAgdmVjMiBtb2RDb29yZCA9IG1vZChpbm5lckRpbXMsIDIuKTtcXG4gICAgcmV0dXJuIG1vZENvb3JkLnggPT0gMC4gP1xcbiAgICAgIChtb2RDb29yZC55ID09IDAuID8gZnJhZy5yIDogZnJhZy5nKSA6XFxuICAgICAgKG1vZENvb3JkLnkgPT0gMC4gPyBmcmFnLmIgOiBmcmFnLmEpO1xcbiAgfVxcbiAgZmxvYXQgZ2V0Q2hhbm5lbCh2ZWM0IGZyYWcsIGludCBkaW0pIHtcXG4gICAgZmxvYXQgbW9kQ29vcmQgPSBtb2QoZmxvYXQoZGltKSwgMi4pO1xcbiAgICByZXR1cm4gbW9kQ29vcmQgPT0gMC4gPyBmcmFnLnIgOiBmcmFnLmc7XFxuICB9XFxuXCI7ZnVuY3Rpb24geGEodCl7cmV0dXJuXCJvZmZzZXRcIit0fWZ1bmN0aW9uIGJhKHQpe3ZhciBlPXQubmFtZSxuPWsodC5zaGFwZUluZm8ubG9naWNhbFNoYXBlKTtyZXR1cm4gbjwyP1wicmV0dXJuIFwiK2UrXCI7XCI6XCJcXG4gICAgZm9yIChpbnQgaSA9IDA7IGkgPCBcIituK1wiOyBpKyspIHtcXG4gICAgICBpZiAoaSA9PSBpbmRleCkge1xcbiAgICAgICAgcmV0dXJuIFwiK2UrXCJbaV07XFxuICAgICAgfVxcbiAgICB9XFxuICBcIn1mdW5jdGlvbiB3YSh0KXtpZih0PD0xKXJldHVyblwiaW50XCI7aWYoMj09PXQpcmV0dXJuXCJpdmVjMlwiO2lmKDM9PT10KXJldHVyblwiaXZlYzNcIjtpZig0PT09dClyZXR1cm5cIml2ZWM0XCI7aWYoNT09PXQpcmV0dXJuXCJpdmVjNVwiO2lmKDY9PT10KXJldHVyblwiaXZlYzZcIjt0aHJvdyBFcnJvcihcIkdQVSBmb3IgcmFuayBcIit0K1wiIGlzIG5vdCB5ZXQgc3VwcG9ydGVkXCIpfWZ1bmN0aW9uIENhKHQsZSl7dmFyIG49SlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeSh0KSk7cmV0dXJuIG4uc2hhcGVJbmZvLmxvZ2ljYWxTaGFwZT1lLG59ZnVuY3Rpb24gRWEodCxlKXtyZXR1cm4gZS5tYXAoKGZ1bmN0aW9uKGUpe3JldHVybiB0W2VdfSkpLmpvaW4oXCIsIFwiKX12YXIgUmE9ZnVuY3Rpb24odCxlLG4scil7dGhpcy52YXJpYWJsZU5hbWVzPVtcIkFcIl0sdGhpcy5wYWNrZWRJbnB1dHM9ITAsdGhpcy5wYWNrZWRPdXRwdXQ9ITAsQyh0Lmxlbmd0aD4yLChmdW5jdGlvbigpe3JldHVyblwiUGFja2VkIGFyZ1wiKyhuLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpK24uc2xpY2UoMSkpK1wiIHN1cHBvcnRzIG9ubHkgaW5wdXRzIHdpdGggcmFuayBhYm92ZSAyLlwifSkpO3ZhciBvPXRbdC5sZW5ndGgtMV0sYT1NYXRoLmNlaWwoby9lKTt0aGlzLm91dHB1dFNoYXBlPXQuc2xpY2UoMCwtMSksYT4xJiZ0aGlzLm91dHB1dFNoYXBlLnB1c2goYSkscnx8dGhpcy52YXJpYWJsZU5hbWVzLnB1c2goXCJiZXN0SW5kaWNlc0FcIik7dmFyIGkscyx1PXRoaXMub3V0cHV0U2hhcGUsYz11Lmxlbmd0aCxsPXdhKGMpLGg9c2EoXCJjb29yZHNcIixjKTtpZigxPT09YSl7dmFyIGY9d2Eocz1jKzEpO2k9XCJcXG4gICAgICAgIFwiK2YrXCIgc291cmNlTG9jUiA9IFwiK2YrXCIoXCIraC5qb2luKCkrXCIsIDApO1xcbiAgICAgICAgKytcIitoW2MtMV0rXCI7XFxuICAgICAgICBcIitmK1wiIHNvdXJjZUxvY0cgPSBcIitmK1wiKFwiK2guam9pbigpK1wiLCAwKTtcXG4gICAgICAgICsrXCIraFtjLTJdK1wiO1xcbiAgICAgICAgXCIrZitcIiBzb3VyY2VMb2NBID0gXCIrZitcIihcIitoLmpvaW4oKStcIiwgMCk7XFxuICAgICAgICAtLVwiK2hbYy0xXStcIjtcXG4gICAgICAgIFwiK2YrXCIgc291cmNlTG9jQiA9IFwiK2YrXCIoXCIraC5qb2luKCkrXCIsIDApO1xcbiAgICAgICAgLS1cIitoW2MtMl0rXCI7XCJ9ZWxzZSBzPWMsaT1cIlxcbiAgICAgICAgXCIrbCtcIiBzb3VyY2VMb2NSID0gY29vcmRzO1xcbiAgICAgICAgKytcIitoW2MtMV0rXCI7XFxuICAgICAgICBcIitsK1wiIHNvdXJjZUxvY0cgPSBjb29yZHM7XFxuICAgICAgICArK1wiK2hbYy0yXStcIjtcXG4gICAgICAgIFwiK2wrXCIgc291cmNlTG9jQSA9IGNvb3JkcztcXG4gICAgICAgIC0tXCIraFtjLTFdK1wiO1xcbiAgICAgICAgXCIrbCtcIiBzb3VyY2VMb2NCID0gY29vcmRzO1xcbiAgICAgICAgLS1cIitoW2MtMl0rXCI7XCI7dmFyIGQ9W1wieFwiLFwieVwiLFwielwiLFwid1wiLFwidVwiLFwidlwiXS5zbGljZSgwLHMpLHA9XCIuXCIrZFtzLTFdLHY9ZC5tYXAoKGZ1bmN0aW9uKHQpe3JldHVyblwiaW50IFwiK3R9KSksbT1zYShcInNvdXJjZUxvY1JcIixzLTEpLmNvbmNhdChcImluSWR4LnJcIiksZz1zYShcInNvdXJjZUxvY0dcIixzLTEpLmNvbmNhdChcImluSWR4LmdcIikseT1zYShcInNvdXJjZUxvY0JcIixzLTEpLmNvbmNhdChcImluSWR4LmJcIikseD1zYShcInNvdXJjZUxvY0FcIixzLTEpLmNvbmNhdChcImluSWR4LmFcIiksYj1cIm1heFwiPT09bj9cImdyZWF0ZXJUaGFuXCI6XCJsZXNzVGhhblwiLHc9cj9cIlwiOlwiXFxuICAgICAgICAgIGluSWR4ID0gcm91bmQodmVjNChnZXRCZXN0SW5kaWNlc0FDaGFubmVsKFwiK20uam9pbigpK1wiKSxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdldEJlc3RJbmRpY2VzQUNoYW5uZWwoXCIrZy5qb2luKCkrXCIpLFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2V0QmVzdEluZGljZXNBQ2hhbm5lbChcIit5LmpvaW4oKStcIiksXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICBnZXRCZXN0SW5kaWNlc0FDaGFubmVsKFwiK3guam9pbigpK1wiKSkpO1wiLEU9XCJ2ZWM0KFxcbiAgICAgICAgICAgIGdldEFDaGFubmVsKFwiK20uam9pbigpK1wiKSxcXG4gICAgICAgICAgICBoYXNOZXh0Q29sID8gZ2V0QUNoYW5uZWwoXCIrZy5qb2luKCkrXCIpIDogMC4sXFxuICAgICAgICAgICAgaGFzTmV4dFJvdyA/IGdldEFDaGFubmVsKFwiK3kuam9pbigpK1wiKSA6IDAuLFxcbiAgICAgICAgICAgIGhhc05leHRSb3cgJiYgaGFzTmV4dENvbCA/IGdldEFDaGFubmVsKFwiK3guam9pbigpK1wiKSA6IDAuKVwiLFI9cj9cIlwiOlwiXFxuICAgICAgZmxvYXQgZ2V0QmVzdEluZGljZXNBQ2hhbm5lbChcIit2LmpvaW4oKStcIikge1xcbiAgICAgICAgcmV0dXJuIGdldENoYW5uZWwoZ2V0QmVzdEluZGljZXNBKFwiK2Quam9pbigpK1wiKSxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2ZWMyKFwiK2Quc2xpY2UoLTIpLmpvaW4oKStcIikpO1xcbiAgICAgIH1cIjt0aGlzLnVzZXJDb2RlPVwiXFxuICAgICAgZmxvYXQgZ2V0QUNoYW5uZWwoXCIrdi5qb2luKCkrXCIpIHtcXG4gICAgICAgIHJldHVybiBnZXRDaGFubmVsKGdldEEoXCIrZC5qb2luKCkrXCIpLFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2ZWMyKFwiK2Quc2xpY2UoLTIpLmpvaW4oKStcIikpO1xcbiAgICAgIH1cXG4gICAgICBcIitSK1wiXFxuICAgICAgdm9pZCBtYWluKCkge1xcbiAgICAgICAgXCIrbCtcIiBjb29yZHMgPSBnZXRPdXRwdXRDb29yZHMoKTtcXG4gICAgICAgIGJvb2wgaGFzTmV4dENvbCA9IFwiK2hbYy0xXStcIiA8IFwiKyh1W2MtMV0tMSkrXCI7XFxuICAgICAgICBib29sIGhhc05leHRSb3cgPSBcIitoW2MtMl0rXCIgPCBcIisodVtjLTJdLTEpK1wiO1xcbiAgICAgICAgXCIraStcIlxcbiAgICAgICAgaXZlYzQgc3JjSWR4ID0gaXZlYzQoc291cmNlTG9jUlwiK3ArXCIsIHNvdXJjZUxvY0dcIitwK1wiLFxcbiAgICAgICAgICBzb3VyY2VMb2NCXCIrcCtcIiwgc291cmNlTG9jQVwiK3ArXCIpICogXCIrZStcIjtcXG4gICAgICAgIGl2ZWM0IGluSWR4ID0gc3JjSWR4O1xcbiAgICAgICAgdmVjNCBiZXN0SW5kZXggPSB2ZWM0KGluSWR4KTtcXG4gICAgICAgIHZlYzQgYmVzdFZhbHVlID0gXCIrRStcIjtcXG5cXG4gICAgICAgIGZvciAoaW50IGkgPSAwOyBpIDwgXCIrZStcIjsgaSsrKSB7XFxuICAgICAgICAgIGluSWR4ID0gc3JjSWR4O1xcbiAgICAgICAgICBcIit3K1wiXFxuICAgICAgICAgIHZlYzQgY2FuZGlkYXRlID0gXCIrRStcIjtcXG4gICAgICAgICAgYnZlYzQgbmFuID0gaXNuYW4oY2FuZGlkYXRlKTtcXG4gICAgICAgICAgYnZlYzQgcmVwbGFjZSA9IGJ2ZWM0KFxcbiAgICAgICAgICAgIHZlYzQoXCIrYitcIihjYW5kaWRhdGUsIGJlc3RWYWx1ZSkpICogKHZlYzQoMS4wKSAtIHZlYzQobmFuKSkpO1xcblxcbiAgICAgICAgICBiZXN0VmFsdWUgPSB2ZWM0KHJlcGxhY2UueCAgPyBjYW5kaWRhdGUueCA6IGJlc3RWYWx1ZS54LFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcGxhY2UueSAgPyBjYW5kaWRhdGUueSA6IGJlc3RWYWx1ZS55LFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcGxhY2UueiAgPyBjYW5kaWRhdGUueiA6IGJlc3RWYWx1ZS56LFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcGxhY2UudyAgPyBjYW5kaWRhdGUudyA6IGJlc3RWYWx1ZS53KTtcXG4gICAgICAgICAgYmVzdEluZGV4ID0gbWl4KGJlc3RJbmRleCwgdmVjNChpbklkeCksIHZlYzQocmVwbGFjZSkpO1xcbiAgICAgICAgICBzcmNJZHgrKztcXG4gICAgICAgIH1cXG4gICAgICAgIHNldE91dHB1dChiZXN0SW5kZXgpO1xcbiAgICAgIH1cXG4gICAgXCJ9LElhPWZ1bmN0aW9uKHQpe3RoaXMudmFyaWFibGVOYW1lcz1bXCJkeVwiXSx0aGlzLm91dHB1dFNoYXBlPXQuaW5TaGFwZTt2YXIgZT10LmZpbHRlckhlaWdodCxuPXQuZmlsdGVyV2lkdGgscj10LnN0cmlkZUhlaWdodCxvPXQuc3RyaWRlV2lkdGgsYT10LmRpbGF0aW9uSGVpZ2h0LGk9dC5kaWxhdGlvbldpZHRoLHM9dC5lZmZlY3RpdmVGaWx0ZXJIZWlnaHQsdT10LmVmZmVjdGl2ZUZpbHRlcldpZHRoLGM9cy0xLXQucGFkSW5mby50b3AsbD11LTEtdC5wYWRJbmZvLmxlZnQsaD0xLyhlKm4pO3RoaXMudXNlckNvZGU9XCJcXG4gICAgICBjb25zdCBpdmVjMiBwYWRzID0gaXZlYzIoXCIrYytcIiwgXCIrbCtcIik7XFxuICAgICAgY29uc3QgZmxvYXQgYXZnTXVsdGlwbGllciA9IGZsb2F0KFwiK2grXCIpO1xcblxcbiAgICAgIHZvaWQgbWFpbigpIHtcXG4gICAgICAgIGl2ZWM0IGNvb3JkcyA9IGdldE91dHB1dENvb3JkcygpO1xcbiAgICAgICAgaW50IGIgPSBjb29yZHNbMF07XFxuICAgICAgICBpbnQgZCA9IGNvb3Jkc1szXTtcXG5cXG4gICAgICAgIGl2ZWMyIGR5UkNDb3JuZXIgPSBjb29yZHMueXogLSBwYWRzO1xcbiAgICAgICAgaW50IGR5UkNvcm5lciA9IGR5UkNDb3JuZXIueDtcXG4gICAgICAgIGludCBkeUNDb3JuZXIgPSBkeVJDQ29ybmVyLnk7XFxuXFxuICAgICAgICAvLyBDb252b2x2ZSBkeSg/LCA/LCBkKSB3aXRoIHBvcyBtYXNrKDosIDosIGQpIHRvIGdldCBkeCh4UiwgeEMsIGQpLlxcbiAgICAgICAgLy8gPyA9IHRvIGJlIGRldGVybWluZWQuIDogPSBhY3Jvc3MgYWxsIHZhbHVlcyBpbiB0aGF0IGF4aXMuXFxuICAgICAgICBmbG9hdCBkb3RQcm9kID0gMC4wO1xcbiAgICAgICAgZm9yIChpbnQgd1IgPSAwOyB3UiA8IFwiK3MrXCI7XFxuICAgICAgICAgICAgd1IgKz0gXCIrYStcIikge1xcbiAgICAgICAgICBmbG9hdCBkeVIgPSBmbG9hdChkeVJDb3JuZXIgKyB3UikgLyBcIityK1wiLjA7XFxuXFxuICAgICAgICAgIGlmIChkeVIgPCAwLjAgfHwgZHlSID49IFwiK3Qub3V0SGVpZ2h0K1wiLjAgfHwgZnJhY3QoZHlSKSA+IDAuMCkge1xcbiAgICAgICAgICAgIGNvbnRpbnVlO1xcbiAgICAgICAgICB9XFxuICAgICAgICAgIGludCBpZHlSID0gaW50KGR5Uik7XFxuXFxuICAgICAgICAgIGZvciAoaW50IHdDID0gMDsgd0MgPCBcIit1K1wiO1xcbiAgICAgICAgICAgIHdDKz0gXCIraStcIikge1xcbiAgICAgICAgICAgIGZsb2F0IGR5QyA9IGZsb2F0KGR5Q0Nvcm5lciArIHdDKSAvIFwiK28rXCIuMDtcXG5cXG4gICAgICAgICAgICBpZiAoZHlDIDwgMC4wIHx8IGR5QyA+PSBcIit0Lm91dFdpZHRoK1wiLjAgfHxcXG4gICAgICAgICAgICAgICAgZnJhY3QoZHlDKSA+IDAuMCkge1xcbiAgICAgICAgICAgICAgY29udGludWU7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIGludCBpZHlDID0gaW50KGR5Qyk7XFxuXFxuICAgICAgICAgICAgZmxvYXQgZHlWYWx1ZSA9IGdldER5KGIsIGlkeVIsIGlkeUMsIGQpO1xcblxcbiAgICAgICAgICAgIGRvdFByb2QgKz0gZHlWYWx1ZSAqIGF2Z011bHRpcGxpZXI7XFxuICAgICAgICAgIH1cXG4gICAgICAgIH1cXG4gICAgICAgIHNldE91dHB1dChkb3RQcm9kKTtcXG4gICAgICB9XFxuICAgIFwifSxrYT1mdW5jdGlvbih0KXt0aGlzLnZhcmlhYmxlTmFtZXM9W1wiZHlcIl0sdGhpcy5vdXRwdXRTaGFwZT10LmluU2hhcGU7dmFyIGU9dC5maWx0ZXJEZXB0aCxuPXQuZmlsdGVySGVpZ2h0LHI9dC5maWx0ZXJXaWR0aCxvPXQuc3RyaWRlRGVwdGgsYT10LnN0cmlkZUhlaWdodCxpPXQuc3RyaWRlV2lkdGgscz10LmRpbGF0aW9uRGVwdGgsdT10LmRpbGF0aW9uSGVpZ2h0LGM9dC5kaWxhdGlvbldpZHRoLGw9dC5lZmZlY3RpdmVGaWx0ZXJEZXB0aCxoPXQuZWZmZWN0aXZlRmlsdGVySGVpZ2h0LGY9dC5lZmZlY3RpdmVGaWx0ZXJXaWR0aCxkPWwtMS10LnBhZEluZm8uZnJvbnQscD1oLTEtdC5wYWRJbmZvLnRvcCx2PWYtMS10LnBhZEluZm8ubGVmdCxtPTEvKGUqbipyKTt0aGlzLnVzZXJDb2RlPVwiXFxuICAgICAgY29uc3QgaXZlYzMgcGFkcyA9IGl2ZWMzKFwiK2QrXCIsIFwiK3ArXCIsIFwiK3YrXCIpO1xcbiAgICAgIGNvbnN0IGZsb2F0IGF2Z011bHRpcGxpZXIgPSBmbG9hdChcIittK1wiKTtcXG5cXG4gICAgICB2b2lkIG1haW4oKSB7XFxuICAgICAgICBpdmVjNSBjb29yZHMgPSBnZXRPdXRwdXRDb29yZHMoKTtcXG4gICAgICAgIGludCBiYXRjaCA9IGNvb3Jkcy54O1xcbiAgICAgICAgaW50IGNoID0gY29vcmRzLnU7XFxuXFxuICAgICAgICBpdmVjMyBkeUNvcm5lciA9IGl2ZWMzKGNvb3Jkcy55LCBjb29yZHMueiwgY29vcmRzLncpIC0gcGFkcztcXG4gICAgICAgIGludCBkeURDb3JuZXIgPSBkeUNvcm5lci54O1xcbiAgICAgICAgaW50IGR5UkNvcm5lciA9IGR5Q29ybmVyLnk7XFxuICAgICAgICBpbnQgZHlDQ29ybmVyID0gZHlDb3JuZXIuejtcXG5cXG4gICAgICAgIC8vIENvbnZvbHZlIGR5KD8sID8sID8sIGQpIHdpdGggcG9zIG1hc2soOiwgOiwgOiwgY2gpIHRvIGdldFxcbiAgICAgICAgLy8gZHgoeEQsIHhSLCB4QywgY2gpLlxcbiAgICAgICAgLy8gPyA9IHRvIGJlIGRldGVybWluZWQuIDogPSBhY3Jvc3MgYWxsIHZhbHVlcyBpbiB0aGF0IGF4aXMuXFxuICAgICAgICBmbG9hdCBkb3RQcm9kID0gMC4wO1xcblxcbiAgICAgICAgZm9yIChpbnQgd0QgPSAwOyB3RCA8IFwiK2wrXCI7XFxuICAgICAgICAgICAgd0QgKz0gXCIrcytcIikge1xcbiAgICAgICAgICBmbG9hdCBkeUQgPSBmbG9hdChkeURDb3JuZXIgKyB3RCkgLyBcIitvK1wiLjA7XFxuXFxuICAgICAgICAgIGlmIChkeUQgPCAwLjAgfHwgZHlEID49IFwiK3Qub3V0RGVwdGgrXCIuMCB8fCBmcmFjdChkeUQpID4gMC4wKSB7XFxuICAgICAgICAgICAgY29udGludWU7XFxuICAgICAgICAgIH1cXG4gICAgICAgICAgaW50IGlkeUQgPSBpbnQoZHlEKTtcXG5cXG4gICAgICAgICAgZm9yIChpbnQgd1IgPSAwOyB3UiA8IFwiK2grXCI7XFxuICAgICAgICAgICAgICB3UiArPSBcIit1K1wiKSB7XFxuICAgICAgICAgICAgZmxvYXQgZHlSID0gZmxvYXQoZHlSQ29ybmVyICsgd1IpIC8gXCIrYStcIi4wO1xcblxcbiAgICAgICAgICAgIGlmIChkeVIgPCAwLjAgfHwgZHlSID49IFwiK3Qub3V0SGVpZ2h0K1wiLjAgfHxcXG4gICAgICAgICAgICAgICAgZnJhY3QoZHlSKSA+IDAuMCkge1xcbiAgICAgICAgICAgICAgY29udGludWU7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIGludCBpZHlSID0gaW50KGR5Uik7XFxuXFxuICAgICAgICAgICAgZm9yIChpbnQgd0MgPSAwOyB3QyA8IFwiK2YrXCI7XFxuICAgICAgICAgICAgICAgIHdDICs9IFwiK2MrXCIpIHtcXG4gICAgICAgICAgICAgIGZsb2F0IGR5QyA9IGZsb2F0KGR5Q0Nvcm5lciArIHdDKSAvIFwiK2krXCIuMDtcXG5cXG4gICAgICAgICAgICAgIGlmIChkeUMgPCAwLjAgfHwgZHlDID49IFwiK3Qub3V0V2lkdGgrXCIuMCB8fFxcbiAgICAgICAgICAgICAgICAgIGZyYWN0KGR5QykgPiAwLjApIHtcXG4gICAgICAgICAgICAgICAgY29udGludWU7XFxuICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICBpbnQgaWR5QyA9IGludChkeUMpO1xcblxcbiAgICAgICAgICAgICAgZmxvYXQgZHlWYWx1ZSA9IGdldER5KGJhdGNoLCBpZHlELCBpZHlSLCBpZHlDLCBjaCk7XFxuXFxuICAgICAgICAgICAgICBkb3RQcm9kICs9IGR5VmFsdWUgKiBhdmdNdWx0aXBsaWVyO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgfVxcbiAgICAgICAgfVxcbiAgICAgICAgc2V0T3V0cHV0KGRvdFByb2QpO1xcbiAgICAgIH1cXG4gICAgXCJ9LFNhPWZ1bmN0aW9uKHQsZSxuLHIsbyxhKXt0aGlzLm91dHB1dFNoYXBlPVtdLHRoaXMudmFyaWFibGVOYW1lcz1bXCJ4XCIsXCJtZWFuXCIsXCJ2YXJpYW5jZVwiXSxSbyh0LGUpLFJvKHQsbik7dmFyIGk9XCIwLjBcIjtudWxsIT1yJiYoUm8odCxyKSx0aGlzLnZhcmlhYmxlTmFtZXMucHVzaChcIm9mZnNldFwiKSxpPVwiZ2V0T2Zmc2V0QXRPdXRDb29yZHMoKVwiKTt2YXIgcz1cIjEuMFwiO251bGwhPW8mJihSbyh0LG8pLHRoaXMudmFyaWFibGVOYW1lcy5wdXNoKFwic2NhbGVcIikscz1cImdldFNjYWxlQXRPdXRDb29yZHMoKVwiKSx0aGlzLm91dHB1dFNoYXBlPXQsdGhpcy51c2VyQ29kZT1cIlxcbiAgICAgIHZvaWQgbWFpbigpIHtcXG4gICAgICAgIGZsb2F0IHggPSBnZXRYQXRPdXRDb29yZHMoKTtcXG4gICAgICAgIGZsb2F0IG1lYW4gPSBnZXRNZWFuQXRPdXRDb29yZHMoKTtcXG4gICAgICAgIGZsb2F0IHZhcmlhbmNlID0gZ2V0VmFyaWFuY2VBdE91dENvb3JkcygpO1xcbiAgICAgICAgZmxvYXQgb2Zmc2V0ID0gXCIraStcIjtcXG4gICAgICAgIGZsb2F0IHNjYWxlID0gXCIrcytcIjtcXG4gICAgICAgIGZsb2F0IGludiA9IHNjYWxlICogaW52ZXJzZXNxcnQodmFyaWFuY2UgKyBmbG9hdChcIithK1wiKSk7XFxuICAgICAgICBzZXRPdXRwdXQoZG90KHZlYzMoeCwgLW1lYW4sIG9mZnNldCksIHZlYzMoaW52LCBpbnYsIDEpKSk7XFxuICAgICAgfVxcbiAgICBcIn0sQWE9ZnVuY3Rpb24odCxlLG4scixvLGEpe3RoaXMucGFja2VkSW5wdXRzPSEwLHRoaXMucGFja2VkT3V0cHV0PSEwLHRoaXMudmFyaWFibGVOYW1lcz1bXCJ4XCIsXCJtZWFuXCIsXCJ2YXJpYW5jZVwiXSxSbyh0LGUpLFJvKHQsbik7dmFyIGk9XCJ2ZWM0KDAuMClcIjtudWxsIT1yJiYoUm8odCxyKSx0aGlzLnZhcmlhYmxlTmFtZXMucHVzaChcIm9mZnNldFwiKSxpPVwiZ2V0T2Zmc2V0QXRPdXRDb29yZHMoKVwiKTt2YXIgcz1cInZlYzQoMS4wKVwiO251bGwhPW8mJihSbyh0LG8pLHRoaXMudmFyaWFibGVOYW1lcy5wdXNoKFwic2NhbGVcIikscz1cImdldFNjYWxlQXRPdXRDb29yZHMoKVwiKSx0aGlzLm91dHB1dFNoYXBlPXQsdGhpcy51c2VyQ29kZT1cIlxcbiAgICAgIHZvaWQgbWFpbigpIHtcXG4gICAgICAgIHZlYzQgb2Zmc2V0ID0gXCIraStcIjtcXG4gICAgICAgIHZlYzQgc2NhbGUgPSBcIitzK1wiO1xcblxcbiAgICAgICAgdmVjNCB4ID0gZ2V0WEF0T3V0Q29vcmRzKCk7XFxuICAgICAgICB2ZWM0IG1lYW4gPSBnZXRNZWFuQXRPdXRDb29yZHMoKTtcXG4gICAgICAgIHZlYzQgdmFyaWFuY2UgPSBnZXRWYXJpYW5jZUF0T3V0Q29vcmRzKCk7XFxuXFxuICAgICAgICB2ZWM0IGludiA9IHNjYWxlICogaW52ZXJzZXNxcnQodmFyaWFuY2UgKyB2ZWM0KFwiK2ErXCIpKTtcXG5cXG4gICAgICAgIHNldE91dHB1dCgoeCAtIG1lYW4pICogaW52ICsgb2Zmc2V0KTtcXG4gICAgICB9XFxuICAgIFwifSxEYT1cInJldHVybiBhcmVhbCAqIGJyZWFsIC0gYWltYWcgKiBiaW1hZztcIixUYT1cInJldHVybiBhcmVhbCAqIGJpbWFnICsgYWltYWcgKiBicmVhbDtcIixOYT1mdW5jdGlvbih0LGUsbil7dGhpcy52YXJpYWJsZU5hbWVzPVtcIkFSZWFsXCIsXCJBSW1hZ1wiLFwiQlJlYWxcIixcIkJJbWFnXCJdLHRoaXMub3V0cHV0U2hhcGU9Um8oZSxuKSx0aGlzLnVzZXJDb2RlPVwiXFxuICAgICAgZmxvYXQgYmluYXJ5T3BDb21wbGV4KFxcbiAgICAgICAgICBmbG9hdCBhcmVhbCwgZmxvYXQgYWltYWcsIGZsb2F0IGJyZWFsLCBmbG9hdCBiaW1hZykge1xcbiAgICAgICAgXCIrdCtcIlxcbiAgICAgIH1cXG5cXG4gICAgICB2b2lkIG1haW4oKSB7XFxuICAgICAgICBmbG9hdCBhcmVhbCA9IGdldEFSZWFsQXRPdXRDb29yZHMoKTtcXG4gICAgICAgIGZsb2F0IGFpbWFnID0gZ2V0QUltYWdBdE91dENvb3JkcygpO1xcbiAgICAgICAgZmxvYXQgYnJlYWwgPSBnZXRCUmVhbEF0T3V0Q29vcmRzKCk7XFxuICAgICAgICBmbG9hdCBiaW1hZyA9IGdldEJJbWFnQXRPdXRDb29yZHMoKTtcXG4gICAgICAgIHNldE91dHB1dChiaW5hcnlPcENvbXBsZXgoYXJlYWwsIGFpbWFnLCBicmVhbCwgYmltYWcpKTtcXG4gICAgICB9XFxuICAgIFwifSxGYT1cInJldHVybiBhICsgYjtcIixfYT1cInJldHVybiBhIC0gYjtcIixPYT1cInJldHVybiBhICogYjtcIixNYT1cInJldHVybiAoYSA8IDAuKSA/IGIgKiBhIDogYTtcIixCYT1mdW5jdGlvbih0LGUsbil7dGhpcy52YXJpYWJsZU5hbWVzPVtcIkFcIixcIkJcIl0sdGhpcy5vdXRwdXRTaGFwZT1SbyhlLG4pLHRoaXMudXNlckNvZGU9XCJcXG4gICAgICBmbG9hdCBiaW5hcnlPcGVyYXRpb24oZmxvYXQgYSwgZmxvYXQgYikge1xcbiAgICAgICAgXCIrdCtcIlxcbiAgICAgIH1cXG5cXG4gICAgICB2b2lkIG1haW4oKSB7XFxuICAgICAgICBmbG9hdCBhID0gZ2V0QUF0T3V0Q29vcmRzKCk7XFxuICAgICAgICBmbG9hdCBiID0gZ2V0QkF0T3V0Q29vcmRzKCk7XFxuICAgICAgICBzZXRPdXRwdXQoYmluYXJ5T3BlcmF0aW9uKGEsIGIpKTtcXG4gICAgICB9XFxuICAgIFwifSxQYT1cIlxcbiAgdmVjNCBhTGVzc1RoYW5aZXJvID0gdmVjNChsZXNzVGhhbihhLCB2ZWM0KDAuKSkpO1xcbiAgcmV0dXJuIChhTGVzc1RoYW5aZXJvICogKGIgKiBhKSkgKyAoKHZlYzQoMS4wKSAtIGFMZXNzVGhhblplcm8pICogYSk7XFxuXCIsTGE9ZnVuY3Rpb24odCxlLG4scil7dm9pZCAwPT09ciYmKHI9ITEpLHRoaXMudmFyaWFibGVOYW1lcz1bXCJBXCIsXCJCXCJdLHRoaXMuc3VwcG9ydHNCcm9hZGNhc3Rpbmc9ITAsdGhpcy5wYWNrZWRJbnB1dHM9ITAsdGhpcy5wYWNrZWRPdXRwdXQ9ITAsdGhpcy5vdXRwdXRTaGFwZT1SbyhlLG4pO3ZhciBvPXRoaXMub3V0cHV0U2hhcGUubGVuZ3RoLGE9XCJcIjtpZihyKWlmKDA9PT1vfHwxPT09ayh0aGlzLm91dHB1dFNoYXBlKSlhPVwiXFxuICAgICAgICAgIHJlc3VsdC55ID0gMC47XFxuICAgICAgICAgIHJlc3VsdC56ID0gMC47XFxuICAgICAgICAgIHJlc3VsdC53ID0gMC47XFxuICAgICAgICBcIjtlbHNlIGlmKGE9XCJcXG4gICAgICAgICAgXCIrd2EobykrXCIgY29vcmRzID0gZ2V0T3V0cHV0Q29vcmRzKCk7XFxuICAgICAgICBcIiwxPT09bylhKz1cIlxcbiAgICAgICAgICAgIHJlc3VsdC55ID0gKGNvb3JkcyArIDEpID49IFwiK3RoaXMub3V0cHV0U2hhcGVbMF0rXCIgPyAwLiA6IHJlc3VsdC55O1xcbiAgICAgICAgICAgIHJlc3VsdC56ID0gMC47XFxuICAgICAgICAgICAgcmVzdWx0LncgPSAwLjtcXG4gICAgICAgICAgXCI7ZWxzZXt2YXIgaT1zYShcImNvb3Jkc1wiLG8pO2ErPVwiXFxuICAgICAgICAgICAgYm9vbCBuZXh0Um93T3V0T2ZCb3VuZHMgPVxcbiAgICAgICAgICAgICAgKFwiK2lbby0yXStcIiArIDEpID49IFwiK3RoaXMub3V0cHV0U2hhcGVbby0yXStcIjtcXG4gICAgICAgICAgICBib29sIG5leHRDb2xPdXRPZkJvdW5kcyA9XFxuICAgICAgICAgICAgICAoXCIraVtvLTFdK1wiICsgMSkgPj0gXCIrdGhpcy5vdXRwdXRTaGFwZVtvLTFdK1wiO1xcbiAgICAgICAgICAgIHJlc3VsdC55ID0gbmV4dENvbE91dE9mQm91bmRzID8gMC4gOiByZXN1bHQueTtcXG4gICAgICAgICAgICByZXN1bHQueiA9IG5leHRSb3dPdXRPZkJvdW5kcyA/IDAuIDogcmVzdWx0Lno7XFxuICAgICAgICAgICAgcmVzdWx0LncgPSBuZXh0Q29sT3V0T2ZCb3VuZHMgfHwgbmV4dFJvd091dE9mQm91bmRzID8gMC4gOiByZXN1bHQudztcXG4gICAgICAgICAgXCJ9dGhpcy51c2VyQ29kZT1cIlxcbiAgICAgIHZlYzQgYmluYXJ5T3BlcmF0aW9uKHZlYzQgYSwgdmVjNCBiKSB7XFxuICAgICAgICBcIit0K1wiXFxuICAgICAgfVxcblxcbiAgICAgIHZvaWQgbWFpbigpIHtcXG4gICAgICAgIHZlYzQgYSA9IGdldEFBdE91dENvb3JkcygpO1xcbiAgICAgICAgdmVjNCBiID0gZ2V0QkF0T3V0Q29vcmRzKCk7XFxuXFxuICAgICAgICB2ZWM0IHJlc3VsdCA9IGJpbmFyeU9wZXJhdGlvbihhLCBiKTtcXG4gICAgICAgIFwiK2ErXCJcXG5cXG4gICAgICAgIHNldE91dHB1dChyZXN1bHQpO1xcbiAgICAgIH1cXG4gICAgXCJ9LFdhPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gdCh0KXt0aGlzLnZhcmlhYmxlTmFtZXM9W1wiQVwiXSx0aGlzLm91dHB1dFNoYXBlPXQsdGhpcy51c2VyQ29kZT1cIlxcbiAgICAgIHVuaWZvcm0gZmxvYXQgbWluVmFsO1xcbiAgICAgIHVuaWZvcm0gZmxvYXQgbWF4VmFsO1xcblxcbiAgICAgIHZvaWQgbWFpbigpIHtcXG4gICAgICAgIGZsb2F0IHZhbHVlID0gZ2V0QUF0T3V0Q29vcmRzKCk7XFxuICAgICAgICBpZiAoaXNuYW4odmFsdWUpKSB7XFxuICAgICAgICAgIHNldE91dHB1dCh2YWx1ZSk7XFxuICAgICAgICAgIHJldHVybjtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIHNldE91dHB1dChjbGFtcCh2YWx1ZSwgbWluVmFsLCBtYXhWYWwpKTtcXG4gICAgICB9XFxuICAgIFwifXJldHVybiB0LnByb3RvdHlwZS5nZXRDdXN0b21TZXR1cEZ1bmM9ZnVuY3Rpb24odCxlKXt2YXIgbj10aGlzO3JldHVybiBmdW5jdGlvbihyLG8pe251bGw9PW4ubWluTG9jJiYobi5taW5Mb2M9ci5nZXRVbmlmb3JtTG9jYXRpb25Ob1Rocm93KG8sXCJtaW5WYWxcIiksbi5tYXhMb2M9ci5nZXRVbmlmb3JtTG9jYXRpb25Ob1Rocm93KG8sXCJtYXhWYWxcIikpLHIuZ2wudW5pZm9ybTFmKG4ubWluTG9jLHQpLHIuZ2wudW5pZm9ybTFmKG4ubWF4TG9jLGUpfX0sdH0oKSxVYT1mdW5jdGlvbigpe2Z1bmN0aW9uIHQodCl7dGhpcy52YXJpYWJsZU5hbWVzPVtcIkFcIl0sdGhpcy5wYWNrZWRJbnB1dHM9ITAsdGhpcy5wYWNrZWRPdXRwdXQ9ITAsdGhpcy5vdXRwdXRTaGFwZT10LHRoaXMudXNlckNvZGU9XCJcXG4gICAgICB1bmlmb3JtIGZsb2F0IG1pblZhbDtcXG4gICAgICB1bmlmb3JtIGZsb2F0IG1heFZhbDtcXG5cXG4gICAgICB2b2lkIG1haW4oKSB7XFxuICAgICAgICB2ZWM0IHZhbHVlID0gZ2V0QUF0T3V0Q29vcmRzKCk7XFxuXFxuICAgICAgICBpZiAoYW55KGlzbmFuKHZhbHVlKSkpIHtcXG4gICAgICAgICAgc2V0T3V0cHV0KHZhbHVlKTtcXG4gICAgICAgICAgcmV0dXJuO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgc2V0T3V0cHV0KGNsYW1wKHZhbHVlLCB2ZWM0KG1pblZhbCksIHZlYzQobWF4VmFsKSkpO1xcbiAgICAgIH1cXG4gICAgXCJ9cmV0dXJuIHQucHJvdG90eXBlLmdldEN1c3RvbVNldHVwRnVuYz1mdW5jdGlvbih0LGUpe3ZhciBuPXRoaXM7cmV0dXJuIGZ1bmN0aW9uKHIsbyl7bnVsbD09bi5taW5Mb2MmJihuLm1pbkxvYz1yLmdldFVuaWZvcm1Mb2NhdGlvbk5vVGhyb3cobyxcIm1pblZhbFwiKSxuLm1heExvYz1yLmdldFVuaWZvcm1Mb2NhdGlvbk5vVGhyb3cobyxcIm1heFZhbFwiKSksci5nbC51bmlmb3JtMWYobi5taW5Mb2MsdCksci5nbC51bmlmb3JtMWYobi5tYXhMb2MsZSl9fSx0fSgpLFZhPWZ1bmN0aW9uKHQpe3RoaXMudmFyaWFibGVOYW1lcz1bXCJyZWFsXCIsXCJpbWFnXCJdLHRoaXMub3V0cHV0U2hhcGU9dCx0aGlzLnVzZXJDb2RlPVwiXFxuICAgICAgdm9pZCBtYWluKCkge1xcbiAgICAgICAgZmxvYXQgcmUgPSBhYnMoZ2V0UmVhbEF0T3V0Q29vcmRzKCkpO1xcbiAgICAgICAgZmxvYXQgaW0gPSBhYnMoZ2V0SW1hZ0F0T3V0Q29vcmRzKCkpO1xcbiAgICAgICAgZmxvYXQgbXggPSBtYXgocmUsIGltKTtcXG5cXG4gICAgICAgIC8vIHNhZGx5IHRoZSBsZW5ndGggZnVuY3Rpb24gaW4gZ2xzbCBpcyBub3QgdW5kZXJmbG93LXNhZmVcXG4gICAgICAgIC8vIChhdCBsZWFzdCBub3Qgb24gSW50ZWwgR1BVcykuIFNvIHRoZSBzYWZlIHNvbHV0aW9uIGlzXFxuICAgICAgICAvLyB0byBlbnN1cmUgdW5kZXJmbG93LXNhZmV0eSBpbiBhbGwgY2FzZXMuXFxuICAgICAgICBzZXRPdXRwdXQoXFxuICAgICAgICAgIG14ID09IDAuMCA/IDAuMCA6IG14ICogbGVuZ3RoKHZlYzIoMSwgbWluKHJlLCBpbSkvbXgpKVxcbiAgICAgICAgKTtcXG4gICAgICB9XFxuICAgIFwifSx6YT1mdW5jdGlvbih0KXt0aGlzLm91dHB1dFNoYXBlPVtdLHRoaXMub3V0cHV0U2hhcGU9U24odCwxKSx0aGlzLnZhcmlhYmxlTmFtZXM9dC5tYXAoKGZ1bmN0aW9uKHQsZSl7cmV0dXJuXCJUXCIrZX0pKTt2YXIgZT1uZXcgQXJyYXkodC5sZW5ndGgtMSk7ZVswXT10WzBdWzFdO2Zvcih2YXIgbj0xO248ZS5sZW5ndGg7bisrKWVbbl09ZVtuLTFdK3Rbbl1bMV07dmFyIHI9W1wiaWYgKHlDIDwgXCIrZVswXStcIikgc2V0T3V0cHV0KGdldFQwKHlSLCB5QykpO1wiXTtmb3Iobj0xO248ZS5sZW5ndGg7bisrKXt2YXIgbz1lW24tMV07ci5wdXNoKFwiZWxzZSBpZiAoeUMgPCBcIitlW25dK1wiKSBzZXRPdXRwdXQoZ2V0VFwiK24rXCIoeVIsIHlDLVwiK28rXCIpKTtcIil9dmFyIGE9ZS5sZW5ndGgsaT1lW2UubGVuZ3RoLTFdO3IucHVzaChcImVsc2Ugc2V0T3V0cHV0KGdldFRcIithK1wiKHlSLCB5Qy1cIitpK1wiKSk7XCIpLHRoaXMudXNlckNvZGU9XCJcXG4gICAgICB2b2lkIG1haW4oKSB7XFxuICAgICAgICBpdmVjMiBjb29yZHMgPSBnZXRPdXRwdXRDb29yZHMoKTtcXG4gICAgICAgIGludCB5UiA9IGNvb3Jkcy54O1xcbiAgICAgICAgaW50IHlDID0gY29vcmRzLnk7XFxuXFxuICAgICAgICBcIityLmpvaW4oXCJcXG4gICAgICAgIFwiKStcIlxcbiAgICAgIH1cXG4gICAgXCJ9LEdhPWZ1bmN0aW9uKHQsZSl7dGhpcy5wYWNrZWRJbnB1dHM9ITAsdGhpcy5wYWNrZWRPdXRwdXQ9ITAsdGhpcy5vdXRwdXRTaGFwZT1bXSx0aGlzLm91dHB1dFNoYXBlPVNuKHQsZSk7dmFyIG49dGhpcy5vdXRwdXRTaGFwZSxyPW4ubGVuZ3RoLG89d2EociksYT1zYShcImNvb3Jkc1wiLHIpLGk9W1wieFwiLFwieVwiLFwielwiLFwid1wiLFwidVwiLFwidlwiXS5zbGljZSgwLHIpO3RoaXMudmFyaWFibGVOYW1lcz10Lm1hcCgoZnVuY3Rpb24odCxlKXtyZXR1cm5cIlRcIitlfSkpO3ZhciBzPW5ldyBBcnJheSh0Lmxlbmd0aC0xKTtzWzBdPXRbMF1bZV07Zm9yKHZhciB1PTE7dTxzLmxlbmd0aDt1Kyspc1t1XT1zW3UtMV0rdFt1XVtlXTt2YXIgYz1pW2VdLGw9aS5zbGljZSgtMiksaD1pLmpvaW4oKSxmPVwiaWYgKFwiK2MrXCIgPCBcIitzWzBdK1wiKSB7XFxuICAgICAgICByZXR1cm4gZ2V0Q2hhbm5lbChcXG4gICAgICAgICAgICBnZXRUMChcIitoK1wiKSwgdmVjMihcIitsLmpvaW4oKStcIikpO1xcbiAgICAgICAgfVwiO2Zvcih1PTE7dTxzLmxlbmd0aDt1Kyspe3ZhciBkPXNbdS0xXTtmKz1cIlxcbiAgICAgICAgaWYgKFwiK2MrXCIgPCBcIitzW3VdK1wiICAmJiBcIitjK1wiID49IFwiK3NbdS0xXStcIikge1xcbiAgICAgICAgICByZXR1cm4gZ2V0Q2hhbm5lbChcXG4gICAgICAgICAgICBnZXRUXCIrdStcIihcIitIYShpLGMsZCkrXCIpLFxcbiAgICAgICAgICAgIHZlYzIoXCIrSGEobCxjLGQpK1wiKSk7XFxuICAgICAgICB9XCJ9dmFyIHA9cy5sZW5ndGgsdj1zW3MubGVuZ3RoLTFdO2YrPVwiXFxuICAgICAgICByZXR1cm4gZ2V0Q2hhbm5lbChcXG4gICAgICAgICAgZ2V0VFwiK3ArXCIoXCIrSGEoaSxjLHYpK1wiKSxcXG4gICAgICAgICAgdmVjMihcIitIYShsLGMsdikrXCIpKTtcIix0aGlzLnVzZXJDb2RlPVwiXFxuICAgICAgZmxvYXQgZ2V0VmFsdWUoXCIraS5tYXAoKGZ1bmN0aW9uKHQpe3JldHVyblwiaW50IFwiK3R9KSkrXCIpIHtcXG4gICAgICAgIFwiK2YrXCJcXG4gICAgICB9XFxuXFxuICAgICAgdm9pZCBtYWluKCkge1xcbiAgICAgICAgXCIrbytcIiBjb29yZHMgPSBnZXRPdXRwdXRDb29yZHMoKTtcXG4gICAgICAgIHZlYzQgcmVzdWx0ID0gdmVjNChnZXRWYWx1ZShcIithK1wiKSwgMC4sIDAuLCAwLik7XFxuXFxuICAgICAgICBcIithW3ItMV0rXCIgPSBcIithW3ItMV0rXCIgKyAxO1xcbiAgICAgICAgaWYgKFwiK2Fbci0xXStcIiA8IFwiK25bci0xXStcIikge1xcbiAgICAgICAgICByZXN1bHQuZyA9IGdldFZhbHVlKFwiK2ErXCIpO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgXCIrYVtyLTJdK1wiID0gXCIrYVtyLTJdK1wiICsgMTtcXG4gICAgICAgIGlmIChcIithW3ItMl0rXCIgPCBcIituW3ItMl0rXCIpIHtcXG4gICAgICAgICAgcmVzdWx0LmEgPSBnZXRWYWx1ZShcIithK1wiKTtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIFwiK2Fbci0xXStcIiA9IFwiK2Fbci0xXStcIiAtIDE7XFxuICAgICAgICBpZiAoXCIrYVtyLTJdK1wiIDwgXCIrbltyLTJdK1wiICYmXFxuICAgICAgICAgICAgXCIrYVtyLTFdK1wiIDwgXCIrbltyLTFdK1wiKSB7XFxuICAgICAgICAgIHJlc3VsdC5iID0gZ2V0VmFsdWUoXCIrYStcIik7XFxuICAgICAgICB9XFxuICAgICAgICBzZXRPdXRwdXQocmVzdWx0KTtcXG4gICAgICB9XFxuICAgIFwifTtmdW5jdGlvbiBIYSh0LGUsbil7dmFyIHI9dC5pbmRleE9mKGUpO3JldHVybiB0Lm1hcCgoZnVuY3Rpb24odCxlKXtyZXR1cm4gZT09PXI/dCtcIiAtIFwiK246dH0pKS5qb2luKCl9dmFyIHFhPWZ1bmN0aW9uKHQpe3RoaXMudmFyaWFibGVOYW1lcz1bXCJ4XCIsXCJkeVwiXSx0aGlzLm91dHB1dFNoYXBlPXQuZmlsdGVyU2hhcGU7dmFyIGU9dC5zdHJpZGVIZWlnaHQsbj10LnN0cmlkZVdpZHRoLHI9dC5wYWRJbmZvLnRvcCxvPXQucGFkSW5mby5sZWZ0LGE9XCJjaGFubmVsc0xhc3RcIj09PXQuZGF0YUZvcm1hdDt0aGlzLnVzZXJDb2RlPVwiXFxuICAgICAgdm9pZCBtYWluKCkge1xcbiAgICAgICAgaXZlYzQgY29vcmRzID0gZ2V0T3V0cHV0Q29vcmRzKCk7XFxuICAgICAgICBpbnQgd1IgPSBjb29yZHMueDtcXG4gICAgICAgIGludCB3QyA9IGNvb3Jkcy55O1xcbiAgICAgICAgaW50IGQxID0gY29vcmRzLno7XFxuICAgICAgICBpbnQgZDIgPSBjb29yZHMudztcXG5cXG4gICAgICAgIC8vIENvbnZvbHZlIHgoPywgPywgZDEpIHdpdGggZHkoOiwgOiwgZDIpIHRvIGdldCBkdyh3Uiwgd0MsIGQxLCBkMikuXFxuICAgICAgICAvLyA/ID0gdG8gYmUgZGV0ZXJtaW5lZC4gOiA9IGFjcm9zcyBhbGwgdmFsdWVzIGluIHRoYXQgYXhpcy5cXG4gICAgICAgIGZsb2F0IGRvdFByb2QgPSAwLjA7XFxuXFxuICAgICAgICBmb3IgKGludCBiID0gMDsgYiA8IFwiK3QuYmF0Y2hTaXplK1wiOyBiKyspIHtcXG4gICAgICAgICAgZm9yIChpbnQgeVIgPSAwOyB5UiA8IFwiK3Qub3V0SGVpZ2h0K1wiOyB5UisrKSB7XFxuICAgICAgICAgICAgaW50IHhSID0gd1IgKyB5UiAqIFwiK2UrXCIgLSBcIityK1wiO1xcblxcbiAgICAgICAgICAgIGlmICh4UiA8IDAgfHwgeFIgPj0gXCIrdC5pbkhlaWdodCtcIikge1xcbiAgICAgICAgICAgICAgY29udGludWU7XFxuICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgIGZvciAoaW50IHlDID0gMDsgeUMgPCBcIit0Lm91dFdpZHRoK1wiOyB5QysrKSB7XFxuICAgICAgICAgICAgICBpbnQgeEMgPSB3QyArIHlDICogXCIrbitcIiAtIFwiK28rXCI7XFxuXFxuICAgICAgICAgICAgICBpZiAoeEMgPCAwIHx8IHhDID49IFwiK3QuaW5XaWR0aCtcIikge1xcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcXG4gICAgICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgICAgIGlmIChcIithK1wiKSB7XFxuICAgICAgICAgICAgICAgIGZsb2F0IGR5VmFsdWUgPSBnZXREeShiLCB5UiwgeUMsIGQyKTtcXG4gICAgICAgICAgICAgICAgZmxvYXQgeFZhbHVlID0gZ2V0WChiLCB4UiwgeEMsIGQxKTtcXG4gICAgICAgICAgICAgICAgZG90UHJvZCArPSAoeFZhbHVlICogZHlWYWx1ZSk7XFxuICAgICAgICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgICAgICBmbG9hdCBkeVZhbHVlID0gZ2V0RHkoYiwgZDIsIHlSLCB5Qyk7XFxuICAgICAgICAgICAgICAgIGZsb2F0IHhWYWx1ZSA9IGdldFgoYiwgZDEsIHhSLCB4Qyk7XFxuICAgICAgICAgICAgICAgIGRvdFByb2QgKz0gKHhWYWx1ZSAqIGR5VmFsdWUpO1xcbiAgICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgfVxcbiAgICAgICAgfVxcbiAgICAgICAgc2V0T3V0cHV0KGRvdFByb2QpO1xcbiAgICAgIH1cXG4gICAgXCJ9LEthPWZ1bmN0aW9uKHQpe3RoaXMudmFyaWFibGVOYW1lcz1bXCJkeVwiLFwiV1wiXSx0aGlzLm91dHB1dFNoYXBlPXQuaW5TaGFwZTt2YXIgZT10LmZpbHRlckhlaWdodCxuPXQuZmlsdGVyV2lkdGgscj10LnN0cmlkZUhlaWdodCxvPXQuc3RyaWRlV2lkdGgsYT1cImNoYW5uZWxzTGFzdFwiPT09dC5kYXRhRm9ybWF0LGk9ZS0xLXQucGFkSW5mby50b3Ascz1uLTEtdC5wYWRJbmZvLmxlZnQsdT1hPzE6MixjPWE/MjozLGw9YT8zOjE7dGhpcy51c2VyQ29kZT1cIlxcbiAgICAgIGNvbnN0IGl2ZWMyIHBhZHMgPSBpdmVjMihcIitpK1wiLCBcIitzK1wiKTtcXG5cXG4gICAgICB2b2lkIG1haW4oKSB7XFxuICAgICAgICBpdmVjNCBjb29yZHMgPSBnZXRPdXRwdXRDb29yZHMoKTtcXG4gICAgICAgIGludCBiYXRjaCA9IGNvb3Jkc1swXTtcXG4gICAgICAgIGludCBkMSA9IGNvb3Jkc1tcIitsK1wiXTtcXG5cXG4gICAgICAgIGl2ZWMyIGR5Q29ybmVyID0gaXZlYzIoY29vcmRzW1wiK3UrXCJdLCBjb29yZHNbXCIrYytcIl0pIC0gcGFkcztcXG4gICAgICAgIGludCBkeVJDb3JuZXIgPSBkeUNvcm5lci54O1xcbiAgICAgICAgaW50IGR5Q0Nvcm5lciA9IGR5Q29ybmVyLnk7XFxuXFxuICAgICAgICAvLyBDb252b2x2ZSBkeSg/LCA/LCBkMikgd2l0aCB3KDosIDosIGQxLCBkMikgdG8gY29tcHV0ZSBkeCh4UiwgeEMsIGQxKS5cXG4gICAgICAgIC8vID8gPSB0byBiZSBkZXRlcm1pbmVkLiA6ID0gYWNyb3NzIGFsbCB2YWx1ZXMgaW4gdGhhdCBheGlzLlxcbiAgICAgICAgZmxvYXQgZG90UHJvZCA9IDAuMDtcXG4gICAgICAgIGZvciAoaW50IHdSID0gMDsgd1IgPCBcIitlK1wiOyB3UisrKSB7XFxuICAgICAgICAgIGZsb2F0IGR5UiA9IGZsb2F0KGR5UkNvcm5lciArIHdSKSAvIFwiK3IrXCIuMDtcXG5cXG4gICAgICAgICAgaWYgKGR5UiA8IDAuMCB8fCBkeVIgPj0gXCIrdC5vdXRIZWlnaHQrXCIuMCB8fCBmcmFjdChkeVIpID4gMC4wKSB7XFxuICAgICAgICAgICAgY29udGludWU7XFxuICAgICAgICAgIH1cXG4gICAgICAgICAgaW50IGlkeVIgPSBpbnQoZHlSKTtcXG5cXG4gICAgICAgICAgaW50IHdSUGVybSA9IFwiK2UrXCIgLSAxIC0gd1I7XFxuXFxuICAgICAgICAgIGZvciAoaW50IHdDID0gMDsgd0MgPCBcIituK1wiOyB3QysrKSB7XFxuICAgICAgICAgICAgZmxvYXQgZHlDID0gZmxvYXQoZHlDQ29ybmVyICsgd0MpIC8gXCIrbytcIi4wO1xcblxcbiAgICAgICAgICAgIGlmIChkeUMgPCAwLjAgfHwgZHlDID49IFwiK3Qub3V0V2lkdGgrXCIuMCB8fFxcbiAgICAgICAgICAgICAgICBmcmFjdChkeUMpID4gMC4wKSB7XFxuICAgICAgICAgICAgICBjb250aW51ZTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgICAgaW50IGlkeUMgPSBpbnQoZHlDKTtcXG5cXG4gICAgICAgICAgICBpbnQgd0NQZXJtID0gXCIrbitcIiAtIDEgLSB3QztcXG5cXG4gICAgICAgICAgICBmb3IgKGludCBkMiA9IDA7IGQyIDwgXCIrdC5vdXRDaGFubmVscytcIjsgZDIrKykge1xcblxcbiAgICAgICAgICAgICAgaWYgKFwiK2ErXCIpIHtcXG4gICAgICAgICAgICAgICAgZmxvYXQgeFZhbHVlID0gZ2V0RHkoYmF0Y2gsIGlkeVIsIGlkeUMsIGQyKTtcXG4gICAgICAgICAgICAgICAgZmxvYXQgd1ZhbHVlID0gZ2V0Vyh3UlBlcm0sIHdDUGVybSwgZDEsIGQyKTtcXG4gICAgICAgICAgICAgICAgZG90UHJvZCArPSB4VmFsdWUgKiB3VmFsdWU7XFxuICAgICAgICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgICAgICBmbG9hdCB4VmFsdWUgPSBnZXREeShiYXRjaCwgZDIsIGlkeVIsIGlkeUMpO1xcbiAgICAgICAgICAgICAgICBmbG9hdCB3VmFsdWUgPSBnZXRXKHdSUGVybSwgd0NQZXJtLCBkMSwgZDIpO1xcbiAgICAgICAgICAgICAgICBkb3RQcm9kICs9IHhWYWx1ZSAqIHdWYWx1ZTtcXG4gICAgICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgICB9XFxuICAgICAgICAgIH1cXG4gICAgICAgIH1cXG4gICAgICAgIHNldE91dHB1dChkb3RQcm9kKTtcXG4gICAgICB9XFxuICAgIFwifSxqYT1mdW5jdGlvbih0KXt0aGlzLnZhcmlhYmxlTmFtZXM9W1wieFwiLFwiZHlcIl0sdGhpcy5vdXRwdXRTaGFwZT10LmZpbHRlclNoYXBlO3ZhciBlPXQuc3RyaWRlRGVwdGgsbj10LnN0cmlkZUhlaWdodCxyPXQuc3RyaWRlV2lkdGgsbz10LnBhZEluZm8uZnJvbnQsYT10LnBhZEluZm8udG9wLGk9dC5wYWRJbmZvLmxlZnQ7dGhpcy51c2VyQ29kZT1cIlxcbiAgICAgIHZvaWQgbWFpbigpIHtcXG4gICAgICAgIGl2ZWM1IGNvb3JkcyA9IGdldE91dHB1dENvb3JkcygpO1xcbiAgICAgICAgaW50IHdGID0gY29vcmRzLng7XFxuICAgICAgICBpbnQgd1IgPSBjb29yZHMueTtcXG4gICAgICAgIGludCB3QyA9IGNvb3Jkcy56O1xcbiAgICAgICAgaW50IGQxID0gY29vcmRzLnc7XFxuICAgICAgICBpbnQgZDIgPSBjb29yZHMudTtcXG5cXG4gICAgICAgIGZsb2F0IGRvdFByb2QgPSAwLjA7XFxuXFxuICAgICAgICBmb3IgKGludCBiID0gMDsgYiA8IFwiK3QuYmF0Y2hTaXplK1wiOyBiKyspIHtcXG4gICAgICAgICAgZm9yIChpbnQgeUYgPSAwOyB5RiA8IFwiK3Qub3V0RGVwdGgrXCI7IHlGKyspIHtcXG4gICAgICAgICAgICBpbnQgeEYgPSB3RiArIHlGICogXCIrZStcIiAtIFwiK28rXCI7XFxuXFxuICAgICAgICAgICAgaWYgKHhGIDwgMCB8fCB4RiA+PSBcIit0LmluRGVwdGgrXCIpIHtcXG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xcbiAgICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgICBmb3IgKGludCB5UiA9IDA7IHlSIDwgXCIrdC5vdXRIZWlnaHQrXCI7IHlSKyspIHtcXG4gICAgICAgICAgICAgIGludCB4UiA9IHdSICsgeVIgKiBcIituK1wiIC0gXCIrYStcIjtcXG5cXG4gICAgICAgICAgICAgIGlmICh4UiA8IDAgfHwgeFIgPj0gXCIrdC5pbkhlaWdodCtcIikge1xcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcXG4gICAgICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgICAgIGZvciAoaW50IHlDID0gMDsgeUMgPCBcIit0Lm91dFdpZHRoK1wiOyB5QysrKSB7XFxuICAgICAgICAgICAgICAgIGludCB4QyA9IHdDICsgeUMgKiBcIityK1wiIC0gXCIraStcIjtcXG5cXG4gICAgICAgICAgICAgICAgaWYgKHhDIDwgMCB8fCB4QyA+PSBcIit0LmluV2lkdGgrXCIpIHtcXG4gICAgICAgICAgICAgICAgICBjb250aW51ZTtcXG4gICAgICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgICAgICBmbG9hdCBkeVZhbHVlID0gZ2V0RHkoYiwgeUYsIHlSLCB5QywgZDIpO1xcbiAgICAgICAgICAgICAgICBmbG9hdCB4VmFsdWUgPSBnZXRYKGIsIHhGLCB4UiwgeEMsIGQxKTtcXG4gICAgICAgICAgICAgICAgZG90UHJvZCArPSAoeFZhbHVlICogZHlWYWx1ZSk7XFxuICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICB9XFxuICAgICAgICB9XFxuICAgICAgICBzZXRPdXRwdXQoZG90UHJvZCk7XFxuICAgICAgfVxcbiAgICBcIn0sWGE9ZnVuY3Rpb24odCl7dGhpcy52YXJpYWJsZU5hbWVzPVtcImR5XCIsXCJXXCJdLHRoaXMub3V0cHV0U2hhcGU9dC5pblNoYXBlO3ZhciBlPXQuZmlsdGVyRGVwdGgsbj10LmZpbHRlckhlaWdodCxyPXQuZmlsdGVyV2lkdGgsbz10LnN0cmlkZURlcHRoLGE9dC5zdHJpZGVIZWlnaHQsaT10LnN0cmlkZVdpZHRoLHM9ZS0xLXQucGFkSW5mby5mcm9udCx1PW4tMS10LnBhZEluZm8udG9wLGM9ci0xLXQucGFkSW5mby5sZWZ0O3RoaXMudXNlckNvZGU9XCJcXG4gICAgICBjb25zdCBpdmVjMyBwYWRzID0gaXZlYzMoXCIrcytcIiwgXCIrdStcIiwgXCIrYytcIik7XFxuXFxuICAgICAgdm9pZCBtYWluKCkge1xcbiAgICAgICAgaXZlYzUgY29vcmRzID0gZ2V0T3V0cHV0Q29vcmRzKCk7XFxuICAgICAgICBpbnQgYmF0Y2ggPSBjb29yZHMueDtcXG4gICAgICAgIGludCBkMSA9IGNvb3Jkcy51O1xcblxcblxcbiAgICAgICAgaXZlYzMgZHlDb3JuZXIgPSBpdmVjMyhjb29yZHMueSwgY29vcmRzLnosIGNvb3Jkcy53KSAtIHBhZHM7XFxuICAgICAgICBpbnQgZHlGQ29ybmVyID0gZHlDb3JuZXIueDtcXG4gICAgICAgIGludCBkeVJDb3JuZXIgPSBkeUNvcm5lci55O1xcbiAgICAgICAgaW50IGR5Q0Nvcm5lciA9IGR5Q29ybmVyLno7XFxuXFxuICAgICAgICBmbG9hdCBkb3RQcm9kID0gMC4wO1xcbiAgICAgICAgZm9yIChpbnQgd0YgPSAwOyB3RiA8IFwiK2UrXCI7IHdGKyspIHtcXG4gICAgICAgICAgZmxvYXQgZHlGID0gZmxvYXQoZHlGQ29ybmVyICsgd0YpIC8gXCIrbytcIi4wO1xcblxcbiAgICAgICAgICBpZiAoZHlGIDwgMC4wIHx8IGR5RiA+PSBcIit0Lm91dERlcHRoK1wiLjAgfHwgZnJhY3QoZHlGKSA+IDAuMCkge1xcbiAgICAgICAgICAgIGNvbnRpbnVlO1xcbiAgICAgICAgICB9XFxuICAgICAgICAgIGludCBpZHlGID0gaW50KGR5Rik7XFxuXFxuICAgICAgICAgIGludCB3RlBlcm0gPSBcIitlK1wiIC0gMSAtIHdGO1xcblxcbiAgICAgICAgICBmb3IgKGludCB3UiA9IDA7IHdSIDwgXCIrbitcIjsgd1IrKykge1xcbiAgICAgICAgICAgIGZsb2F0IGR5UiA9IGZsb2F0KGR5UkNvcm5lciArIHdSKSAvIFwiK2ErXCIuMDtcXG5cXG4gICAgICAgICAgICBpZiAoZHlSIDwgMC4wIHx8IGR5UiA+PSBcIit0Lm91dEhlaWdodCtcIi4wIHx8XFxuICAgICAgICAgICAgICBmcmFjdChkeVIpID4gMC4wKSB7XFxuICAgICAgICAgICAgICBjb250aW51ZTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgICAgaW50IGlkeVIgPSBpbnQoZHlSKTtcXG5cXG4gICAgICAgICAgICBpbnQgd1JQZXJtID0gXCIrbitcIiAtIDEgLSB3UjtcXG5cXG4gICAgICAgICAgICBmb3IgKGludCB3QyA9IDA7IHdDIDwgXCIrcitcIjsgd0MrKykge1xcbiAgICAgICAgICAgICAgZmxvYXQgZHlDID0gZmxvYXQoZHlDQ29ybmVyICsgd0MpIC8gXCIraStcIi4wO1xcblxcbiAgICAgICAgICAgICAgaWYgKGR5QyA8IDAuMCB8fCBkeUMgPj0gXCIrdC5vdXRXaWR0aCtcIi4wIHx8XFxuICAgICAgICAgICAgICAgICAgZnJhY3QoZHlDKSA+IDAuMCkge1xcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcXG4gICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgIGludCBpZHlDID0gaW50KGR5Qyk7XFxuXFxuICAgICAgICAgICAgICBpbnQgd0NQZXJtID0gXCIrcitcIiAtIDEgLSB3QztcXG5cXG4gICAgICAgICAgICAgIGZvciAoaW50IGQyID0gMDsgZDIgPCBcIit0Lm91dENoYW5uZWxzK1wiOyBkMisrKSB7XFxuICAgICAgICAgICAgICAgIGZsb2F0IHhWYWx1ZSA9IGdldER5KGJhdGNoLCBpZHlGLCBpZHlSLCBpZHlDLCBkMik7XFxuICAgICAgICAgICAgICAgIGZsb2F0IHdWYWx1ZSA9IGdldFcod0ZQZXJtLCB3UlBlcm0sIHdDUGVybSwgZDEsIGQyKTtcXG4gICAgICAgICAgICAgICAgZG90UHJvZCArPSB4VmFsdWUgKiB3VmFsdWU7XFxuICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICB9XFxuICAgICAgICB9XFxuICAgICAgICBzZXRPdXRwdXQoZG90UHJvZCk7XFxuICAgICAgfVxcbiAgICBcIn0sWWE9ZnVuY3Rpb24odCl7dGhpcy52YXJpYWJsZU5hbWVzPVtcInhcIixcImR5XCJdLHRoaXMub3V0cHV0U2hhcGU9dC5maWx0ZXJTaGFwZTt2YXIgZT10LnN0cmlkZUhlaWdodCxuPXQuc3RyaWRlV2lkdGgscj10LnBhZEluZm8udG9wLG89dC5wYWRJbmZvLmxlZnQsYT10Lm91dENoYW5uZWxzL3QuaW5DaGFubmVsczt0aGlzLnVzZXJDb2RlPVwiXFxuICAgICAgdm9pZCBtYWluKCkge1xcbiAgICAgICAgaXZlYzQgY29vcmRzID0gZ2V0T3V0cHV0Q29vcmRzKCk7XFxuICAgICAgICBpbnQgd1IgPSBjb29yZHMueDtcXG4gICAgICAgIGludCB3QyA9IGNvb3Jkcy55O1xcbiAgICAgICAgaW50IGQxID0gY29vcmRzLno7XFxuICAgICAgICBpbnQgZG0gPSBjb29yZHMudztcXG4gICAgICAgIGludCBkMiA9IGQxICogXCIrYStcIiArIGRtO1xcblxcbiAgICAgICAgZmxvYXQgZG90UHJvZCA9IDAuMDtcXG5cXG4gICAgICAgIC8vIFRPIERPOiBWZWM0IG92ZXIgdGhlIGJhdGNoIHNpemVcXG4gICAgICAgIGZvciAoaW50IGIgPSAwOyBiIDwgXCIrdC5iYXRjaFNpemUrXCI7IGIrKykge1xcbiAgICAgICAgICBmb3IgKGludCB5UiA9IDA7IHlSIDwgXCIrdC5vdXRIZWlnaHQrXCI7IHlSKyspIHtcXG4gICAgICAgICAgICBpbnQgeFIgPSB3UiArIHlSICogXCIrZStcIiAtIFwiK3IrXCI7XFxuXFxuICAgICAgICAgICAgaWYgKHhSIDwgMCB8fCB4UiA+PSBcIit0LmluSGVpZ2h0K1wiKSB7XFxuICAgICAgICAgICAgICBjb250aW51ZTtcXG4gICAgICAgICAgICB9XFxuXFxuICAgICAgICAgICAgZm9yIChpbnQgeUMgPSAwOyB5QyA8IFwiK3Qub3V0V2lkdGgrXCI7IHlDKyspIHtcXG4gICAgICAgICAgICAgIGludCB4QyA9IHdDICsgeUMgKiBcIituK1wiIC0gXCIrbytcIjtcXG5cXG4gICAgICAgICAgICAgIGlmICh4QyA8IDAgfHwgeEMgPj0gXCIrdC5pbldpZHRoK1wiKSB7XFxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xcbiAgICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgICAgZmxvYXQgZHlWYWx1ZSA9IGdldER5KGIsIHlSLCB5QywgZDIpO1xcbiAgICAgICAgICAgICAgZmxvYXQgeFZhbHVlID0gZ2V0WChiLCB4UiwgeEMsIGQxKTtcXG4gICAgICAgICAgICAgIGRvdFByb2QgKz0gKHhWYWx1ZSAqIGR5VmFsdWUpO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgfVxcbiAgICAgICAgfVxcbiAgICAgICAgc2V0T3V0cHV0KGRvdFByb2QpO1xcbiAgICAgIH1cXG4gICAgXCJ9LCRhPWZ1bmN0aW9uKHQpe3RoaXMudmFyaWFibGVOYW1lcz1bXCJkeVwiLFwiV1wiXSx0aGlzLm91dHB1dFNoYXBlPXQuaW5TaGFwZTt2YXIgZT10LmZpbHRlckhlaWdodCxuPXQuZmlsdGVyV2lkdGgscj10LnN0cmlkZUhlaWdodCxvPXQuc3RyaWRlV2lkdGgsYT1lLTEtdC5wYWRJbmZvLnRvcCxpPW4tMS10LnBhZEluZm8ubGVmdCxzPXQub3V0Q2hhbm5lbHMvdC5pbkNoYW5uZWxzO3RoaXMudXNlckNvZGU9XCJcXG4gICAgICBjb25zdCBpdmVjMiBwYWRzID0gaXZlYzIoXCIrYStcIiwgXCIraStcIik7XFxuXFxuICAgICAgdm9pZCBtYWluKCkge1xcbiAgICAgICAgaXZlYzQgY29vcmRzID0gZ2V0T3V0cHV0Q29vcmRzKCk7XFxuICAgICAgICBpbnQgYmF0Y2ggPSBjb29yZHNbMF07XFxuICAgICAgICBpbnQgZDEgPSBjb29yZHNbM107XFxuICAgICAgICBpdmVjMiBkeUNvcm5lciA9IGNvb3Jkcy55eiAtIHBhZHM7XFxuICAgICAgICBpbnQgZHlSQ29ybmVyID0gZHlDb3JuZXIueDtcXG4gICAgICAgIGludCBkeUNDb3JuZXIgPSBkeUNvcm5lci55O1xcblxcbiAgICAgICAgZmxvYXQgZG90UHJvZCA9IDAuMDtcXG5cXG4gICAgICAgIGZvciAoaW50IHdSID0gMDsgd1IgPCBcIitlK1wiOyB3UisrKSB7XFxuICAgICAgICAgIGZsb2F0IGR5UiA9IGZsb2F0KGR5UkNvcm5lciArIHdSKSAvIFwiK3IrXCIuMDtcXG5cXG4gICAgICAgICAgaWYgKGR5UiA8IDAuMCB8fCBkeVIgPj0gXCIrdC5vdXRIZWlnaHQrXCIuMCB8fCBmcmFjdChkeVIpID4gMC4wKSB7XFxuICAgICAgICAgICAgY29udGludWU7XFxuICAgICAgICAgIH1cXG4gICAgICAgICAgaW50IGlkeVIgPSBpbnQoZHlSKTtcXG5cXG4gICAgICAgICAgaW50IHdSUGVybSA9IFwiK2UrXCIgLSAxIC0gd1I7XFxuXFxuICAgICAgICAgIGZvciAoaW50IHdDID0gMDsgd0MgPCBcIituK1wiOyB3QysrKSB7XFxuICAgICAgICAgICAgZmxvYXQgZHlDID0gZmxvYXQoZHlDQ29ybmVyICsgd0MpIC8gXCIrbytcIi4wO1xcblxcbiAgICAgICAgICAgIGlmIChkeUMgPCAwLjAgfHwgZHlDID49IFwiK3Qub3V0V2lkdGgrXCIuMCB8fFxcbiAgICAgICAgICAgICAgICBmcmFjdChkeUMpID4gMC4wKSB7XFxuICAgICAgICAgICAgICBjb250aW51ZTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgICAgaW50IGlkeUMgPSBpbnQoZHlDKTtcXG5cXG4gICAgICAgICAgICBpbnQgd0NQZXJtID0gXCIrbitcIiAtIDEgLSB3QztcXG5cXG4gICAgICAgICAgICAvLyBUTyBETzogVmVjNCBvdmVyIHRoZSBjaGFubmVsTXVsXFxuICAgICAgICAgICAgZm9yIChpbnQgZG0gPSAwOyBkbSA8IFwiK3MrXCI7IGRtKyspIHtcXG4gICAgICAgICAgICAgIGludCBkMiA9IGQxICogXCIrcytcIiArIGRtO1xcbiAgICAgICAgICAgICAgZmxvYXQgeFZhbHVlID0gZ2V0RHkoYmF0Y2gsIGlkeVIsIGlkeUMsIGQyKTtcXG4gICAgICAgICAgICAgIGZsb2F0IHdWYWx1ZSA9IGdldFcod1JQZXJtLCB3Q1Blcm0sIGQxLCBkbSk7XFxuICAgICAgICAgICAgICBkb3RQcm9kICs9IHhWYWx1ZSAqIHdWYWx1ZTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgIH1cXG4gICAgICAgIH1cXG4gICAgICAgIHNldE91dHB1dChkb3RQcm9kKTtcXG4gICAgICB9XFxuICAgIFwifSxRYT1mdW5jdGlvbih0LGUsbixyKXt2b2lkIDA9PT1lJiYoZT0hMSksdm9pZCAwPT09biYmKG49bnVsbCksdm9pZCAwPT09ciYmKHI9ITEpLHRoaXMudmFyaWFibGVOYW1lcz1bXCJ4XCIsXCJXXCJdLHRoaXMub3V0cHV0U2hhcGU9dC5vdXRTaGFwZTt2YXIgbz10LnBhZEluZm8udG9wLGE9dC5wYWRJbmZvLmxlZnQsaT10LnN0cmlkZUhlaWdodCxzPXQuc3RyaWRlV2lkdGgsdT10LmRpbGF0aW9uSGVpZ2h0LGM9dC5kaWxhdGlvbldpZHRoLGw9dC5maWx0ZXJIZWlnaHQsaD10LmZpbHRlcldpZHRoLGY9NCpNYXRoLmZsb29yKHQuaW5DaGFubmVscy80KSxkPXQuaW5DaGFubmVscyU0LHA9XCJjaGFubmVsc0xhc3RcIj09PXQuZGF0YUZvcm1hdCx2PXA/MToyLG09cD8yOjMsZz1wPzM6MSx5PVwiXCIseD1cIlwiO24mJih5PXI/XCJmbG9hdCBhY3RpdmF0aW9uKGZsb2F0IGEpIHtcXG4gICAgICAgICAgZmxvYXQgYiA9IGdldFByZWx1QWN0aXZhdGlvbldlaWdodHNBdE91dENvb3JkcygpO1xcbiAgICAgICAgICBcIituK1wiXFxuICAgICAgICB9XCI6XCJcXG4gICAgICAgICAgZmxvYXQgYWN0aXZhdGlvbihmbG9hdCB4KSB7XFxuICAgICAgICAgICAgXCIrbitcIlxcbiAgICAgICAgICB9XFxuICAgICAgICBcIix4PVwicmVzdWx0ID0gYWN0aXZhdGlvbihyZXN1bHQpO1wiKTt2YXIgYj1lP1wicmVzdWx0ICs9IGdldEJpYXNBdE91dENvb3JkcygpO1wiOlwiXCI7ZSYmdGhpcy52YXJpYWJsZU5hbWVzLnB1c2goXCJiaWFzXCIpLHImJnRoaXMudmFyaWFibGVOYW1lcy5wdXNoKFwicHJlbHVBY3RpdmF0aW9uV2VpZ2h0c1wiKSx0aGlzLnVzZXJDb2RlPVwiXFxuICAgICAgXCIreStcIlxcblxcbiAgICAgIGNvbnN0IGl2ZWMyIHN0cmlkZXMgPSBpdmVjMihcIitpK1wiLCBcIitzK1wiKTtcXG4gICAgICBjb25zdCBpdmVjMiBwYWRzID0gaXZlYzIoXCIrbytcIiwgXCIrYStcIik7XFxuXFxuICAgICAgdm9pZCBtYWluKCkge1xcbiAgICAgICAgaXZlYzQgY29vcmRzID0gZ2V0T3V0cHV0Q29vcmRzKCk7XFxuICAgICAgICBpbnQgYmF0Y2ggPSBjb29yZHNbMF07XFxuICAgICAgICBpbnQgZDIgPSBjb29yZHNbXCIrZytcIl07XFxuXFxuICAgICAgICBpdmVjMiB4UkNDb3JuZXIgPVxcbiAgICAgICAgICAgIGl2ZWMyKGNvb3Jkc1tcIit2K1wiXSwgY29vcmRzW1wiK20rXCJdKSAqIHN0cmlkZXMgLSBwYWRzO1xcbiAgICAgICAgaW50IHhSQ29ybmVyID0geFJDQ29ybmVyLng7XFxuICAgICAgICBpbnQgeENDb3JuZXIgPSB4UkNDb3JuZXIueTtcXG5cXG4gICAgICAgIC8vIENvbnZvbHZlIHgoPywgPywgZDEpIHdpdGggdyg6LCA6LCBkMSwgZDIpIHRvIGdldCB5KHlSLCB5QywgZDIpLlxcbiAgICAgICAgLy8gPyA9IHRvIGJlIGRldGVybWluZWQuIDogPSBhY3Jvc3MgYWxsIHZhbHVlcyBpbiB0aGF0IGF4aXMuXFxuICAgICAgICBmbG9hdCBkb3RQcm9kID0gMC4wO1xcbiAgICAgICAgZm9yIChpbnQgd1IgPSAwOyB3UiA8IFwiK2wrXCI7IHdSKyspIHtcXG4gICAgICAgICAgaW50IHhSID0geFJDb3JuZXIgKyB3UiAqIFwiK3UrXCI7XFxuXFxuICAgICAgICAgIGlmICh4UiA8IDAgfHwgeFIgPj0gXCIrdC5pbkhlaWdodCtcIikge1xcbiAgICAgICAgICAgIGNvbnRpbnVlO1xcbiAgICAgICAgICB9XFxuXFxuICAgICAgICAgIGZvciAoaW50IHdDID0gMDsgd0MgPCBcIitoK1wiOyB3QysrKSB7XFxuICAgICAgICAgICAgaW50IHhDID0geENDb3JuZXIgKyB3QyAqIFwiK2MrXCI7XFxuXFxuICAgICAgICAgICAgaWYgKHhDIDwgMCB8fCB4QyA+PSBcIit0LmluV2lkdGgrXCIpIHtcXG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xcbiAgICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgICBmb3IgKGludCBkMSA9IDA7IGQxIDwgXCIrZitcIjsgZDEgKz0gNCkge1xcbiAgICAgICAgICAgICAgdmVjNCB3VmFsdWVzID0gdmVjNChcXG4gICAgICAgICAgICAgICAgZ2V0Vyh3Uiwgd0MsIGQxLCBkMiksXFxuICAgICAgICAgICAgICAgIGdldFcod1IsIHdDLCBkMSArIDEsIGQyKSxcXG4gICAgICAgICAgICAgICAgZ2V0Vyh3Uiwgd0MsIGQxICsgMiwgZDIpLFxcbiAgICAgICAgICAgICAgICBnZXRXKHdSLCB3QywgZDEgKyAzLCBkMilcXG4gICAgICAgICAgICAgICk7XFxuXFxuICAgICAgICAgICAgICBpZiAoXCIrcCtcIikge1xcbiAgICAgICAgICAgICAgICB2ZWM0IHhWYWx1ZXMgPSB2ZWM0KFxcbiAgICAgICAgICAgICAgICAgIGdldFgoYmF0Y2gsIHhSLCB4QywgZDEpLFxcbiAgICAgICAgICAgICAgICAgIGdldFgoYmF0Y2gsIHhSLCB4QywgZDEgKyAxKSxcXG4gICAgICAgICAgICAgICAgICBnZXRYKGJhdGNoLCB4UiwgeEMsIGQxICsgMiksXFxuICAgICAgICAgICAgICAgICAgZ2V0WChiYXRjaCwgeFIsIHhDLCBkMSArIDMpXFxuICAgICAgICAgICAgICAgICk7XFxuICAgICAgICAgICAgICAgIGRvdFByb2QgKz0gZG90KHhWYWx1ZXMsIHdWYWx1ZXMpO1xcbiAgICAgICAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICAgICAgdmVjNCB4VmFsdWVzID0gdmVjNChcXG4gICAgICAgICAgICAgICAgICBnZXRYKGJhdGNoLCBkMSwgeFIsIHhDKSxcXG4gICAgICAgICAgICAgICAgICBnZXRYKGJhdGNoLCBkMSArIDEsIHhSLCB4QyksXFxuICAgICAgICAgICAgICAgICAgZ2V0WChiYXRjaCwgZDEgKyAyLCB4UiwgeEMpLFxcbiAgICAgICAgICAgICAgICAgIGdldFgoYmF0Y2gsIGQxICsgMywgeFIsIHhDKVxcbiAgICAgICAgICAgICAgICApO1xcbiAgICAgICAgICAgICAgICBkb3RQcm9kICs9IGRvdCh4VmFsdWVzLCB3VmFsdWVzKTtcXG4gICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICB9XFxuXFxuICAgICAgICAgICAgaWYgKFwiKygxPT09ZCkrXCIpIHtcXG5cXG4gICAgICAgICAgICAgIGlmIChcIitwK1wiKSB7XFxuICAgICAgICAgICAgICAgIGRvdFByb2QgKz1cXG4gICAgICAgICAgICAgICAgICAgIGdldFgoYmF0Y2gsIHhSLCB4QywgXCIrZitcIikgKlxcbiAgICAgICAgICAgICAgICAgICAgZ2V0Vyh3Uiwgd0MsIFwiK2YrXCIsIGQyKTtcXG4gICAgICAgICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgICAgICAgIGRvdFByb2QgKz1cXG4gICAgICAgICAgICAgICAgICAgIGdldFgoYmF0Y2gsIFwiK2YrXCIsIHhSLCB4QykgKlxcbiAgICAgICAgICAgICAgICAgICAgZ2V0Vyh3Uiwgd0MsIFwiK2YrXCIsIGQyKTtcXG4gICAgICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgICB9IGVsc2UgaWYgKFwiKygyPT09ZCkrXCIpIHtcXG4gICAgICAgICAgICAgIHZlYzIgd1ZhbHVlcyA9IHZlYzIoXFxuICAgICAgICAgICAgICAgIGdldFcod1IsIHdDLCBcIitmK1wiLCBkMiksXFxuICAgICAgICAgICAgICAgIGdldFcod1IsIHdDLCBcIitmK1wiICsgMSwgZDIpXFxuICAgICAgICAgICAgICApO1xcblxcbiAgICAgICAgICAgICAgaWYgKFwiK3ArXCIpIHtcXG4gICAgICAgICAgICAgICAgdmVjMiB4VmFsdWVzID0gdmVjMihcXG4gICAgICAgICAgICAgICAgICBnZXRYKGJhdGNoLCB4UiwgeEMsIFwiK2YrXCIpLFxcbiAgICAgICAgICAgICAgICAgIGdldFgoYmF0Y2gsIHhSLCB4QywgXCIrZitcIiArIDEpXFxuICAgICAgICAgICAgICAgICk7XFxuICAgICAgICAgICAgICAgIGRvdFByb2QgKz0gZG90KHhWYWx1ZXMsIHdWYWx1ZXMpO1xcbiAgICAgICAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICAgICAgdmVjMiB4VmFsdWVzID0gdmVjMihcXG4gICAgICAgICAgICAgICAgICBnZXRYKGJhdGNoLCBcIitmK1wiLCB4UiwgeEMpLFxcbiAgICAgICAgICAgICAgICAgIGdldFgoYmF0Y2gsIFwiK2YrXCIgKyAxLCB4UiwgeEMpXFxuICAgICAgICAgICAgICAgICk7XFxuICAgICAgICAgICAgICAgIGRvdFByb2QgKz0gZG90KHhWYWx1ZXMsIHdWYWx1ZXMpO1xcbiAgICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoXCIrKDM9PT1kKStcIikge1xcbiAgICAgICAgICAgICAgdmVjMyB3VmFsdWVzID0gdmVjMyhcXG4gICAgICAgICAgICAgICAgZ2V0Vyh3Uiwgd0MsIFwiK2YrXCIsIGQyKSxcXG4gICAgICAgICAgICAgICAgZ2V0Vyh3Uiwgd0MsIFwiK2YrXCIgKyAxLCBkMiksXFxuICAgICAgICAgICAgICAgIGdldFcod1IsIHdDLCBcIitmK1wiICsgMiwgZDIpXFxuICAgICAgICAgICAgICApO1xcblxcbiAgICAgICAgICAgICAgaWYgKFwiK3ArXCIpIHtcXG4gICAgICAgICAgICAgICAgdmVjMyB4VmFsdWVzID0gdmVjMyhcXG4gICAgICAgICAgICAgICAgICBnZXRYKGJhdGNoLCB4UiwgeEMsIFwiK2YrXCIpLFxcbiAgICAgICAgICAgICAgICAgIGdldFgoYmF0Y2gsIHhSLCB4QywgXCIrZitcIiArIDEpLFxcbiAgICAgICAgICAgICAgICAgIGdldFgoYmF0Y2gsIHhSLCB4QywgXCIrZitcIiArIDIpXFxuICAgICAgICAgICAgICAgICk7XFxuICAgICAgICAgICAgICAgIGRvdFByb2QgKz0gZG90KHhWYWx1ZXMsIHdWYWx1ZXMpO1xcbiAgICAgICAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICAgICAgdmVjMyB4VmFsdWVzID0gdmVjMyhcXG4gICAgICAgICAgICAgICAgICBnZXRYKGJhdGNoLCBcIitmK1wiLCB4UiwgeEMpLFxcbiAgICAgICAgICAgICAgICAgIGdldFgoYmF0Y2gsIFwiK2YrXCIgKyAxLCB4UiwgeEMpLFxcbiAgICAgICAgICAgICAgICAgIGdldFgoYmF0Y2gsIFwiK2YrXCIgKyAyLCB4UiwgeEMpXFxuICAgICAgICAgICAgICAgICk7XFxuICAgICAgICAgICAgICAgIGRvdFByb2QgKz0gZG90KHhWYWx1ZXMsIHdWYWx1ZXMpO1xcbiAgICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgfVxcbiAgICAgICAgfVxcblxcbiAgICAgICAgZmxvYXQgcmVzdWx0ID0gZG90UHJvZDtcXG4gICAgICAgIFwiK2IrXCJcXG4gICAgICAgIFwiK3grXCJcXG4gICAgICAgIHNldE91dHB1dChyZXN1bHQpO1xcbiAgICAgIH1cXG4gICAgXCJ9LEphPWZ1bmN0aW9uKHQpe3RoaXMudmFyaWFibGVOYW1lcz1bXCJ4XCIsXCJXXCJdLHRoaXMub3V0cHV0U2hhcGU9dC5vdXRTaGFwZTt2YXIgZT10LnBhZEluZm8uZnJvbnQsbj10LnBhZEluZm8udG9wLHI9dC5wYWRJbmZvLmxlZnQsbz10LnN0cmlkZURlcHRoLGE9dC5zdHJpZGVIZWlnaHQsaT10LnN0cmlkZVdpZHRoLHM9dC5kaWxhdGlvbkRlcHRoLHU9dC5kaWxhdGlvbkhlaWdodCxjPXQuZGlsYXRpb25XaWR0aCxsPXQuZmlsdGVyRGVwdGgsaD10LmZpbHRlckhlaWdodCxmPXQuZmlsdGVyV2lkdGgsZD00Kk1hdGguZmxvb3IodC5pbkNoYW5uZWxzLzQpLHA9dC5pbkNoYW5uZWxzJTQ7dGhpcy51c2VyQ29kZT1cIlxcbiAgICAgIGNvbnN0IGl2ZWMzIHN0cmlkZXMgPSBpdmVjMyhcIitvK1wiLCBcIithK1wiLCBcIitpK1wiKTtcXG4gICAgICBjb25zdCBpdmVjMyBwYWRzID0gaXZlYzMoXCIrZStcIiwgXCIrbitcIiwgXCIrcitcIik7XFxuXFxuICAgICAgdm9pZCBtYWluKCkge1xcbiAgICAgICAgaXZlYzUgY29vcmRzID0gZ2V0T3V0cHV0Q29vcmRzKCk7XFxuICAgICAgICBpbnQgYmF0Y2ggPSBjb29yZHMueDtcXG4gICAgICAgIGludCBkMiA9IGNvb3Jkcy51O1xcblxcbiAgICAgICAgaXZlYzMgeEZSQ0Nvcm5lciA9IGl2ZWMzKGNvb3Jkcy55LCBjb29yZHMueiwgY29vcmRzLncpICogc3RyaWRlcyAtIHBhZHM7XFxuICAgICAgICBpbnQgeEZDb3JuZXIgPSB4RlJDQ29ybmVyLng7XFxuICAgICAgICBpbnQgeFJDb3JuZXIgPSB4RlJDQ29ybmVyLnk7XFxuICAgICAgICBpbnQgeENDb3JuZXIgPSB4RlJDQ29ybmVyLno7XFxuXFxuICAgICAgICAvLyBDb252b2x2ZSB4KD8sID8sID8sIGQxKSB3aXRoIHcoOiwgOiwgOiwgZDEsIGQyKSB0byBnZXRcXG4gICAgICAgIC8vIHkoeUYsIHlSLCB5QywgZDIpLiA/ID0gdG8gYmUgZGV0ZXJtaW5lZC4gOiA9IGFjcm9zcyBhbGxcXG4gICAgICAgIC8vIHZhbHVlcyBpbiB0aGF0IGF4aXMuXFxuICAgICAgICBmbG9hdCBkb3RQcm9kID0gMC4wO1xcbiAgICAgICAgZm9yIChpbnQgd0YgPSAwOyB3RiA8IFwiK2wrXCI7IHdGKyspIHtcXG4gICAgICAgICAgaW50IHhGID0geEZDb3JuZXIgKyB3RiAqIFwiK3MrXCI7XFxuXFxuICAgICAgICAgIGlmICh4RiA8IDAgfHwgeEYgPj0gXCIrdC5pbkRlcHRoK1wiKSB7XFxuICAgICAgICAgICAgY29udGludWU7XFxuICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgZm9yIChpbnQgd1IgPSAwOyB3UiA8IFwiK2grXCI7IHdSKyspIHtcXG4gICAgICAgICAgICBpbnQgeFIgPSB4UkNvcm5lciArIHdSICogXCIrdStcIjtcXG5cXG4gICAgICAgICAgICBpZiAoeFIgPCAwIHx8IHhSID49IFwiK3QuaW5IZWlnaHQrXCIpIHtcXG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xcbiAgICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgICBmb3IgKGludCB3QyA9IDA7IHdDIDwgXCIrZitcIjsgd0MrKykge1xcbiAgICAgICAgICAgICAgaW50IHhDID0geENDb3JuZXIgKyB3QyAqIFwiK2MrXCI7XFxuXFxuICAgICAgICAgICAgICBpZiAoeEMgPCAwIHx8IHhDID49IFwiK3QuaW5XaWR0aCtcIikge1xcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcXG4gICAgICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgICAgIGZvciAoaW50IGQxID0gMDsgZDEgPCBcIitkK1wiOyBkMSArPSA0KSB7XFxuICAgICAgICAgICAgICAgIHZlYzQgeFZhbHVlcyA9IHZlYzQoXFxuICAgICAgICAgICAgICAgICAgZ2V0WChiYXRjaCwgeEYsIHhSLCB4QywgZDEpLFxcbiAgICAgICAgICAgICAgICAgIGdldFgoYmF0Y2gsIHhGLCB4UiwgeEMsIGQxICsgMSksXFxuICAgICAgICAgICAgICAgICAgZ2V0WChiYXRjaCwgeEYsIHhSLCB4QywgZDEgKyAyKSxcXG4gICAgICAgICAgICAgICAgICBnZXRYKGJhdGNoLCB4RiwgeFIsIHhDLCBkMSArIDMpXFxuICAgICAgICAgICAgICAgICk7XFxuICAgICAgICAgICAgICAgIHZlYzQgd1ZhbHVlcyA9IHZlYzQoXFxuICAgICAgICAgICAgICAgICAgZ2V0Vyh3Riwgd1IsIHdDLCBkMSwgZDIpLFxcbiAgICAgICAgICAgICAgICAgIGdldFcod0YsIHdSLCB3QywgZDEgKyAxLCBkMiksXFxuICAgICAgICAgICAgICAgICAgZ2V0Vyh3Riwgd1IsIHdDLCBkMSArIDIsIGQyKSxcXG4gICAgICAgICAgICAgICAgICBnZXRXKHdGLCB3Uiwgd0MsIGQxICsgMywgZDIpXFxuICAgICAgICAgICAgICAgICk7XFxuXFxuICAgICAgICAgICAgICAgIGRvdFByb2QgKz0gZG90KHhWYWx1ZXMsIHdWYWx1ZXMpO1xcbiAgICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgICAgaWYgKFwiKygxPT09cCkrXCIpIHtcXG4gICAgICAgICAgICAgICAgZG90UHJvZCArPVxcbiAgICAgICAgICAgICAgICAgIGdldFgoYmF0Y2gsIHhGLCB4UiwgeEMsIFwiK2QrXCIpICpcXG4gICAgICAgICAgICAgICAgICBnZXRXKHdGLCB3Uiwgd0MsIFwiK2QrXCIsIGQyKTtcXG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAoXCIrKDI9PT1wKStcIikge1xcbiAgICAgICAgICAgICAgICB2ZWMyIHhWYWx1ZXMgPSB2ZWMyKFxcbiAgICAgICAgICAgICAgICAgIGdldFgoYmF0Y2gsIHhGLCB4UiwgeEMsIFwiK2QrXCIpLFxcbiAgICAgICAgICAgICAgICAgIGdldFgoYmF0Y2gsIHhGLCB4UiwgeEMsIFwiK2QrXCIgKyAxKVxcbiAgICAgICAgICAgICAgICApO1xcbiAgICAgICAgICAgICAgICB2ZWMyIHdWYWx1ZXMgPSB2ZWMyKFxcbiAgICAgICAgICAgICAgICAgIGdldFcod0YsIHdSLCB3QywgXCIrZCtcIiwgZDIpLFxcbiAgICAgICAgICAgICAgICAgIGdldFcod0YsIHdSLCB3QywgXCIrZCtcIiArIDEsIGQyKVxcbiAgICAgICAgICAgICAgICApO1xcbiAgICAgICAgICAgICAgICBkb3RQcm9kICs9IGRvdCh4VmFsdWVzLCB3VmFsdWVzKTtcXG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAoXCIrKDM9PT1wKStcIikge1xcbiAgICAgICAgICAgICAgICB2ZWMzIHhWYWx1ZXMgPSB2ZWMzKFxcbiAgICAgICAgICAgICAgICAgIGdldFgoYmF0Y2gsIHhGLCB4UiwgeEMsIFwiK2QrXCIpLFxcbiAgICAgICAgICAgICAgICAgIGdldFgoYmF0Y2gsIHhGLCB4UiwgeEMsIFwiK2QrXCIgKyAxKSxcXG4gICAgICAgICAgICAgICAgICBnZXRYKGJhdGNoLCB4RiwgeFIsIHhDLCBcIitkK1wiICsgMilcXG4gICAgICAgICAgICAgICAgKTtcXG4gICAgICAgICAgICAgICAgdmVjMyB3VmFsdWVzID0gdmVjMyhcXG4gICAgICAgICAgICAgICAgICBnZXRXKHdGLCB3Uiwgd0MsIFwiK2QrXCIsIGQyKSxcXG4gICAgICAgICAgICAgICAgICBnZXRXKHdGLCB3Uiwgd0MsIFwiK2QrXCIgKyAxLCBkMiksXFxuICAgICAgICAgICAgICAgICAgZ2V0Vyh3Riwgd1IsIHdDLCBcIitkK1wiICsgMiwgZDIpXFxuICAgICAgICAgICAgICAgICk7XFxuICAgICAgICAgICAgICAgIGRvdFByb2QgKz0gZG90KHhWYWx1ZXMsIHdWYWx1ZXMpO1xcbiAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgfVxcbiAgICAgICAgfVxcbiAgICAgICAgc2V0T3V0cHV0KGRvdFByb2QpO1xcbiAgICAgIH1cXG4gICAgXCJ9LFphPWZ1bmN0aW9uKHQsZSxuLHIpe3ZvaWQgMD09PWUmJihlPSExKSx2b2lkIDA9PT1uJiYobj1udWxsKSx2b2lkIDA9PT1yJiYocj0hMSksdGhpcy52YXJpYWJsZU5hbWVzPVtcInhcIixcIldcIl0sdGhpcy5vdXRwdXRTaGFwZT10Lm91dFNoYXBlO3ZhciBvPXQuaW5IZWlnaHQsYT10LmluV2lkdGgsaT10LnBhZEluZm8udG9wLHM9dC5wYWRJbmZvLmxlZnQsdT10LnN0cmlkZUhlaWdodCxjPXQuc3RyaWRlV2lkdGgsbD10LmRpbGF0aW9uSGVpZ2h0LGg9dC5kaWxhdGlvbldpZHRoLGY9dC5maWx0ZXJIZWlnaHQsZD10LmZpbHRlcldpZHRoLHA9dC5vdXRDaGFubmVscy90LmluQ2hhbm5lbHMsdj1cIlwiLG09XCJcIjtuJiYodj1yP1wiZmxvYXQgYWN0aXZhdGlvbihmbG9hdCBhKSB7XFxuICAgICAgICAgIGZsb2F0IGIgPSBnZXRQcmVsdUFjdGl2YXRpb25XZWlnaHRzQXRPdXRDb29yZHMoKTtcXG4gICAgICAgICAgXCIrbitcIlxcbiAgICAgICAgfVwiOlwiXFxuICAgICAgICAgIGZsb2F0IGFjdGl2YXRpb24oZmxvYXQgeCkge1xcbiAgICAgICAgICAgIFwiK24rXCJcXG4gICAgICAgICAgfVxcbiAgICAgICAgXCIsbT1cInJlc3VsdCA9IGFjdGl2YXRpb24ocmVzdWx0KTtcIik7dmFyIGc9ZT9cInJlc3VsdCArPSBnZXRCaWFzQXRPdXRDb29yZHMoKTtcIjpcIlwiO2UmJnRoaXMudmFyaWFibGVOYW1lcy5wdXNoKFwiYmlhc1wiKSxyJiZ0aGlzLnZhcmlhYmxlTmFtZXMucHVzaChcInByZWx1QWN0aXZhdGlvbldlaWdodHNcIiksdGhpcy51c2VyQ29kZT1cIlxcbiAgICAgIFwiK3YrXCJcXG5cXG4gICAgICBjb25zdCBpdmVjMiBzdHJpZGVzID0gaXZlYzIoXCIrdStcIiwgXCIrYytcIik7XFxuICAgICAgY29uc3QgaXZlYzIgcGFkcyA9IGl2ZWMyKFwiK2krXCIsIFwiK3MrXCIpO1xcblxcbiAgICAgIHZvaWQgbWFpbigpIHtcXG4gICAgICAgIGl2ZWM0IGNvb3JkcyA9IGdldE91dHB1dENvb3JkcygpO1xcbiAgICAgICAgaW50IGJhdGNoID0gY29vcmRzLng7XFxuICAgICAgICBpdmVjMiB4UkNDb3JuZXIgPSBjb29yZHMueXogKiBzdHJpZGVzIC0gcGFkcztcXG4gICAgICAgIGludCBkMiA9IGNvb3Jkcy53O1xcbiAgICAgICAgaW50IGQxID0gZDIgLyBcIitwK1wiO1xcbiAgICAgICAgaW50IHEgPSBkMiAtIGQxICogXCIrcCtcIjtcXG5cXG4gICAgICAgIGludCB4UkNvcm5lciA9IHhSQ0Nvcm5lci54O1xcbiAgICAgICAgaW50IHhDQ29ybmVyID0geFJDQ29ybmVyLnk7XFxuXFxuICAgICAgICAvLyBDb252b2x2ZSB4KD8sID8sIGQxKSB3aXRoIHcoOiwgOiwgZDEsIHEpIHRvIGdldCB5KHlSLCB5QywgZDIpLlxcbiAgICAgICAgLy8gPyA9IHRvIGJlIGRldGVybWluZWQuIDogPSBhY3Jvc3MgYWxsIHZhbHVlcyBpbiB0aGF0IGF4aXMuXFxuICAgICAgICBmbG9hdCBkb3RQcm9kID0gMC4wO1xcbiAgICAgICAgLy8gVE8gRE8oZHNtaWxrb3YpOiBGbGF0dGVuIHRoZSB0d28gZm9yIGxvb3BzIGFuZCB2ZWM0IHRoZSBvcGVyYXRpb25zLlxcbiAgICAgICAgZm9yIChpbnQgd1IgPSAwOyB3UiA8IFwiK2YrXCI7IHdSKyspIHtcXG4gICAgICAgICAgaW50IHhSID0geFJDb3JuZXIgKyB3UiAqIFwiK2wrXCI7XFxuXFxuICAgICAgICAgIGlmICh4UiA8IDAgfHwgeFIgPj0gXCIrbytcIikge1xcbiAgICAgICAgICAgIGNvbnRpbnVlO1xcbiAgICAgICAgICB9XFxuXFxuICAgICAgICAgIGZvciAoaW50IHdDID0gMDsgd0MgPCBcIitkK1wiOyB3QysrKSB7XFxuICAgICAgICAgICAgaW50IHhDID0geENDb3JuZXIgKyB3QyAqIFwiK2grXCI7XFxuXFxuICAgICAgICAgICAgaWYgKHhDIDwgMCB8fCB4QyA+PSBcIithK1wiKSB7XFxuICAgICAgICAgICAgICBjb250aW51ZTtcXG4gICAgICAgICAgICB9XFxuXFxuICAgICAgICAgICAgZmxvYXQgeFZhbCA9IGdldFgoYmF0Y2gsIHhSLCB4QywgZDEpO1xcbiAgICAgICAgICAgIGZsb2F0IHdWYWwgPSBnZXRXKHdSLCB3QywgZDEsIHEpO1xcbiAgICAgICAgICAgIGRvdFByb2QgKz0geFZhbCAqIHdWYWw7XFxuICAgICAgICAgIH1cXG4gICAgICAgIH1cXG5cXG4gICAgICAgIGZsb2F0IHJlc3VsdCA9IGRvdFByb2Q7XFxuICAgICAgICBcIitnK1wiXFxuICAgICAgICBcIittK1wiXFxuICAgICAgICBzZXRPdXRwdXQocmVzdWx0KTtcXG4gICAgICB9XFxuICAgIFwifSx0aT1mdW5jdGlvbih0LGUsbixyKXt2b2lkIDA9PT1lJiYoZT0hMSksdm9pZCAwPT09biYmKG49bnVsbCksdm9pZCAwPT09ciYmKHI9ITEpLHRoaXMudmFyaWFibGVOYW1lcz1bXCJ4XCIsXCJXXCJdLHRoaXMucGFja2VkSW5wdXRzPSEwLHRoaXMucGFja2VkT3V0cHV0PSEwLHRoaXMub3V0cHV0U2hhcGU9dC5vdXRTaGFwZTtmb3IodmFyIG89dC5pbkhlaWdodCxhPXQuaW5XaWR0aCxpPXQucGFkSW5mby50b3Ascz10LnBhZEluZm8ubGVmdCx1PXQuc3RyaWRlSGVpZ2h0LGM9dC5zdHJpZGVXaWR0aCxsPXQuZGlsYXRpb25IZWlnaHQsaD10LmRpbGF0aW9uV2lkdGgsZj10LmZpbHRlckhlaWdodCxkPXQuZmlsdGVyV2lkdGgscD1kLHY9XCJpbnQgeFI7IGludCB4QzsgaW50IHhDT2Zmc2V0O1wiLG09MDttPGY7bSsrKWZvcih2YXIgZz0wO2c8ZDtnKyspdis9XCJcXG4gICAgICAgICAgdmVjNCB4VGV4ZWxSXCIrbStcIkNcIisyKmcrXCIgPSB2ZWM0KDAuKTtcXG4gICAgICAgICAgdmVjNCB3UlwiK20rXCJDXCIrZytcIiA9IHZlYzQoMC4pO1xcbiAgICAgICAgICB2ZWM0IHhSXCIrbStcIkNcIitnK1wiID0gdmVjNCgwLik7XCI7Zm9yKG09MDttPGY7bSsrKWZvcih2YXIgeT0wO3k8cDt5Kyspe2lmKHYrPVwiXFxuICAgICAgICAgIHhSID0geFJDb3JuZXIgKyBcIittKmwrXCI7XFxuICAgICAgICAgIHhDID0geENDb3JuZXIgKyBcIisoZz0yKnkpKmgrXCI7XFxuICAgICAgICBcIiwxPT09Yyl7aWYoZzxkJiYodis9cyUyPT0xP1wiXFxuICAgICAgICAgICAgICAgIHhDT2Zmc2V0ID0geEMgKyAxO1xcbiAgICAgICAgICAgICAgICBpZih4UiA+PSAwICYmIHhSIDwgXCIrbytcIiAmJiB4Q09mZnNldCA+PSAwICYmIHhDT2Zmc2V0IDwgXCIrYStcIikge1xcbiAgICAgICAgICAgICAgICAgIHhUZXhlbFJcIittK1wiQ1wiK2crXCIgPSBnZXRYKGJhdGNoLCB4UiwgeENPZmZzZXQsIGQxKTtcXG5cXG4gICAgICAgICAgICAgICAgICAvLyBOZWVkIHRvIG1hbnVhbGx5IGNsZWFyIHVudXNlZCBjaGFubmVscyBpbiBjYXNlXFxuICAgICAgICAgICAgICAgICAgLy8gd2UncmUgcmVhZGluZyBmcm9tIHJlY3ljbGVkIHRleHR1cmUuXFxuICAgICAgICAgICAgICAgICAgaWYoeENPZmZzZXQgKyAxID49IFwiK2ErXCIpIHtcXG4gICAgICAgICAgICAgICAgICAgIHhUZXhlbFJcIittK1wiQ1wiK2crXCIuencgPSB2ZWMyKDAuKTtcXG4gICAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgICAgICAgICAgeFRleGVsUlwiK20rXCJDXCIrZytcIiA9IHZlYzQoMC4pO1xcbiAgICAgICAgICAgICAgICB9XFxuXFxuICAgICAgICAgICAgICAgIHhDT2Zmc2V0ID0geEMgKyAxIC0gMjtcXG4gICAgICAgICAgICAgICAgaWYoeFIgPj0gMCAmJiB4UiA8IFwiK28rXCIgJiYgeENPZmZzZXQgPj0gMCAmJiB4Q09mZnNldCA8IFwiK2ErXCIpIHtcXG4gICAgICAgICAgICAgICAgICB2ZWM0IHByZXZpb3VzID0gZ2V0WChiYXRjaCwgeFIsIHhDT2Zmc2V0LCBkMSk7XFxuXFxuICAgICAgICAgICAgICAgICAgLy8gTmVlZCB0byBtYW51YWxseSBjbGVhciB1bnVzZWQgY2hhbm5lbHMgaW4gY2FzZVxcbiAgICAgICAgICAgICAgICAgIC8vIHdlJ3JlIHJlYWRpbmcgZnJvbSByZWN5Y2xlZCB0ZXh0dXJlLlxcbiAgICAgICAgICAgICAgICAgIGlmKHhDT2Zmc2V0ICsgMSA+PSBcIithK1wiKSB7XFxuICAgICAgICAgICAgICAgICAgICBwcmV2aW91cy56dyA9IHZlYzIoMC4pO1xcbiAgICAgICAgICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgICAgICAgICB4UlwiK20rXCJDXCIrZytcIiA9IHZlYzQocHJldmlvdXMuencsIHhUZXhlbFJcIittK1wiQ1wiK2crXCIueHkpO1xcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgICAgICAgIHhSXCIrbStcIkNcIitnK1wiID0gdmVjNCgwLCAwLCB4VGV4ZWxSXCIrbStcIkNcIitnK1wiLnh5KTtcXG4gICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgXCI6XCJcXG4gICAgICAgICAgICAgICAgaWYoeFIgPj0gMCAmJiB4UiA8IFwiK28rXCIgJiYgeEMgPj0gMCAmJiB4QyA8IFwiK2ErXCIpIHtcXG4gICAgICAgICAgICAgICAgICB4VGV4ZWxSXCIrbStcIkNcIitnK1wiID0gZ2V0WChiYXRjaCwgeFIsIHhDLCBkMSk7XFxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgICAgICAgICAgeFRleGVsUlwiK20rXCJDXCIrZytcIiA9IHZlYzQoMC4pO1xcbiAgICAgICAgICAgICAgICB9XFxuXFxuICAgICAgICAgICAgICAgIHhSXCIrbStcIkNcIitnK1wiID0geFRleGVsUlwiK20rXCJDXCIrZytcIjtcXG4gICAgICAgICAgICAgIFwiLGcrMTxkKSl7dmFyIHg9cyUyPT0wP2IoaCk6aDtoJTI9PTAmJnMlMj09MXx8aCUyIT0wJiZzJTIhPTE/KHYrPVwiXFxuICAgICAgICAgICAgICAgICAgeENPZmZzZXQgPSB4QyArIFwiK3MlMitcIiArIFwiK3grXCI7XFxuXFxuICAgICAgICAgICAgICAgICAgaWYoeFIgPj0gMCAmJiB4UiA8IFwiK28rXCIgJiZcXG4gICAgICAgICAgICAgICAgICAgIHhDT2Zmc2V0ID49IDAgJiYgeENPZmZzZXQgPCBcIithK1wiKSB7XFxuICAgICAgICAgICAgICAgICAgICB4VGV4ZWxSXCIrbStcIkNcIisoZysyKStcIiA9IGdldFgoYmF0Y2gsIHhSLCB4Q09mZnNldCwgZDEpO1xcbiAgICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgXCIsaD4xJiYodis9XCJcXG4gICAgICAgICAgICAgICAgICAgIHhDT2Zmc2V0IC09IDI7XFxuICAgICAgICAgICAgICAgICAgICBpZih4UiA+PSAwICYmIHhSIDwgXCIrbytcIiAmJlxcbiAgICAgICAgICAgICAgICAgICAgICB4Q09mZnNldCA+PSAwICYmIHhDT2Zmc2V0IDwgXCIrYStcIikge1xcbiAgICAgICAgICAgICAgICAgICAgICB4VGV4ZWxSXCIrbStcIkNcIitnK1wiID0gZ2V0WChiYXRjaCwgeFIsIHhDT2Zmc2V0LCBkMSk7XFxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgICAgICAgICAgICB4VGV4ZWxSXCIrbStcIkNcIitnK1wiID0gdmVjNCgwLik7XFxuICAgICAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgICAgXCIpLHYrPVwiXFxuICAgICAgICAgICAgICAgICAgeFJcIittK1wiQ1wiKyhnKzEpK1wiID0gdmVjNChcXG4gICAgICAgICAgICAgICAgICAgIHhUZXhlbFJcIittK1wiQ1wiK2crXCIuencsIHhUZXhlbFJcIittK1wiQ1wiKyhnKzIpK1wiLnh5KTtcXG4gICAgICAgICAgICAgICAgXCIpOnYrPVwiXFxuICAgICAgICAgICAgICAgICAgeENPZmZzZXQgPSB4QyArIFwiK3grXCI7XFxuXFxuICAgICAgICAgICAgICAgICAgaWYoeFIgPj0gMCAmJiB4UiA8IFwiK28rXCIgJiZcXG4gICAgICAgICAgICAgICAgICAgIHhDT2Zmc2V0ID49IDAgJiYgeENPZmZzZXQgPCBcIithK1wiKSB7XFxuICAgICAgICAgICAgICAgICAgICB4VGV4ZWxSXCIrbStcIkNcIisoZysyKStcIiA9IGdldFgoYmF0Y2gsIHhSLCB4Q09mZnNldCwgZDEpO1xcbiAgICAgICAgICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgICAgICAgICB4UlwiK20rXCJDXCIrKGcrMSkrXCIgPSB4VGV4ZWxSXCIrbStcIkNcIisoZysyKStcIjtcXG4gICAgICAgICAgICAgICAgXCJ9fWVsc2UgZzxkJiYodis9XCJcXG4gICAgICAgICAgICAgIGlmKHhSID49IDAgJiYgeFIgPCBcIitvK1wiKSB7XFxuICAgICAgICAgICAgXCIscyUyPT0xPyh2Kz1cIlxcbiAgICAgICAgICAgICAgICB4Q09mZnNldCA9IHhDICsgMSAtIFwiK2MrXCI7XFxuICAgICAgICAgICAgICAgIGlmKHhDT2Zmc2V0ID49IDAgJiYgeENPZmZzZXQgPCBcIithK1wiKSB7XFxuICAgICAgICAgICAgICAgICAgeFRleGVsUlwiK20rXCJDXCIrZytcIiA9IGdldFgoYmF0Y2gsIHhSLCB4Q09mZnNldCwgZDEpO1xcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgICAgICAgIHhUZXhlbFJcIittK1wiQ1wiK2crXCIgPSB2ZWM0KDAuKTtcXG4gICAgICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgICAgICBpZih4QyArIDEgPj0gMCAmJiB4QyArIDEgPCBcIithK1wiKSB7XFxuICAgICAgICAgICAgICAgICAgeFRleGVsUlwiK20rXCJDXCIrKGcrMikrXCIgPSBnZXRYKGJhdGNoLCB4UiwgeEMgKyAxLCBkMSk7XFxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgICAgICAgICAgeFRleGVsUlwiK20rXCJDXCIrKGcrMikrXCIgPSB2ZWM0KDAuKTtcXG4gICAgICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgICAgICB4UlwiK20rXCJDXCIrZytcIiA9IHZlYzQoXFxuICAgICAgICAgICAgICAgICAgeFRleGVsUlwiK20rXCJDXCIrZytcIi56dywgeFRleGVsUlwiK20rXCJDXCIrKGcrMikrXCIuencpO1xcbiAgICAgICAgICAgICAgXCIsZysxPGQmJih2Kz1cIlxcbiAgICAgICAgICAgICAgICAgIHZlYzQgZmluYWwgPSB2ZWM0KDAuKTtcXG4gICAgICAgICAgICAgICAgICB4Q09mZnNldCA9IHhDICsgMSArIFwiK2MrXCI7XFxuICAgICAgICAgICAgICAgICAgaWYoeENPZmZzZXQgPj0gMCAmJiB4Q09mZnNldCA8IFwiK2ErXCIpIHtcXG4gICAgICAgICAgICAgICAgICAgIGZpbmFsID0gZ2V0WChiYXRjaCwgeFIsIHhDT2Zmc2V0LCBkMSk7XFxuICAgICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICAgIHhSXCIrbStcIkNcIisoZysxKStcIiA9IHZlYzQoeFRleGVsUlwiK20rXCJDXCIrKGcrMikrXCIueHksIGZpbmFsLnh5KTtcXG4gICAgICAgICAgICAgICAgXCIpKToodis9XCJcXG4gICAgICAgICAgICAgICAgaWYoeEMgPj0gMCAmJiB4QyA8IFwiK2ErXCIpIHtcXG4gICAgICAgICAgICAgICAgICB4VGV4ZWxSXCIrbStcIkNcIitnK1wiID0gZ2V0WChiYXRjaCwgeFIsIHhDLCBkMSk7XFxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgICAgICAgICAgeFRleGVsUlwiK20rXCJDXCIrZytcIiA9IHZlYzQoMC4pO1xcbiAgICAgICAgICAgICAgICB9XFxuXFxuICAgICAgICAgICAgICAgIHhDT2Zmc2V0ID0geEMgKyBcIitjK1wiO1xcbiAgICAgICAgICAgICAgICBpZih4Q09mZnNldCA+PSAwICYmIHhDT2Zmc2V0IDwgXCIrYStcIikge1xcbiAgICAgICAgICAgICAgICAgIHhUZXhlbFJcIittK1wiQ1wiKyhnKzIpK1wiID0gZ2V0WChiYXRjaCwgeFIsIHhDT2Zmc2V0LCBkMSk7XFxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgICAgICAgICAgeFRleGVsUlwiK20rXCJDXCIrKGcrMikrXCIgPSB2ZWM0KDAuKTtcXG4gICAgICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgICAgICB4UlwiK20rXCJDXCIrZytcIiA9IHZlYzQoXFxuICAgICAgICAgICAgICAgICAgeFRleGVsUlwiK20rXCJDXCIrZytcIi54eSwgeFRleGVsUlwiK20rXCJDXCIrKGcrMikrXCIueHkpO1xcbiAgICAgICAgICAgICAgXCIsZysxPGQmJih2Kz1cIlxcbiAgICAgICAgICAgICAgICAgIHhSXCIrbStcIkNcIisoZysxKStcIiA9IHZlYzQoXFxuICAgICAgICAgICAgICAgICAgICB4VGV4ZWxSXCIrbStcIkNcIitnK1wiLnp3LCB4VGV4ZWxSXCIrbStcIkNcIisoZysyKStcIi56dyk7XFxuICAgICAgICAgICAgICAgIFwiKSksdis9XCJ9XCIpO2c8ZCYmKHYrPVwiXFxuICAgICAgICAgICAgdmVjNCB3VGV4ZWxSXCIrbStcIkNcIitnK1wiID0gZ2V0VyhcIittK1wiLCBcIitnK1wiLCBkMSwgcSk7XFxuICAgICAgICAgICAgd1JcIittK1wiQ1wiK2crXCIgPSB2ZWM0KHdUZXhlbFJcIittK1wiQ1wiK2crXCIueHosIHdUZXhlbFJcIittK1wiQ1wiK2crXCIueHopO1xcbiAgICAgICAgICBcIixnKzE8ZCYmKHYrPVwiXFxuICAgICAgICAgICAgICB2ZWM0IHdUZXhlbFJcIittK1wiQ1wiKyhnKzEpK1wiID0gZ2V0VyhcIittK1wiLCBcIisoZysxKStcIiwgZDEsIHEpO1xcbiAgICAgICAgICAgICAgd1JcIittK1wiQ1wiKyhnKzEpK1wiID1cXG4gICAgICAgICAgICAgICAgdmVjNCh3VGV4ZWxSXCIrbStcIkNcIisoZysxKStcIi54eiwgd1RleGVsUlwiK20rXCJDXCIrKGcrMSkrXCIueHopO1wiKSl9Zm9yKG09MDttPGY7bSsrKWZvcihnPTA7ZzxkO2crKyl2Kz1cImRvdFByb2QgKz0geFJcIittK1wiQ1wiK2crXCIgKiB3UlwiK20rXCJDXCIrZytcIjtcIjt2YXIgdz1cIlwiLEM9XCJcIjtuJiYodz1yP1widmVjNCBhY3RpdmF0aW9uKHZlYzQgYSkge1xcbiAgICAgICAgICB2ZWM0IGIgPSBnZXRQcmVsdUFjdGl2YXRpb25XZWlnaHRzQXRPdXRDb29yZHMoKTtcXG4gICAgICAgICAgXCIrbitcIlxcbiAgICAgICAgfVwiOlwidmVjNCBhY3RpdmF0aW9uKHZlYzQgeCkge1xcbiAgICAgICAgICBcIituK1wiXFxuICAgICAgICB9XCIsQz1cInJlc3VsdCA9IGFjdGl2YXRpb24ocmVzdWx0KTtcIik7dmFyIEU9ZT9cInJlc3VsdCArPSBnZXRCaWFzQXRPdXRDb29yZHMoKTtcIjpcIlwiO2UmJnRoaXMudmFyaWFibGVOYW1lcy5wdXNoKFwiYmlhc1wiKSxyJiZ0aGlzLnZhcmlhYmxlTmFtZXMucHVzaChcInByZWx1QWN0aXZhdGlvbldlaWdodHNcIiksdGhpcy51c2VyQ29kZT1cIlxcbiAgICAgIFwiK3crXCJcXG5cXG4gICAgICBjb25zdCBpdmVjMiBzdHJpZGVzID0gaXZlYzIoXCIrdStcIiwgXCIrYytcIik7XFxuICAgICAgY29uc3QgaXZlYzIgcGFkcyA9IGl2ZWMyKFwiK2krXCIsIFwiK3MrXCIpO1xcblxcbiAgICAgIHZvaWQgbWFpbigpIHtcXG5cXG4gICAgICAgIGl2ZWM0IGNvb3JkcyA9IGdldE91dHB1dENvb3JkcygpO1xcbiAgICAgICAgaW50IGJhdGNoID0gY29vcmRzLng7XFxuICAgICAgICBpdmVjMiB4UkNDb3JuZXIgPSBjb29yZHMueXogKiBzdHJpZGVzIC0gcGFkcztcXG4gICAgICAgIGludCBkMiA9IGNvb3Jkcy53O1xcbiAgICAgICAgaW50IGQxID0gZDI7XFxuICAgICAgICBpbnQgcSA9IDA7XFxuICAgICAgICBpbnQgeFJDb3JuZXIgPSB4UkNDb3JuZXIueDtcXG4gICAgICAgIGludCB4Q0Nvcm5lciA9IHhSQ0Nvcm5lci55O1xcblxcbiAgICAgICAgdmVjNCBkb3RQcm9kID0gdmVjNCgwLik7XFxuXFxuICAgICAgICBcIit2K1wiXFxuXFxuICAgICAgICB2ZWM0IHJlc3VsdCA9IGRvdFByb2Q7XFxuICAgICAgICBcIitFK1wiXFxuICAgICAgICBcIitDK1wiXFxuICAgICAgICBzZXRPdXRwdXQocmVzdWx0KTtcXG4gICAgICB9XFxuICAgIFwifSxlaT1mdW5jdGlvbih0LGUsbixyLG8pe3RoaXMudmFyaWFibGVOYW1lcz1bXCJJbWFnZVwiLFwiQm94ZXNcIixcIkJveEluZFwiXSx0aGlzLm91dHB1dFNoYXBlPVtdO3ZhciBhPXRbMF0saT10WzFdLHM9dFsyXSx1PXRbM10sYz1lWzBdLGw9blswXSxoPW5bMV07dGhpcy5vdXRwdXRTaGFwZT1bYyxsLGgsdV07dmFyIGY9XCJiaWxpbmVhclwiPT09cj8xOjAsZD1baS0xK1wiLjBcIixzLTErXCIuMFwiXSxwPWRbMF0sdj1kWzFdLG09bD4xP1tcIlwiKyhpLTEpLyhsLTEpLFwiKHkyLXkxKSAqIGhlaWdodF9yYXRpb1wiLFwieTEqXCIrcCtcIiArIGZsb2F0KHkpKihoZWlnaHRfc2NhbGUpXCJdOltcIjAuMFwiLFwiMC4wXCIsXCIwLjUgKiAoeTEreTIpICogXCIrcF0sZz1tWzBdLHk9bVsxXSx4PW1bMl0sYj1oPjE/W1wiXCIrKHMtMSkvKGgtMSksXCIoeDIteDEpICogd2lkdGhfcmF0aW9cIixcIngxKlwiK3YrXCIgKyBmbG9hdCh4KSood2lkdGhfc2NhbGUpXCJdOltcIjAuMFwiLFwiMC4wXCIsXCIwLjUgKiAoeDEreDIpICogXCIrdl0sdz1iWzBdLEM9YlsxXSxFPWJbMl07dGhpcy51c2VyQ29kZT1cIlxcbiAgICAgIGNvbnN0IGZsb2F0IGhlaWdodF9yYXRpbyA9IGZsb2F0KFwiK2crXCIpO1xcbiAgICAgIGNvbnN0IGZsb2F0IHdpZHRoX3JhdGlvID0gZmxvYXQoXCIrdytcIik7XFxuICAgICAgdm9pZCBtYWluKCkge1xcbiAgICAgICAgaXZlYzQgY29vcmRzID0gZ2V0T3V0cHV0Q29vcmRzKCk7XFxuICAgICAgICBpbnQgYiA9IGNvb3Jkc1swXTtcXG4gICAgICAgIGludCB5ID0gY29vcmRzWzFdO1xcbiAgICAgICAgaW50IHggPSBjb29yZHNbMl07XFxuICAgICAgICBpbnQgZCA9IGNvb3Jkc1szXTtcXG5cXG4gICAgICAgIC8vIGdldCBib3ggdmFsc1xcbiAgICAgICAgZmxvYXQgeTEgPSBnZXRCb3hlcyhiLDApO1xcbiAgICAgICAgZmxvYXQgeDEgPSBnZXRCb3hlcyhiLDEpO1xcbiAgICAgICAgZmxvYXQgeTIgPSBnZXRCb3hlcyhiLDIpO1xcbiAgICAgICAgZmxvYXQgeDIgPSBnZXRCb3hlcyhiLDMpO1xcblxcbiAgICAgICAgLy8gZ2V0IGltYWdlIGluIGJhdGNoIGluZGV4XFxuICAgICAgICBpbnQgYkluZCA9IHJvdW5kKGdldEJveEluZChiKSk7XFxuICAgICAgICBpZihiSW5kIDwgMCB8fCBiSW5kID49IFwiK2ErXCIpIHtcXG4gICAgICAgICAgcmV0dXJuO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgZmxvYXQgaGVpZ2h0X3NjYWxlID0gXCIreStcIjtcXG4gICAgICAgIGZsb2F0IHdpZHRoX3NjYWxlID0gXCIrQytcIjtcXG5cXG4gICAgICAgIGZsb2F0IGluX3kgPSBcIit4K1wiO1xcbiAgICAgICAgaWYoIGluX3kgPCAwLjAgfHwgaW5feSA+IFwiK3ArXCIgKSB7XFxuICAgICAgICAgIHNldE91dHB1dChmbG9hdChcIitvK1wiKSk7XFxuICAgICAgICAgIHJldHVybjtcXG4gICAgICAgIH1cXG4gICAgICAgIGZsb2F0IGluX3ggPSBcIitFK1wiO1xcbiAgICAgICAgaWYoIGluX3ggPCAwLjAgfHwgaW5feCA+IFwiK3YrXCIgKSB7XFxuICAgICAgICAgIHNldE91dHB1dChmbG9hdChcIitvK1wiKSk7XFxuICAgICAgICAgIHJldHVybjtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIHZlYzIgc291cmNlRnJhY0luZGV4Q1IgPSB2ZWMyKGluX3gsaW5feSk7XFxuICAgICAgICBpZihcIitmK1wiID09IDEpIHtcXG4gICAgICAgICAgLy8gQ29tcHV0ZSB0aGUgZm91ciBpbnRlZ2VyIGluZGljZXMuXFxuICAgICAgICAgIGl2ZWMyIHNvdXJjZUZsb29yQ1IgPSBpdmVjMihzb3VyY2VGcmFjSW5kZXhDUik7XFxuICAgICAgICAgIGl2ZWMyIHNvdXJjZUNlaWxDUiA9IGl2ZWMyKGNlaWwoc291cmNlRnJhY0luZGV4Q1IpKTtcXG5cXG4gICAgICAgICAgZmxvYXQgdG9wTGVmdCA9IGdldEltYWdlKGIsIHNvdXJjZUZsb29yQ1IueSwgc291cmNlRmxvb3JDUi54LCBkKTtcXG4gICAgICAgICAgZmxvYXQgYm90dG9tTGVmdCA9IGdldEltYWdlKGIsIHNvdXJjZUNlaWxDUi55LCBzb3VyY2VGbG9vckNSLngsIGQpO1xcbiAgICAgICAgICBmbG9hdCB0b3BSaWdodCA9IGdldEltYWdlKGIsIHNvdXJjZUZsb29yQ1IueSwgc291cmNlQ2VpbENSLngsIGQpO1xcbiAgICAgICAgICBmbG9hdCBib3R0b21SaWdodCA9IGdldEltYWdlKGIsIHNvdXJjZUNlaWxDUi55LCBzb3VyY2VDZWlsQ1IueCwgZCk7XFxuXFxuICAgICAgICAgIHZlYzIgZnJhY0NSID0gc291cmNlRnJhY0luZGV4Q1IgLSB2ZWMyKHNvdXJjZUZsb29yQ1IpO1xcblxcbiAgICAgICAgICBmbG9hdCB0b3AgPSB0b3BMZWZ0ICsgKHRvcFJpZ2h0IC0gdG9wTGVmdCkgKiBmcmFjQ1IueDtcXG4gICAgICAgICAgZmxvYXQgYm90dG9tID0gYm90dG9tTGVmdCArIChib3R0b21SaWdodCAtIGJvdHRvbUxlZnQpICogZnJhY0NSLng7XFxuICAgICAgICAgIGZsb2F0IG5ld1ZhbHVlID0gdG9wICsgKGJvdHRvbSAtIHRvcCkgKiBmcmFjQ1IueTtcXG4gICAgICAgICAgc2V0T3V0cHV0KG5ld1ZhbHVlKTtcXG4gICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgIC8vIENvbXB1dGUgdGhlIGNvb3JkaW5hdG9ycyBvZiBuZWFyZXN0IG5laWdoYm9yIHBvaW50LlxcbiAgICAgICAgICBpdmVjMiBzb3VyY2VOZWFyZXN0Q1IgPSBpdmVjMihmbG9vcihcXG4gICAgICAgICAgICBzb3VyY2VGcmFjSW5kZXhDUiArIHZlYzIoMC41LDAuNSkpKTtcXG4gICAgICAgICAgZmxvYXQgbmV3VmFsdWUgPSBnZXRJbWFnZShiLCBzb3VyY2VOZWFyZXN0Q1IueSwgc291cmNlTmVhcmVzdENSLngsIGQpO1xcbiAgICAgICAgICBzZXRPdXRwdXQobmV3VmFsdWUpO1xcbiAgICAgICAgfVxcbiAgICAgIH1cXG4gICAgXCJ9LG5pPWZ1bmN0aW9uKHQsZSxuKXt0aGlzLnZhcmlhYmxlTmFtZXM9W1wieFwiXSx0aGlzLm91dHB1dFNoYXBlPXQ7dmFyIHI9dC5sZW5ndGgsbz10W3QubGVuZ3RoLTFdLGE9bj9cIjxcIjpcIj5cIjt0aGlzLnVzZXJDb2RlPVwiXFxuICAgICAgaW50IGdldEluZGV4KGludCBpKSB7XFxuICAgICAgICBcIisobj9cInJldHVybiBcIitvK1wiIC1pIC0gMTtcIjpcInJldHVybiBpO1wiKStcIlxcbiAgICAgIH1cXG5cXG4gICAgICB2b2lkIG1haW4oKSB7XFxuICAgICAgICBcIit3YShyKStcIiBjb29yZHMgPSBnZXRPdXRwdXRDb29yZHMoKTtcXG4gICAgICAgIGludCBlbmQgPSBcIityaShyLFwiY29vcmRzXCIpK1wiO1xcbiAgICAgICAgZmxvYXQgdmFsID0gMC4wO1xcbiAgICAgICAgZm9yIChpbnQgaSA9IFwiK28rXCIgLSAxOyBpID49IDA7IGkgLT0gMSkge1xcbiAgICAgICAgICBpbnQgaWR4ID0gZ2V0SW5kZXgoaSk7XFxuICAgICAgICAgIGlmIChpZHggXCIrYStcIiBlbmQpIHtcXG4gICAgICAgICAgICBjb250aW51ZTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgICBpZiAoaWR4ID09IGVuZCAmJiBcIitlK1wiKSB7XFxuICAgICAgICAgICAgY29udGludWU7XFxuICAgICAgICAgIH1cXG4gICAgICAgICAgXCIrcmkocixcImNvb3Jkc1wiKStcIiA9IGlkeDtcXG4gICAgICAgICAgdmFsICs9IGdldFgoXCIrZnVuY3Rpb24odCxlKXtpZigxPT09dClyZXR1cm5cIlwiK2U7aWYoMj09PXQpcmV0dXJuIGUrXCIueCwgXCIrZStcIi55XCI7aWYoMz09PXQpcmV0dXJuIGUrXCIueCwgXCIrZStcIi55LCBcIitlK1wiLnpcIjtpZig0PT09dClyZXR1cm4gZStcIi54LCBcIitlK1wiLnksIFwiK2UrXCIueiwgXCIrZStcIi53XCI7dGhyb3cgRXJyb3IoXCJDdW11bGF0aXZlIHN1bSBmb3IgcmFuayBcIit0K1wiIGlzIG5vdCB5ZXQgc3VwcG9ydGVkXCIpfShyLFwiY29vcmRzXCIpK1wiKTtcXG4gICAgICAgIH1cXG4gICAgICAgIHNldE91dHB1dCh2YWwpO1xcbiAgICAgIH1cXG4gICAgXCJ9O2Z1bmN0aW9uIHJpKHQsZSl7aWYoMT09PXQpcmV0dXJuXCJcIitlO2lmKDI9PT10KXJldHVybiBlK1wiLnlcIjtpZigzPT09dClyZXR1cm4gZStcIi56XCI7aWYoND09PXQpcmV0dXJuIGUrXCIud1wiO3Rocm93IEVycm9yKFwiQ3VtdWxhdGl2ZSBzdW0gZm9yIHJhbmsgXCIrdCtcIiBpcyBub3QgeWV0IHN1cHBvcnRlZFwiKX12YXIgb2k9ZnVuY3Rpb24odCl7dGhpcy52YXJpYWJsZU5hbWVzPVtcIkFcIl0sdGhpcy5wYWNrZWRJbnB1dHM9ITEsdGhpcy5wYWNrZWRPdXRwdXQ9ITAsdGhpcy5vdXRQYWNraW5nU2NoZW1lPVZ0LkRFTlNFO3ZhciBlPVl0KHQpLG49dWEoKTt0aGlzLm91dHB1dFNoYXBlPXQsdGhpcy51c2VyQ29kZT1cIlxcbiAgICAgIGl2ZWMzIG91dENvb3Jkc0Zyb21GbGF0SW5kZXgoaW50IGluZGV4KSB7XFxuICAgICAgICBcIitjYShbXCJyXCIsXCJjXCIsXCJkXCJdLHQpK1wiXFxuICAgICAgICByZXR1cm4gaXZlYzMociwgYywgZCk7XFxuICAgICAgfVxcblxcbiAgICAgIHZvaWQgbWFpbigpIHtcXG4gICAgICAgIGl2ZWMyIHJlc1RleFJDID0gaXZlYzIocmVzdWx0VVYueXggKlxcbiAgICAgICAgICB2ZWMyKFwiK2VbMF0rXCIsIFwiK2VbMV0rXCIpKTtcXG4gICAgICAgIGludCBpbmRleCA9IDQgKiAocmVzVGV4UkMueCAqIFwiK2VbMV0rXCIgKyByZXNUZXhSQy55KTtcXG5cXG4gICAgICAgIHZlYzQgcmVzdWx0ID0gdmVjNCgwLik7XFxuXFxuICAgICAgICBmb3IgKGludCBpPTA7IGk8NDsgaSsrKSB7XFxuICAgICAgICAgIGludCBmbGF0SW5kZXggPSBpbmRleCArIGk7XFxuICAgICAgICAgIGl2ZWMzIHJjID0gb3V0Q29vcmRzRnJvbUZsYXRJbmRleChmbGF0SW5kZXgpO1xcbiAgICAgICAgICByZXN1bHRbaV0gPSBnZXRBKHJjLngsIHJjLnksIHJjLnopO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgXCIrbi5vdXRwdXQrXCIgPSByZXN1bHQ7XFxuICAgICAgfVxcbiAgICBcIn0sYWk9ZnVuY3Rpb24odCl7dGhpcy52YXJpYWJsZU5hbWVzPVtcIkFcIl0sdGhpcy5wYWNrZWRJbnB1dHM9ITAsdGhpcy5wYWNrZWRPdXRwdXQ9ITAsdGhpcy5vdXRQYWNraW5nU2NoZW1lPVZ0LkRFTlNFO3ZhciBlPVl0KHQpLG49dWEoKTt0aGlzLm91dHB1dFNoYXBlPXQsdGhpcy51c2VyQ29kZT1cIlxcbiAgICAgIGl2ZWMzIG91dENvb3Jkc0Zyb21GbGF0SW5kZXgoaW50IGluZGV4KSB7XFxuICAgICAgICBcIitjYShbXCJyXCIsXCJjXCIsXCJkXCJdLHQpK1wiXFxuICAgICAgICByZXR1cm4gaXZlYzMociwgYywgZCk7XFxuICAgICAgfVxcblxcbiAgICAgIHZvaWQgbWFpbigpIHtcXG4gICAgICAgIGl2ZWMyIHJlc1RleFJDID0gaXZlYzIocmVzdWx0VVYueXggKlxcbiAgICAgICAgICB2ZWMyKFwiK2VbMF0rXCIsIFwiK2VbMV0rXCIpKTtcXG4gICAgICAgIGludCBpbmRleCA9IDQgKiAocmVzVGV4UkMueCAqIFwiK2VbMV0rXCIgKyByZXNUZXhSQy55KTtcXG5cXG4gICAgICAgIHZlYzQgcmVzdWx0ID0gdmVjNCgwLik7XFxuXFxuICAgICAgICBmb3IgKGludCBpPTA7IGk8NDsgaSsrKSB7XFxuICAgICAgICAgIGludCBmbGF0SW5kZXggPSBpbmRleCArIGk7XFxuICAgICAgICAgIGl2ZWMzIHJjID0gb3V0Q29vcmRzRnJvbUZsYXRJbmRleChmbGF0SW5kZXgpO1xcbiAgICAgICAgICByZXN1bHRbaV0gPSBnZXRDaGFubmVsKGdldEEocmMueCwgcmMueSwgcmMueiksIHZlYzIocmMueSwgcmMueikpO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgXCIrbi5vdXRwdXQrXCIgPSByZXN1bHQ7XFxuICAgICAgfVxcbiAgICBcIn0saWk9ZnVuY3Rpb24oKXtmdW5jdGlvbiB0KHQsZSxuKXt0aGlzLnZhcmlhYmxlTmFtZXM9W1wieFwiXSx0aGlzLm91dHB1dFNoYXBlPVtdLHRoaXMub3V0cHV0U2hhcGU9dCx0aGlzLmJsb2NrU2l6ZT1lLHRoaXMuZGF0YUZvcm1hdD1uLHRoaXMudXNlckNvZGU9XCJcXG4gICAgdm9pZCBtYWluKCkge1xcbiAgICAgIGl2ZWM0IGNvb3JkcyA9IGdldE91dHB1dENvb3JkcygpO1xcbiAgICAgIGludCBiID0gY29vcmRzWzBdO1xcbiAgICAgIGludCBoID0gXCIrdGhpcy5nZXRIZWlnaHRDb29yZFN0cmluZygpK1wiO1xcbiAgICAgIGludCB3ID0gXCIrdGhpcy5nZXRXaWR0aENvb3JkU3RyaW5nKCkrXCI7XFxuICAgICAgaW50IGQgPSBcIit0aGlzLmdldERlcHRoQ29vcmRTdHJpbmcoKStcIjtcXG5cXG4gICAgICBpbnQgaW5faCA9IGggLyBcIitlK1wiO1xcbiAgICAgIGludCBvZmZzZXRfaCA9IGltb2QoaCwgXCIrZStcIik7XFxuICAgICAgaW50IGluX3cgPSB3IC8gXCIrZStcIjtcXG4gICAgICBpbnQgb2Zmc2V0X3cgPSBpbW9kKHcsIFwiK2UrXCIpO1xcbiAgICAgIGludCBvZmZzZXRfZCA9IChvZmZzZXRfaCAqIFwiK2UrXCIgKyBvZmZzZXRfdykgKlxcbiAgICAgICAgXCIrdGhpcy5nZXRPdXRwdXREZXB0aFNpemUoKStcIjtcXG4gICAgICBpbnQgaW5fZCA9IGQgKyBvZmZzZXRfZDtcXG5cXG4gICAgICBmbG9hdCByZXN1bHQgPSBcIit0aGlzLmdldElucHV0U2FtcGxpbmdTdHJpbmcoKStcIjtcXG4gICAgICBzZXRPdXRwdXQocmVzdWx0KTtcXG4gICAgfVxcbiAgXCJ9cmV0dXJuIHQucHJvdG90eXBlLmdldEhlaWdodENvb3JkU3RyaW5nPWZ1bmN0aW9uKCl7cmV0dXJuXCJOSFdDXCI9PT10aGlzLmRhdGFGb3JtYXQ/XCJjb29yZHNbMV1cIjpcImNvb3Jkc1syXVwifSx0LnByb3RvdHlwZS5nZXRXaWR0aENvb3JkU3RyaW5nPWZ1bmN0aW9uKCl7cmV0dXJuXCJOSFdDXCI9PT10aGlzLmRhdGFGb3JtYXQ/XCJjb29yZHNbMl1cIjpcImNvb3Jkc1szXVwifSx0LnByb3RvdHlwZS5nZXREZXB0aENvb3JkU3RyaW5nPWZ1bmN0aW9uKCl7cmV0dXJuXCJOSFdDXCI9PT10aGlzLmRhdGFGb3JtYXQ/XCJjb29yZHNbM11cIjpcImNvb3Jkc1sxXVwifSx0LnByb3RvdHlwZS5nZXRPdXRwdXREZXB0aFNpemU9ZnVuY3Rpb24oKXtyZXR1cm5cIk5IV0NcIj09PXRoaXMuZGF0YUZvcm1hdD90aGlzLm91dHB1dFNoYXBlWzNdOnRoaXMub3V0cHV0U2hhcGVbMV19LHQucHJvdG90eXBlLmdldElucHV0U2FtcGxpbmdTdHJpbmc9ZnVuY3Rpb24oKXtyZXR1cm5cIk5IV0NcIj09PXRoaXMuZGF0YUZvcm1hdD9cImdldFgoYiwgaW5faCwgaW5fdywgaW5fZClcIjpcImdldFgoYiwgaW5fZCwgaW5faCwgaW5fdylcIn0sdH0oKSxzaT1mdW5jdGlvbih0KXt0aGlzLnZhcmlhYmxlTmFtZXM9W1wiWFwiXSx0aGlzLm91dHB1dFNoYXBlPVt0LHRdLHRoaXMudXNlckNvZGU9XCJcXG4gICAgICB2b2lkIG1haW4oKSB7XFxuICAgICAgICAgIGl2ZWMyIGNvb3JkcyA9IGdldE91dHB1dENvb3JkcygpO1xcbiAgICAgICAgICBmbG9hdCB2YWwgPSBjb29yZHNbMF0gPT0gY29vcmRzWzFdID8gZ2V0WChjb29yZHNbMF0pIDogMC4wO1xcbiAgICAgICAgICBzZXRPdXRwdXQodmFsKTtcXG4gICAgICB9XFxuICAgIFwifSx1aT1mdW5jdGlvbih0KXt0aGlzLnZhcmlhYmxlTmFtZXM9W1wiQVwiXSx0aGlzLm91dFRleFVzYWdlPXp0LkRPV05MT0FEO3ZhciBlPXVhKCk7dGhpcy5vdXRwdXRTaGFwZT10LHRoaXMudXNlckNvZGU9XCJcXG4gICAgICBcIitoYStcIlxcblxcbiAgICAgIHZvaWQgbWFpbigpIHtcXG4gICAgICAgIGZsb2F0IHggPSBnZXRBQXRPdXRDb29yZHMoKTtcXG4gICAgICAgIFwiK2Uub3V0cHV0K1wiID0gZW5jb2RlX2Zsb2F0KHgpO1xcbiAgICAgIH1cXG4gICAgXCJ9LGNpPWZ1bmN0aW9uKHQpe3RoaXMudmFyaWFibGVOYW1lcz1bXCJBXCJdLHRoaXMucGFja2VkSW5wdXRzPSEwLHRoaXMucGFja2VkT3V0cHV0PSExLHRoaXMub3V0VGV4VXNhZ2U9enQuRE9XTkxPQUQ7dmFyIGU9dWEoKTt0aGlzLm91dHB1dFNoYXBlPXQsdGhpcy51c2VyQ29kZT1cIlxcbiAgICAgIFwiK2hhK1wiXFxuXFxuICAgICAgdm9pZCBtYWluKCkge1xcbiAgICAgICAgaXZlYzMgY29vcmRzID0gZ2V0T3V0cHV0Q29vcmRzKCk7XFxuICAgICAgICBmbG9hdCB4ID0gZ2V0Q2hhbm5lbChnZXRBQXRPdXRDb29yZHMoKSwgdmVjMihjb29yZHMueSwgY29vcmRzLnopKTtcXG4gICAgICAgIFwiK2Uub3V0cHV0K1wiID0gZW5jb2RlX2Zsb2F0KHgpO1xcbiAgICAgIH1cXG4gICAgXCJ9LGxpPWZ1bmN0aW9uKHQsZSxuKXt2b2lkIDA9PT1uJiYobj0hMSksdGhpcy52YXJpYWJsZU5hbWVzPVtcIkFcIl07dmFyIHI9dWEoKSxvPWVbMF0sYT1lWzFdO3RoaXMub3V0cHV0U2hhcGU9dDt2YXIgaT1cInJlc3VsdFwiO24mJihpPVwiZmxvb3IocmVzdWx0ICogMjU1LiArIDAuNSlcIiksdGhpcy51c2VyQ29kZT1cIlxcbiAgICAgIFwiK2xhKHQpK1wiXFxuXFxuICAgICAgdm9pZCBtYWluKCkge1xcbiAgICAgICAgaXZlYzMgY29vcmRzID0gZ2V0T3V0cHV0Q29vcmRzKCk7XFxuXFxuICAgICAgICBpbnQgZmxhdEluZGV4ID0gZ2V0RmxhdEluZGV4KGNvb3Jkcyk7XFxuICAgICAgICBpbnQgb2Zmc2V0ID0gaW1vZChmbGF0SW5kZXgsIDQpO1xcblxcbiAgICAgICAgZmxhdEluZGV4ID0gaWRpdihmbGF0SW5kZXgsIDQsIDEuKTtcXG4gICAgICAgIFxcbiAgICAgICAgaW50IHIgPSBmbGF0SW5kZXggLyBcIithK1wiO1xcbiAgICAgICAgaW50IGMgPSBpbW9kKGZsYXRJbmRleCwgXCIrYStcIik7XFxuICAgICAgICB2ZWMyIHV2ID0gKHZlYzIoYywgcikgKyBoYWxmQ1IpIC8gdmVjMihcIithK1wiLjAsIFwiK28rXCIuMCk7XFxuICAgICAgICB2ZWM0IHZhbHVlcyA9IFwiK3IudGV4dHVyZTJEK1wiKEEsIHV2KTtcXG5cXG4gICAgICAgIGZsb2F0IHJlc3VsdDtcXG5cXG4gICAgICAgIGlmKG9mZnNldCA9PSAwKSB7XFxuICAgICAgICAgIHJlc3VsdCA9IHZhbHVlc1swXTtcXG4gICAgICAgIH0gZWxzZSBpZihvZmZzZXQgPT0gMSkge1xcbiAgICAgICAgICByZXN1bHQgPSB2YWx1ZXNbMV07XFxuICAgICAgICB9IGVsc2UgaWYob2Zmc2V0ID09IDIpIHtcXG4gICAgICAgICAgcmVzdWx0ID0gdmFsdWVzWzJdO1xcbiAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgcmVzdWx0ID0gdmFsdWVzWzNdO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgXCIrci5vdXRwdXQrXCIgPSB2ZWM0KFwiK2krXCIsIDAuLCAwLiwgMC4pO1xcbiAgICAgIH1cXG4gICAgXCJ9LGhpPWZ1bmN0aW9uKHQsZSxuKXt2b2lkIDA9PT1uJiYobj0hMSksdGhpcy52YXJpYWJsZU5hbWVzPVtcIkFcIl0sdGhpcy5wYWNrZWRJbnB1dHM9ITEsdGhpcy5wYWNrZWRPdXRwdXQ9ITA7dmFyIHI9dWEoKSxvPWVbMF0sYT1lWzFdO3RoaXMub3V0cHV0U2hhcGU9dDt2YXIgaT1cIlwiLHM9XCJyZXN1bHRcIjtuJiYocz1cImZsb29yKHJlc3VsdCAqIDI1NS4gKyAwLjUpXCIpO2Zvcih2YXIgdT0wO3U8PTE7dSsrKWZvcih2YXIgYz0wO2M8PTE7YysrKXt2YXIgbD0yKnUrYztpKz1cIlxcbiAgICAgICAgICBsb2NhbENvb3JkcyA9IGNvb3JkcztcXG4gICAgICAgICAgaWYobG9jYWxDb29yZHNbMl0gKyBcIitjK1wiIDwgXCIrdFsyXStcIikge1xcbiAgICAgICAgICAgIGxvY2FsQ29vcmRzWzJdICs9IFwiK2MrXCI7XFxuICAgICAgICAgICAgaWYobG9jYWxDb29yZHNbMV0gKyBcIit1K1wiIDwgXCIrdFsxXStcIikge1xcbiAgICAgICAgICAgICAgbG9jYWxDb29yZHNbMV0gKz0gXCIrdStcIjtcXG5cXG4gICAgICAgICAgICAgIGZsYXRJbmRleCA9IGdldEZsYXRJbmRleChsb2NhbENvb3Jkcyk7XFxuICAgICAgICAgICAgICBvZmZzZXQgPSBpbW9kKGZsYXRJbmRleCwgNCk7XFxuXFxuICAgICAgICAgICAgICBmbGF0SW5kZXggPSBpZGl2KGZsYXRJbmRleCwgNCwgMS4pO1xcblxcbiAgICAgICAgICAgICAgciA9IGZsYXRJbmRleCAvIFwiK2ErXCI7XFxuICAgICAgICAgICAgICBjID0gaW1vZChmbGF0SW5kZXgsIFwiK2ErXCIpO1xcbiAgICAgICAgICAgICAgdXYgPSAodmVjMihjLCByKSArIGhhbGZDUikgLyB2ZWMyKFwiK2ErXCIuMCwgXCIrbytcIi4wKTtcXG4gICAgICAgICAgICAgIHZhbHVlcyA9IFwiK3IudGV4dHVyZTJEK1wiKEEsIHV2KTtcXG5cXG4gICAgICAgICAgICAgIGlmKG9mZnNldCA9PSAwKSB7XFxuICAgICAgICAgICAgICAgIHJlc3VsdFtcIitsK1wiXSA9IHZhbHVlc1swXTtcXG4gICAgICAgICAgICAgIH0gZWxzZSBpZihvZmZzZXQgPT0gMSkge1xcbiAgICAgICAgICAgICAgICByZXN1bHRbXCIrbCtcIl0gPSB2YWx1ZXNbMV07XFxuICAgICAgICAgICAgICB9IGVsc2UgaWYob2Zmc2V0ID09IDIpIHtcXG4gICAgICAgICAgICAgICAgcmVzdWx0W1wiK2wrXCJdID0gdmFsdWVzWzJdO1xcbiAgICAgICAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICAgICAgcmVzdWx0W1wiK2wrXCJdID0gdmFsdWVzWzNdO1xcbiAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgfVxcbiAgICAgICAgXCJ9dGhpcy51c2VyQ29kZT1cIlxcbiAgICAgIFwiK2xhKHQpK1wiXFxuXFxuICAgICAgdm9pZCBtYWluKCkge1xcbiAgICAgICAgaXZlYzMgY29vcmRzID0gZ2V0T3V0cHV0Q29vcmRzKCk7XFxuXFxuICAgICAgICB2ZWM0IHJlc3VsdCA9IHZlYzQoMC4pO1xcbiAgICAgICAgaW50IGZsYXRJbmRleCwgciwgYywgb2Zmc2V0O1xcbiAgICAgICAgaXZlYzMgbG9jYWxDb29yZHM7XFxuICAgICAgICB2ZWMyIHV2O1xcbiAgICAgICAgdmVjNCB2YWx1ZXM7XFxuXFxuICAgICAgICBcIitpK1wiXFxuXFxuICAgICAgICBcIityLm91dHB1dCtcIiA9IFwiK3MrXCI7XFxuICAgICAgfVxcbiAgICBcIn0sZmk9XCJyZXR1cm4gcmVhbCAqIGV4cFIgLSBpbWFnICogZXhwSTtcIixkaT1cInJldHVybiByZWFsICogZXhwSSArIGltYWcgKiBleHBSO1wiLHBpPWZ1bmN0aW9uKHQsZSxuKXt0aGlzLnZhcmlhYmxlTmFtZXM9W1wicmVhbFwiLFwiaW1hZ1wiXTt2YXIgcj1lWzFdO3RoaXMub3V0cHV0U2hhcGU9ZTt2YXIgbz1uP1wiMi4wICogXCIrTWF0aC5QSTpcIi0yLjAgKiBcIitNYXRoLlBJLGE9bj9yK1wiLjBcIjpcIjEuMFwiO3RoaXMudXNlckNvZGU9XCJcXG4gICAgICBjb25zdCBmbG9hdCBleHBvbmVudE11bHRpcGxpZXIgPSBcIitvK1wiO1xcblxcbiAgICAgIGZsb2F0IHVuYXJ5T3BDb21wbGV4KGZsb2F0IHJlYWwsIGZsb2F0IGV4cFIsIGZsb2F0IGltYWcsIGZsb2F0IGV4cEkpIHtcXG4gICAgICAgIFwiK3QrXCJcXG4gICAgICB9XFxuXFxuICAgICAgZmxvYXQgbXVsTWF0REZUKGludCBiYXRjaCwgaW50IGluZGV4KSB7XFxuICAgICAgICBmbG9hdCBpbmRleFJhdGlvID0gZmxvYXQoaW5kZXgpIC8gZmxvYXQoXCIrcitcIik7XFxuICAgICAgICBmbG9hdCBleHBvbmVudE11bHRpcGxpZXJUaW1lc0luZGV4UmF0aW8gPVxcbiAgICAgICAgICAgIGV4cG9uZW50TXVsdGlwbGllciAqIGluZGV4UmF0aW87XFxuXFxuICAgICAgICBmbG9hdCByZXN1bHQgPSAwLjA7XFxuXFxuICAgICAgICBmb3IgKGludCBpID0gMDsgaSA8IFwiK3IrXCI7IGkrKykge1xcbiAgICAgICAgICAvLyB4ID0gKC0yfDIgKiBQSSAvIE4pICogaW5kZXggKiBpO1xcbiAgICAgICAgICBmbG9hdCB4ID0gZXhwb25lbnRNdWx0aXBsaWVyVGltZXNJbmRleFJhdGlvICogZmxvYXQoaSk7XFxuICAgICAgICAgIGZsb2F0IGV4cFIgPSBjb3MoeCk7XFxuICAgICAgICAgIGZsb2F0IGV4cEkgPSBzaW4oeCk7XFxuICAgICAgICAgIGZsb2F0IHJlYWwgPSBnZXRSZWFsKGJhdGNoLCBpKTtcXG4gICAgICAgICAgZmxvYXQgaW1hZyA9IGdldEltYWcoYmF0Y2gsIGkpO1xcblxcbiAgICAgICAgICByZXN1bHQgKz1cXG4gICAgICAgICAgICAgIHVuYXJ5T3BDb21wbGV4KHJlYWwsIGV4cFIsIGltYWcsIGV4cEkpIC8gXCIrYStcIjtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIHJldHVybiByZXN1bHQ7XFxuICAgICAgfVxcblxcbiAgICAgIHZvaWQgbWFpbigpIHtcXG4gICAgICAgIGl2ZWMyIGNvb3JkcyA9IGdldE91dHB1dENvb3JkcygpO1xcbiAgICAgICAgc2V0T3V0cHV0KG11bE1hdERGVChjb29yZHNbMF0sIGNvb3Jkc1sxXSkpO1xcbiAgICAgIH1cXG4gICAgXCJ9LHZpPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gdCh0LGUpe3RoaXMub3V0cHV0U2hhcGU9W10sdGhpcy52YXJpYWJsZU5hbWVzPVtcInhcIl0sdGhpcy5vdXRwdXRTaGFwZT10LHRoaXMudXNlckNvZGU9XCJcXG4gICAgICB1bmlmb3JtIGZsb2F0IHZhbHVlO1xcbiAgICAgIHZvaWQgbWFpbigpIHtcXG4gICAgICAgIC8vIElucHV0IGNhbiBiZSBvYnRhaW5lZCBmcm9tIHVuaWZvcm0gdmFsdWUuXFxuICAgICAgICBzZXRPdXRwdXQodmFsdWUpO1xcbiAgICAgIH1cXG4gICAgXCJ9cmV0dXJuIHQucHJvdG90eXBlLmdldEN1c3RvbVNldHVwRnVuYz1mdW5jdGlvbih0KXt2YXIgZT10aGlzO3JldHVybiBmdW5jdGlvbihuLHIpe251bGw9PWUudmFsdWVMb2MmJihlLnZhbHVlTG9jPW4uZ2V0VW5pZm9ybUxvY2F0aW9uTm9UaHJvdyhyLFwidmFsdWVcIikpLG4uZ2wudW5pZm9ybTFmKGUudmFsdWVMb2MsdCl9fSx0fSgpLG1pPWZ1bmN0aW9uKHQsZSxuKXt0aGlzLnZhcmlhYmxlTmFtZXM9W1wiQVwiLFwiaW5kaWNlc1wiXTt2YXIgcj10LnNsaWNlKCk7cltuXT1lLHRoaXMub3V0cHV0U2hhcGU9cix0aGlzLnJhbms9ci5sZW5ndGg7dmFyIG89d2EodGhpcy5yYW5rKSxhPWZ1bmN0aW9uKHQsZSl7dmFyIG49dC5sZW5ndGg7aWYobj40KXRocm93IEVycm9yKFwiR2F0aGVyIGZvciByYW5rIFwiK24rXCIgaXMgbm90IHlldCBzdXBwb3J0ZWRcIik7aWYoMT09PW4pcmV0dXJuXCJpbnQoZ2V0SW5kaWNlcyhyZXNSQykpXCI7Zm9yKHZhciByPVtcInJlc1JDLnhcIixcInJlc1JDLnlcIixcInJlc1JDLnpcIixcInJlc1JDLndcIl0sbz1bXSxhPTA7YTx0Lmxlbmd0aDthKyspYT09PWU/by5wdXNoKFwiaW50KGdldEluZGljZXMoXCIrclthXStcIikpXCIpOm8ucHVzaChcIlwiK3JbYV0pO3JldHVybiBvLmpvaW4oKX0odCxuKTt0aGlzLnVzZXJDb2RlPVwiXFxuICAgICAgdm9pZCBtYWluKCkge1xcbiAgICAgICAgXCIrbytcIiByZXNSQyA9IGdldE91dHB1dENvb3JkcygpO1xcbiAgICAgICAgc2V0T3V0cHV0KGdldEEoXCIrYStcIikpO1xcbiAgICAgIH1cXG4gICAgXCJ9O3ZhciBnaT1mdW5jdGlvbih0LGUsbil7dGhpcy5zbGljZURpbT10LHRoaXMuc3RyaWRlcz1lLHRoaXMudmFyaWFibGVOYW1lcz1bXCJ4XCIsXCJpbmRpY2VzXCJdLHRoaXMub3V0cHV0U2hhcGU9bjt2YXIgcj13YShlLmxlbmd0aCksbz13YShuLmxlbmd0aCksYT10aGlzLnNsaWNlRGltPjE/XCJzdHJpZGVzW2pdXCI6XCJzdHJpZGVzXCI7dGhpcy51c2VyQ29kZT1cIlxcbiAgICAgICAgXCIrcitcIiBzdHJpZGVzID0gXCIrcitcIihcIit0aGlzLnN0cmlkZXMrXCIpO1xcbiAgICAgICAgIHZvaWQgbWFpbigpIHtcXG4gICAgICAgICAgXCIrbytcIiBjb29yZHMgPSBnZXRPdXRwdXRDb29yZHMoKTtcXG4gICAgICAgICAgaW50IGZsYXR0ZW5JbmRleCA9IDA7XFxuICAgICAgICAgIGZvciAoaW50IGogPSAwOyBqIDwgXCIrdGhpcy5zbGljZURpbStcIjsgaisrKSB7XFxuICAgICAgICAgICAgaW50IGluZGV4ID0gcm91bmQoZ2V0SW5kaWNlcyhjb29yZHNbMF0sIGopKTtcXG4gICAgICAgICAgICBmbGF0dGVuSW5kZXggKz0gaW5kZXggKiBcIithK1wiO1xcbiAgICAgICAgICB9XFxuICAgICAgICAgIHNldE91dHB1dChnZXRYKGZsYXR0ZW5JbmRleCwgY29vcmRzWzFdKSk7XFxuICAgICAgICB9XFxuICAgICAgXCJ9O2Z1bmN0aW9uIHlpKHQsZSl7dmFyIG49dWEoKTtyZXR1cm4gb2UodCxlLG4udmVyc2lvbitcIlxcbiAgICBwcmVjaXNpb24gaGlnaHAgZmxvYXQ7XFxuICAgIFwiK24uYXR0cmlidXRlK1wiIHZlYzMgY2xpcFNwYWNlUG9zO1xcbiAgICBcIituLmF0dHJpYnV0ZStcIiB2ZWMyIHV2O1xcbiAgICBcIituLnZhcnlpbmdWcytcIiB2ZWMyIHJlc3VsdFVWO1xcblxcbiAgICB2b2lkIG1haW4oKSB7XFxuICAgICAgZ2xfUG9zaXRpb24gPSB2ZWM0KGNsaXBTcGFjZVBvcywgMSk7XFxuICAgICAgcmVzdWx0VVYgPSB1djtcXG4gICAgfVwiKX1mdW5jdGlvbiB4aSh0LGUpe3JldHVybiBmZSh0LGUsbmV3IEZsb2F0MzJBcnJheShbLTEsMSwwLDAsMSwtMSwtMSwwLDAsMCwxLDEsMCwxLDEsMSwtMSwwLDEsMF0pKX1mdW5jdGlvbiBiaSh0LGUpe3JldHVybiBkZSh0LGUsbmV3IFVpbnQxNkFycmF5KFswLDEsMiwyLDEsM10pKX1mdW5jdGlvbiB3aSh0LGUsbixyLG8sYSxpKXt2ZShuLHIpO3ZhciBzPXBlKHQsZSksdT10LlRFWFRVUkVfMkQ7cmV0dXJuIEp0KHQsZSwoZnVuY3Rpb24oKXtyZXR1cm4gdC5iaW5kVGV4dHVyZSh1LHMpfSkpLEp0KHQsZSwoZnVuY3Rpb24oKXtyZXR1cm4gdC50ZXhQYXJhbWV0ZXJpKHUsdC5URVhUVVJFX1dSQVBfUyx0LkNMQU1QX1RPX0VER0UpfSkpLEp0KHQsZSwoZnVuY3Rpb24oKXtyZXR1cm4gdC50ZXhQYXJhbWV0ZXJpKHUsdC5URVhUVVJFX1dSQVBfVCx0LkNMQU1QX1RPX0VER0UpfSkpLEp0KHQsZSwoZnVuY3Rpb24oKXtyZXR1cm4gdC50ZXhQYXJhbWV0ZXJpKHUsdC5URVhUVVJFX01JTl9GSUxURVIsdC5ORUFSRVNUKX0pKSxKdCh0LGUsKGZ1bmN0aW9uKCl7cmV0dXJuIHQudGV4UGFyYW1ldGVyaSh1LHQuVEVYVFVSRV9NQUdfRklMVEVSLHQuTkVBUkVTVCl9KSksSnQodCxlLChmdW5jdGlvbigpe3JldHVybiB0LnRleEltYWdlMkQodSwwLG8sbixyLDAsYSxpLG51bGwpfSkpLEp0KHQsZSwoZnVuY3Rpb24oKXtyZXR1cm4gdC5iaW5kVGV4dHVyZSh0LlRFWFRVUkVfMkQsbnVsbCl9KSksc31mdW5jdGlvbiBDaSh0LGUsbixyLG8pe3ZhciBhPVh0KG4scik7cmV0dXJuIHdpKHQsZSxhWzBdLGFbMV0sby5pbnRlcm5hbEZvcm1hdEZsb2F0LG8udGV4dHVyZUZvcm1hdEZsb2F0LHQuRkxPQVQpfWZ1bmN0aW9uIEVpKHQsZSxuLHIsbyl7dmFyIGE9WHQobixyKTtyZXR1cm4gd2kodCxlLGFbMF0sYVsxXSxvLmludGVybmFsRm9ybWF0SGFsZkZsb2F0LG8udGV4dHVyZUZvcm1hdEZsb2F0LG8udGV4dHVyZVR5cGVIYWxmRmxvYXQpfWZ1bmN0aW9uIFJpKHQsZSxuLHIsbyl7dmFyIGE9WHQobixyKTtyZXR1cm4gd2kodCxlLGFbMF0sYVsxXSx0LlJHQkEsdC5SR0JBLHQuVU5TSUdORURfQllURSl9ZnVuY3Rpb24gSWkodCxlLG4scixvKXt2YXIgYT0kdChuLHIpO3JldHVybiB3aSh0LGUsYVswXSxhWzFdLG8uaW50ZXJuYWxGb3JtYXRQYWNrZWRGbG9hdCx0LlJHQkEsdC5GTE9BVCl9ZnVuY3Rpb24ga2kodCxlLG4scixvKXt2YXIgYT0kdChuLHIpO3JldHVybiB3aSh0LGUsYVswXSxhWzFdLG8uaW50ZXJuYWxGb3JtYXRQYWNrZWRIYWxmRmxvYXQsdC5SR0JBLG8udGV4dHVyZVR5cGVIYWxmRmxvYXQpfWZ1bmN0aW9uIFNpKHQsZSxuLHIpe3JldHVybiBKdCh0LGUsKGZ1bmN0aW9uKCl7cmV0dXJuIHQuYmluZEJ1ZmZlcih0LkFSUkFZX0JVRkZFUixyKX0pKSxnZSh0LGUsbixcImNsaXBTcGFjZVBvc1wiLHIsMywyMCwwKSYmZ2UodCxlLG4sXCJ1dlwiLHIsMiwyMCwxMil9ZnVuY3Rpb24gQWkodCxlLG4scixvLGEsaSl7dmFyIHMsdSxjO0p0KHQsZSwoZnVuY3Rpb24oKXtyZXR1cm4gdC5iaW5kVGV4dHVyZSh0LlRFWFRVUkVfMkQsbil9KSksYSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXk/KHM9bmV3IFVpbnQ4QXJyYXkocipvKjQpLHU9dC5VTlNJR05FRF9CWVRFLGM9dC5SR0JBKToocz1uZXcgRmxvYXQzMkFycmF5KHIqbyo0KSx1PXQuRkxPQVQsYz1pLmludGVybmFsRm9ybWF0UGFja2VkRmxvYXQpLHMuc2V0KGEpLEp0KHQsZSwoZnVuY3Rpb24oKXtyZXR1cm4gdC50ZXhJbWFnZTJEKHQuVEVYVFVSRV8yRCwwLGMscixvLDAsdC5SR0JBLHUscyl9KSksSnQodCxlLChmdW5jdGlvbigpe3JldHVybiB0LmJpbmRUZXh0dXJlKHQuVEVYVFVSRV8yRCxudWxsKX0pKX1mdW5jdGlvbiBEaSh0LGUsbixyKXtKdCh0LGUsKGZ1bmN0aW9uKCl7cmV0dXJuIHQuYmluZFRleHR1cmUodC5URVhUVVJFXzJELG4pfSkpLHIuZGF0YSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXk/SnQodCxlLChmdW5jdGlvbigpe3JldHVybiB0LnRleEltYWdlMkQodC5URVhUVVJFXzJELDAsdC5SR0JBLHIud2lkdGgsci5oZWlnaHQsMCx0LlJHQkEsdC5VTlNJR05FRF9CWVRFLHIuZGF0YSl9KSk6SnQodCxlLChmdW5jdGlvbigpe3JldHVybiB0LnRleEltYWdlMkQodC5URVhUVVJFXzJELDAsdC5SR0JBLHQuUkdCQSx0LlVOU0lHTkVEX0JZVEUscil9KSksSnQodCxlLChmdW5jdGlvbigpe3JldHVybiB0LmJpbmRUZXh0dXJlKHQuVEVYVFVSRV8yRCxudWxsKX0pKX1mdW5jdGlvbiBUaSh0LGUsbixyLG8pe3ZhciBhPXQuY3JlYXRlQnVmZmVyKCk7SnQodCxlLChmdW5jdGlvbigpe3JldHVybiB0LmJpbmRCdWZmZXIodC5QSVhFTF9QQUNLX0JVRkZFUixhKX0pKTt2YXIgaT0xNipuKnI7cmV0dXJuIEp0KHQsZSwoZnVuY3Rpb24oKXtyZXR1cm4gdC5idWZmZXJEYXRhKHQuUElYRUxfUEFDS19CVUZGRVIsaSx0LlNUUkVBTV9SRUFEKX0pKSxKdCh0LGUsKGZ1bmN0aW9uKCl7cmV0dXJuIHQucmVhZFBpeGVscygwLDAscixuLHQuUkdCQSx0LkZMT0FULDApfSkpLEp0KHQsZSwoZnVuY3Rpb24oKXtyZXR1cm4gdC5iaW5kQnVmZmVyKHQuUElYRUxfUEFDS19CVUZGRVIsbnVsbCl9KSksYX1mdW5jdGlvbiBOaSh0LGUsbil7dmFyIHI9dCxvPW5ldyBGbG9hdDMyQXJyYXkobik7cmV0dXJuIHIuYmluZEJ1ZmZlcihyLlBJWEVMX1BBQ0tfQlVGRkVSLGUpLHIuZ2V0QnVmZmVyU3ViRGF0YShyLlBJWEVMX1BBQ0tfQlVGRkVSLDAsbyksci5iaW5kQnVmZmVyKHIuUElYRUxfUEFDS19CVUZGRVIsbnVsbCksb31mdW5jdGlvbiBGaSh0LGUsbixyLG8pe3ZhciBhPVh0KG4sciksaT1hWzBdLHM9YVsxXSx1PW5ldyBVaW50OEFycmF5KG4qcio0KTtyZXR1cm4gSnQodCxlLChmdW5jdGlvbigpe3JldHVybiB0LnJlYWRQaXhlbHMoMCwwLGkscyxvLmRvd25sb2FkVGV4dHVyZUZvcm1hdCx0LlVOU0lHTkVEX0JZVEUsdSl9KSksbmV3IEZsb2F0MzJBcnJheSh1LmJ1ZmZlcil9ZnVuY3Rpb24gX2kodCxlLG4scixvLGEsaSxzKXt2YXIgdT10LGM9bmV3IEZsb2F0MzJBcnJheShmdW5jdGlvbih0LGUpe3ZhciBuPSR0KHQsZSk7cmV0dXJuIG5bMF0qblsxXSo0fShhLGkpKTtyZXR1cm4gdS5iaW5kQnVmZmVyKHUuUElYRUxfUEFDS19CVUZGRVIsZSksdS5nZXRCdWZmZXJTdWJEYXRhKHUuUElYRUxfUEFDS19CVUZGRVIsMCxjKSx1LmJpbmRCdWZmZXIodS5QSVhFTF9QQUNLX0JVRkZFUixudWxsKSxjfWZ1bmN0aW9uIE9pKHQsZSxuLHIpe3ZhciBvPW5ldyBGbG9hdDMyQXJyYXkobipyKjQpO3JldHVybiBKdCh0LGUsKGZ1bmN0aW9uKCl7cmV0dXJuIHQucmVhZFBpeGVscygwLDAscixuLHQuUkdCQSx0LkZMT0FULG8pfSkpLG99dmFyIE1pPU9iamVjdC5mcmVlemUoe2NyZWF0ZVZlcnRleFNoYWRlcjp5aSxjcmVhdGVWZXJ0ZXhCdWZmZXI6eGksY3JlYXRlSW5kZXhCdWZmZXI6YmksY3JlYXRlRmxvYXQzMk1hdHJpeFRleHR1cmU6Q2ksY3JlYXRlRmxvYXQxNk1hdHJpeFRleHR1cmU6RWksY3JlYXRlVW5zaWduZWRCeXRlc01hdHJpeFRleHR1cmU6UmksY3JlYXRlUGFja2VkTWF0cml4VGV4dHVyZTpJaSxjcmVhdGVGbG9hdDE2UGFja2VkTWF0cml4VGV4dHVyZTpraSxiaW5kVmVydGV4UHJvZ3JhbUF0dHJpYnV0ZVN0cmVhbXM6U2ksdXBsb2FkRGVuc2VNYXRyaXhUb1RleHR1cmU6QWksdXBsb2FkUGl4ZWxEYXRhVG9UZXh0dXJlOkRpLGNyZWF0ZUJ1ZmZlckZyb21PdXRwdXRUZXh0dXJlOlRpLGRvd25sb2FkRmxvYXQzMk1hdHJpeEZyb21CdWZmZXI6TmksZG93bmxvYWRCeXRlRW5jb2RlZEZsb2F0TWF0cml4RnJvbU91dHB1dFRleHR1cmU6RmksZG93bmxvYWRQYWNrZWRNYXRyaXhGcm9tQnVmZmVyOl9pLGRvd25sb2FkTWF0cml4RnJvbVBhY2tlZE91dHB1dFRleHR1cmU6T2l9KSxCaT1mdW5jdGlvbigpe2Z1bmN0aW9uIHQodCl7dGhpcy5vdXRwdXRUZXh0dXJlPW51bGwsdGhpcy5wcm9ncmFtPW51bGwsdGhpcy5kaXNwb3NlZD0hMSx0aGlzLnZlcnRleEF0dHJzQXJlQm91bmQ9ITEsdGhpcy5pdGVtc1RvUG9sbD1bXTt2YXIgZT1pKCkuZ2V0TnVtYmVyKFwiV0VCR0xfVkVSU0lPTlwiKTtudWxsIT10Pyh0aGlzLmdsPXQsS3QoZSx0KSk6dGhpcy5nbD1qdChlKTt2YXIgbj1cIldFQkdMX2NvbG9yX2J1ZmZlcl9mbG9hdFwiO2lmKDE9PT1pKCkuZ2V0TnVtYmVyKFwiV0VCR0xfVkVSU0lPTlwiKSl7aWYodGhpcy50ZXh0dXJlRmxvYXRFeHRlbnNpb249cmUodGhpcy5nbCx0aGlzLmRlYnVnLFwiT0VTX3RleHR1cmVfZmxvYXRcIiksUGUodGhpcy5nbCxcIk9FU190ZXh0dXJlX2hhbGZfZmxvYXRcIikpdGhpcy50ZXh0dXJlSGFsZkZsb2F0RXh0ZW5zaW9uPXJlKHRoaXMuZ2wsdGhpcy5kZWJ1ZyxcIk9FU190ZXh0dXJlX2hhbGZfZmxvYXRcIik7ZWxzZSBpZihpKCkuZ2V0KFwiV0VCR0xfRk9SQ0VfRjE2X1RFWFRVUkVTXCIpKXRocm93IG5ldyBFcnJvcihcIkdMIGNvbnRleHQgZG9lcyBub3Qgc3VwcG9ydCBoYWxmIGZsb2F0IHRleHR1cmVzLCB5ZXQgdGhlIGVudmlyb25tZW50IGZsYWcgV0VCR0xfRk9SQ0VfRjE2X1RFWFRVUkVTIGlzIHNldCB0byB0cnVlLlwiKTtpZih0aGlzLmNvbG9yQnVmZmVyRmxvYXRFeHRlbnNpb249dGhpcy5nbC5nZXRFeHRlbnNpb24obiksUGUodGhpcy5nbCxcIkVYVF9jb2xvcl9idWZmZXJfaGFsZl9mbG9hdFwiKSl0aGlzLmNvbG9yQnVmZmVySGFsZkZsb2F0RXh0ZW5zaW9uPXJlKHRoaXMuZ2wsdGhpcy5kZWJ1ZyxcIkVYVF9jb2xvcl9idWZmZXJfaGFsZl9mbG9hdFwiKTtlbHNlIGlmKGkoKS5nZXQoXCJXRUJHTF9GT1JDRV9GMTZfVEVYVFVSRVNcIikpdGhyb3cgbmV3IEVycm9yKFwiR0wgY29udGV4dCBkb2VzIG5vdCBzdXBwb3J0IGNvbG9yIHJlbmRlcmFibGUgaGFsZiBmbG9hdHMsIHlldCB0aGUgZW52aXJvbm1lbnQgZmxhZyBXRUJHTF9GT1JDRV9GMTZfVEVYVFVSRVMgaXMgc2V0IHRvIHRydWUuXCIpfWVsc2UgaWYobj1cIkVYVF9jb2xvcl9idWZmZXJfZmxvYXRcIixQZSh0aGlzLmdsLG4pKXRoaXMuY29sb3JCdWZmZXJGbG9hdEV4dGVuc2lvbj10aGlzLmdsLmdldEV4dGVuc2lvbihuKTtlbHNle2lmKCFQZSh0aGlzLmdsLFwiRVhUX2NvbG9yX2J1ZmZlcl9oYWxmX2Zsb2F0XCIpKXRocm93IG5ldyBFcnJvcihcIkdMIGNvbnRleHQgZG9lcyBub3Qgc3VwcG9ydCBjb2xvciByZW5kZXJhYmxlIGZsb2F0c1wiKTt0aGlzLmNvbG9yQnVmZmVySGFsZkZsb2F0RXh0ZW5zaW9uPXRoaXMuZ2wuZ2V0RXh0ZW5zaW9uKFwiRVhUX2NvbG9yX2J1ZmZlcl9oYWxmX2Zsb2F0XCIpfXRoaXMudmVydGV4QnVmZmVyPXhpKHRoaXMuZ2wsdGhpcy5kZWJ1ZyksdGhpcy5pbmRleEJ1ZmZlcj1iaSh0aGlzLmdsLHRoaXMuZGVidWcpLHRoaXMuZnJhbWVidWZmZXI9bWUodGhpcy5nbCx0aGlzLmRlYnVnKSx0aGlzLnRleHR1cmVDb25maWc9UXQodGhpcy5nbCx0aGlzLnRleHR1cmVIYWxmRmxvYXRFeHRlbnNpb24pfXJldHVybiBPYmplY3QuZGVmaW5lUHJvcGVydHkodC5wcm90b3R5cGUsXCJkZWJ1Z1wiLHtnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gaSgpLmdldEJvb2woXCJERUJVR1wiKX0sZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITB9KSx0LnByb3RvdHlwZS5kaXNwb3NlPWZ1bmN0aW9uKCl7dmFyIHQ9dGhpcztpZighdGhpcy5kaXNwb3NlZCl7bnVsbCE9dGhpcy5wcm9ncmFtJiZjb25zb2xlLndhcm4oXCJEaXNwb3NpbmcgYSBHUEdQVUNvbnRleHQgdGhhdCBzdGlsbCBoYXMgYSBib3VuZCBXZWJHTFByb2dyYW0uIFRoaXMgaXMgcHJvYmFibHkgYSByZXNvdXJjZSBsZWFrLCBkZWxldGUgdGhlIHByb2dyYW0gd2l0aCBHUEdQVUNvbnRleHQuZGVsZXRlUHJvZ3JhbSBiZWZvcmUgZGlzcG9zaW5nLlwiKSxudWxsIT10aGlzLm91dHB1dFRleHR1cmUmJmNvbnNvbGUud2FybihcIkRpc3Bvc2luZyBhIEdQR1BVQ29udGV4dCB0aGF0IHN0aWxsIGhhcyBhIGJvdW5kIG91dHB1dCBtYXRyaXggdGV4dHVyZS4gIFRoaXMgaXMgcHJvYmFibHkgYSByZXNvdXJjZSBsZWFrLCBkZWxldGUgdGhlIG91dHB1dCBtYXRyaXggdGV4dHVyZSB3aXRoIEdQR1BVQ29udGV4dC5kZWxldGVNYXRyaXhUZXh0dXJlIGJlZm9yZSBkaXNwb3NpbmcuXCIpO3ZhciBlPXRoaXMuZ2w7SnQoZSx0aGlzLmRlYnVnLChmdW5jdGlvbigpe3JldHVybiBlLmZpbmlzaCgpfSkpLEp0KGUsdGhpcy5kZWJ1ZywoZnVuY3Rpb24oKXtyZXR1cm4gZS5iaW5kRnJhbWVidWZmZXIoZS5GUkFNRUJVRkZFUixudWxsKX0pKSxKdChlLHRoaXMuZGVidWcsKGZ1bmN0aW9uKCl7cmV0dXJuIGUuZGVsZXRlRnJhbWVidWZmZXIodC5mcmFtZWJ1ZmZlcil9KSksSnQoZSx0aGlzLmRlYnVnLChmdW5jdGlvbigpe3JldHVybiBlLmJpbmRCdWZmZXIoZS5BUlJBWV9CVUZGRVIsbnVsbCl9KSksSnQoZSx0aGlzLmRlYnVnLChmdW5jdGlvbigpe3JldHVybiBlLmJpbmRCdWZmZXIoZS5FTEVNRU5UX0FSUkFZX0JVRkZFUixudWxsKX0pKSxKdChlLHRoaXMuZGVidWcsKGZ1bmN0aW9uKCl7cmV0dXJuIGUuZGVsZXRlQnVmZmVyKHQuaW5kZXhCdWZmZXIpfSkpLHRoaXMuZGlzcG9zZWQ9ITB9fSx0LnByb3RvdHlwZS5jcmVhdGVGbG9hdDMyTWF0cml4VGV4dHVyZT1mdW5jdGlvbih0LGUpe3JldHVybiB0aGlzLnRocm93SWZEaXNwb3NlZCgpLENpKHRoaXMuZ2wsdGhpcy5kZWJ1Zyx0LGUsdGhpcy50ZXh0dXJlQ29uZmlnKX0sdC5wcm90b3R5cGUuY3JlYXRlRmxvYXQxNk1hdHJpeFRleHR1cmU9ZnVuY3Rpb24odCxlKXtyZXR1cm4gdGhpcy50aHJvd0lmRGlzcG9zZWQoKSxFaSh0aGlzLmdsLHRoaXMuZGVidWcsdCxlLHRoaXMudGV4dHVyZUNvbmZpZyl9LHQucHJvdG90eXBlLmNyZWF0ZVVuc2lnbmVkQnl0ZXNNYXRyaXhUZXh0dXJlPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCksUmkodGhpcy5nbCx0aGlzLmRlYnVnLHQsZSx0aGlzLnRleHR1cmVDb25maWcpfSx0LnByb3RvdHlwZS51cGxvYWRQaXhlbERhdGFUb1RleHR1cmU9ZnVuY3Rpb24odCxlKXt0aGlzLnRocm93SWZEaXNwb3NlZCgpLERpKHRoaXMuZ2wsdGhpcy5kZWJ1Zyx0LGUpfSx0LnByb3RvdHlwZS51cGxvYWREZW5zZU1hdHJpeFRvVGV4dHVyZT1mdW5jdGlvbih0LGUsbixyKXt0aGlzLnRocm93SWZEaXNwb3NlZCgpLEFpKHRoaXMuZ2wsdGhpcy5kZWJ1Zyx0LGUsbixyLHRoaXMudGV4dHVyZUNvbmZpZyl9LHQucHJvdG90eXBlLmNyZWF0ZUZsb2F0MTZQYWNrZWRNYXRyaXhUZXh0dXJlPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCksa2kodGhpcy5nbCx0aGlzLmRlYnVnLHQsZSx0aGlzLnRleHR1cmVDb25maWcpfSx0LnByb3RvdHlwZS5jcmVhdGVQYWNrZWRNYXRyaXhUZXh0dXJlPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCksSWkodGhpcy5nbCx0aGlzLmRlYnVnLHQsZSx0aGlzLnRleHR1cmVDb25maWcpfSx0LnByb3RvdHlwZS5kZWxldGVNYXRyaXhUZXh0dXJlPWZ1bmN0aW9uKHQpe3ZhciBlPXRoaXM7dGhpcy50aHJvd0lmRGlzcG9zZWQoKSx0aGlzLm91dHB1dFRleHR1cmU9PT10JiYoRWUodGhpcy5nbCx0aGlzLmRlYnVnLHRoaXMuZnJhbWVidWZmZXIpLHRoaXMub3V0cHV0VGV4dHVyZT1udWxsKSxKdCh0aGlzLmdsLHRoaXMuZGVidWcsKGZ1bmN0aW9uKCl7cmV0dXJuIGUuZ2wuZGVsZXRlVGV4dHVyZSh0KX0pKX0sdC5wcm90b3R5cGUuZG93bmxvYWRCeXRlRW5jb2RlZEZsb2F0TWF0cml4RnJvbU91dHB1dFRleHR1cmU9ZnVuY3Rpb24odCxlLG4pe3ZhciByPXRoaXM7cmV0dXJuIHRoaXMuZG93bmxvYWRNYXRyaXhEcml2ZXIodCwoZnVuY3Rpb24oKXtyZXR1cm4gRmkoci5nbCxyLmRlYnVnLGUsbixyLnRleHR1cmVDb25maWcpfSkpfSx0LnByb3RvdHlwZS5kb3dubG9hZFBhY2tlZE1hdHJpeEZyb21CdWZmZXI9ZnVuY3Rpb24odCxlLG4scixvLGEpe3JldHVybiBfaSh0aGlzLmdsLHQsMCwwLDAsbyxhLHRoaXMudGV4dHVyZUNvbmZpZyl9LHQucHJvdG90eXBlLmRvd25sb2FkRmxvYXQzMk1hdHJpeEZyb21CdWZmZXI9ZnVuY3Rpb24odCxlKXtyZXR1cm4gTmkodGhpcy5nbCx0LGUpfSx0LnByb3RvdHlwZS5jcmVhdGVCdWZmZXJGcm9tVGV4dHVyZT1mdW5jdGlvbih0LGUsbil7dGhpcy5iaW5kVGV4dHVyZVRvRnJhbWVCdWZmZXIodCk7dmFyIHI9VGkodGhpcy5nbCx0aGlzLmRlYnVnLGUsbix0aGlzLnRleHR1cmVDb25maWcpO3JldHVybiB0aGlzLnVuYmluZFRleHR1cmVUb0ZyYW1lQnVmZmVyKCkscn0sdC5wcm90b3R5cGUuY3JlYXRlQW5kV2FpdEZvckZlbmNlPWZ1bmN0aW9uKCl7dmFyIHQ9dGhpcy5jcmVhdGVGZW5jZSh0aGlzLmdsKTtyZXR1cm4gdGhpcy5wb2xsRmVuY2UodCl9LHQucHJvdG90eXBlLmNyZWF0ZUZlbmNlPWZ1bmN0aW9uKHQpe3ZhciBlLG4scj10aGlzO2lmKGkoKS5nZXRCb29sKFwiV0VCR0xfRkVOQ0VfQVBJX0VOQUJMRURcIikpe3ZhciBvPXQsYT1vLmZlbmNlU3luYyhvLlNZTkNfR1BVX0NPTU1BTkRTX0NPTVBMRVRFLDApO3QuZmx1c2goKSxuPWZ1bmN0aW9uKCl7dmFyIHQ9by5jbGllbnRXYWl0U3luYyhhLDAsMCk7cmV0dXJuIHQ9PT1vLkFMUkVBRFlfU0lHTkFMRUR8fHQ9PT1vLkNPTkRJVElPTl9TQVRJU0ZJRUR9LGU9YX1lbHNlIGkoKS5nZXROdW1iZXIoXCJXRUJHTF9ESVNKT0lOVF9RVUVSWV9USU1FUl9FWFRFTlNJT05fVkVSU0lPTlwiKT4wPyhlPXRoaXMuYmVnaW5RdWVyeSgpLHRoaXMuZW5kUXVlcnkoKSxuPWZ1bmN0aW9uKCl7cmV0dXJuIHIuaXNRdWVyeUF2YWlsYWJsZShlLGkoKS5nZXROdW1iZXIoXCJXRUJHTF9ESVNKT0lOVF9RVUVSWV9USU1FUl9FWFRFTlNJT05fVkVSU0lPTlwiKSl9KTpuPWZ1bmN0aW9uKCl7cmV0dXJuITB9O3JldHVybntxdWVyeTplLGlzRmVuY2VQYXNzZWQ6bn19LHQucHJvdG90eXBlLmRvd25sb2FkTWF0cml4RnJvbVBhY2tlZFRleHR1cmU9ZnVuY3Rpb24odCxlLG4pe3ZhciByPXRoaXM7cmV0dXJuIHRoaXMuZG93bmxvYWRNYXRyaXhEcml2ZXIodCwoZnVuY3Rpb24oKXtyZXR1cm4gT2koci5nbCxyLmRlYnVnLGUsbil9KSl9LHQucHJvdG90eXBlLmNyZWF0ZVByb2dyYW09ZnVuY3Rpb24odCl7dGhpcy50aHJvd0lmRGlzcG9zZWQoKTt2YXIgZT10aGlzLmdsLG49YWUoZSx0aGlzLmRlYnVnLHQpLHI9eWkoZSx0aGlzLmRlYnVnKSxvPWNlKGUsdGhpcy5kZWJ1Zyk7cmV0dXJuIEp0KGUsdGhpcy5kZWJ1ZywoZnVuY3Rpb24oKXtyZXR1cm4gZS5hdHRhY2hTaGFkZXIobyxyKX0pKSxKdChlLHRoaXMuZGVidWcsKGZ1bmN0aW9uKCl7cmV0dXJuIGUuYXR0YWNoU2hhZGVyKG8sbil9KSksbGUoZSx0aGlzLmRlYnVnLG8pLHRoaXMuZGVidWcmJmhlKGUsdGhpcy5kZWJ1ZyxvKSx0aGlzLnZlcnRleEF0dHJzQXJlQm91bmR8fCh0aGlzLnNldFByb2dyYW0obyksdGhpcy52ZXJ0ZXhBdHRyc0FyZUJvdW5kPVNpKGUsdGhpcy5kZWJ1Zyx0aGlzLnByb2dyYW0sdGhpcy52ZXJ0ZXhCdWZmZXIpKSxvfSx0LnByb3RvdHlwZS5kZWxldGVQcm9ncmFtPWZ1bmN0aW9uKHQpe3ZhciBlPXRoaXM7dGhpcy50aHJvd0lmRGlzcG9zZWQoKSx0PT09dGhpcy5wcm9ncmFtJiYodGhpcy5wcm9ncmFtPW51bGwpLG51bGwhPXQmJkp0KHRoaXMuZ2wsdGhpcy5kZWJ1ZywoZnVuY3Rpb24oKXtyZXR1cm4gZS5nbC5kZWxldGVQcm9ncmFtKHQpfSkpfSx0LnByb3RvdHlwZS5zZXRQcm9ncmFtPWZ1bmN0aW9uKHQpe3ZhciBlPXRoaXM7dGhpcy50aHJvd0lmRGlzcG9zZWQoKSx0aGlzLnByb2dyYW09dCxudWxsIT10aGlzLnByb2dyYW0mJnRoaXMuZGVidWcmJmhlKHRoaXMuZ2wsdGhpcy5kZWJ1Zyx0aGlzLnByb2dyYW0pLEp0KHRoaXMuZ2wsdGhpcy5kZWJ1ZywoZnVuY3Rpb24oKXtyZXR1cm4gZS5nbC51c2VQcm9ncmFtKHQpfSkpfSx0LnByb3RvdHlwZS5nZXRVbmlmb3JtTG9jYXRpb249ZnVuY3Rpb24odCxlLG4pe3JldHVybiB2b2lkIDA9PT1uJiYobj0hMCksdGhpcy50aHJvd0lmRGlzcG9zZWQoKSxuP3hlKHRoaXMuZ2wsdGhpcy5kZWJ1Zyx0LGUpOmJlKHRoaXMuZ2wsdCxlKX0sdC5wcm90b3R5cGUuZ2V0QXR0cmlidXRlTG9jYXRpb249ZnVuY3Rpb24odCxlKXt2YXIgbj10aGlzO3JldHVybiB0aGlzLnRocm93SWZEaXNwb3NlZCgpLEp0KHRoaXMuZ2wsdGhpcy5kZWJ1ZywoZnVuY3Rpb24oKXtyZXR1cm4gbi5nbC5nZXRBdHRyaWJMb2NhdGlvbih0LGUpfSkpfSx0LnByb3RvdHlwZS5nZXRVbmlmb3JtTG9jYXRpb25Ob1Rocm93PWZ1bmN0aW9uKHQsZSl7cmV0dXJuIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCksdGhpcy5nbC5nZXRVbmlmb3JtTG9jYXRpb24odCxlKX0sdC5wcm90b3R5cGUuc2V0SW5wdXRNYXRyaXhUZXh0dXJlPWZ1bmN0aW9uKHQsZSxuKXt0aGlzLnRocm93SWZEaXNwb3NlZCgpLHRoaXMudGhyb3dJZk5vUHJvZ3JhbSgpLHdlKHRoaXMuZ2wsdGhpcy5kZWJ1Zyx0aGlzLnByb2dyYW0sdCxlLG4pfSx0LnByb3RvdHlwZS5zZXRPdXRwdXRNYXRyaXhUZXh0dXJlPWZ1bmN0aW9uKHQsZSxuKXt0aGlzLnNldE91dHB1dE1hdHJpeFRleHR1cmVEcml2ZXIodCxuLGUpfSx0LnByb3RvdHlwZS5zZXRPdXRwdXRQYWNrZWRNYXRyaXhUZXh0dXJlPWZ1bmN0aW9uKHQsZSxuKXt0aGlzLnRocm93SWZEaXNwb3NlZCgpO3ZhciByPSR0KGUsbiksbz1yWzBdLGE9clsxXTt0aGlzLnNldE91dHB1dE1hdHJpeFRleHR1cmVEcml2ZXIodCxvLGEpfSx0LnByb3RvdHlwZS5zZXRPdXRwdXRNYXRyaXhXcml0ZVJlZ2lvbj1mdW5jdGlvbih0LGUsbixyKXt0aGlzLnNldE91dHB1dE1hdHJpeFdyaXRlUmVnaW9uRHJpdmVyKG4sdCxyLGUpfSx0LnByb3RvdHlwZS5zZXRPdXRwdXRQYWNrZWRNYXRyaXhXcml0ZVJlZ2lvbj1mdW5jdGlvbih0LGUsbixyKXt0aHJvdyBuZXcgRXJyb3IoXCJzZXRPdXRwdXRQYWNrZWRNYXRyaXhXcml0ZVJlZ2lvbiBub3QgaW1wbGVtZW50ZWQuXCIpfSx0LnByb3RvdHlwZS5kZWJ1Z1ZhbGlkYXRlPWZ1bmN0aW9uKCl7bnVsbCE9dGhpcy5wcm9ncmFtJiZoZSh0aGlzLmdsLHRoaXMuZGVidWcsdGhpcy5wcm9ncmFtKSxSZSh0aGlzLmdsKX0sdC5wcm90b3R5cGUuZXhlY3V0ZVByb2dyYW09ZnVuY3Rpb24oKXt0aGlzLnRocm93SWZEaXNwb3NlZCgpLHRoaXMudGhyb3dJZk5vUHJvZ3JhbSgpO3ZhciB0PXRoaXMuZ2w7dGhpcy5kZWJ1ZyYmdGhpcy5kZWJ1Z1ZhbGlkYXRlKCksSnQodCx0aGlzLmRlYnVnLChmdW5jdGlvbigpe3JldHVybiB0LmRyYXdFbGVtZW50cyh0LlRSSUFOR0xFUyw2LHQuVU5TSUdORURfU0hPUlQsMCl9KSl9LHQucHJvdG90eXBlLmJsb2NrVW50aWxBbGxQcm9ncmFtc0NvbXBsZXRlZD1mdW5jdGlvbigpe3ZhciB0PXRoaXM7dGhpcy50aHJvd0lmRGlzcG9zZWQoKSxKdCh0aGlzLmdsLHRoaXMuZGVidWcsKGZ1bmN0aW9uKCl7cmV0dXJuIHQuZ2wuZmluaXNoKCl9KSl9LHQucHJvdG90eXBlLmdldFF1ZXJ5VGltZXJFeHRlbnNpb249ZnVuY3Rpb24oKXtyZXR1cm4gbnVsbD09dGhpcy5kaXNqb2ludFF1ZXJ5VGltZXJFeHRlbnNpb24mJih0aGlzLmRpc2pvaW50UXVlcnlUaW1lckV4dGVuc2lvbj1yZSh0aGlzLmdsLHRoaXMuZGVidWcsMj09PWkoKS5nZXROdW1iZXIoXCJXRUJHTF9ESVNKT0lOVF9RVUVSWV9USU1FUl9FWFRFTlNJT05fVkVSU0lPTlwiKT9cIkVYVF9kaXNqb2ludF90aW1lcl9xdWVyeV93ZWJnbDJcIjpcIkVYVF9kaXNqb2ludF90aW1lcl9xdWVyeVwiKSksdGhpcy5kaXNqb2ludFF1ZXJ5VGltZXJFeHRlbnNpb259LHQucHJvdG90eXBlLmdldFF1ZXJ5VGltZXJFeHRlbnNpb25XZWJHTDI9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5nZXRRdWVyeVRpbWVyRXh0ZW5zaW9uKCl9LHQucHJvdG90eXBlLmdldFF1ZXJ5VGltZXJFeHRlbnNpb25XZWJHTDE9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5nZXRRdWVyeVRpbWVyRXh0ZW5zaW9uKCl9LHQucHJvdG90eXBlLmJlZ2luUXVlcnk9ZnVuY3Rpb24oKXtpZigyPT09aSgpLmdldE51bWJlcihcIldFQkdMX0RJU0pPSU5UX1FVRVJZX1RJTUVSX0VYVEVOU0lPTl9WRVJTSU9OXCIpKXt2YXIgdD10aGlzLmdsLGU9dGhpcy5nZXRRdWVyeVRpbWVyRXh0ZW5zaW9uV2ViR0wyKCksbj10LmNyZWF0ZVF1ZXJ5KCk7cmV0dXJuIHQuYmVnaW5RdWVyeShlLlRJTUVfRUxBUFNFRF9FWFQsbiksbn12YXIgcj10aGlzLmdldFF1ZXJ5VGltZXJFeHRlbnNpb25XZWJHTDEoKSxvPXIuY3JlYXRlUXVlcnlFWFQoKTtyZXR1cm4gci5iZWdpblF1ZXJ5RVhUKHIuVElNRV9FTEFQU0VEX0VYVCxvKSxvfSx0LnByb3RvdHlwZS5lbmRRdWVyeT1mdW5jdGlvbigpe2lmKDIhPT1pKCkuZ2V0TnVtYmVyKFwiV0VCR0xfRElTSk9JTlRfUVVFUllfVElNRVJfRVhURU5TSU9OX1ZFUlNJT05cIikpe3ZhciB0PXRoaXMuZ2V0UXVlcnlUaW1lckV4dGVuc2lvbldlYkdMMSgpO3QuZW5kUXVlcnlFWFQodC5USU1FX0VMQVBTRURfRVhUKX1lbHNle3ZhciBlPXRoaXMuZ2wsbj10aGlzLmdldFF1ZXJ5VGltZXJFeHRlbnNpb25XZWJHTDIoKTtlLmVuZFF1ZXJ5KG4uVElNRV9FTEFQU0VEX0VYVCl9fSx0LnByb3RvdHlwZS53YWl0Rm9yUXVlcnlBbmRHZXRUaW1lPWZ1bmN0aW9uKHQpe3JldHVybiBuKHRoaXMsdm9pZCAwLHZvaWQgMCwoZnVuY3Rpb24oKXt2YXIgZT10aGlzO3JldHVybiByKHRoaXMsKGZ1bmN0aW9uKG4pe3N3aXRjaChuLmxhYmVsKXtjYXNlIDA6cmV0dXJuWzQsRigoZnVuY3Rpb24oKXtyZXR1cm4gZS5kaXNwb3NlZHx8ZS5pc1F1ZXJ5QXZhaWxhYmxlKHQsaSgpLmdldE51bWJlcihcIldFQkdMX0RJU0pPSU5UX1FVRVJZX1RJTUVSX0VYVEVOU0lPTl9WRVJTSU9OXCIpKX0pKV07Y2FzZSAxOnJldHVybiBuLnNlbnQoKSxbMix0aGlzLmdldFF1ZXJ5VGltZSh0LGkoKS5nZXROdW1iZXIoXCJXRUJHTF9ESVNKT0lOVF9RVUVSWV9USU1FUl9FWFRFTlNJT05fVkVSU0lPTlwiKSldfX0pKX0pKX0sdC5wcm90b3R5cGUuZ2V0UXVlcnlUaW1lPWZ1bmN0aW9uKHQsZSl7aWYoMD09PWUpcmV0dXJuIG51bGw7aWYoMj09PWUpe3ZhciBuPXRoaXMuZ2w7cmV0dXJuIG4uZ2V0UXVlcnlQYXJhbWV0ZXIodCxuLlFVRVJZX1JFU1VMVCkvMWU2fXZhciByPXRoaXMuZ2V0UXVlcnlUaW1lckV4dGVuc2lvbldlYkdMMSgpO3JldHVybiByLmdldFF1ZXJ5T2JqZWN0RVhUKHQsci5RVUVSWV9SRVNVTFRfRVhUKS8xZTZ9LHQucHJvdG90eXBlLmlzUXVlcnlBdmFpbGFibGU9ZnVuY3Rpb24odCxlKXtpZigwPT09ZSlyZXR1cm4hMDtpZigyPT09ZSl7dmFyIG49dGhpcy5nbCxyPXRoaXMuZ2V0UXVlcnlUaW1lckV4dGVuc2lvbldlYkdMMigpLG89bi5nZXRRdWVyeVBhcmFtZXRlcih0LG4uUVVFUllfUkVTVUxUX0FWQUlMQUJMRSk7cmV0dXJuIG51bGw9PXRoaXMuZGlzam9pbnQmJih0aGlzLmRpc2pvaW50PXRoaXMuZ2wuZ2V0UGFyYW1ldGVyKHIuR1BVX0RJU0pPSU5UX0VYVCkpLG8mJiF0aGlzLmRpc2pvaW50fW89KHI9dGhpcy5nZXRRdWVyeVRpbWVyRXh0ZW5zaW9uV2ViR0wxKCkpLmdldFF1ZXJ5T2JqZWN0RVhUKHQsci5RVUVSWV9SRVNVTFRfQVZBSUxBQkxFX0VYVCk7cmV0dXJuIG51bGw9PXRoaXMuZGlzam9pbnQmJih0aGlzLmRpc2pvaW50PXRoaXMuZ2wuZ2V0UGFyYW1ldGVyKHIuR1BVX0RJU0pPSU5UX0VYVCkpLG8mJiF0aGlzLmRpc2pvaW50fSx0LnByb3RvdHlwZS5wb2xsRmVuY2U9ZnVuY3Rpb24odCl7dmFyIGU9dGhpcztyZXR1cm4gbmV3IFByb21pc2UoKGZ1bmN0aW9uKG4pe2UuYWRkSXRlbVRvUG9sbCgoZnVuY3Rpb24oKXtyZXR1cm4gdC5pc0ZlbmNlUGFzc2VkKCl9KSwoZnVuY3Rpb24oKXtyZXR1cm4gbigpfSkpfSkpfSx0LnByb3RvdHlwZS5wb2xsSXRlbXM9ZnVuY3Rpb24oKXtmb3IodmFyIHQ9ZnVuY3Rpb24odCl7Zm9yKHZhciBlPTA7ZTx0Lmxlbmd0aDsrK2Upe2lmKCF0W2VdKCkpYnJlYWt9cmV0dXJuIGUtMX0odGhpcy5pdGVtc1RvUG9sbC5tYXAoKGZ1bmN0aW9uKHQpe3JldHVybiB0LmlzRG9uZUZufSkpKSxlPTA7ZTw9dDsrK2UpeygwLHRoaXMuaXRlbXNUb1BvbGxbZV0ucmVzb2x2ZUZuKSgpfXRoaXMuaXRlbXNUb1BvbGw9dGhpcy5pdGVtc1RvUG9sbC5zbGljZSh0KzEpfSx0LnByb3RvdHlwZS5hZGRJdGVtVG9Qb2xsPWZ1bmN0aW9uKHQsZSl7dmFyIG49dGhpczt0aGlzLml0ZW1zVG9Qb2xsLnB1c2goe2lzRG9uZUZuOnQscmVzb2x2ZUZuOmV9KSx0aGlzLml0ZW1zVG9Qb2xsLmxlbmd0aD4xfHxGKChmdW5jdGlvbigpe3JldHVybiBuLnBvbGxJdGVtcygpLDA9PT1uLml0ZW1zVG9Qb2xsLmxlbmd0aH0pKX0sdC5wcm90b3R5cGUuYmluZFRleHR1cmVUb0ZyYW1lQnVmZmVyPWZ1bmN0aW9uKHQpe3RoaXMudGhyb3dJZkRpc3Bvc2VkKCksQ2UodGhpcy5nbCx0aGlzLmRlYnVnLHQsdGhpcy5mcmFtZWJ1ZmZlciksdGhpcy5kZWJ1ZyYmUmUodGhpcy5nbCl9LHQucHJvdG90eXBlLnVuYmluZFRleHR1cmVUb0ZyYW1lQnVmZmVyPWZ1bmN0aW9uKCl7bnVsbCE9dGhpcy5vdXRwdXRUZXh0dXJlPyhDZSh0aGlzLmdsLHRoaXMuZGVidWcsdGhpcy5vdXRwdXRUZXh0dXJlLHRoaXMuZnJhbWVidWZmZXIpLHRoaXMuZGVidWcmJlJlKHRoaXMuZ2wpKTpFZSh0aGlzLmdsLHRoaXMuZGVidWcsdGhpcy5mcmFtZWJ1ZmZlcil9LHQucHJvdG90eXBlLmRvd25sb2FkTWF0cml4RHJpdmVyPWZ1bmN0aW9uKHQsZSl7dGhpcy5iaW5kVGV4dHVyZVRvRnJhbWVCdWZmZXIodCk7dmFyIG49ZSgpO3JldHVybiB0aGlzLnVuYmluZFRleHR1cmVUb0ZyYW1lQnVmZmVyKCksbn0sdC5wcm90b3R5cGUuc2V0T3V0cHV0TWF0cml4VGV4dHVyZURyaXZlcj1mdW5jdGlvbih0LGUsbil7dGhpcy50aHJvd0lmRGlzcG9zZWQoKTt2YXIgcj10aGlzLmdsO0NlKHIsdGhpcy5kZWJ1Zyx0LHRoaXMuZnJhbWVidWZmZXIpLHRoaXMuZGVidWcmJlJlKHIpLHRoaXMub3V0cHV0VGV4dHVyZT10LEp0KHIsdGhpcy5kZWJ1ZywoZnVuY3Rpb24oKXtyZXR1cm4gci52aWV3cG9ydCgwLDAsZSxuKX0pKSxKdChyLHRoaXMuZGVidWcsKGZ1bmN0aW9uKCl7cmV0dXJuIHIuc2Npc3NvcigwLDAsZSxuKX0pKX0sdC5wcm90b3R5cGUuc2V0T3V0cHV0TWF0cml4V3JpdGVSZWdpb25Ecml2ZXI9ZnVuY3Rpb24odCxlLG4scil7dmFyIG89dGhpczt0aGlzLnRocm93SWZEaXNwb3NlZCgpLEp0KHRoaXMuZ2wsdGhpcy5kZWJ1ZywoZnVuY3Rpb24oKXtyZXR1cm4gby5nbC5zY2lzc29yKHQsZSxuLHIpfSkpfSx0LnByb3RvdHlwZS50aHJvd0lmRGlzcG9zZWQ9ZnVuY3Rpb24oKXtpZih0aGlzLmRpc3Bvc2VkKXRocm93IG5ldyBFcnJvcihcIkF0dGVtcHRlZCB0byB1c2UgZGlzcG9zZWQgR1BHUFVDb250ZXh0LlwiKX0sdC5wcm90b3R5cGUudGhyb3dJZk5vUHJvZ3JhbT1mdW5jdGlvbigpe2lmKG51bGw9PXRoaXMucHJvZ3JhbSl0aHJvdyBuZXcgRXJyb3IoXCJObyBHUFUgcHJvZ3JhbSBpcyBjdXJyZW50bHkgc2V0LlwiKX0sdH0oKTtmdW5jdGlvbiBQaSh0LGUpe2lmKHQubGVuZ3RoIT09ZS5sZW5ndGgpdGhyb3cgRXJyb3IoXCJCaW5hcnkgd2FzIGNvbXBpbGVkIHdpdGggXCIrdC5sZW5ndGgrXCIgaW5wdXRzLCBidXQgd2FzIGV4ZWN1dGVkIHdpdGggXCIrZS5sZW5ndGgrXCIgaW5wdXRzXCIpO3QuZm9yRWFjaCgoZnVuY3Rpb24odCxuKXt2YXIgcj10LmxvZ2ljYWxTaGFwZSxvPWVbbl0sYT1vLnNoYXBlO2lmKCFTKHIsYSkpdGhyb3cgRXJyb3IoXCJCaW5hcnkgd2FzIGNvbXBpbGVkIHdpdGggZGlmZmVyZW50IHNoYXBlcyB0aGFuIHRoZSBjdXJyZW50IGFyZ3MuIFNoYXBlcyBcIityK1wiIGFuZCBcIithK1wiIG11c3QgbWF0Y2hcIik7aWYoIXQuaXNVbmlmb3JtfHwhby5pc1VuaWZvcm0pe3ZhciBpPXQudGV4U2hhcGUscz1vLmlzVW5pZm9ybT9udWxsOm8udGV4RGF0YS50ZXhTaGFwZTtpZighUyhpLHMpKXRocm93IEVycm9yKFwiQmluYXJ5IHdhcyBjb21waWxlZCB3aXRoIGRpZmZlcmVudCB0ZXh0dXJlIHNoYXBlcyB0aGFuIHRoZSBjdXJyZW50IGFyZ3MuIFNoYXBlIFwiK2krXCIgYW5kIFwiK3MrXCIgbXVzdCBtYXRjaFwiKX19KSl9dmFyIExpPWZ1bmN0aW9uKHQsZSxuKXt0aGlzLnZhcmlhYmxlTmFtZXM9W1wiQVwiXSx0aGlzLnBhY2tlZElucHV0cz0hMCx0aGlzLnBhY2tlZE91dHB1dD0hMCx0aGlzLm91dHB1dFNoYXBlPXQ7Zm9yKHZhciByPW4uZmlsdGVyV2lkdGgsbz1uLmluQ2hhbm5lbHMsYT1uLnN0cmlkZVdpZHRoLGk9bi5zdHJpZGVIZWlnaHQscz1uLnBhZEluZm8sdT1uLm91dFdpZHRoLGM9bi5kaWxhdGlvbldpZHRoLGw9bi5kaWxhdGlvbkhlaWdodCxoPW4uZGF0YUZvcm1hdCxmPXMubGVmdCxkPXMudG9wLHA9bypyLHY9dWEoKSxtPVwiY2hhbm5lbHNMYXN0XCI9PT1oLGc9bT8wOjEseT1tPzE6Mix4PVwiXCIsYj0wO2I8PTE7YisrKWZvcih2YXIgdz0wO3c8PTE7dysrKXgrPVwiXFxuICAgICAgICAgIGJsb2NrSW5kZXggPSByYy55ICsgXCIrdytcIjtcXG4gICAgICAgICAgcG9zID0gcmMueCArIFwiK2IrXCI7XFxuXFxuICAgICAgICAgIGlmKGJsb2NrSW5kZXggPCBcIit0WzFdK1wiICYmIHBvcyA8IFwiK3RbMF0rXCIpIHtcXG4gICAgICAgICAgICBvZmZzZXRZID0gaW50KGJsb2NrSW5kZXggLyAoXCIrdStcIikpICogXCIraStcIiAtIFwiK2QrXCI7XFxuICAgICAgICAgICAgZDAgPSBvZmZzZXRZICsgXCIrbCtcIiAqIChwb3MgLyBcIitwK1wiKTtcXG5cXG4gICAgICAgICAgICBpZihkMCA8IFwiK2VbZ10rXCIgJiYgZDAgPj0gMCkge1xcblxcbiAgICAgICAgICAgICAgb2Zmc2V0WCA9IGludChtb2QoZmxvYXQoYmxvY2tJbmRleCksIFwiK3UrXCIuKSAqIFwiK2ErXCIuIC0gXCIrZitcIi4pO1xcbiAgICAgICAgICAgICAgZDEgPSBvZmZzZXRYICsgXCIrYytcIiAqIChpbnQobW9kKGZsb2F0KHBvcyksIFwiK3ArXCIuKSAvIFwiK28rXCIuKSk7XFxuXFxuICAgICAgICAgICAgICBpZihkMSA8IFwiK2VbeV0rXCIgJiYgZDEgPj0gMCkge1xcblxcbiAgICAgICAgICAgICAgICBjaCA9IGludChtb2QoZmxvYXQocG9zKSwgXCIrbytcIi4pKTtcXG5cXG4gICAgICAgICAgICAgICAgaWYgKFwiK20rXCIpIHtcXG4gICAgICAgICAgICAgICAgICBpbm5lckRpbXMgPSB2ZWMyKGQxLCBjaCk7XFxuICAgICAgICAgICAgICAgICAgcmVzdWx0W1wiKygyKmIrdykrXCJdID0gZ2V0Q2hhbm5lbChcXG4gICAgICAgICAgICAgICAgICAgIGdldEEoZDAsIGludChpbm5lckRpbXMueCksXFxuICAgICAgICAgICAgICAgICAgICBpbnQoaW5uZXJEaW1zLnkpKSwgaW5uZXJEaW1zKTtcXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICAgICAgICBpbm5lckRpbXMgPSB2ZWMyKGQwLCBkMSk7XFxuICAgICAgICAgICAgICAgICAgcmVzdWx0W1wiKygyKmIrdykrXCJdID0gZ2V0Q2hhbm5lbChcXG4gICAgICAgICAgICAgICAgICAgIGdldEEoY2gsIGludChpbm5lckRpbXMueCksXFxuICAgICAgICAgICAgICAgICAgICBpbnQoaW5uZXJEaW1zLnkpKSwgaW5uZXJEaW1zKTtcXG4gICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgfVxcbiAgICAgICAgXCI7dGhpcy51c2VyQ29kZT1cIlxcbiAgICAgIHZvaWQgbWFpbigpIHtcXG4gICAgICAgIGl2ZWMyIHJjID0gZ2V0T3V0cHV0Q29vcmRzKCk7XFxuXFxuICAgICAgICB2ZWM0IHJlc3VsdCA9IHZlYzQoMCk7XFxuXFxuICAgICAgICBpbnQgYmxvY2tJbmRleCwgcG9zLCBvZmZzZXRZLCBkMCwgb2Zmc2V0WCwgZDEsIGNoO1xcbiAgICAgICAgdmVjMiBpbm5lckRpbXM7XFxuXFxuICAgICAgICBcIit4K1wiXFxuXFxuICAgICAgICBcIit2Lm91dHB1dCtcIiA9IHJlc3VsdDtcXG4gICAgICB9XFxuICAgIFwifSxXaT1mdW5jdGlvbih0LGUsbixyLG8pe3RoaXMudmFyaWFibGVOYW1lcz1bXCJ4XCJdLHRoaXMub3V0cHV0U2hhcGU9W107dmFyIGEsaT1lLHM9dFszXS0xO3RoaXMub3V0cHV0U2hhcGU9dDt2YXIgdT1cImZsb2F0KFwiK24rXCIpICsgZmxvYXQoXCIrcitcIikgKiBzdW1cIjthPS41PT09bz9cImludmVyc2VzcXJ0KFwiK3UrXCIpXCI6MT09PW8/XCIxLjAvKFwiK3UrXCIpXCI6XCJleHAobG9nKFwiK3UrXCIpICogZmxvYXQoLVwiK28rXCIpKTtcIix0aGlzLnVzZXJDb2RlPVwiXFxuICAgICAgdm9pZCBtYWluKCkge1xcbiAgICAgICAgaXZlYzQgY29vcmRzID0gZ2V0T3V0cHV0Q29vcmRzKCk7XFxuICAgICAgICBpbnQgYiA9IGNvb3Jkc1swXTtcXG4gICAgICAgIGludCByID0gY29vcmRzWzFdO1xcbiAgICAgICAgaW50IGMgPSBjb29yZHNbMl07XFxuICAgICAgICBpbnQgZCA9IGNvb3Jkc1szXTtcXG4gICAgICAgIGZsb2F0IHggPSBnZXRYKGIsIHIsIGMsIGQpO1xcbiAgICAgICAgZmxvYXQgc3VtID0gMC4wO1xcbiAgICAgICAgZm9yIChpbnQgaiA9IC1cIitpK1wiOyBqIDw9IFwiK2krXCI7IGorKykge1xcbiAgICAgICAgICBpbnQgaWR4ID0gZCArIGo7XFxuICAgICAgICAgIGlmIChpZHggPj0gMCAmJiBpZHggPD0gIFwiK3MrXCIpIHtcXG4gICAgICAgICAgICBmbG9hdCB6ID0gZ2V0WChiLCByLCBjLCBpZHgpO1xcbiAgICAgICAgICAgIHN1bSArPSB6ICogejtcXG4gICAgICAgICAgfVxcbiAgICAgICAgfVxcbiAgICAgICAgZmxvYXQgdmFsID0geCAqIFwiK2ErXCI7XFxuICAgICAgICBzZXRPdXRwdXQodmFsKTtcXG4gICAgICB9XFxuICAgIFwifSxVaT1mdW5jdGlvbih0LGUsbixyLG8pe3RoaXMudmFyaWFibGVOYW1lcz1bXCJpbnB1dEltYWdlXCIsXCJvdXRwdXRJbWFnZVwiLFwiZHlcIl0sdGhpcy5vdXRwdXRTaGFwZT1bXSx0aGlzLm91dHB1dFNoYXBlPXQsdGhpcy5kZXB0aD10WzNdLHRoaXMuZGVwdGhSYWRpdXM9ZSx0aGlzLmJpYXM9bix0aGlzLmFscGhhPXIsdGhpcy5iZXRhPW8sdGhpcy51c2VyQ29kZT1cIlxcbiAgICAgIHZvaWQgbWFpbigpIHtcXG4gICAgICAgIGl2ZWM0IGNvb3JkcyA9IGdldE91dHB1dENvb3JkcygpO1xcbiAgICAgICAgaW50IGIgPSBjb29yZHNbMF07XFxuICAgICAgICBpbnQgciA9IGNvb3Jkc1sxXTtcXG4gICAgICAgIGludCBjID0gY29vcmRzWzJdO1xcblxcbiAgICAgICAgZmxvYXQgcmVzdWx0ID0gMC4wO1xcbiAgICAgICAgZm9yIChpbnQgZCA9IDA7IGQgPCBcIit0aGlzLmRlcHRoK1wiOyArK2QpIHtcXG4gICAgICAgICAgaW50IGRlcHRoQmVnaW4gPSBpbnQobWF4KDAuMCwgZmxvYXQoZCAtIFwiK2UrXCIpKSk7XFxuICAgICAgICAgIGludCBkZXB0aEVuZCA9IGludChtaW4oZmxvYXQoXCIrdGhpcy5kZXB0aCtcIiksXFxuICAgICAgICAgICAgICBmbG9hdChkICsgXCIrZStcIiArIDEpKSk7XFxuXFxuICAgICAgICAgIGNvbnN0IGludCBNSU5fREVQVEhfQkVHSU4gPSAwO1xcbiAgICAgICAgICBjb25zdCBpbnQgTUFYX0RFUFRIX0VORCA9IFwiK3RoaXMuZGVwdGgrXCI7XFxuXFxuICAgICAgICAgIGZsb2F0IG5vcm0gPSAwLjA7XFxuICAgICAgICAgIGZvciAoaW50IGsgPSBNSU5fREVQVEhfQkVHSU47IGsgPCBNQVhfREVQVEhfRU5EOyArK2spIHtcXG4gICAgICAgICAgICBpZiAoayA8IGRlcHRoQmVnaW4pe1xcbiAgICAgICAgICAgICAgY29udGludWU7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIGVsc2UgaWYgKGsgPj0gZGVwdGhCZWdpbiAmJiBrIDwgZGVwdGhFbmQpIHtcXG4gICAgICAgICAgICAgIG5vcm0gKz0gZ2V0SW5wdXRJbWFnZShiLCByLCBjLCBrKSAqIGdldElucHV0SW1hZ2UoYiwgciwgYywgayk7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIGVsc2Uge1xcbiAgICAgICAgICAgICAgYnJlYWs7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICB9XFxuXFxuICAgICAgICAgIG5vcm0gPSBmbG9hdChcIityK1wiKSAqIG5vcm0gKyBmbG9hdChcIituK1wiKTtcXG5cXG4gICAgICAgICAgZm9yKGludCBrID0gTUlOX0RFUFRIX0JFR0lOOyBrIDwgTUFYX0RFUFRIX0VORDsgKytrKXtcXG4gICAgICAgICAgICBpZiAoayA8IGRlcHRoQmVnaW4pe1xcbiAgICAgICAgICAgICAgY29udGludWU7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIGVsc2UgaWYgKGsgPj0gZGVwdGhCZWdpbiAmJiBrIDwgZGVwdGhFbmQpe1xcbiAgICAgICAgICAgICAgZmxvYXQgZHlpID0gLTIuMCAqIGZsb2F0KFwiK3IrXCIpXFxuICAgICAgICAgICAgICAgICogZmxvYXQoXCIrbytcIilcXG4gICAgICAgICAgICAgICAgKiBnZXRJbnB1dEltYWdlKGIgLHIgLGMsIGspICogZ2V0T3V0cHV0SW1hZ2UoYiwgciwgYywgZClcXG4gICAgICAgICAgICAgICAgLyBub3JtO1xcbiAgICAgICAgICAgICAgaWYgKGsgPT0gZCkge1xcbiAgICAgICAgICAgICAgICBkeWkgKz0gcG93KG5vcm0sIC0xLjAgKiBcIitvK1wiKTtcXG4gICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgIGlmIChrID09IGNvb3Jkc1szXSkge1xcbiAgICAgICAgICAgICAgICBkeWkgKj0gZ2V0RHkoYiwgciwgYywgZCk7XFxuICAgICAgICAgICAgICAgIHJlc3VsdCArPSBkeWk7XFxuICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIGVsc2Uge1xcbiAgICAgICAgICAgICAgYnJlYWs7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICB9XFxuICAgICAgfVxcbiAgICAgIHNldE91dHB1dChyZXN1bHQpO1xcbiAgICAgIH1cXG4gICAgXCJ9LFZpPWZ1bmN0aW9uKHQsZSxuLHIsbyl7dGhpcy52YXJpYWJsZU5hbWVzPVtcInhcIl0sdGhpcy5vdXRwdXRTaGFwZT1bXSx0aGlzLnBhY2tlZElucHV0cz0hMCx0aGlzLnBhY2tlZE91dHB1dD0hMDt2YXIgYSxpPWUscz10WzNdLTE7dGhpcy5vdXRwdXRTaGFwZT10O3ZhciB1PVwiZmxvYXQoXCIrbitcIikgKyBmbG9hdChcIityK1wiKSAqIHN1bVwiO2E9LjU9PT1vP1wiaW52ZXJzZXNxcnQoXCIrdStcIilcIjoxPT09bz9cIjEuMC8oXCIrdStcIilcIjpcImV4cChsb2coXCIrdStcIikgKiBmbG9hdCgtXCIrbytcIikpO1wiLHRoaXMudXNlckNvZGU9XCJcXG4gICAgICB2b2lkIG1haW4oKSB7XFxuICAgICAgICBpdmVjNCBjb29yZHMgPSBnZXRPdXRwdXRDb29yZHMoKTtcXG4gICAgICAgIGludCBiID0gY29vcmRzLng7XFxuICAgICAgICBpbnQgciA9IGNvb3Jkcy55O1xcbiAgICAgICAgaW50IGMgPSBjb29yZHMuejtcXG4gICAgICAgIGludCBkID0gY29vcmRzLnc7XFxuXFxuICAgICAgICBib29sIGhhc05leHRDb2wgPSBkIDwgXCIrdGhpcy5vdXRwdXRTaGFwZVszXStcIjtcXG4gICAgICAgIGJvb2wgaGFzTmV4dFJvdyA9IGMgPCBcIit0aGlzLm91dHB1dFNoYXBlWzJdK1wiO1xcblxcbiAgICAgICAgdmVjNCBzdW0gPSB2ZWM0KDAuKTtcXG4gICAgICAgIHZlYzQgeEZyYWdBdE91dHB1dENvb3JkcyA9IGdldFgoYiwgciwgYywgZCk7XFxuXFxuICAgICAgICB2ZWM0IHhBdE91dHB1dENvb3JkcyA9IHZlYzQoXFxuICAgICAgICAgIGdldENoYW5uZWwoeEZyYWdBdE91dHB1dENvb3JkcywgdmVjMihjLCBkKSksXFxuICAgICAgICAgIGhhc05leHRDb2wgP1xcbiAgICAgICAgICAgIGdldENoYW5uZWwoeEZyYWdBdE91dHB1dENvb3JkcywgdmVjMihjLCBkICsgMSkpIDogMC4wLFxcbiAgICAgICAgICBoYXNOZXh0Um93ID9cXG4gICAgICAgICAgICBnZXRDaGFubmVsKHhGcmFnQXRPdXRwdXRDb29yZHMgLCB2ZWMyKGMgKyAxLCBkKSkgOiAwLjAsXFxuICAgICAgICAgIChoYXNOZXh0Um93ICYmIGhhc05leHRDb2wpID9cXG4gICAgICAgICAgICBnZXRDaGFubmVsKHhGcmFnQXRPdXRwdXRDb29yZHMsIHZlYzIoYyArIDEsIGQgKyAxKSkgOiAwLjBcXG4gICAgICAgICk7XFxuXFxuICAgICAgICBpbnQgZmlyc3RDaGFubmVsID0gZCAtIFwiK2krXCI7XFxuICAgICAgICB2ZWMyIGNhY2hlID0gdmVjMigwLik7XFxuICAgICAgICBpZihmaXJzdENoYW5uZWwgPj0gMCl7XFxuICAgICAgICAgIHZlYzQgZmlyc3RDaGFubmVsRnJhZyA9IGdldFgoYiwgciwgYywgZmlyc3RDaGFubmVsKTtcXG4gICAgICAgICAgY2FjaGUueCA9IGdldENoYW5uZWwoZmlyc3RDaGFubmVsRnJhZywgdmVjMihjLCBmaXJzdENoYW5uZWwpKTtcXG4gICAgICAgICAgICBpZihoYXNOZXh0Um93KXtcXG4gICAgICAgICAgICAgIGNhY2hlLnkgPSBnZXRDaGFubmVsKGZpcnN0Q2hhbm5lbEZyYWcsIHZlYzIoYyArIDEsIGZpcnN0Q2hhbm5lbCkpO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgIH1cXG5cXG4gICAgICAgIGl2ZWMyIGRlcHRoID0gaXZlYzIoZCwgZCArIDEpO1xcbiAgICAgICAgZm9yIChpbnQgaiA9IC0gXCIraStcIjsgaiA8PSBcIitpK1wiOyBqKyspIHtcXG4gICAgICAgICAgaXZlYzIgaWR4ID0gZGVwdGggKyBqO1xcbiAgICAgICAgICBidmVjMiBhYm92ZUxvd2VyQm91bmQgPSBncmVhdGVyVGhhbkVxdWFsKGlkeCwgaXZlYzIoMCkpO1xcbiAgICAgICAgICBidmVjMiBiZWxvd1VwcGVyQm91bmQgPSBsZXNzVGhhbkVxdWFsKGlkeCwgaXZlYzIoXCIrcytcIikpO1xcblxcbiAgICAgICAgICBib29sIGRlcHRoSW5SYW5nZSA9IGFib3ZlTG93ZXJCb3VuZC54ICYmIGJlbG93VXBwZXJCb3VuZC54O1xcbiAgICAgICAgICBib29sIGRlcHRoUGx1c09uZUluUmFuZ2UgPSBhYm92ZUxvd2VyQm91bmQueSAmJiBiZWxvd1VwcGVyQm91bmQueTtcXG5cXG4gICAgICAgICAgaWYoZGVwdGhJblJhbmdlIHx8IGRlcHRoUGx1c09uZUluUmFuZ2Upe1xcbiAgICAgICAgICAgIHZlYzQgeiA9IHZlYzQoMC4pO1xcbiAgICAgICAgICAgIHZlYzQgeEZyYWdBdEN1cnJlbnREZXB0aDtcXG4gICAgICAgICAgICB6Lnh6ID0gY2FjaGUueHk7XFxuICAgICAgICAgICAgaWYoZGVwdGhQbHVzT25lSW5SYW5nZSAmJiBoYXNOZXh0Q29sKXtcXG4gICAgICAgICAgICAgIHhGcmFnQXRDdXJyZW50RGVwdGggPSBpZHgueSAhPSBkID9cXG4gICAgICAgICAgICAgICAgZ2V0WChiLCByLCBjLCBpZHgueSkgOiB4RnJhZ0F0T3V0cHV0Q29vcmRzO1xcbiAgICAgICAgICAgICAgei55ID0gZ2V0Q2hhbm5lbCh4RnJhZ0F0Q3VycmVudERlcHRoLCB2ZWMyKGMsIGlkeC55KSk7XFxuICAgICAgICAgICAgICBpZihoYXNOZXh0Um93KXtcXG4gICAgICAgICAgICAgICAgei53ID0gZ2V0Q2hhbm5lbCh4RnJhZ0F0Q3VycmVudERlcHRoLCB2ZWMyKGMgKyAxLCBpZHgueSkpO1xcbiAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgICBjYWNoZS54eSA9IHoueXc7XFxuICAgICAgICAgICAgc3VtICs9IHogKiB6O1xcbiAgICAgICAgICB9XFxuICAgICAgICB9XFxuICAgICAgICB2ZWM0IHJlc3VsdCA9IHhBdE91dHB1dENvb3JkcyAqIFwiK2ErXCI7XFxuICAgICAgICBzZXRPdXRwdXQocmVzdWx0KTtcXG4gICAgICB9XFxuICAgIFwifSx6aT1mdW5jdGlvbih0KXt0aGlzLnZhcmlhYmxlTmFtZXM9W1wiZHlcIixcIm1heFBvc1wiXSx0aGlzLm91dHB1dFNoYXBlPXQuaW5TaGFwZTt2YXIgZT10LnN0cmlkZUhlaWdodCxuPXQuc3RyaWRlV2lkdGgscj10LmRpbGF0aW9uSGVpZ2h0LG89dC5lZmZlY3RpdmVGaWx0ZXJIZWlnaHQsYT10LmVmZmVjdGl2ZUZpbHRlcldpZHRoLGk9by0xLXQucGFkSW5mby50b3Ascz1hLTEtdC5wYWRJbmZvLmxlZnQsdT1vKmEtMTt0aGlzLnVzZXJDb2RlPVwiXFxuICAgICAgY29uc3QgaXZlYzIgcGFkcyA9IGl2ZWMyKFwiK2krXCIsIFwiK3MrXCIpO1xcblxcbiAgICAgIHZvaWQgbWFpbigpIHtcXG4gICAgICAgIGl2ZWM0IGNvb3JkcyA9IGdldE91dHB1dENvb3JkcygpO1xcbiAgICAgICAgaW50IGIgPSBjb29yZHNbMF07XFxuICAgICAgICBpbnQgZCA9IGNvb3Jkc1szXTtcXG5cXG4gICAgICAgIGl2ZWMyIGR5UkNDb3JuZXIgPSBjb29yZHMueXogLSBwYWRzO1xcbiAgICAgICAgaW50IGR5UkNvcm5lciA9IGR5UkNDb3JuZXIueDtcXG4gICAgICAgIGludCBkeUNDb3JuZXIgPSBkeVJDQ29ybmVyLnk7XFxuXFxuICAgICAgICAvLyBDb252b2x2ZSBkeSg/LCA/LCBkKSB3aXRoIHBvcyBtYXNrKDosIDosIGQpIHRvIGdldCBkeCh4UiwgeEMsIGQpLlxcbiAgICAgICAgLy8gPyA9IHRvIGJlIGRldGVybWluZWQuIDogPSBhY3Jvc3MgYWxsIHZhbHVlcyBpbiB0aGF0IGF4aXMuXFxuICAgICAgICBmbG9hdCBkb3RQcm9kID0gMC4wO1xcbiAgICAgICAgZm9yIChpbnQgd1IgPSAwOyB3UiA8IFwiK28rXCI7XFxuICAgICAgICAgIHdSICs9IFwiK3IrXCIpIHtcXG4gICAgICAgICAgZmxvYXQgZHlSID0gZmxvYXQoZHlSQ29ybmVyICsgd1IpIC8gXCIrZStcIi4wO1xcblxcbiAgICAgICAgICBpZiAoZHlSIDwgMC4wIHx8IGR5UiA+PSBcIit0Lm91dEhlaWdodCtcIi4wIHx8IGZyYWN0KGR5UikgPiAwLjApIHtcXG4gICAgICAgICAgICBjb250aW51ZTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgICBpbnQgaWR5UiA9IGludChkeVIpO1xcblxcbiAgICAgICAgICBmb3IgKGludCB3QyA9IDA7IHdDIDwgXCIrYStcIjsgd0MrKykge1xcbiAgICAgICAgICAgIGZsb2F0IGR5QyA9IGZsb2F0KGR5Q0Nvcm5lciArIHdDKSAvIFwiK24rXCIuMDtcXG5cXG4gICAgICAgICAgICBpZiAoZHlDIDwgMC4wIHx8IGR5QyA+PSBcIit0Lm91dFdpZHRoK1wiLjAgfHxcXG4gICAgICAgICAgICAgICAgZnJhY3QoZHlDKSA+IDAuMCkge1xcbiAgICAgICAgICAgICAgY29udGludWU7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIGludCBpZHlDID0gaW50KGR5Qyk7XFxuXFxuICAgICAgICAgICAgZmxvYXQgZHlWYWx1ZSA9IGdldER5KGIsIGlkeVIsIGlkeUMsIGQpO1xcbiAgICAgICAgICAgIGludCBtYXhQb3NWYWx1ZSA9IFwiK3UrXCIgLSBpbnQoZ2V0TWF4UG9zKGIsIGlkeVIsIGlkeUMsIGQpKTtcXG5cXG4gICAgICAgICAgICAvLyBHZXQgdGhlIGN1cnJlbnQgdmFsdWUsIGNoZWNrIGl0IGFnYWluc3QgdGhlIHZhbHVlIGZyb20gdGhlXFxuICAgICAgICAgICAgLy8gcG9zaXRpb24gbWF0cml4LlxcbiAgICAgICAgICAgIGludCBjdXJQb3NWYWx1ZSA9IHdSICogXCIrYStcIiArIHdDO1xcbiAgICAgICAgICAgIGZsb2F0IG1hc2sgPSBmbG9hdChtYXhQb3NWYWx1ZSA9PSBjdXJQb3NWYWx1ZSA/IDEuMCA6IDAuMCk7XFxuXFxuICAgICAgICAgICAgZG90UHJvZCArPSBkeVZhbHVlICogbWFzaztcXG4gICAgICAgICAgfVxcbiAgICAgICAgfVxcbiAgICAgICAgc2V0T3V0cHV0KGRvdFByb2QpO1xcbiAgICAgIH1cXG4gICAgXCJ9LEdpPWZ1bmN0aW9uKHQpe3RoaXMudmFyaWFibGVOYW1lcz1bXCJkeVwiLFwibWF4UG9zXCJdLHRoaXMub3V0cHV0U2hhcGU9dC5pblNoYXBlO3ZhciBlPXQuc3RyaWRlRGVwdGgsbj10LnN0cmlkZUhlaWdodCxyPXQuc3RyaWRlV2lkdGgsbz10LmRpbGF0aW9uRGVwdGgsYT10LmRpbGF0aW9uSGVpZ2h0LGk9dC5kaWxhdGlvbldpZHRoLHM9dC5lZmZlY3RpdmVGaWx0ZXJEZXB0aCx1PXQuZWZmZWN0aXZlRmlsdGVySGVpZ2h0LGM9dC5lZmZlY3RpdmVGaWx0ZXJXaWR0aCxsPXMtMS10LnBhZEluZm8uZnJvbnQsaD11LTEtdC5wYWRJbmZvLnRvcCxmPWMtMS10LnBhZEluZm8ubGVmdCxkPXMqdSpjLTE7dGhpcy51c2VyQ29kZT1cIlxcbiAgICAgIGNvbnN0IGl2ZWMzIHBhZHMgPSBpdmVjMyhcIitsK1wiLCBcIitoK1wiLCBcIitmK1wiKTtcXG5cXG4gICAgICB2b2lkIG1haW4oKSB7XFxuICAgICAgICBpdmVjNSBjb29yZHMgPSBnZXRPdXRwdXRDb29yZHMoKTtcXG4gICAgICAgIGludCBiYXRjaCA9IGNvb3Jkcy54O1xcbiAgICAgICAgaW50IGNoID0gY29vcmRzLnU7XFxuXFxuICAgICAgICBpdmVjMyBkeUNvcm5lciA9IGl2ZWMzKGNvb3Jkcy55LCBjb29yZHMueiwgY29vcmRzLncpIC0gcGFkcztcXG4gICAgICAgIGludCBkeURDb3JuZXIgPSBkeUNvcm5lci54O1xcbiAgICAgICAgaW50IGR5UkNvcm5lciA9IGR5Q29ybmVyLnk7XFxuICAgICAgICBpbnQgZHlDQ29ybmVyID0gZHlDb3JuZXIuejtcXG5cXG4gICAgICAgIC8vIENvbnZvbHZlIGR5KD8sID8sID8sIGNoKSB3aXRoIHBvcyBtYXNrKDosIDosIDosIGQpIHRvIGdldFxcbiAgICAgICAgLy8gZHgoeEQsIHhSLCB4QywgY2gpLlxcbiAgICAgICAgLy8gPyA9IHRvIGJlIGRldGVybWluZWQuIDogPSBhY3Jvc3MgYWxsIHZhbHVlcyBpbiB0aGF0IGF4aXMuXFxuICAgICAgICBmbG9hdCBkb3RQcm9kID0gMC4wO1xcblxcbiAgICAgICAgZm9yIChpbnQgd0QgPSAwOyB3RCA8IFwiK3MrXCI7XFxuICAgICAgICAgICB3RCArPSBcIitvK1wiKSB7XFxuICAgICAgICAgIGZsb2F0IGR5RCA9IGZsb2F0KGR5RENvcm5lciArIHdEKSAvIFwiK2UrXCIuMDtcXG5cXG4gICAgICAgICAgaWYgKGR5RCA8IDAuMCB8fCBkeUQgPj0gXCIrdC5vdXREZXB0aCtcIi4wIHx8IGZyYWN0KGR5RCkgPiAwLjApIHtcXG4gICAgICAgICAgICBjb250aW51ZTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgICBpbnQgaWR5RCA9IGludChkeUQpO1xcblxcbiAgICAgICAgICBmb3IgKGludCB3UiA9IDA7IHdSIDwgXCIrdStcIjtcXG4gICAgICAgICAgICAgIHdSICs9IFwiK2ErXCIpIHtcXG4gICAgICAgICAgICBmbG9hdCBkeVIgPSBmbG9hdChkeVJDb3JuZXIgKyB3UikgLyBcIituK1wiLjA7XFxuXFxuICAgICAgICAgICAgaWYgKGR5UiA8IDAuMCB8fCBkeVIgPj0gXCIrdC5vdXRIZWlnaHQrXCIuMCB8fFxcbiAgICAgICAgICAgICAgICBmcmFjdChkeVIpID4gMC4wKSB7XFxuICAgICAgICAgICAgICBjb250aW51ZTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgICAgaW50IGlkeVIgPSBpbnQoZHlSKTtcXG5cXG4gICAgICAgICAgICBmb3IgKGludCB3QyA9IDA7IHdDIDwgXCIrYytcIjtcXG4gICAgICAgICAgICAgICAgd0MgKz0gXCIraStcIikge1xcbiAgICAgICAgICAgICAgZmxvYXQgZHlDID0gZmxvYXQoZHlDQ29ybmVyICsgd0MpIC8gXCIrcitcIi4wO1xcblxcbiAgICAgICAgICAgICAgaWYgKGR5QyA8IDAuMCB8fCBkeUMgPj0gXCIrdC5vdXRXaWR0aCtcIi4wIHx8XFxuICAgICAgICAgICAgICAgICAgZnJhY3QoZHlDKSA+IDAuMCkge1xcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcXG4gICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgIGludCBpZHlDID0gaW50KGR5Qyk7XFxuXFxuICAgICAgICAgICAgICBmbG9hdCBkeVZhbHVlID0gZ2V0RHkoYmF0Y2gsIGlkeUQsIGlkeVIsIGlkeUMsIGNoKTtcXG4gICAgICAgICAgICAgIGludCBtYXhQb3NWYWx1ZSA9IFwiK2QrXCIgLVxcbiAgICAgICAgICAgICAgICAgIGludChnZXRNYXhQb3MoYmF0Y2gsIGlkeUQsIGlkeVIsIGlkeUMsIGNoKSk7XFxuXFxuICAgICAgICAgICAgICAvLyBHZXQgdGhlIGN1cnJlbnQgdmFsdWUsIGNoZWNrIGl0IGFnYWluc3QgdGhlIHZhbHVlIGZyb20gdGhlXFxuICAgICAgICAgICAgICAvLyBwb3NpdGlvbiBtYXRyaXguXFxuICAgICAgICAgICAgICBpbnQgY3VyUG9zVmFsdWUgPVxcbiAgICAgICAgICAgICAgICAgIHdEICogXCIrdStcIiAqIFwiK2MrXCIgK1xcbiAgICAgICAgICAgICAgICAgIHdSICogXCIrYytcIiArIHdDO1xcbiAgICAgICAgICAgICAgZmxvYXQgbWFzayA9IGZsb2F0KG1heFBvc1ZhbHVlID09IGN1clBvc1ZhbHVlID8gMS4wIDogMC4wKTtcXG5cXG4gICAgICAgICAgICAgIGRvdFByb2QgKz0gZHlWYWx1ZSAqIG1hc2s7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICB9XFxuICAgICAgICB9XFxuICAgICAgICBzZXRPdXRwdXQoZG90UHJvZCk7XFxuICAgICAgfVxcbiAgICBcIn0sSGk9ZnVuY3Rpb24odCxlLG4scixvLGEsaSl7dm9pZCAwPT09biYmKG49ITEpLHZvaWQgMD09PXImJihyPSExKSx2b2lkIDA9PT1vJiYobz0hMSksdm9pZCAwPT09YSYmKGE9bnVsbCksdm9pZCAwPT09aSYmKGk9ITEpLHRoaXMudmFyaWFibGVOYW1lcz1bXCJtYXRyaXhBXCIsXCJtYXRyaXhCXCJdLHRoaXMucGFja2VkSW5wdXRzPSEwLHRoaXMucGFja2VkT3V0cHV0PSEwLHRoaXMub3V0cHV0U2hhcGU9ZTt2YXIgcz1uP3RbMV06dFsyXSx1PU1hdGguY2VpbChzLzIpLGM9bj9cImkgKiAyLCByYy55XCI6XCJyYy55LCBpICogMlwiLGw9cj9cInJjLnosIGkgKiAyXCI6XCJpICogMiwgcmMuelwiLGg9bj9bXCJhLnh4eXlcIixcImEuenp3d1wiXTpbXCJhLnh4enpcIixcImEueXl3d1wiXSxmPXI/W1wiYi54enh6XCIsXCJiLnl3eXdcIl06W1wiYi54eXh5XCIsXCJiLnp3endcIl0sZD1cIlwiLHA9XCJcIjthJiYoZD1pP1widmVjNCBhY3RpdmF0aW9uKHZlYzQgYSkge1xcbiAgICAgICAgICB2ZWM0IGIgPSBnZXRQcmVsdUFjdGl2YXRpb25XZWlnaHRzQXRPdXRDb29yZHMoKTtcXG4gICAgICAgICAgXCIrYStcIlxcbiAgICAgICAgfVwiOlwidmVjNCBhY3RpdmF0aW9uKHZlYzQgeCkge1xcbiAgICAgICAgICBcIithK1wiXFxuICAgICAgICB9XCIscD1cInJlc3VsdCA9IGFjdGl2YXRpb24ocmVzdWx0KTtcIik7dmFyIHY9bz9cInJlc3VsdCArPSBnZXRCaWFzQXRPdXRDb29yZHMoKTtcIjpcIlwiO28mJnRoaXMudmFyaWFibGVOYW1lcy5wdXNoKFwiYmlhc1wiKSxpJiZ0aGlzLnZhcmlhYmxlTmFtZXMucHVzaChcInByZWx1QWN0aXZhdGlvbldlaWdodHNcIiksdGhpcy51c2VyQ29kZT1cIlxcbiAgICAgIFwiK2QrXCJcXG5cXG4gICAgICBjb25zdCBmbG9hdCBzaGFyZWREaW1lbnNpb24gPSBcIit1K1wiLjA7XFxuXFxuICAgICAgdmVjNCBkb3QyeDJBUm93QkNvbChpdmVjMyByYykge1xcbiAgICAgICAgdmVjNCByZXN1bHQgPSB2ZWM0KDApO1xcbiAgICAgICAgZm9yIChpbnQgaSA9IDA7IGkgPCBcIit1K1wiOyBpKyspIHtcXG4gICAgICAgICAgdmVjNCBhID0gZ2V0TWF0cml4QShyYy54LCBcIitjK1wiKTtcXG4gICAgICAgICAgdmVjNCBiID0gZ2V0TWF0cml4QihyYy54LCBcIitsK1wiKTtcXG5cXG4gICAgICAgICAgLy8gVGhlc2Ugc3dpenpsZWQgcHJvZHVjdHMgbmVlZCB0byBiZSBzZXBhcmF0ZWx5IGFkZGVkLlxcbiAgICAgICAgICAvLyBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS90ZW5zb3JmbG93L3RmanMvaXNzdWVzLzE3MzVcXG4gICAgICAgICAgcmVzdWx0ICs9IChcIitoWzBdK1wiICogXCIrZlswXStcIik7XFxuICAgICAgICAgIHJlc3VsdCArPSAoXCIraFsxXStcIiAqIFwiK2ZbMV0rXCIpO1xcbiAgICAgICAgfVxcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcXG4gICAgICB9XFxuXFxuICAgICAgdm9pZCBtYWluKCkge1xcbiAgICAgICAgaXZlYzMgcmMgPSBnZXRPdXRwdXRDb29yZHMoKTtcXG4gICAgICAgIHZlYzQgcmVzdWx0ID0gZG90MngyQVJvd0JDb2wocmMpO1xcblxcbiAgICAgICAgXCIrditcIlxcblxcbiAgICAgICAgXCIrcCtcIlxcblxcbiAgICAgICAgc2V0T3V0cHV0KHJlc3VsdCk7XFxuICAgICAgfVxcbiAgICBcIn0scWk9ZnVuY3Rpb24oKXtmdW5jdGlvbiB0KHQsZSxuKXt0aGlzLnZhcmlhYmxlTmFtZXM9W1wicHJvYnNcIl0sdGhpcy5vdXRwdXRTaGFwZT1bdCxuXSx0aGlzLnVzZXJDb2RlPVwiXFxuICAgICAgdW5pZm9ybSBmbG9hdCBzZWVkO1xcblxcbiAgICAgIHZvaWQgbWFpbigpIHtcXG4gICAgICAgIGl2ZWMyIGNvb3JkcyA9IGdldE91dHB1dENvb3JkcygpO1xcbiAgICAgICAgaW50IGJhdGNoID0gY29vcmRzWzBdO1xcblxcbiAgICAgICAgZmxvYXQgciA9IHJhbmRvbShzZWVkKTtcXG4gICAgICAgIGZsb2F0IGNkZiA9IDAuMDtcXG5cXG4gICAgICAgIGZvciAoaW50IGkgPSAwOyBpIDwgXCIrKGUtMSkrXCI7IGkrKykge1xcbiAgICAgICAgICBjZGYgKz0gZ2V0UHJvYnMoYmF0Y2gsIGkpO1xcblxcbiAgICAgICAgICBpZiAociA8IGNkZikge1xcbiAgICAgICAgICAgIHNldE91dHB1dChmbG9hdChpKSk7XFxuICAgICAgICAgICAgcmV0dXJuO1xcbiAgICAgICAgICB9XFxuICAgICAgICB9XFxuXFxuICAgICAgICAvLyBJZiBubyBvdGhlciBldmVudCBoYXBwZW5lZCwgbGFzdCBldmVudCBoYXBwZW5lZC5cXG4gICAgICAgIHNldE91dHB1dChmbG9hdChcIisoZS0xKStcIikpO1xcbiAgICAgIH1cXG4gICAgXCJ9cmV0dXJuIHQucHJvdG90eXBlLmdldEN1c3RvbVNldHVwRnVuYz1mdW5jdGlvbih0KXt2YXIgZT10aGlzO3JldHVybiBmdW5jdGlvbihuLHIpe251bGw9PWUuc2VlZExvYyYmKGUuc2VlZExvYz1uLmdldFVuaWZvcm1Mb2NhdGlvbihyLFwic2VlZFwiKSksbi5nbC51bmlmb3JtMWYoZS5zZWVkTG9jLHQpfX0sdH0oKSxLaT1mdW5jdGlvbih0LGUsbixyKXt0aGlzLnZhcmlhYmxlTmFtZXM9W1wiaW5kaWNlc1wiXSx0aGlzLm91dHB1dFNoYXBlPVt0LGVdLHRoaXMudXNlckNvZGU9XCJcXG4gICAgICB2b2lkIG1haW4oKSB7XFxuICAgICAgICBpdmVjMiBjb29yZHMgPSBnZXRPdXRwdXRDb29yZHMoKTtcXG4gICAgICAgIGludCBpbmRleCA9IHJvdW5kKGdldEluZGljZXMoY29vcmRzLngpKTtcXG4gICAgICAgIHNldE91dHB1dChtaXgoZmxvYXQoXCIrcitcIiksIGZsb2F0KFwiK24rXCIpLFxcbiAgICAgICAgICAgICAgICAgICAgICBmbG9hdChpbmRleCA9PSBjb29yZHMueSkpKTtcXG4gICAgICB9XFxuICAgIFwifSxqaT1mdW5jdGlvbih0KXt0aGlzLnZhcmlhYmxlTmFtZXM9W1wiQVwiXSx0aGlzLnBhY2tlZElucHV0cz0hMSx0aGlzLnBhY2tlZE91dHB1dD0hMCx0aGlzLm91dHB1dFNoYXBlPXQ7dmFyIGU9dC5sZW5ndGg7aWYoMD09PWUpdGhpcy51c2VyQ29kZT1cIlxcbiAgICAgICAgdm9pZCBtYWluKCkge1xcbiAgICAgICAgICBzZXRPdXRwdXQodmVjNChnZXRBKCksIDAuLCAwLiwgMC4pKTtcXG4gICAgICAgIH1cXG4gICAgICBcIjtlbHNle3ZhciBuPXNhKFwicmNcIixlKSxyPXdhKGUpLG89ZnVuY3Rpb24odCxlLG4pe2lmKDE9PT10KXJldHVyblwicmMgPiBcIitlWzBdO2Zvcih2YXIgcj1cIlwiLG89dC0yO288dDtvKyspcis9bltvXStcIiA+PSBcIitlW29dLG88dC0xJiYocis9XCJ8fFwiKTtyZXR1cm4gcn0oZSx0LG4pLGE9ZnVuY3Rpb24odCxlLG4scil7aWYoMT09PXQpcmV0dXJuXCJcIjt2YXIgbz1yLnNsaWNlKC0yKTtyZXR1cm5cIlxcbiAgICBpbnQgciA9IFwiK29bMF0rXCI7XFxuICAgIGludCBjID0gXCIrb1sxXStcIjtcXG4gICAgaW50IHJwMSA9IHIgKyAxO1xcbiAgICBpbnQgY3AxID0gYyArIDE7XFxuXFxuICAgIGJvb2wgY0VkZ2UgPSBjcDEgPj0gXCIrZStcIjtcXG4gICAgYm9vbCByRWRnZSA9IHJwMSA+PSBcIituK1wiO1xcbiAgXCJ9KGUsdFt0Lmxlbmd0aC0xXSx0W3QubGVuZ3RoLTJdLG4pLGk9ZnVuY3Rpb24odCxlKXt2YXIgbj10Lmxlbmd0aCxyPWZ1bmN0aW9uKHQsZSl7Zm9yKHZhciBuPVtdLHI9MDtyPD0xO3IrKylmb3IodmFyIG89MDtvPD0xO28rKyl7Zm9yKHZhciBhPSgwPT09cj9cInJcIjpcInJwMVwiKStcIiwgXCIrKDA9PT1vP1wiY1wiOlwiY3AxXCIpLGk9MjtpPHQ7aSsrKWE9ZVtlLmxlbmd0aC0xLWldK1wiLFwiK2E7bi5wdXNoKGEpfXJldHVybiBufShuLGUpO3JldHVybiAxPT09bj9cImdldEEocmMpLFxcbiAgICAgICAgICAgIHJjICsgMSA+PSBcIit0WzBdK1wiID8gMC4gOiBnZXRBKHJjICsgMSksXFxuICAgICAgICAgICAgMCwgMFwiOlwiZ2V0QShcIityWzBdK1wiKSxcXG4gICAgICAgICAgY0VkZ2UgPyAwLiA6IGdldEEoXCIrclsxXStcIiksXFxuICAgICAgICAgIHJFZGdlID8gMC4gOiBnZXRBKFwiK3JbMl0rXCIpLFxcbiAgICAgICAgICByRWRnZSB8fCBjRWRnZSA/IDAuIDogZ2V0QShcIityWzNdK1wiKVwifSh0LG4pO3RoaXMudXNlckNvZGU9XCJcXG4gICAgICAgIHZvaWQgbWFpbigpIHtcXG4gICAgICAgICAgXCIrcitcIiByYyA9IGdldE91dHB1dENvb3JkcygpO1xcblxcbiAgICAgICAgICBpZihcIitvK1wiKSB7XFxuICAgICAgICAgICAgc2V0T3V0cHV0KHZlYzQoMCkpO1xcbiAgICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgIFwiK2ErXCJcXG5cXG4gICAgICAgICAgICBzZXRPdXRwdXQodmVjNChcIitpK1wiKSk7XFxuICAgICAgICAgIH1cXG4gICAgICAgIH1cXG4gICAgICBcIn19O3ZhciBYaT1mdW5jdGlvbih0LGUsbil7dGhpcy52YXJpYWJsZU5hbWVzPVtcInhcIl0sdGhpcy5vdXRwdXRTaGFwZT1lLm1hcCgoZnVuY3Rpb24oZSxuKXtyZXR1cm4gZVswXSt0W25dK2VbMV19KSk7dmFyIHI9dC5sZW5ndGgsbz13YShyKSxhPWUubWFwKChmdW5jdGlvbih0KXtyZXR1cm4gdFswXX0pKS5qb2luKFwiLFwiKSxpPWUubWFwKChmdW5jdGlvbihlLG4pe3JldHVybiBlWzBdK3Rbbl19KSkuam9pbihcIixcIikscz1bXCJjb29yZHNbMF1cIixcImNvb3Jkc1sxXVwiLFwiY29vcmRzWzJdXCIsXCJjb29yZHNbM11cIl0uc2xpY2UoMCxyKTt0aGlzLnVzZXJDb2RlPTEhPT1yP1wiXFxuICAgICAgXCIrbytcIiBzdGFydCA9IFwiK28rXCIoXCIrYStcIik7XFxuICAgICAgXCIrbytcIiBlbmQgPSBcIitvK1wiKFwiK2krXCIpO1xcblxcbiAgICAgIHZvaWQgbWFpbigpIHtcXG4gICAgICAgIFwiK28rXCIgb3V0QyA9IGdldE91dHB1dENvb3JkcygpO1xcbiAgICAgICAgaWYgKGFueShsZXNzVGhhbihvdXRDLCBzdGFydCkpIHx8IGFueShncmVhdGVyVGhhbkVxdWFsKG91dEMsIGVuZCkpKSB7XFxuICAgICAgICAgIHNldE91dHB1dChmbG9hdChcIituK1wiKSk7XFxuICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICBcIitvK1wiIGNvb3JkcyA9IG91dEMgLSBzdGFydDtcXG4gICAgICAgICAgc2V0T3V0cHV0KGdldFgoXCIrcytcIikpO1xcbiAgICAgICAgfVxcbiAgICAgIH1cXG4gICAgXCI6XCJcXG4gICAgICAgIGludCBzdGFydCA9IFwiK2ErXCI7XFxuICAgICAgICBpbnQgZW5kID0gXCIraStcIjtcXG5cXG4gICAgICAgIHZvaWQgbWFpbigpIHtcXG4gICAgICAgICAgaW50IG91dEMgPSBnZXRPdXRwdXRDb29yZHMoKTtcXG4gICAgICAgICAgaWYgKG91dEMgPCBzdGFydCB8fCBvdXRDID49IGVuZCkge1xcbiAgICAgICAgICAgIHNldE91dHB1dChmbG9hdChcIituK1wiKSk7XFxuICAgICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgICAgc2V0T3V0cHV0KGdldFgob3V0QyAtIHN0YXJ0KSk7XFxuICAgICAgICAgIH1cXG4gICAgICAgIH1cXG4gICAgICBcIn0sWWk9ZnVuY3Rpb24odCxlLG4pe3RoaXMudmFyaWFibGVOYW1lcz1bXCJ4XCJdLHRoaXMucGFja2VkSW5wdXRzPSEwLHRoaXMucGFja2VkT3V0cHV0PSEwLHRoaXMub3V0cHV0U2hhcGU9ZS5tYXAoKGZ1bmN0aW9uKGUsbil7cmV0dXJuIGVbMF0rdFtuXStlWzFdfSkpO2Zvcih2YXIgcj10Lmxlbmd0aCxvPXdhKHIpLGE9ZS5tYXAoKGZ1bmN0aW9uKHQpe3JldHVybiB0WzBdfSkpLmpvaW4oXCIsXCIpLGk9ZS5tYXAoKGZ1bmN0aW9uKGUsbil7cmV0dXJuIGVbMF0rdFtuXX0pKS5qb2luKFwiLFwiKSxzPXNhKFwicmNcIixyKSx1PXNhKFwic291cmNlXCIsciksYz1zW3ItMV0rXCIgPCBcIit0aGlzLm91dHB1dFNoYXBlW3ItMV0sbD0xPT09cj9cInNvdXJjZVwiOlwidmVjMihcIit1LnNsaWNlKC0yKS5qb2luKCkrXCIpXCIsaD1bbytcIiByYyA9IG91dHB1dExvYztcIixzW3ItMV0rXCIgKz0gMTtcXG4gICAgICAgaWYoXCIrYytcIikge1xcbiAgICAgIFwiLDE9PT1yP1wiXCI6XCJ9XFxuICAgICAgIHJjID0gb3V0cHV0TG9jO1xcbiAgICAgICBcIitzW3ItMl0rXCIgKz0gMTtcXG4gICAgICAgaWYoXCIrc1tyLTJdK1wiIDwgXCIrdGhpcy5vdXRwdXRTaGFwZVtyLTJdK1wiKSB7XCIsMT09PXI/XCJcIjpcIiAgXCIrc1tyLTFdK1wiICs9IDE7XFxuICAgICAgICAgaWYoXCIrYytcIikge1wiXSxmPTE9PT1yP1wicmMgPCBzdGFydCB8fCByYyA+PSBlbmRcIjpcImFueShsZXNzVGhhbihyYywgc3RhcnQpKSB8fCBhbnkoZ3JlYXRlclRoYW5FcXVhbChyYywgZW5kKSlcIixkPVwiXCIscD0wLHY9MT09PXI/Mjo0O3A8djtwKyspZCs9XCJcXG4gICAgICAgIFwiK2hbcF0rXCJcXG4gICAgICAgIGlmIChcIitmK1wiKSB7XFxuICAgICAgICAgIHJlc3VsdFtcIitwK1wiXSA9IGZsb2F0KFwiK24rXCIpO1xcbiAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgXCIrbytcIiBzb3VyY2UgPSByYyAtIHN0YXJ0O1xcbiAgICAgICAgICByZXN1bHRbXCIrcCtcIl0gPSBnZXRDaGFubmVsKGdldFgoXCIrdS5qb2luKCkrXCIpLCBcIitsK1wiKTtcXG4gICAgICAgIH1cXG4gICAgICBcIjtkKz0xPT09cj9cIn0gXCI6XCJ9fVwiLHRoaXMudXNlckNvZGU9XCJcXG4gICAgICBjb25zdCBcIitvK1wiIHN0YXJ0ID0gXCIrbytcIihcIithK1wiKTtcXG4gICAgICBjb25zdCBcIitvK1wiIGVuZCA9IFwiK28rXCIoXCIraStcIik7XFxuXFxuICAgICAgdm9pZCBtYWluKCkge1xcbiAgICAgICAgXCIrbytcIiBvdXRwdXRMb2MgPSBnZXRPdXRwdXRDb29yZHMoKTtcXG4gICAgICAgIHZlYzQgcmVzdWx0ID0gdmVjNCgwLik7XFxuICAgICAgICBcIitkK1wiXFxuICAgICAgICBzZXRPdXRwdXQocmVzdWx0KTtcXG4gICAgICB9XFxuICAgIFwifSwkaT1mdW5jdGlvbih0LGUsbil7aWYodGhpcy52YXJpYWJsZU5hbWVzPVtcInhcIl0sXCJhdmdcIj09PWUmJm4pdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGNvbXB1dGUgcG9zaXRpb25zIGZvciBhdmVyYWdlIHBvb2wuXCIpO3ZhciByPXQuZmlsdGVyV2lkdGgsbz10LnN0cmlkZUhlaWdodCxhPXQuc3RyaWRlV2lkdGgsaT10LmRpbGF0aW9uSGVpZ2h0LHM9dC5kaWxhdGlvbldpZHRoLHU9dC5lZmZlY3RpdmVGaWx0ZXJIZWlnaHQsYz10LmVmZmVjdGl2ZUZpbHRlcldpZHRoLGw9dC5wYWRJbmZvLnRvcCxoPXQucGFkSW5mby5sZWZ0O3RoaXMub3V0cHV0U2hhcGU9dC5vdXRTaGFwZTt2YXIgZj1cImF2Z1wiPT09ZSxkPVwiMC4wXCI7aWYoZnx8KGQ9XCItMS4wIC8gMWUtMjBcIiksbil0aGlzLnVzZXJDb2RlPVwiXFxuICAgICAgICBjb25zdCBpdmVjMiBzdHJpZGVzID0gaXZlYzIoXCIrbytcIiwgXCIrYStcIik7XFxuICAgICAgICBjb25zdCBpdmVjMiBwYWRzID0gaXZlYzIoXCIrbCtcIiwgXCIraCtcIik7XFxuXFxuICAgICAgICB2b2lkIG1haW4oKSB7XFxuICAgICAgICAgIGl2ZWM0IGNvb3JkcyA9IGdldE91dHB1dENvb3JkcygpO1xcbiAgICAgICAgICBpbnQgYmF0Y2ggPSBjb29yZHNbMF07XFxuICAgICAgICAgIGludCBkID0gY29vcmRzWzNdO1xcblxcbiAgICAgICAgICBpdmVjMiB4UkNDb3JuZXIgPSBjb29yZHMueXogKiBzdHJpZGVzIC0gcGFkcztcXG4gICAgICAgICAgaW50IHhSQ29ybmVyID0geFJDQ29ybmVyLng7XFxuICAgICAgICAgIGludCB4Q0Nvcm5lciA9IHhSQ0Nvcm5lci55O1xcblxcbiAgICAgICAgICAvLyBtYXgvbWluIHgoPywgPywgZCkgdG8gZ2V0IHkoeVIsIHlDLCBkKS5cXG4gICAgICAgICAgLy8gPyA9IHRvIGJlIGRldGVybWluZWRcXG4gICAgICAgICAgZmxvYXQgbWluTWF4VmFsdWUgPSAwLjA7XFxuICAgICAgICAgIGZsb2F0IG1pbk1heFZhbHVlRm91bmQgPSAwLjA7XFxuICAgICAgICAgIGludCBtaW5NYXhQb3NpdGlvbiA9IDA7XFxuICAgICAgICAgIGZsb2F0IGF2Z1ZhbHVlID0gMC4wO1xcblxcbiAgICAgICAgICBmb3IgKGludCB3UiA9IDA7IHdSIDwgXCIrdStcIjtcXG4gICAgICAgICAgICAgIHdSICs9IFwiK2krXCIpIHtcXG4gICAgICAgICAgICBpbnQgeFIgPSB4UkNvcm5lciArIHdSO1xcblxcbiAgICAgICAgICAgIGlmICh4UiA8IDAgfHwgeFIgPj0gXCIrdC5pbkhlaWdodCtcIikge1xcbiAgICAgICAgICAgICAgY29udGludWU7XFxuICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgIGZvciAoaW50IHdDID0gMDsgd0MgPCBcIitjK1wiO1xcbiAgICAgICAgICAgICAgICB3QyArPSBcIitzK1wiKSB7XFxuICAgICAgICAgICAgICBpbnQgeEMgPSB4Q0Nvcm5lciArIHdDO1xcblxcbiAgICAgICAgICAgICAgaWYgKHhDIDwgMCB8fCB4QyA+PSBcIit0LmluV2lkdGgrXCIpIHtcXG4gICAgICAgICAgICAgICAgY29udGludWU7XFxuICAgICAgICAgICAgICB9XFxuXFxuICAgICAgICAgICAgICBmbG9hdCB2YWx1ZSA9IGdldFgoYmF0Y2gsIHhSLCB4QywgZCk7XFxuXFxuICAgICAgICAgICAgICAvLyBJZiBhIG1pbiAvIG1heCB2YWx1ZSBoYXMgYWxyZWFkeSBiZWVuIGZvdW5kLCB1c2UgaXQuIElmIG5vdCxcXG4gICAgICAgICAgICAgIC8vIHVzZSB0aGUgY3VycmVudCB2YWx1ZS5cXG4gICAgICAgICAgICAgIGZsb2F0IGN1cnJNaW5NYXhWYWx1ZSA9IG1peChcXG4gICAgICAgICAgICAgICAgICB2YWx1ZSwgbWluTWF4VmFsdWUsIG1pbk1heFZhbHVlRm91bmQpO1xcbiAgICAgICAgICAgICAgaWYgKHZhbHVlID49IGN1cnJNaW5NYXhWYWx1ZSkge1xcbiAgICAgICAgICAgICAgICBtaW5NYXhWYWx1ZSA9IHZhbHVlO1xcbiAgICAgICAgICAgICAgICBtaW5NYXhWYWx1ZUZvdW5kID0gMS4wO1xcbiAgICAgICAgICAgICAgICBtaW5NYXhQb3NpdGlvbiA9IHdSICogXCIrYytcIiArIHdDO1xcbiAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgfVxcbiAgICAgICAgICBzZXRPdXRwdXQoZmxvYXQobWluTWF4UG9zaXRpb24pKTtcXG4gICAgICAgIH1cXG4gICAgICBcIjtlbHNle3ZhciBwPWUrXCIoXCIrZStcIihcIitlK1wiKG1pbk1heFZhbHVlWzBdLCBtaW5NYXhWYWx1ZVsxXSksIG1pbk1heFZhbHVlWzJdKSwgbWluTWF4VmFsdWVbM10pXCI7XCJhdmdcIj09PWUmJihwPVwiYXZnVmFsdWUgLyBjb3VudFwiKTt2YXIgdj00Kk1hdGguZmxvb3Ioci80KSxtPXIlNCxnPVwiXFxuICAgICAgaWYgKFwiK2YrXCIpIHtcXG4gICAgICAgIGF2Z1ZhbHVlICs9IGRvdCh2YWx1ZXMsIG9uZXMpO1xcbiAgICAgIH0gZWxzZSB7XFxuICAgICAgICBtaW5NYXhWYWx1ZSA9IG1heCh2YWx1ZXMsIG1pbk1heFZhbHVlKTtcXG4gICAgICB9XFxuICAgIFwiO3RoaXMudXNlckNvZGU9XCJcXG4gICAgICBjb25zdCBpdmVjMiBzdHJpZGVzID0gaXZlYzIoXCIrbytcIiwgXCIrYStcIik7XFxuICAgICAgY29uc3QgaXZlYzIgcGFkcyA9IGl2ZWMyKFwiK2wrXCIsIFwiK2grXCIpO1xcbiAgICAgIGNvbnN0IGZsb2F0IGluaXRpYWxpemF0aW9uVmFsdWUgPSBcIitkK1wiO1xcbiAgICAgIGNvbnN0IHZlYzQgb25lcyA9IHZlYzQoMS4wLCAxLjAsIDEuMCwgMS4wKTtcXG5cXG4gICAgICBmbG9hdCBjb3VudCA9IDAuMDtcXG5cXG4gICAgICBmbG9hdCBnZXRWYWx1ZShpbnQgYmF0Y2gsIGludCB4UiwgaW50IHhDLCBpbnQgZCkge1xcbiAgICAgICAgaWYgKHhDIDwgMCB8fCB4QyA+PSBcIit0LmluV2lkdGgrXCIpIHtcXG4gICAgICAgICAgcmV0dXJuIGluaXRpYWxpemF0aW9uVmFsdWU7XFxuICAgICAgICB9XFxuICAgICAgICBjb3VudCArPSAxLjA7XFxuICAgICAgICByZXR1cm4gZ2V0WChiYXRjaCwgeFIsIHhDLCBkKTtcXG4gICAgICB9XFxuXFxuICAgICAgdm9pZCBtYWluKCkge1xcbiAgICAgICAgaXZlYzQgY29vcmRzID0gZ2V0T3V0cHV0Q29vcmRzKCk7XFxuICAgICAgICBpbnQgYmF0Y2ggPSBjb29yZHNbMF07XFxuICAgICAgICBpbnQgZCA9IGNvb3Jkc1szXTtcXG5cXG4gICAgICAgIGl2ZWMyIHhSQ0Nvcm5lciA9IGNvb3Jkcy55eiAqIHN0cmlkZXMgLSBwYWRzO1xcbiAgICAgICAgaW50IHhSQ29ybmVyID0geFJDQ29ybmVyLng7XFxuICAgICAgICBpbnQgeENDb3JuZXIgPSB4UkNDb3JuZXIueTtcXG5cXG4gICAgICAgIC8vIG1heC9taW4geCg/LCA/LCBkKSB0byBnZXQgeSh5UiwgeUMsIGQpLlxcbiAgICAgICAgLy8gPyA9IHRvIGJlIGRldGVybWluZWRcXG4gICAgICAgIHZlYzQgbWluTWF4VmFsdWUgPSB2ZWM0KFwiK2QrXCIpO1xcbiAgICAgICAgZmxvYXQgYXZnVmFsdWUgPSAwLjA7XFxuICAgICAgICBjb3VudCA9IDAuMDtcXG5cXG4gICAgICAgIGZvciAoaW50IHdSID0gMDsgd1IgPCBcIit1K1wiO1xcbiAgICAgICAgICAgIHdSICs9IFwiK2krXCIpIHtcXG4gICAgICAgICAgaW50IHhSID0geFJDb3JuZXIgKyB3UjtcXG5cXG4gICAgICAgICAgaWYgKHhSIDwgMCB8fCB4UiA+PSBcIit0LmluSGVpZ2h0K1wiKSB7XFxuICAgICAgICAgICAgY29udGludWU7XFxuICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgZm9yIChpbnQgd0MgPSAwOyB3QyA8IFwiK3YrXCI7IHdDICs9IDQpIHtcXG4gICAgICAgICAgICBpbnQgeEMgPSB4Q0Nvcm5lciArIHdDICogXCIrcytcIjtcXG5cXG4gICAgICAgICAgICB2ZWM0IHZhbHVlcyA9IHZlYzQoXFxuICAgICAgICAgICAgICBnZXRWYWx1ZShiYXRjaCwgeFIsIHhDLCBkKSxcXG4gICAgICAgICAgICAgIGdldFZhbHVlKGJhdGNoLCB4UiwgeEMgKyBcIitzK1wiLCBkKSxcXG4gICAgICAgICAgICAgIGdldFZhbHVlKGJhdGNoLCB4UiwgeEMgKyAyICogXCIrcytcIiwgZCksXFxuICAgICAgICAgICAgICBnZXRWYWx1ZShiYXRjaCwgeFIsIHhDICsgMyAqIFwiK3MrXCIsIGQpXFxuICAgICAgICAgICAgKTtcXG5cXG4gICAgICAgICAgICBcIitnK1wiXFxuICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgaW50IHhDID0geENDb3JuZXIgKyBcIit2K1wiO1xcbiAgICAgICAgICBpZiAoXCIrKDE9PT1tKStcIikge1xcbiAgICAgICAgICAgIHZlYzQgdmFsdWVzID0gdmVjNChcXG4gICAgICAgICAgICAgIGdldFZhbHVlKGJhdGNoLCB4UiwgeEMsIGQpLFxcbiAgICAgICAgICAgICAgaW5pdGlhbGl6YXRpb25WYWx1ZSxcXG4gICAgICAgICAgICAgIGluaXRpYWxpemF0aW9uVmFsdWUsXFxuICAgICAgICAgICAgICBpbml0aWFsaXphdGlvblZhbHVlXFxuICAgICAgICAgICAgKTtcXG5cXG4gICAgICAgICAgICBcIitnK1wiXFxuICAgICAgICAgIH0gZWxzZSBpZiAoXCIrKDI9PT1tKStcIikge1xcbiAgICAgICAgICAgIHZlYzQgdmFsdWVzID0gdmVjNChcXG4gICAgICAgICAgICAgIGdldFZhbHVlKGJhdGNoLCB4UiwgeEMsIGQpLFxcbiAgICAgICAgICAgICAgZ2V0VmFsdWUoYmF0Y2gsIHhSLCB4QyArIFwiK3MrXCIsIGQpLFxcbiAgICAgICAgICAgICAgaW5pdGlhbGl6YXRpb25WYWx1ZSxcXG4gICAgICAgICAgICAgIGluaXRpYWxpemF0aW9uVmFsdWVcXG4gICAgICAgICAgICApO1xcblxcbiAgICAgICAgICAgIFwiK2crXCJcXG4gICAgICAgICAgfSBlbHNlIGlmIChcIisoMz09PW0pK1wiKSB7XFxuICAgICAgICAgICAgdmVjNCB2YWx1ZXMgPSB2ZWM0KFxcbiAgICAgICAgICAgICAgZ2V0VmFsdWUoYmF0Y2gsIHhSLCB4QywgZCksXFxuICAgICAgICAgICAgICBnZXRWYWx1ZShiYXRjaCwgeFIsIHhDICsgXCIrcytcIiwgZCksXFxuICAgICAgICAgICAgICBnZXRWYWx1ZShiYXRjaCwgeFIsIHhDICsgMiAqIFwiK3MrXCIsIGQpLFxcbiAgICAgICAgICAgICAgaW5pdGlhbGl6YXRpb25WYWx1ZVxcbiAgICAgICAgICAgICk7XFxuXFxuICAgICAgICAgICAgXCIrZytcIlxcbiAgICAgICAgICB9XFxuICAgICAgICB9XFxuICAgICAgICBzZXRPdXRwdXQoXCIrcCtcIik7XFxuICAgICAgfVxcbiAgICBcIn19LFFpPWZ1bmN0aW9uKHQsZSxuKXtpZih0aGlzLnZhcmlhYmxlTmFtZXM9W1wieFwiXSxcImF2Z1wiPT09ZSYmbil0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgY29tcHV0ZSBwb3NpdGlvbnMgZm9yIGF2ZXJhZ2UgcG9vbC5cIik7dmFyIHI9dC5maWx0ZXJXaWR0aCxvPXQuc3RyaWRlRGVwdGgsYT10LnN0cmlkZUhlaWdodCxpPXQuc3RyaWRlV2lkdGgscz10LmRpbGF0aW9uRGVwdGgsdT10LmRpbGF0aW9uSGVpZ2h0LGM9dC5kaWxhdGlvbldpZHRoLGw9dC5lZmZlY3RpdmVGaWx0ZXJEZXB0aCxoPXQuZWZmZWN0aXZlRmlsdGVySGVpZ2h0LGY9dC5lZmZlY3RpdmVGaWx0ZXJXaWR0aCxkPXQucGFkSW5mby5mcm9udCxwPXQucGFkSW5mby50b3Asdj10LnBhZEluZm8ubGVmdDt0aGlzLm91dHB1dFNoYXBlPXQub3V0U2hhcGU7dmFyIG09XCJhdmdcIj09PWUsZz1cIjAuMFwiO2lmKG18fChnPVwiLTEuMCAvIDFlLTIwXCIpLG4pdGhpcy51c2VyQ29kZT1cIlxcbiAgICAgICAgY29uc3QgaXZlYzMgc3RyaWRlcyA9XFxuICAgICAgICAgICAgaXZlYzMoXCIrbytcIiwgXCIrYStcIiwgXCIraStcIik7XFxuICAgICAgICBjb25zdCBpdmVjMyBwYWRzID0gaXZlYzMoXCIrZCtcIiwgXCIrcCtcIiwgXCIrditcIik7XFxuXFxuICAgICAgICB2b2lkIG1haW4oKSB7XFxuICAgICAgICAgIGl2ZWM1IGNvb3JkcyA9IGdldE91dHB1dENvb3JkcygpO1xcbiAgICAgICAgICBpbnQgYmF0Y2ggPSBjb29yZHMueDtcXG4gICAgICAgICAgaW50IGNoID0gY29vcmRzLnU7XFxuXFxuICAgICAgICAgIGl2ZWMzIHhDb3JuZXIgPSBpdmVjMyhjb29yZHMueSwgY29vcmRzLnosIGNvb3Jkcy53KSAqIHN0cmlkZXMgLSBwYWRzO1xcbiAgICAgICAgICBpbnQgeERDb3JuZXIgPSB4Q29ybmVyLng7XFxuICAgICAgICAgIGludCB4UkNvcm5lciA9IHhDb3JuZXIueTtcXG4gICAgICAgICAgaW50IHhDQ29ybmVyID0geENvcm5lci56O1xcblxcbiAgICAgICAgICAvLyBtYXgvbWluIHgoPywgPywgPywgY2gpIHRvIGdldCB5KHlELCB5UiwgeUMsIGNoKS5cXG4gICAgICAgICAgLy8gPyA9IHRvIGJlIGRldGVybWluZWRcXG4gICAgICAgICAgZmxvYXQgbWluTWF4VmFsdWUgPSAwLjA7XFxuICAgICAgICAgIGZsb2F0IG1pbk1heFZhbHVlRm91bmQgPSAwLjA7XFxuICAgICAgICAgIGludCBtaW5NYXhQb3NpdGlvbiA9IDA7XFxuXFxuICAgICAgICAgIGZvciAoaW50IHdEID0gMDsgd0QgPCBcIitsK1wiO1xcbiAgICAgICAgICAgICAgd0QgKz0gXCIrcytcIikge1xcbiAgICAgICAgICAgIGludCB4RCA9IHhEQ29ybmVyICsgd0Q7XFxuXFxuICAgICAgICAgICAgaWYgKHhEIDwgMCB8fCB4RCA+PSBcIit0LmluRGVwdGgrXCIpIHtcXG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xcbiAgICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgICBmb3IgKGludCB3UiA9IDA7IHdSIDwgXCIraCtcIjtcXG4gICAgICAgICAgICAgICAgd1IgKz0gXCIrdStcIikge1xcbiAgICAgICAgICAgICAgaW50IHhSID0geFJDb3JuZXIgKyB3UjtcXG5cXG4gICAgICAgICAgICAgIGlmICh4UiA8IDAgfHwgeFIgPj0gXCIrdC5pbkhlaWdodCtcIikge1xcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcXG4gICAgICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgICAgIGZvciAoaW50IHdDID0gMDsgd0MgPCBcIitmK1wiO1xcbiAgICAgICAgICAgICAgICAgIHdDICs9IFwiK2MrXCIpIHtcXG4gICAgICAgICAgICAgICAgaW50IHhDID0geENDb3JuZXIgKyB3QztcXG5cXG4gICAgICAgICAgICAgICAgaWYgKHhDIDwgMCB8fCB4QyA+PSBcIit0LmluV2lkdGgrXCIpIHtcXG4gICAgICAgICAgICAgICAgICBjb250aW51ZTtcXG4gICAgICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgICAgICBmbG9hdCB2YWx1ZSA9IGdldFgoYmF0Y2gsIHhELCB4UiwgeEMsIGNoKTtcXG5cXG4gICAgICAgICAgICAgICAgLy8gSWYgYSBtaW4gLyBtYXggdmFsdWUgaGFzIGFscmVhZHkgYmVlbiBmb3VuZCwgdXNlIGl0LiBJZiBub3QsXFxuICAgICAgICAgICAgICAgIC8vIHVzZSB0aGUgY3VycmVudCB2YWx1ZS5cXG4gICAgICAgICAgICAgICAgZmxvYXQgY3Vyck1pbk1heFZhbHVlID0gbWl4KFxcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUsIG1pbk1heFZhbHVlLCBtaW5NYXhWYWx1ZUZvdW5kKTtcXG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlID49IGN1cnJNaW5NYXhWYWx1ZSkge1xcbiAgICAgICAgICAgICAgICAgIG1pbk1heFZhbHVlID0gdmFsdWU7XFxuICAgICAgICAgICAgICAgICAgbWluTWF4VmFsdWVGb3VuZCA9IDEuMDtcXG4gICAgICAgICAgICAgICAgICBtaW5NYXhQb3NpdGlvbiA9XFxuICAgICAgICAgICAgICAgICAgICAgIHdEICogXCIraCtcIiAqIFwiK2YrXCIgK1xcbiAgICAgICAgICAgICAgICAgICAgICB3UiAqIFwiK2YrXCIgKyB3Qzs7XFxuICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICB9XFxuICAgICAgICAgIH1cXG4gICAgICAgICAgc2V0T3V0cHV0KGZsb2F0KG1pbk1heFBvc2l0aW9uKSk7XFxuICAgICAgICB9XFxuICAgICAgXCI7ZWxzZXt2YXIgeT1lK1wiKFwiK2UrXCIoXCIrZStcIihtaW5NYXhWYWx1ZVswXSwgbWluTWF4VmFsdWVbMV0pLCBtaW5NYXhWYWx1ZVsyXSksIG1pbk1heFZhbHVlWzNdKVwiO1wiYXZnXCI9PT1lJiYoeT1cImF2Z1ZhbHVlIC8gY291bnRcIik7dmFyIHg9NCpNYXRoLmZsb29yKHIvNCksYj1yJTQsdz1cIlxcbiAgICAgIGlmIChcIittK1wiKSB7XFxuICAgICAgICBhdmdWYWx1ZSArPSBkb3QodmFsdWVzLCBvbmVzKTtcXG4gICAgICB9IGVsc2Uge1xcbiAgICAgICAgbWluTWF4VmFsdWUgPSBtYXgodmFsdWVzLCBtaW5NYXhWYWx1ZSk7XFxuICAgICAgfVxcbiAgICBcIjt0aGlzLnVzZXJDb2RlPVwiXFxuICAgICAgY29uc3QgaXZlYzMgc3RyaWRlcyA9XFxuICAgICAgICBpdmVjMyhcIitvK1wiLCBcIithK1wiLCBcIitpK1wiKTtcXG4gICAgICBjb25zdCBpdmVjMyBwYWRzID0gaXZlYzMoXCIrZCtcIiwgXCIrcCtcIiwgXCIrditcIik7XFxuICAgICAgY29uc3QgZmxvYXQgaW5pdGlhbGl6YXRpb25WYWx1ZSA9IFwiK2crXCI7XFxuICAgICAgY29uc3QgdmVjNCBvbmVzID0gdmVjNCgxLjAsIDEuMCwgMS4wLCAxLjApO1xcblxcbiAgICAgIGZsb2F0IGNvdW50ID0gMC4wO1xcblxcbiAgICAgIGZsb2F0IGdldFZhbHVlKGludCBiYXRjaCwgaW50IHhELCBpbnQgeFIsIGludCB4QywgaW50IGNoKSB7XFxuICAgICAgICBpZiAoeEMgPCAwIHx8IHhDID49IFwiK3QuaW5XaWR0aCtcIikge1xcbiAgICAgICAgICByZXR1cm4gaW5pdGlhbGl6YXRpb25WYWx1ZTtcXG4gICAgICAgIH1cXG4gICAgICAgIGNvdW50ICs9IDEuMDtcXG4gICAgICAgIHJldHVybiBnZXRYKGJhdGNoLCB4RCwgeFIsIHhDLCBjaCk7XFxuICAgICAgfVxcblxcbiAgICAgIHZvaWQgbWFpbigpIHtcXG4gICAgICAgIGl2ZWM1IGNvb3JkcyA9IGdldE91dHB1dENvb3JkcygpO1xcbiAgICAgICAgaW50IGJhdGNoID0gY29vcmRzLng7XFxuICAgICAgICBpbnQgY2ggPSBjb29yZHMudTtcXG5cXG4gICAgICAgIGl2ZWMzIHhDb3JuZXIgPSBpdmVjMyhjb29yZHMueSwgY29vcmRzLnosIGNvb3Jkcy53KSAqIHN0cmlkZXMgLSBwYWRzO1xcbiAgICAgICAgaW50IHhEQ29ybmVyID0geENvcm5lci54O1xcbiAgICAgICAgaW50IHhSQ29ybmVyID0geENvcm5lci55O1xcbiAgICAgICAgaW50IHhDQ29ybmVyID0geENvcm5lci56O1xcblxcbiAgICAgICAgLy8gbWF4L21pbiB4KD8sID8sID8sIGQpIHRvIGdldCB5KHlELCB5UiwgeUMsIGNoKS5cXG4gICAgICAgIC8vID8gPSB0byBiZSBkZXRlcm1pbmVkXFxuICAgICAgICB2ZWM0IG1pbk1heFZhbHVlID0gdmVjNChcIitnK1wiKTtcXG4gICAgICAgIGZsb2F0IGF2Z1ZhbHVlID0gMC4wO1xcbiAgICAgICAgY291bnQgPSAwLjA7XFxuXFxuICAgICAgICBmb3IgKGludCB3RCA9IDA7IHdEIDwgXCIrbCtcIjtcXG4gICAgICAgICAgICB3RCArPSBcIitzK1wiKSB7XFxuICAgICAgICAgIGludCB4RCA9IHhEQ29ybmVyICsgd0Q7XFxuXFxuICAgICAgICAgIGlmICh4RCA8IDAgfHwgeEQgPj0gXCIrdC5pbkRlcHRoK1wiKSB7XFxuICAgICAgICAgICAgY29udGludWU7XFxuICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgZm9yIChpbnQgd1IgPSAwOyB3UiA8IFwiK2grXCI7XFxuICAgICAgICAgICAgd1IgKz0gXCIrdStcIikge1xcbiAgICAgICAgICAgIGludCB4UiA9IHhSQ29ybmVyICsgd1I7XFxuXFxuICAgICAgICAgICAgaWYgKHhSIDwgMCB8fCB4UiA+PSBcIit0LmluSGVpZ2h0K1wiKSB7XFxuICAgICAgICAgICAgICBjb250aW51ZTtcXG4gICAgICAgICAgICB9XFxuXFxuICAgICAgICAgICAgZm9yIChpbnQgd0MgPSAwOyB3QyA8IFwiK3grXCI7IHdDICs9IDQpIHtcXG4gICAgICAgICAgICAgIGludCB4QyA9IHhDQ29ybmVyICsgd0MgKiBcIitjK1wiO1xcblxcbiAgICAgICAgICAgICAgdmVjNCB2YWx1ZXMgPSB2ZWM0KFxcbiAgICAgICAgICAgICAgICBnZXRWYWx1ZShiYXRjaCwgeEQsIHhSLCB4QywgY2gpLFxcbiAgICAgICAgICAgICAgICBnZXRWYWx1ZShiYXRjaCwgeEQsIHhSLCB4QyArIFwiK2MrXCIsIGNoKSxcXG4gICAgICAgICAgICAgICAgZ2V0VmFsdWUoYmF0Y2gsIHhELCB4UiwgeEMgKyAyICogXCIrYytcIiwgY2gpLFxcbiAgICAgICAgICAgICAgICBnZXRWYWx1ZShiYXRjaCwgeEQsIHhSLCB4QyArIDMgKiBcIitjK1wiLCBjaClcXG4gICAgICAgICAgICAgICk7XFxuXFxuICAgICAgICAgICAgICBcIit3K1wiXFxuICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgIGludCB4QyA9IHhDQ29ybmVyICsgXCIreCtcIjtcXG4gICAgICAgICAgICBpZiAoXCIrKDE9PT1iKStcIikge1xcbiAgICAgICAgICAgICAgdmVjNCB2YWx1ZXMgPSB2ZWM0KFxcbiAgICAgICAgICAgICAgICBnZXRWYWx1ZShiYXRjaCwgeEQsIHhSLCB4QywgY2gpLFxcbiAgICAgICAgICAgICAgICBpbml0aWFsaXphdGlvblZhbHVlLFxcbiAgICAgICAgICAgICAgICBpbml0aWFsaXphdGlvblZhbHVlLFxcbiAgICAgICAgICAgICAgICBpbml0aWFsaXphdGlvblZhbHVlXFxuICAgICAgICAgICAgICApO1xcblxcbiAgICAgICAgICAgICAgXCIrdytcIlxcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoXCIrKDI9PT1iKStcIikge1xcbiAgICAgICAgICAgICAgdmVjNCB2YWx1ZXMgPSB2ZWM0KFxcbiAgICAgICAgICAgICAgICBnZXRWYWx1ZShiYXRjaCwgeEQsIHhSLCB4QywgY2gpLFxcbiAgICAgICAgICAgICAgICBnZXRWYWx1ZShiYXRjaCwgeEQsIHhSLCB4QyArIFwiK2MrXCIsIGNoKSxcXG4gICAgICAgICAgICAgICAgaW5pdGlhbGl6YXRpb25WYWx1ZSxcXG4gICAgICAgICAgICAgICAgaW5pdGlhbGl6YXRpb25WYWx1ZVxcbiAgICAgICAgICAgICAgKTtcXG5cXG4gICAgICAgICAgICAgIFwiK3crXCJcXG4gICAgICAgICAgICB9IGVsc2UgaWYgKFwiKygzPT09YikrXCIpIHtcXG4gICAgICAgICAgICAgIHZlYzQgdmFsdWVzID0gdmVjNChcXG4gICAgICAgICAgICAgICAgZ2V0VmFsdWUoYmF0Y2gsIHhELCB4UiwgeEMsIGNoKSxcXG4gICAgICAgICAgICAgICAgZ2V0VmFsdWUoYmF0Y2gsIHhELCB4UiwgeEMgKyBcIitjK1wiLCBjaCksXFxuICAgICAgICAgICAgICAgIGdldFZhbHVlKGJhdGNoLCB4RCwgeFIsIHhDICsgMiAqIFwiK2MrXCIsIGNoKSxcXG4gICAgICAgICAgICAgICAgaW5pdGlhbGl6YXRpb25WYWx1ZVxcbiAgICAgICAgICAgICAgKTtcXG5cXG4gICAgICAgICAgICAgIFwiK3crXCJcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgIH1cXG4gICAgICAgICAgc2V0T3V0cHV0KFwiK3krXCIpO1xcbiAgICAgICAgfVxcbiAgICAgIH1cXG4gICAgXCJ9fSxKaT1mdW5jdGlvbih0LGUpe3RoaXMudmFyaWFibGVOYW1lcz1bXCJ4XCJdO3ZhciBuPXQud2luZG93U2l6ZSxyPXQuYmF0Y2hTaXplLG89dC5pblNpemUsYT1NYXRoLmNlaWwoby9uKTt0aGlzLm91dHB1dFNoYXBlPVtyLGFdO3ZhciBpPVwiMC4wXCIscz1cIlwiO1wicHJvZFwiPT09ZT9pPVwiMS4wXCI6XCJtaW5cIj09PWU/KGk9XCIxLjAgLyAxZS0yMFwiLHM9XCJtaW5cIik6XCJtYXhcIj09PWUmJihpPVwiLTEuMCAvIDFlLTIwXCIscz1cIm1heFwiKTt2YXIgdT1lK1wiKFwiK2UrXCIoXCIrZStcIihtaW5NYXhWYWx1ZVswXSwgbWluTWF4VmFsdWVbMV0pLCBtaW5NYXhWYWx1ZVsyXSksIG1pbk1heFZhbHVlWzNdKVwiO1wic3VtXCI9PT1lP3U9XCJzdW1WYWx1ZVwiOlwicHJvZFwiPT09ZT91PVwicHJvZFZhbHVlXCI6XCJhbGxcIj09PWU/dT1cImFsbFZhbHVlXCI6XCJhbnlcIj09PWUmJih1PVwiYW55VmFsdWVcIik7dmFyIGM9NCpNYXRoLmZsb29yKG4vNCksbD1uJTQsaD1cIlxcbiAgICAgIGlmIChcIisoXCJzdW1cIj09PWUpK1wiKSB7XFxuICAgICAgICBzdW1WYWx1ZSArPSBkb3QodmFsdWVzLCBvbmVzKTtcXG4gICAgICB9IGVsc2UgaWYgKFwiKyhcInByb2RcIj09PWUpK1wiKSB7XFxuICAgICAgICB2ZWMyIHRtcCA9IHZlYzIodmFsdWVzWzBdLCB2YWx1ZXNbMV0pICogdmVjMih2YWx1ZXNbMl0sIHZhbHVlc1szXSk7XFxuICAgICAgICBwcm9kVmFsdWUgKj0gdG1wWzBdICogdG1wWzFdO1xcbiAgICAgIH0gZWxzZSB7XFxuICAgICAgICBtaW5NYXhWYWx1ZSA9IFwiK3MrXCIodmFsdWVzLCBtaW5NYXhWYWx1ZSk7XFxuICAgICAgfVxcbiAgICBcIixmPVwidmVjNFwiO1wiYWxsXCI9PT1lPyhpPVwiMS4wXCIsaD1cIlxcbiAgICAgICAgYm9vbCByZWR1Y2VkQWxsVmFsdWUgPSBhbGwodmFsdWVzKTtcXG4gICAgICAgIGZsb2F0IGZsb2F0ZWRSZWR1Y2VkQWxsVmFsdWUgPSBmbG9hdChyZWR1Y2VkQWxsVmFsdWUpO1xcbiAgICAgICAgYWxsVmFsdWUgPSBmbG9hdChhbGxWYWx1ZSA+PSAxLjAgJiYgZmxvYXRlZFJlZHVjZWRBbGxWYWx1ZSA+PSAxLjApO1xcbiAgICAgIFwiLGY9XCJidmVjNFwiKTpcImFueVwiPT09ZSYmKGk9XCIwLjBcIixoPVwiXFxuICAgICAgICBib29sIHJlZHVjZWRBbnlWYWx1ZSA9IGFueSh2YWx1ZXMpO1xcbiAgICAgICAgZmxvYXQgZmxvYXRlZFJlZHVjZWRBbnlWYWx1ZSA9IGZsb2F0KHJlZHVjZWRBbnlWYWx1ZSk7XFxuICAgICAgICBhbnlWYWx1ZSA9IGZsb2F0KGFueVZhbHVlID49IDEuMCB8fCBmbG9hdGVkUmVkdWNlZEFueVZhbHVlID49IDEuMCk7XFxuICAgICAgXCIsZj1cImJ2ZWM0XCIpO3ZhciBkPVwiXCI7byVuPjAmJihkPVwiXFxuICAgICAgICBpZiAoaW5JZHggPCAwIHx8IGluSWR4ID49IFwiK28rXCIpIHtcXG4gICAgICAgICAgcmV0dXJuIGluaXRpYWxpemF0aW9uVmFsdWU7XFxuICAgICAgICB9XFxuICAgICAgXCIpLHRoaXMudXNlckNvZGU9XCJcXG4gICAgICBjb25zdCBmbG9hdCBpbml0aWFsaXphdGlvblZhbHVlID0gXCIraStcIjtcXG4gICAgICBjb25zdCB2ZWM0IG9uZXMgPSB2ZWM0KDEuMCwgMS4wLCAxLjAsIDEuMCk7XFxuXFxuICAgICAgZmxvYXQgZ2V0VmFsdWUoaW50IGJhdGNoLCBpbnQgaW5JZHgpIHtcXG4gICAgICAgIFwiK2QrXCJcXG4gICAgICAgIHJldHVybiBnZXRYKGJhdGNoLCBpbklkeCk7XFxuICAgICAgfVxcblxcbiAgICAgIHZvaWQgbWFpbigpIHtcXG4gICAgICAgIGl2ZWMyIGNvb3JkcyA9IGdldE91dHB1dENvb3JkcygpO1xcbiAgICAgICAgaW50IGJhdGNoID0gY29vcmRzWzBdO1xcbiAgICAgICAgaW50IG91dElkeCA9IGNvb3Jkc1sxXTtcXG4gICAgICAgIGludCBpbk9mZnNldCA9IG91dElkeCAqIFwiK24rXCI7XFxuXFxuICAgICAgICB2ZWM0IG1pbk1heFZhbHVlID0gdmVjNChcIitpK1wiKTtcXG4gICAgICAgIGZsb2F0IHByb2RWYWx1ZSA9IDEuMDtcXG4gICAgICAgIGZsb2F0IHN1bVZhbHVlID0gMC4wO1xcbiAgICAgICAgZmxvYXQgYWxsVmFsdWUgPSAxLjA7XFxuICAgICAgICBmbG9hdCBhbnlWYWx1ZSA9IDAuMDtcXG5cXG4gICAgICAgIGZvciAoaW50IGkgPSAwOyBpIDwgXCIrYytcIjsgaSArPSA0KSB7XFxuICAgICAgICAgIGludCBpbklkeCA9IGluT2Zmc2V0ICsgaTtcXG4gICAgICAgICAgXCIrZitcIiB2YWx1ZXMgPSBcIitmK1wiKFxcbiAgICAgICAgICAgIGdldFZhbHVlKGJhdGNoLCBpbklkeCksXFxuICAgICAgICAgICAgZ2V0VmFsdWUoYmF0Y2gsIGluSWR4ICsgMSksXFxuICAgICAgICAgICAgZ2V0VmFsdWUoYmF0Y2gsIGluSWR4ICsgMiksXFxuICAgICAgICAgICAgZ2V0VmFsdWUoYmF0Y2gsIGluSWR4ICsgMylcXG4gICAgICAgICAgKTtcXG5cXG4gICAgICAgICAgXCIraCtcIlxcbiAgICAgICAgfVxcblxcbiAgICAgICAgaW50IGluSWR4ID0gaW5PZmZzZXQgKyBcIitjK1wiO1xcbiAgICAgICAgaWYgKFwiKygxPT09bCkrXCIpIHtcXG4gICAgICAgICAgXCIrZitcIiB2YWx1ZXMgPSBcIitmK1wiKFxcbiAgICAgICAgICAgIGdldFZhbHVlKGJhdGNoLCBpbklkeCksXFxuICAgICAgICAgICAgaW5pdGlhbGl6YXRpb25WYWx1ZSxcXG4gICAgICAgICAgICBpbml0aWFsaXphdGlvblZhbHVlLFxcbiAgICAgICAgICAgIGluaXRpYWxpemF0aW9uVmFsdWVcXG4gICAgICAgICAgKTtcXG5cXG4gICAgICAgICAgXCIraCtcIlxcbiAgICAgICAgfSBlbHNlIGlmIChcIisoMj09PWwpK1wiKSB7XFxuICAgICAgICAgIFwiK2YrXCIgdmFsdWVzID0gXCIrZitcIihcXG4gICAgICAgICAgICBnZXRWYWx1ZShiYXRjaCwgaW5JZHgpLFxcbiAgICAgICAgICAgIGdldFZhbHVlKGJhdGNoLCBpbklkeCArIDEpLFxcbiAgICAgICAgICAgIGluaXRpYWxpemF0aW9uVmFsdWUsXFxuICAgICAgICAgICAgaW5pdGlhbGl6YXRpb25WYWx1ZVxcbiAgICAgICAgICApO1xcblxcbiAgICAgICAgICBcIitoK1wiXFxuICAgICAgICB9IGVsc2UgaWYgKFwiKygzPT09bCkrXCIpIHtcXG4gICAgICAgICAgXCIrZitcIiB2YWx1ZXMgPSBcIitmK1wiKFxcbiAgICAgICAgICAgIGdldFZhbHVlKGJhdGNoLCBpbklkeCksXFxuICAgICAgICAgICAgZ2V0VmFsdWUoYmF0Y2gsIGluSWR4ICsgMSksXFxuICAgICAgICAgICAgZ2V0VmFsdWUoYmF0Y2gsIGluSWR4ICsgMiksXFxuICAgICAgICAgICAgaW5pdGlhbGl6YXRpb25WYWx1ZVxcbiAgICAgICAgICApO1xcblxcbiAgICAgICAgICBcIitoK1wiXFxuICAgICAgICB9XFxuICAgICAgICBzZXRPdXRwdXQoXCIrdStcIik7XFxuICAgICAgfVxcbiAgICBcIn0sWmk9ZnVuY3Rpb24odCxlKXt0aGlzLnZhcmlhYmxlTmFtZXM9W1wiQVwiXSx0aGlzLnBhY2tlZElucHV0cz0hMCx0aGlzLnBhY2tlZE91dHB1dD0hMCx0aGlzLm91dHB1dFNoYXBlPXQ7Zm9yKHZhciBuPVwiXCIscj0wO3I8NDtyKyspe3ZhciBvPVwidGhpc1JDID0gcmM7XCI7ciUyPT0xJiYobys9XCJ0aGlzUkMueiArPSAxO1wiKSxyPjEmJihvKz1cInRoaXNSQy55ICs9IDE7XCIpLG4rPVwiXFxuICAgICAgICBcIitvK1wiXFxuICAgICAgICBcIisocj4wP1wiaWYodGhpc1JDLnkgPCByb3dzICYmIHRoaXNSQy56IDwgY29scyl7XCI6XCJcIikrXCJcXG4gICAgICAgICAgaW50IGZsYXRJbmRleCA9IGdldEZsYXRJbmRleCh0aGlzUkMpO1xcblxcbiAgICAgICAgICBpdmVjMyBpbnB1dFJDID0gaW5wdXRDb29yZHNGcm9tUmVzaGFwZWRPdXRDb29yZHMoZmxhdEluZGV4KTtcXG4gICAgICAgICAgdmVjMiBpbnB1dFJDSW5uZXJEaW1zID0gdmVjMihmbG9hdChpbnB1dFJDLnkpLGZsb2F0KGlucHV0UkMueikpO1xcblxcbiAgICAgICAgICByZXN1bHRbXCIrcitcIl0gPVxcbiAgICAgICAgICAgIGdldENoYW5uZWwoZ2V0QShpbnB1dFJDLngsIGlucHV0UkMueSwgaW5wdXRSQy56KSwgaW5wdXRSQ0lubmVyRGltcyk7XFxuICAgICAgICBcIisocj4wP1wifVwiOlwiXCIpK1wiXFxuICAgICAgXCJ9dGhpcy51c2VyQ29kZT1cIlxcbiAgICAgIFxcbiAgICBpdmVjMyBpbnB1dENvb3Jkc0Zyb21SZXNoYXBlZE91dENvb3JkcyhpbnQgaW5kZXgpIHtcXG4gICAgICBcIitjYShbXCJyXCIsXCJjXCIsXCJkXCJdLGUpK1wiXFxuICAgICAgcmV0dXJuIGl2ZWMzKHIsIGMsIGQpO1xcbiAgICB9XFxuICBcXG4gICAgICBcIitsYSh0KStcIlxcblxcbiAgICAgIHZvaWQgbWFpbigpIHtcXG4gICAgICAgIGl2ZWMzIHJjID0gZ2V0T3V0cHV0Q29vcmRzKCk7XFxuXFxuICAgICAgICB2ZWM0IHJlc3VsdCA9IHZlYzQoMC4pO1xcblxcbiAgICAgICAgaXZlYzMgdGhpc1JDO1xcbiAgICAgICAgaW50IHJvd3MgPSBcIit0WzFdK1wiO1xcbiAgICAgICAgaW50IGNvbHMgPSBcIit0WzJdK1wiO1xcblxcbiAgICAgICAgXCIrbitcIlxcblxcbiAgICAgICAgc2V0T3V0cHV0KHJlc3VsdCk7XFxuICAgICAgfVxcbiAgICBcIn07dmFyIHRzPWZ1bmN0aW9uKHQsZSxuKXt0aGlzLnZhcmlhYmxlTmFtZXM9W1wiZHlcIl0sdGhpcy5vdXRwdXRTaGFwZT1bXSx0aGlzLm91dHB1dFNoYXBlPWUuc2hhcGU7dmFyIHI9ZS5zaGFwZSxvPXJbMV0sYT1yWzJdLGk9dC5zaGFwZSxzPWlbMV0sdT1pWzJdLGM9W24mJnM+MT9vLTE6byxuJiZ1PjE/YS0xOmFdLGw9W24mJnM+MT9zLTE6cyxuJiZ1PjE/dS0xOnVdLGg9Y1swXS9sWzBdLGY9Y1sxXS9sWzFdLGQ9MS9oLHA9MS9mLHY9MipNYXRoLmNlaWwoZCkrMixtPTIqTWF0aC5jZWlsKHApKzI7dGhpcy51c2VyQ29kZT1cIlxcbiAgICAgIHZvaWQgbWFpbigpIHtcXG4gICAgICAgIGl2ZWM0IGNvb3JkcyA9IGdldE91dHB1dENvb3JkcygpO1xcbiAgICAgICAgaW50IGIgPSBjb29yZHNbMF07XFxuICAgICAgICBpbnQgZCA9IGNvb3Jkc1szXTtcXG4gICAgICAgIGludCByID0gY29vcmRzWzFdO1xcbiAgICAgICAgaW50IGMgPSBjb29yZHNbMl07XFxuXFxuICAgICAgICBmbG9hdCBhY2N1bXVsYXRvciA9IDAuMDtcXG5cXG4gICAgICAgIGNvbnN0IGZsb2F0IGhlaWdodFNjYWxlID0gZmxvYXQoXCIraCtcIik7XFxuICAgICAgICBjb25zdCBmbG9hdCB3aWR0aFNjYWxlID0gZmxvYXQoXCIrZitcIik7XFxuXFxuICAgICAgICBjb25zdCBmbG9hdCBpbnZIZWlnaHRTY2FsZSA9IGZsb2F0KFwiK2QrXCIpO1xcbiAgICAgICAgY29uc3QgZmxvYXQgaW52V2lkdGhTY2FsZSA9IGZsb2F0KFwiK3ArXCIpO1xcblxcbiAgICAgICAgY29uc3QgaW50IHdpbkhlaWdodCA9IGludChcIit2K1wiKTtcXG4gICAgICAgIGNvbnN0IGludCB3aW5XaWR0aCA9IGludChcIittK1wiKTtcXG5cXG4gICAgICAgIC8vIENvbXB1dGUgYm91bmRzIGZvciB3aGVyZSBpbiBkeSB3ZSB3aWxsIGxvb2tcXG4gICAgICAgIGZsb2F0IHN0YXJ0UkxlcnAgPSBmbG9vcihmbG9hdChyKSAqIGludkhlaWdodFNjYWxlKTtcXG4gICAgICAgIGludCBzdGFydER5UiA9IGludChzdGFydFJMZXJwIC0gZmxvYXQod2luSGVpZ2h0IC8gMikpO1xcblxcbiAgICAgICAgZmxvYXQgc3RhcnRDTGVycCA9IGZsb29yKGZsb2F0KGMpICogaW52V2lkdGhTY2FsZSk7XFxuICAgICAgICBpbnQgc3RhcnREeUMgPSBpbnQoc3RhcnRDTGVycCAtIGZsb2F0KHdpbldpZHRoIC8gMikpO1xcblxcbiAgICAgICAgLy8gTG9vcCBvdmVyIGR5XFxuICAgICAgICBmb3IgKGludCBkeVJPZmZzZXQgPSAwOyBkeVJPZmZzZXQgPCB3aW5IZWlnaHQ7IGR5Uk9mZnNldCsrKSB7XFxuICAgICAgICAgIGludCBkeVIgPSBkeVJPZmZzZXQgKyBzdGFydER5UjtcXG5cXG4gICAgICAgICAgLy8gR3VhcmQgYWdhaW5zdCB0aGUgd2luZG93IGV4Y2VlZGluZyB0aGUgYm91bmRzIG9mIGR5XFxuICAgICAgICAgIGlmIChkeVIgPCAwIHx8IGR5UiA+PSBcIitzK1wiKSB7XFxuICAgICAgICAgICAgY29udGludWU7XFxuICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgZm9yIChpbnQgZHlDT2Zmc2V0ID0gMDsgZHlDT2Zmc2V0IDwgd2luV2lkdGg7IGR5Q09mZnNldCsrKSB7XFxuICAgICAgICAgICAgaW50IGR5QyA9IGR5Q09mZnNldCArIHN0YXJ0RHlDO1xcblxcbiAgICAgICAgICAgIC8vIEd1YXJkIGFnYWluc3QgdGhlIHdpbmRvdyBleGNlZWRpbmcgdGhlIGJvdW5kcyBvZiBkeVxcbiAgICAgICAgICAgIGlmIChkeUMgPCAwIHx8IGR5QyA+PSBcIit1K1wiKSB7XFxuICAgICAgICAgICAgICBjb250aW51ZTtcXG4gICAgICAgICAgICB9XFxuXFxuICAgICAgICAgICAgZmxvYXQgZHhSID0gZmxvYXQoZHlSKSAqIGhlaWdodFNjYWxlO1xcbiAgICAgICAgICAgIGludCB0b3BEeFJJbmRleCA9IGludChmbG9vcihkeFIpKTtcXG4gICAgICAgICAgICBpbnQgYm90dG9tRHhSSW5kZXggPSBpbnQobWluKGNlaWwoZHhSKSwgXCIrKG8tMSkrXCIuMCkpO1xcbiAgICAgICAgICAgIGZsb2F0IGR4UkxlcnAgPSBkeFIgLSBmbG9hdCh0b3BEeFJJbmRleCk7XFxuICAgICAgICAgICAgZmxvYXQgaW52ZXJzZUR4UkxlcnAgPSAxLjAgLSBkeFJMZXJwO1xcblxcbiAgICAgICAgICAgIGZsb2F0IGR4QyA9IGZsb2F0KGR5QykgKiB3aWR0aFNjYWxlO1xcbiAgICAgICAgICAgIGludCBsZWZ0RHhDSW5kZXggPSBpbnQoZmxvb3IoZHhDKSk7XFxuICAgICAgICAgICAgaW50IHJpZ2h0RHhDSW5kZXggPSBpbnQobWluKGNlaWwoZHhDKSwgXCIrKGEtMSkrXCIuMCkpO1xcbiAgICAgICAgICAgIGZsb2F0IGR4Q0xlcnAgPSBkeEMgLSBmbG9hdChsZWZ0RHhDSW5kZXgpO1xcbiAgICAgICAgICAgIGZsb2F0IGludmVyc2VEeENMZXJwID0gMS4wIC0gZHhDTGVycDtcXG5cXG4gICAgICAgICAgICBpZiAociA9PSB0b3BEeFJJbmRleCAmJiBjID09IGxlZnREeENJbmRleCkge1xcbiAgICAgICAgICAgICAgLy8gdG9wTGVmdFxcbiAgICAgICAgICAgICAgYWNjdW11bGF0b3IgKz1cXG4gICAgICAgICAgICAgICAgZ2V0RHkoYiwgZHlSLCBkeUMsIGQpICogaW52ZXJzZUR4UkxlcnAgKiBpbnZlcnNlRHhDTGVycDtcXG4gICAgICAgICAgICB9XFxuXFxuICAgICAgICAgICAgaWYgKHIgPT0gdG9wRHhSSW5kZXggJiYgYyA9PSByaWdodER4Q0luZGV4KSB7XFxuICAgICAgICAgICAgICAvLyB0b3BSaWdodFxcbiAgICAgICAgICAgICAgYWNjdW11bGF0b3IgKz0gZ2V0RHkoYiwgZHlSLCBkeUMsIGQpICogaW52ZXJzZUR4UkxlcnAgKiBkeENMZXJwO1xcbiAgICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgICBpZiAociA9PSBib3R0b21EeFJJbmRleCAmJiBjID09IGxlZnREeENJbmRleCkge1xcbiAgICAgICAgICAgICAgLy8gYm90dG9tTGVmdFxcbiAgICAgICAgICAgICAgYWNjdW11bGF0b3IgKz0gZ2V0RHkoYiwgZHlSLCBkeUMsIGQpICogZHhSTGVycCAqIGludmVyc2VEeENMZXJwO1xcbiAgICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgICBpZiAociA9PSBib3R0b21EeFJJbmRleCAmJiBjID09IHJpZ2h0RHhDSW5kZXgpIHtcXG4gICAgICAgICAgICAgIC8vIGJvdHRvbVJpZ2h0XFxuICAgICAgICAgICAgICBhY2N1bXVsYXRvciArPSBnZXREeShiLCBkeVIsIGR5QywgZCkgKiBkeFJMZXJwICogZHhDTGVycDtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgIH1cXG4gICAgICAgIH1cXG4gICAgICAgIC8vIEVuZCBsb29wIG92ZXIgZHlcXG5cXG4gICAgICAgIHNldE91dHB1dChhY2N1bXVsYXRvcik7XFxuICAgICAgfVxcbiAgICBcIn0sZXM9ZnVuY3Rpb24odCxlLG4scil7dGhpcy52YXJpYWJsZU5hbWVzPVtcIkFcIl0sdGhpcy5vdXRwdXRTaGFwZT1bXTt2YXIgbz10WzBdLGE9dFsxXSxpPXRbMl0scz10WzNdO3RoaXMub3V0cHV0U2hhcGU9W28sZSxuLHNdO3ZhciB1PVtyJiZlPjE/YS0xOmEsciYmbj4xP2ktMTppXSxjPVtyJiZlPjE/ZS0xOmUsciYmbj4xP24tMTpuXTt0aGlzLnVzZXJDb2RlPVwiXFxuICAgICAgY29uc3QgdmVjMiBlZmZlY3RpdmVJbnB1dE92ZXJPdXRwdXRSYXRpb1JDID0gdmVjMihcXG4gICAgICAgICAgXCIrdVswXS9jWzBdK1wiLFxcbiAgICAgICAgICBcIit1WzFdL2NbMV0rXCIpO1xcbiAgICAgIGNvbnN0IHZlYzIgaW5wdXRTaGFwZVJDID0gdmVjMihcIithK1wiLjAsIFwiK2krXCIuMCk7XFxuXFxuICAgICAgdm9pZCBtYWluKCkge1xcbiAgICAgICAgaXZlYzQgY29vcmRzID0gZ2V0T3V0cHV0Q29vcmRzKCk7XFxuICAgICAgICBpbnQgYiA9IGNvb3Jkc1swXTtcXG4gICAgICAgIGludCBkID0gY29vcmRzWzNdO1xcbiAgICAgICAgaXZlYzIgeVJDID0gY29vcmRzLnl6O1xcblxcbiAgICAgICAgLy8gRnJhY3Rpb25hbCBzb3VyY2UgaW5kZXguXFxuICAgICAgICB2ZWMyIHNvdXJjZUZyYWNJbmRleFJDID0gdmVjMih5UkMpICogZWZmZWN0aXZlSW5wdXRPdmVyT3V0cHV0UmF0aW9SQztcXG5cXG4gICAgICAgIC8vIENvbXB1dGUgdGhlIGZvdXIgaW50ZWdlciBpbmRpY2VzLlxcbiAgICAgICAgaXZlYzIgc291cmNlRmxvb3JSQyA9IGl2ZWMyKHNvdXJjZUZyYWNJbmRleFJDKTtcXG4gICAgICAgIGl2ZWMyIHNvdXJjZUNlaWxSQyA9IGl2ZWMyKFxcbiAgICAgICAgICBtaW4oaW5wdXRTaGFwZVJDIC0gMS4wLCBjZWlsKHNvdXJjZUZyYWNJbmRleFJDKSkpO1xcblxcbiAgICAgICAgZmxvYXQgdG9wTGVmdCA9IGdldEEoYiwgc291cmNlRmxvb3JSQy54LCBzb3VyY2VGbG9vclJDLnksIGQpO1xcbiAgICAgICAgZmxvYXQgYm90dG9tTGVmdCA9IGdldEEoYiwgc291cmNlQ2VpbFJDLngsIHNvdXJjZUZsb29yUkMueSwgZCk7XFxuICAgICAgICBmbG9hdCB0b3BSaWdodCA9IGdldEEoYiwgc291cmNlRmxvb3JSQy54LCBzb3VyY2VDZWlsUkMueSwgZCk7XFxuICAgICAgICBmbG9hdCBib3R0b21SaWdodCA9IGdldEEoYiwgc291cmNlQ2VpbFJDLngsIHNvdXJjZUNlaWxSQy55LCBkKTtcXG5cXG4gICAgICAgIHZlYzIgZnJhY1JDID0gc291cmNlRnJhY0luZGV4UkMgLSB2ZWMyKHNvdXJjZUZsb29yUkMpO1xcblxcbiAgICAgICAgZmxvYXQgdG9wID0gdG9wTGVmdCArICh0b3BSaWdodCAtIHRvcExlZnQpICogZnJhY1JDLnk7XFxuICAgICAgICBmbG9hdCBib3R0b20gPSBib3R0b21MZWZ0ICsgKGJvdHRvbVJpZ2h0IC0gYm90dG9tTGVmdCkgKiBmcmFjUkMueTtcXG4gICAgICAgIGZsb2F0IG5ld1ZhbHVlID0gdG9wICsgKGJvdHRvbSAtIHRvcCkgKiBmcmFjUkMueDtcXG5cXG4gICAgICAgIHNldE91dHB1dChuZXdWYWx1ZSk7XFxuICAgICAgfVxcbiAgICBcIn0sbnM9ZnVuY3Rpb24odCxlLG4scil7dGhpcy52YXJpYWJsZU5hbWVzPVtcIkFcIl0sdGhpcy5wYWNrZWRJbnB1dHM9ITAsdGhpcy5wYWNrZWRPdXRwdXQ9ITAsdGhpcy5vdXRwdXRTaGFwZT1bXTt2YXIgbz10WzBdLGE9dFsxXSxpPXRbMl0scz10WzNdO3RoaXMub3V0cHV0U2hhcGU9W28sZSxuLHNdO3ZhciB1PVtyJiZlPjE/YS0xOmEsciYmbj4xP2ktMTppXSxjPVtyJiZlPjE/ZS0xOmUsciYmbj4xP24tMTpuXTt0aGlzLnVzZXJDb2RlPVwiXFxuICAgICAgY29uc3QgdmVjMyBlZmZlY3RpdmVJbnB1dE92ZXJPdXRwdXRSYXRpb1JDID0gdmVjMyhcXG4gICAgICAgICAgXCIrdVswXS9jWzBdK1wiLFxcbiAgICAgICAgICBcIit1WzFdL2NbMV0rXCIsXFxuICAgICAgICAgIFwiK3VbMV0vY1sxXStcIik7XFxuICAgICAgY29uc3QgdmVjMyBpbnB1dFNoYXBlUkMgPSB2ZWMzKFwiK2ErXCIuMCwgXCIraStcIi4wLFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIitpK1wiLjApO1xcblxcbiAgICAgIGZsb2F0IGdldEFWYWx1ZShpbnQgYiwgaW50IHIsIGludCBjLCBpbnQgZCkge1xcbiAgICAgICAgcmV0dXJuIGdldENoYW5uZWwoZ2V0QShiLCByLCBjLCBkKSwgdmVjMihjLCBkKSk7XFxuICAgICAgfVxcblxcbiAgICAgIHZvaWQgbWFpbigpIHtcXG4gICAgICAgIGl2ZWM0IGNvb3JkcyA9IGdldE91dHB1dENvb3JkcygpO1xcbiAgICAgICAgaW50IGIgPSBjb29yZHNbMF07XFxuICAgICAgICBpbnQgZCA9IGNvb3Jkc1szXTtcXG4gICAgICAgIC8vIENhbGN1bGF0ZSB2YWx1ZXMgZm9yIG5leHQgY29sdW1uIGluIHlSQy56LlxcbiAgICAgICAgaXZlYzMgeVJDID0gY29vcmRzLnl6eiArIGl2ZWMzKDAsIDAsIDEpO1xcblxcbiAgICAgICAgLy8gRnJhY3Rpb25hbCBzb3VyY2UgaW5kZXguXFxuICAgICAgICB2ZWMzIHNvdXJjZUZyYWNJbmRleFJDID0gdmVjMyh5UkMpICogZWZmZWN0aXZlSW5wdXRPdmVyT3V0cHV0UmF0aW9SQztcXG5cXG4gICAgICAgIC8vIENvbXB1dGUgdGhlIGZvdXIgaW50ZWdlciBpbmRpY2VzLlxcbiAgICAgICAgaXZlYzMgc291cmNlRmxvb3JSQyA9IGl2ZWMzKHNvdXJjZUZyYWNJbmRleFJDKTtcXG4gICAgICAgIGl2ZWMzIHNvdXJjZUNlaWxSQyA9IGl2ZWMzKFxcbiAgICAgICAgICBtaW4oaW5wdXRTaGFwZVJDIC0gMS4wLCBjZWlsKHNvdXJjZUZyYWNJbmRleFJDKSkpO1xcblxcbiAgICAgICAgLy8gU2hvdWxkIHdlIGNhbGN1bGF0ZSBuZXh0IGNvbHVtbiBhbmQgcm93IGVsZW1lbnRzIGluIDJ4MiBwYWNrZWQgY2VsbC5cXG4gICAgICAgIGJvb2wgaGFzTmV4dENvbCA9IGQgPCBcIisocy0xKStcIjtcXG4gICAgICAgIGJvb2wgaGFzTmV4dFJvdyA9IGNvb3Jkcy56IDwgXCIrKG4tMSkrXCI7XFxuXFxuICAgICAgICAvLyBJbiBwYXJhbGxlbCwgY29uc3RydWN0IGZvdXIgY29ybmVycyBmb3IgYWxsIGZvdXIgY29tcG9uZW50cyBpblxcbiAgICAgICAgLy8gcGFja2VkIDJ4MiBjZWxsLlxcbiAgICAgICAgdmVjNCB0b3BMZWZ0ID0gdmVjNChcXG4gICAgICAgICAgZ2V0QVZhbHVlKGIsIHNvdXJjZUZsb29yUkMueCwgc291cmNlRmxvb3JSQy55LCBkKSxcXG4gICAgICAgICAgaGFzTmV4dENvbCA/IGdldEFWYWx1ZShiLCBzb3VyY2VGbG9vclJDLngsIHNvdXJjZUZsb29yUkMueSwgZCArIDEpXFxuICAgICAgICAgICAgICAgICAgICAgOiAwLjAsXFxuICAgICAgICAgIGhhc05leHRSb3cgPyBnZXRBVmFsdWUoYiwgc291cmNlRmxvb3JSQy54LCBzb3VyY2VGbG9vclJDLnosIGQpXFxuICAgICAgICAgICAgICAgICAgICAgOiAwLjAsXFxuICAgICAgICAgIChoYXNOZXh0Um93ICYmIGhhc05leHRDb2wpID9cXG4gICAgICAgICAgICBnZXRBVmFsdWUoYiwgc291cmNlRmxvb3JSQy54LCBzb3VyY2VGbG9vclJDLnosIGQgKyAxKSA6IDAuMCk7XFxuXFxuICAgICAgICB2ZWM0IGJvdHRvbUxlZnQgPSB2ZWM0KFxcbiAgICAgICAgICBnZXRBVmFsdWUoYiwgc291cmNlQ2VpbFJDLngsIHNvdXJjZUZsb29yUkMueSwgZCksXFxuICAgICAgICAgIGhhc05leHRDb2wgPyBnZXRBVmFsdWUoYiwgc291cmNlQ2VpbFJDLngsIHNvdXJjZUZsb29yUkMueSwgZCArIDEpXFxuICAgICAgICAgICAgICAgICAgICAgOiAwLjAsXFxuICAgICAgICAgIGhhc05leHRSb3cgPyBnZXRBVmFsdWUoYiwgc291cmNlQ2VpbFJDLngsIHNvdXJjZUZsb29yUkMueiwgZClcXG4gICAgICAgICAgICAgICAgICAgICA6IDAuMCxcXG4gICAgICAgICAgKGhhc05leHRSb3cgJiYgaGFzTmV4dENvbCkgP1xcbiAgICAgICAgICAgIGdldEFWYWx1ZShiLCBzb3VyY2VDZWlsUkMueCwgc291cmNlRmxvb3JSQy56LCBkICsgMSkgOiAwLjApO1xcblxcbiAgICAgICAgdmVjNCB0b3BSaWdodCA9IHZlYzQoXFxuICAgICAgICAgIGdldEFWYWx1ZShiLCBzb3VyY2VGbG9vclJDLngsIHNvdXJjZUNlaWxSQy55LCBkKSxcXG4gICAgICAgICAgaGFzTmV4dENvbCA/IGdldEFWYWx1ZShiLCBzb3VyY2VGbG9vclJDLngsIHNvdXJjZUNlaWxSQy55LCBkICsgMSlcXG4gICAgICAgICAgICAgICAgICAgICA6IDAuMCxcXG4gICAgICAgICAgaGFzTmV4dFJvdyA/IGdldEFWYWx1ZShiLCBzb3VyY2VGbG9vclJDLngsIHNvdXJjZUNlaWxSQy56LCBkKVxcbiAgICAgICAgICAgICAgICAgICAgIDogMC4wLFxcbiAgICAgICAgICAoaGFzTmV4dFJvdyAmJiBoYXNOZXh0Q29sKSA/XFxuICAgICAgICAgICAgZ2V0QVZhbHVlKGIsIHNvdXJjZUZsb29yUkMueCwgc291cmNlQ2VpbFJDLnosIGQgKyAxKSA6IDAuMCk7XFxuXFxuICAgICAgICB2ZWM0IGJvdHRvbVJpZ2h0ID0gdmVjNChcXG4gICAgICAgICAgZ2V0QVZhbHVlKGIsIHNvdXJjZUNlaWxSQy54LCBzb3VyY2VDZWlsUkMueSwgZCksXFxuICAgICAgICAgIGhhc05leHRDb2wgPyBnZXRBVmFsdWUoYiwgc291cmNlQ2VpbFJDLngsIHNvdXJjZUNlaWxSQy55LCBkICsgMSlcXG4gICAgICAgICAgICAgICAgICAgICA6IDAuMCxcXG4gICAgICAgICAgaGFzTmV4dFJvdyA/IGdldEFWYWx1ZShiLCBzb3VyY2VDZWlsUkMueCwgc291cmNlQ2VpbFJDLnosIGQpXFxuICAgICAgICAgICAgICAgICAgICAgOiAwLjAsXFxuICAgICAgICAgIChoYXNOZXh0Um93ICYmIGhhc05leHRDb2wpID9cXG4gICAgICAgICAgICBnZXRBVmFsdWUoYiwgc291cmNlQ2VpbFJDLngsIHNvdXJjZUNlaWxSQy56LCBkICsgMSkgOiAwLjApO1xcblxcbiAgICAgICAgdmVjMyBmcmFjUkMgPSBzb3VyY2VGcmFjSW5kZXhSQyAtIHZlYzMoc291cmNlRmxvb3JSQyk7XFxuXFxuICAgICAgICB2ZWM0IHRvcCA9IG1peCh0b3BMZWZ0LCB0b3BSaWdodCwgZnJhY1JDLnl5enopO1xcbiAgICAgICAgdmVjNCBib3R0b20gPSBtaXgoYm90dG9tTGVmdCwgYm90dG9tUmlnaHQsIGZyYWNSQy55eXp6KTtcXG4gICAgICAgIHZlYzQgbmV3VmFsdWUgPSBtaXgodG9wLCBib3R0b20sIGZyYWNSQy54KTtcXG5cXG4gICAgICAgIHNldE91dHB1dChuZXdWYWx1ZSk7XFxuICAgICAgfVxcbiAgICBcIn0scnM9ZnVuY3Rpb24odCxlLG4pe3RoaXMudmFyaWFibGVOYW1lcz1bXCJkeVwiXSx0aGlzLm91dHB1dFNoYXBlPVtdLHRoaXMub3V0cHV0U2hhcGU9ZS5zaGFwZTt2YXIgcj1lLnNoYXBlLG89clsxXSxhPXJbMl0saT10LnNoYXBlLHM9aVsxXSx1PWlbMl0sYz1bbiYmcz4xP28tMTpvLG4mJnU+MT9hLTE6YV0sbD1bbiYmcz4xP3MtMTpzLG4mJnU+MT91LTE6dV0saD1jWzBdL2xbMF0sZj1jWzFdL2xbMV0sZD0xL2gscD0xL2Ysdj0yKk1hdGguY2VpbChkKSsyLG09MipNYXRoLmNlaWwocCkrMjt0aGlzLnVzZXJDb2RlPVwiXFxuICAgICAgdm9pZCBtYWluKCkge1xcbiAgICAgICAgaXZlYzQgY29vcmRzID0gZ2V0T3V0cHV0Q29vcmRzKCk7XFxuICAgICAgICBpbnQgYiA9IGNvb3Jkc1swXTtcXG4gICAgICAgIGludCBkID0gY29vcmRzWzNdO1xcbiAgICAgICAgaW50IHIgPSBjb29yZHNbMV07XFxuICAgICAgICBpbnQgYyA9IGNvb3Jkc1syXTtcXG5cXG4gICAgICAgIGZsb2F0IGFjY3VtdWxhdG9yID0gMC4wO1xcblxcbiAgICAgICAgY29uc3QgZmxvYXQgaGVpZ2h0U2NhbGUgPSBmbG9hdChcIitoK1wiKTtcXG4gICAgICAgIGNvbnN0IGZsb2F0IHdpZHRoU2NhbGUgPSBmbG9hdChcIitmK1wiKTtcXG5cXG4gICAgICAgIGNvbnN0IGZsb2F0IGludkhlaWdodFNjYWxlID0gZmxvYXQoXCIrZCtcIik7XFxuICAgICAgICBjb25zdCBmbG9hdCBpbnZXaWR0aFNjYWxlID0gZmxvYXQoXCIrcCtcIik7XFxuXFxuICAgICAgICBjb25zdCBpbnQgd2luSGVpZ2h0ID0gaW50KFwiK3YrXCIpO1xcbiAgICAgICAgY29uc3QgaW50IHdpbldpZHRoID0gaW50KFwiK20rXCIpO1xcblxcbiAgICAgICAgLy8gQ29tcHV0ZSBib3VuZHMgZm9yIHdoZXJlIGluIGR5IHdlIHdpbGwgbG9va1xcbiAgICAgICAgZmxvYXQgc3RhcnRSTGVycCA9IGZsb29yKGZsb2F0KHIpICogaW52SGVpZ2h0U2NhbGUpO1xcbiAgICAgICAgaW50IHN0YXJ0RHlSID0gaW50KGZsb29yKHN0YXJ0UkxlcnAgLSBmbG9hdCh3aW5IZWlnaHQgLyAyKSkpO1xcblxcbiAgICAgICAgZmxvYXQgc3RhcnRDTGVycCA9IGZsb29yKGZsb2F0KGMpICogaW52V2lkdGhTY2FsZSk7XFxuICAgICAgICBpbnQgc3RhcnREeUMgPSBpbnQoZmxvb3Ioc3RhcnRDTGVycCAtIGZsb2F0KHdpbldpZHRoIC8gMikpKTtcXG5cXG4gICAgICAgIC8vIExvb3Agb3ZlciBkeVxcbiAgICAgICAgZm9yIChpbnQgZHlST2Zmc2V0ID0gMDsgZHlST2Zmc2V0IDwgd2luSGVpZ2h0OyBkeVJPZmZzZXQrKykge1xcbiAgICAgICAgICBpbnQgZHlSID0gZHlST2Zmc2V0ICsgc3RhcnREeVI7XFxuXFxuICAgICAgICAgIC8vIEd1YXJkIGFnYWluc3QgdGhlIHdpbmRvdyBleGNlZWRpbmcgdGhlIGJvdW5kcyBvZiBkeVxcbiAgICAgICAgICBpZiAoZHlSIDwgMCB8fCBkeVIgPj0gXCIrcytcIikge1xcbiAgICAgICAgICAgIGNvbnRpbnVlO1xcbiAgICAgICAgICB9XFxuXFxuICAgICAgICAgIGZvciAoaW50IGR5Q09mZnNldCA9IDA7IGR5Q09mZnNldCA8IHdpbldpZHRoOyBkeUNPZmZzZXQrKykge1xcbiAgICAgICAgICAgIGludCBkeUMgPSBkeUNPZmZzZXQgKyBzdGFydER5QztcXG5cXG4gICAgICAgICAgICAvLyBHdWFyZCBhZ2FpbnN0IHRoZSB3aW5kb3cgZXhjZWVkaW5nIHRoZSBib3VuZHMgb2YgZHlcXG4gICAgICAgICAgICBpZiAoZHlDIDwgMCB8fCBkeUMgPj0gXCIrdStcIikge1xcbiAgICAgICAgICAgICAgY29udGludWU7XFxuICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgIGZsb2F0IHNvdXJjZUZyYWNSb3cgPVxcbiAgICAgICAgICAgICAgZmxvYXQoXCIrY1swXStcIikgKlxcbiAgICAgICAgICAgICAgICAoZmxvYXQoZHlSKSAvIGZsb2F0KFwiK2xbMF0rXCIpKTtcXG5cXG4gICAgICAgICAgICBmbG9hdCBzb3VyY2VGcmFjQ29sID1cXG4gICAgICAgICAgICAgICAgZmxvYXQoXCIrY1sxXStcIikgKlxcbiAgICAgICAgICAgICAgICAgIChmbG9hdChkeUMpIC8gZmxvYXQoXCIrbFsxXStcIikpO1xcblxcbiAgICAgICAgICAgIGludCBzb3VyY2VOZWFyZXN0Um93ID0gaW50KG1pbihcXG4gICAgICAgICAgICAgICAgZmxvYXQoaW50KFwiK28rXCIpIC0gMSksXFxuICAgICAgICAgICAgICAgIFwiK24rXCIgPyBmbG9hdChyb3VuZChzb3VyY2VGcmFjUm93KSkgOlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmbG9hdChmbG9vcihzb3VyY2VGcmFjUm93KSkpKTtcXG5cXG4gICAgICAgICAgICBpbnQgc291cmNlTmVhcmVzdENvbCA9IGludChtaW4oXFxuICAgICAgICAgICAgICAgIGZsb2F0KGludChcIithK1wiKSAtIDEpLFxcbiAgICAgICAgICAgICAgICBcIituK1wiID8gZmxvYXQocm91bmQoc291cmNlRnJhY0NvbCkpIDpcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmxvYXQoZmxvb3Ioc291cmNlRnJhY0NvbCkpKSk7XFxuXFxuICAgICAgICAgICAgaWYgKHIgPT0gc291cmNlTmVhcmVzdFJvdyAmJiBjID09IHNvdXJjZU5lYXJlc3RDb2wpIHtcXG4gICAgICAgICAgICAgIGFjY3VtdWxhdG9yICs9IGdldER5KGIsIGR5UiwgZHlDLCBkKTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgIH1cXG4gICAgICAgIH1cXG4gICAgICAgIC8vIEVuZCBsb29wIG92ZXIgZHlcXG5cXG4gICAgICAgIHNldE91dHB1dChhY2N1bXVsYXRvcik7XFxuICAgICAgfVxcbiAgICBcIn0sb3M9ZnVuY3Rpb24odCxlLG4scil7dGhpcy52YXJpYWJsZU5hbWVzPVtcIkFcIl0sdGhpcy5vdXRwdXRTaGFwZT1bXTt2YXIgbz10WzBdLGE9dFsxXSxpPXRbMl0scz10WzNdO3RoaXMub3V0cHV0U2hhcGU9W28sZSxuLHNdO3ZhciB1PVtyJiZlPjE/YS0xOmEsciYmbj4xP2ktMTppXSxjPVtyJiZlPjE/ZS0xOmUsciYmbj4xP24tMTpuXSxsPXI/XCIwLjVcIjpcIjAuMFwiO3RoaXMudXNlckNvZGU9XCJcXG4gICAgICBjb25zdCB2ZWMyIGVmZmVjdGl2ZUlucHV0T3Zlck91dHB1dFJhdGlvUkMgPSB2ZWMyKFxcbiAgICAgICAgICBcIit1WzBdL2NbMF0rXCIsXFxuICAgICAgICAgIFwiK3VbMV0vY1sxXStcIik7XFxuICAgICAgY29uc3QgdmVjMiBpbnB1dFNoYXBlUkMgPSB2ZWMyKFwiK2ErXCIuMCwgXCIraStcIi4wKTtcXG5cXG4gICAgICB2b2lkIG1haW4oKSB7XFxuICAgICAgICBpdmVjNCBjb29yZHMgPSBnZXRPdXRwdXRDb29yZHMoKTtcXG4gICAgICAgIGludCBiID0gY29vcmRzWzBdO1xcbiAgICAgICAgaW50IGQgPSBjb29yZHNbM107XFxuICAgICAgICBpdmVjMiB5UkMgPSBjb29yZHMueXo7XFxuXFxuICAgICAgICAvLyBGcmFjdGlvbmFsIHNvdXJjZSBpbmRleC5cXG4gICAgICAgIHZlYzIgc291cmNlRnJhY0luZGV4UkMgPSB2ZWMyKHlSQykgKiBlZmZlY3RpdmVJbnB1dE92ZXJPdXRwdXRSYXRpb1JDO1xcblxcbiAgICAgICAgLy8gQ29tcHV0ZSB0aGUgY29vcmRpbmF0b3JzIG9mIG5lYXJlc3QgbmVpZ2hib3IgcG9pbnQuXFxuICAgICAgICBpdmVjMiBzb3VyY2VOZWFyZXN0UkMgPSBpdmVjMihcXG4gICAgICAgICAgbWluKGlucHV0U2hhcGVSQyAtIDEuMCwgZmxvb3Ioc291cmNlRnJhY0luZGV4UkMgKyBcIitsK1wiKSkpO1xcblxcbiAgICAgICAgZmxvYXQgbmV3VmFsdWUgPSBnZXRBKGIsIHNvdXJjZU5lYXJlc3RSQy54LCBzb3VyY2VOZWFyZXN0UkMueSwgZCk7XFxuXFxuICAgICAgICBzZXRPdXRwdXQobmV3VmFsdWUpO1xcbiAgICAgIH1cXG4gICAgXCJ9LGFzPWZ1bmN0aW9uKHQsZSl7dGhpcy52YXJpYWJsZU5hbWVzPVtcInhcIl07dmFyIG49dC5sZW5ndGg7aWYobj40KXRocm93IG5ldyBFcnJvcihcIldlYkdMIGJhY2tlbmQ6IFJldmVyc2Ugb2YgcmFuay1cIituK1wiIHRlbnNvciBpcyBub3QgeWV0IHN1cHBvcnRlZFwiKTtpZih0aGlzLm91dHB1dFNoYXBlPXQsMSE9PW4pe3ZhciByPXQubWFwKChmdW5jdGlvbihuLHIpe3JldHVybiBmdW5jdGlvbihuKXtyZXR1cm4tMSE9PWUuaW5kZXhPZihuKSYmMSE9PXRbbl0/dFtuXStcIiAtIGNvb3Jkc1tcIituK1wiXSAtIDFcIjpcImNvb3Jkc1tcIituK1wiXVwifShyKX0pKS5qb2luKFwiLFwiKSxvPXdhKG4pO3RoaXMudXNlckNvZGU9XCJcXG4gICAgICB2b2lkIG1haW4oKSB7XFxuICAgICAgICBcIitvK1wiIGNvb3JkcyA9IGdldE91dHB1dENvb3JkcygpO1xcbiAgICAgICAgc2V0T3V0cHV0KGdldFgoXCIrcitcIikpO1xcbiAgICAgIH1cXG4gICAgXCJ9ZWxzZSB0aGlzLnVzZXJDb2RlPVwiXFxuICAgICAgICB2b2lkIG1haW4oKSB7XFxuICAgICAgICAgIGludCBjb29yZCA9IGdldE91dHB1dENvb3JkcygpO1xcbiAgICAgICAgICBzZXRPdXRwdXQoZ2V0WChcIit0WzBdK1wiIC0gY29vcmQgLSAxKSk7XFxuICAgICAgICB9XFxuICAgICAgXCJ9LGlzPWZ1bmN0aW9uKHQsZSl7dGhpcy52YXJpYWJsZU5hbWVzPVtcInhcIl0sdGhpcy5wYWNrZWRJbnB1dHM9ITAsdGhpcy5wYWNrZWRPdXRwdXQ9ITA7dmFyIG49dC5sZW5ndGg7aWYobj40KXRocm93IG5ldyBFcnJvcihcIldlYkdMIGJhY2tlbmQ6IFJldmVyc2Ugb2YgcmFuay1cIituK1wiIHRlbnNvciBpcyBub3QgeWV0IHN1cHBvcnRlZFwiKTt0aGlzLm91dHB1dFNoYXBlPXQ7dmFyIHI9c2EoXCJyY1wiLG4pLG89cltuLTFdK1wiICsgMSA8IFwiK3RoaXMub3V0cHV0U2hhcGVbbi0xXSxhPXJbbi0yXStcIiArIDEgPCBcIit0aGlzLm91dHB1dFNoYXBlW24tMl0saT13YShuKTtmdW5jdGlvbiBzKG4pe3ZhciByPXQubWFwKChmdW5jdGlvbihyLG8pe3JldHVybiBmdW5jdGlvbihuLHIpe3JldHVybi0xIT09ZS5pbmRleE9mKG4pJiYxIT09dFtuXT90W25dK1wiIC0gXCIrcltuXStcIiAtIDFcIjpcIlwiK3Jbbl19KG8sbil9KSk7cmV0dXJuXCJnZXRDaGFubmVsKGdldFgoXCIrci5qb2luKFwiLFwiKStcIiksIHZlYzIoXCIrci5zbGljZSgtMikuam9pbihcIixcIikrXCIpKVwifXRoaXMudXNlckNvZGU9MT09PW4/XCJcXG4gICAgICAgIHZvaWQgbWFpbigpe1xcbiAgICAgICAgICBpbnQgcmMgPSBnZXRPdXRwdXRDb29yZHMoKTtcXG4gICAgICAgICAgdmVjNCByZXN1bHQgPSB2ZWM0KDAuKTtcXG4gICAgICAgICAgcmVzdWx0LnIgPSBnZXRDaGFubmVsKGdldFgoXCIrdFswXStcIiAtIHJjIC0gMSksXFxuICAgICAgICAgICAgXCIrdFswXStcIiAtIHJjIC0gMSk7XFxuICAgICAgICAgIGlmKFwiK28rXCIpe1xcbiAgICAgICAgICAgICAgcmVzdWx0LmcgPSBnZXRDaGFubmVsKGdldFgoXCIrdFswXStcIiAtIChyYyAgKyAxKSAtIDEpLFxcbiAgICAgICAgICAgICAgICBcIit0WzBdK1wiIC0gKHJjICArIDEpIC0gMSk7XFxuICAgICAgICAgIH1cXG4gICAgICAgICAgc2V0T3V0cHV0KHJlc3VsdCk7XFxuICAgICAgICB9XFxuICAgICAgXCI6XCJcXG4gICAgICAgIHZvaWQgbWFpbigpIHtcXG4gICAgICAgICAgXCIraStcIiByYyA9IGdldE91dHB1dENvb3JkcygpO1xcbiAgICAgICAgICB2ZWM0IHJlc3VsdCA9IHZlYzQoMC4pO1xcbiAgICAgICAgICByZXN1bHQuciA9IFwiK2Z1bmN0aW9uKHQpe3JldHVybiBzKHQpfShyLnNsaWNlKCkpK1wiO1xcbiAgICAgICAgICBpZihcIitvK1wiKXtcXG4gICAgICAgICAgICByZXN1bHQuZyA9IFwiK2Z1bmN0aW9uKHQpe3JldHVybiB0W24tMV09XCIoXCIrdFtuLTFdK1wiICsgMSlcIixzKHQpfShyLnNsaWNlKCkpK1wiO1xcbiAgICAgICAgICB9XFxuICAgICAgICAgIGlmKFwiK2ErXCIpIHtcXG4gICAgICAgICAgICByZXN1bHQuYiA9IFwiK2Z1bmN0aW9uKHQpe3JldHVybiB0W24tMl09XCIoXCIrdFtuLTJdK1wiICsgMSlcIixzKHQpfShyLnNsaWNlKCkpK1wiO1xcbiAgICAgICAgICAgIGlmKFwiK28rXCIpIHtcXG4gICAgICAgICAgICAgIHJlc3VsdC5hID0gXCIrZnVuY3Rpb24odCl7cmV0dXJuIHRbbi0xXT1cIihcIit0W24tMV0rXCIgKyAxKVwiLHRbbi0yXT1cIihcIit0W24tMl0rXCIgKyAxKVwiLHModCl9KHIuc2xpY2UoKSkrXCI7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICB9XFxuICAgICAgICAgIHNldE91dHB1dChyZXN1bHQpO1xcbiAgICAgICAgfVxcbiAgICBcIn0sc3M9ZnVuY3Rpb24odCxlLG4scixvLGEsaSl7dm9pZCAwPT09aSYmKGk9ITApLHRoaXMudmFyaWFibGVOYW1lcz1bXCJ1cGRhdGVzXCIsXCJpbmRpY2VzXCIsXCJkZWZhdWx0VmFsdWVcIl0sdGhpcy5vdXRwdXRTaGFwZT1hO3ZhciBzPXdhKG8ubGVuZ3RoKSx1PXdhKGEubGVuZ3RoKSxjPVwiXCI7MT09PW4/Yz1cImlcIjoyPT09biYmKGM9XCJpLCBqXCIpO3ZhciBsPVwiZ2V0SW5kaWNlcyhcIitjK1wiKVwiLGg9XCJcIjsxPT09cj9oPVwiaVwiOjI9PT1yJiYoaD1cImksIGNvb3Jkc1sxXVwiKTt2YXIgZj1cImdldFVwZGF0ZXMoXCIraCtcIilcIixkPWU+MT9cInN0cmlkZXNbal1cIjpcInN0cmlkZXNcIjt0aGlzLnVzZXJDb2RlPVwiXFxuICAgICAgICBcIitzK1wiIHN0cmlkZXMgPSBcIitzK1wiKFwiK28rXCIpO1xcblxcbiAgICAgICAgdm9pZCBtYWluKCkge1xcbiAgICAgICAgICBcIit1K1wiIGNvb3JkcyA9IGdldE91dHB1dENvb3JkcygpO1xcbiAgICAgICAgICBmbG9hdCBzdW0gPSAwLjA7XFxuICAgICAgICAgIGJvb2wgZm91bmQgPSBmYWxzZTtcXG4gICAgICAgICAgZm9yIChpbnQgaSA9IDA7IGkgPCBcIit0K1wiOyBpKyspIHtcXG4gICAgICAgICAgICBpbnQgZmxhdHRlbmVkSW5kZXggPSAwO1xcbiAgICAgICAgICAgIGZvciAoaW50IGogPSAwOyBqIDwgXCIrZStcIjsgaisrKSB7XFxuICAgICAgICAgICAgICBpbnQgaW5kZXggPSByb3VuZChcIitsK1wiKTtcXG4gICAgICAgICAgICAgIGZsYXR0ZW5lZEluZGV4ICs9IGluZGV4ICogXCIrZCtcIjtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgICAgaWYgKGZsYXR0ZW5lZEluZGV4ID09IGNvb3Jkc1swXSkge1xcbiAgICAgICAgICAgICAgc3VtICs9IFwiK2YrXCI7XFxuICAgICAgICAgICAgICBmb3VuZCA9IHRydWU7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICB9XFxuICAgICAgICAgIHNldE91dHB1dChtaXgoZ2V0RGVmYXVsdFZhbHVlKCksIHN1bSwgZmxvYXQoZm91bmQpKSk7XFxuICAgICAgICB9XFxuICAgICAgXCJ9LHVzPWZ1bmN0aW9uKHQsZSl7dGhpcy52YXJpYWJsZU5hbWVzPVtcInhcIixcInNlZ21lbnRJZHNcIl07dmFyIG49dC53aW5kb3dTaXplLHI9dC5iYXRjaFNpemUsbz10LmluU2l6ZSxhPXQubnVtU2VnbWVudHMsaT1hKk1hdGguY2VpbChvL24pO3RoaXMub3V0cHV0U2hhcGU9W3IsaV07dmFyIHM9NCpNYXRoLmZsb29yKG4vNCksdT1uJTQsYz1cIlxcbiAgICAgICAgc3VtVmFsdWUgKz0gZG90KHZhbHVlcywgc2VnRmlsdGVyKTtcXG4gICAgXCIsbD1cIlwiO28lbj4wJiYobD1cIlxcbiAgICAgICAgaWYgKGluSWR4IDwgMCB8fCBpbklkeCA+PSBcIitvK1wiKSB7XFxuICAgICAgICAgIHJldHVybiBpbml0aWFsaXphdGlvblZhbHVlO1xcbiAgICAgICAgfVxcbiAgICAgIFwiKTt2YXIgaD1cIlwiO28lbj4wJiYoaD1cIlxcbiAgICAgICAgaWYgKGluSWR4IDwgMCB8fCBpbklkeCA+PSBcIitvK1wiKSB7XFxuICAgICAgICAgIHJldHVybiAtMS4wO1xcbiAgICAgICAgfVxcbiAgICAgIFwiKSx0aGlzLnVzZXJDb2RlPVwiXFxuICAgICAgY29uc3QgZmxvYXQgaW5pdGlhbGl6YXRpb25WYWx1ZSA9IDAuMDtcXG5cXG4gICAgICBmbG9hdCBnZXRWYWx1ZShpbnQgYmF0Y2gsIGludCBpbklkeCkge1xcbiAgICAgICAgXCIrbCtcIlxcbiAgICAgICAgcmV0dXJuIGdldFgoYmF0Y2gsIGluSWR4KTtcXG4gICAgICB9XFxuXFxuICAgICAgZmxvYXQgZ2V0U2VnbWVudElkQXRJbmRleChpbnQgaW5JZHgpIHtcXG4gICAgICAgIFwiK2grXCJcXG4gICAgICAgIHJldHVybiBnZXRTZWdtZW50SWRzKGluSWR4KTtcXG4gICAgICB9XFxuXFxuICAgICAgdm9pZCBtYWluKCkge1xcbiAgICAgICAgaXZlYzIgY29vcmRzID0gZ2V0T3V0cHV0Q29vcmRzKCk7XFxuICAgICAgICBpbnQgYmF0Y2ggPSBjb29yZHNbMF07XFxuICAgICAgICBpbnQgb3V0SWR4ID0gY29vcmRzWzFdO1xcbiAgICAgICAgaW50IGluT2Zmc2V0ID0gaW50KGZsb29yKGZsb2F0KG91dElkeCkgLyBmbG9hdChcXG4gICAgICAgICAgXCIrYStcIikpICogZmxvYXQoXCIrbitcIikpO1xcbiAgICAgICAgaW50IGN1cnJlbnRTZWcgPSBpbnQobW9kKGZsb2F0KG91dElkeCksIGZsb2F0KFwiK2ErXCIpKSk7XFxuXFxuICAgICAgICBmbG9hdCBzdW1WYWx1ZSA9IDAuMDtcXG5cXG4gICAgICAgIGZvciAoaW50IGkgPSAwOyBpIDwgXCIrcytcIjsgaSArPSA0KSB7XFxuICAgICAgICAgIGludCBpbklkeCA9IGluT2Zmc2V0ICsgaTtcXG4gICAgICAgICAgdmVjNCB2YWx1ZXMgPSB2ZWM0KFxcbiAgICAgICAgICAgIGdldFZhbHVlKGJhdGNoLCBpbklkeCksXFxuICAgICAgICAgICAgZ2V0VmFsdWUoYmF0Y2gsIGluSWR4ICsgMSksXFxuICAgICAgICAgICAgZ2V0VmFsdWUoYmF0Y2gsIGluSWR4ICsgMiksXFxuICAgICAgICAgICAgZ2V0VmFsdWUoYmF0Y2gsIGluSWR4ICsgMylcXG4gICAgICAgICAgKTtcXG5cXG4gICAgICAgICAgdmVjNCBzZWdGaWx0ZXIgPSB2ZWM0KFxcbiAgICAgICAgICAgIGludChnZXRTZWdtZW50SWRBdEluZGV4KGluSWR4KSkgPT0gY3VycmVudFNlZyA/IDEgOiAwLFxcbiAgICAgICAgICAgIGludChnZXRTZWdtZW50SWRBdEluZGV4KGluSWR4ICsgMSkpID09IGN1cnJlbnRTZWcgPyAxIDogMCxcXG4gICAgICAgICAgICBpbnQoZ2V0U2VnbWVudElkQXRJbmRleChpbklkeCArIDIpKSA9PSBjdXJyZW50U2VnID8gMSA6IDAsXFxuICAgICAgICAgICAgaW50KGdldFNlZ21lbnRJZEF0SW5kZXgoaW5JZHggKyAzKSkgPT0gY3VycmVudFNlZyA/IDEgOiAwXFxuICAgICAgICAgICk7XFxuXFxuICAgICAgICAgIFwiK2MrXCJcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIGludCBpbklkeCA9IGluT2Zmc2V0ICsgXCIrcytcIjtcXG4gICAgICAgIGlmIChcIisoMT09PXUpK1wiKSB7XFxuICAgICAgICAgIHZlYzQgdmFsdWVzID0gdmVjNChcXG4gICAgICAgICAgICBnZXRWYWx1ZShiYXRjaCwgaW5JZHgpLFxcbiAgICAgICAgICAgIGluaXRpYWxpemF0aW9uVmFsdWUsXFxuICAgICAgICAgICAgaW5pdGlhbGl6YXRpb25WYWx1ZSxcXG4gICAgICAgICAgICBpbml0aWFsaXphdGlvblZhbHVlXFxuICAgICAgICAgICk7XFxuXFxuICAgICAgICAgIGludCBpbklkeFNlZyA9IGludChnZXRTZWdtZW50SWRBdEluZGV4KGluSWR4KSk7XFxuXFxuICAgICAgICAgIHZlYzQgc2VnRmlsdGVyID0gdmVjNChcXG4gICAgICAgICAgICBpbnQoZ2V0U2VnbWVudElkQXRJbmRleChpbklkeCkpID09IGN1cnJlbnRTZWcgPyAxIDogMCxcXG4gICAgICAgICAgICAwLFxcbiAgICAgICAgICAgIDAsXFxuICAgICAgICAgICAgMFxcbiAgICAgICAgICApO1xcblxcbiAgICAgICAgICBcIitjK1wiXFxuICAgICAgICB9IGVsc2UgaWYgKFwiKygyPT09dSkrXCIpIHtcXG4gICAgICAgICAgdmVjNCB2YWx1ZXMgPSB2ZWM0KFxcbiAgICAgICAgICAgIGdldFZhbHVlKGJhdGNoLCBpbklkeCksXFxuICAgICAgICAgICAgZ2V0VmFsdWUoYmF0Y2gsIGluSWR4ICsgMSksXFxuICAgICAgICAgICAgaW5pdGlhbGl6YXRpb25WYWx1ZSxcXG4gICAgICAgICAgICBpbml0aWFsaXphdGlvblZhbHVlXFxuICAgICAgICAgICk7XFxuXFxuICAgICAgICAgIHZlYzQgc2VnRmlsdGVyID0gdmVjNChcXG4gICAgICAgICAgICBpbnQoZ2V0U2VnbWVudElkQXRJbmRleChpbklkeCkpID09IGN1cnJlbnRTZWcgPyAxIDogMCxcXG4gICAgICAgICAgICBpbnQoZ2V0U2VnbWVudElkQXRJbmRleChpbklkeCArIDEpKSA9PSBjdXJyZW50U2VnID8gMSA6IDAsXFxuICAgICAgICAgICAgICAwLFxcbiAgICAgICAgICAgICAgMFxcbiAgICAgICAgICApO1xcblxcbiAgICAgICAgICBcIitjK1wiXFxuICAgICAgICB9IGVsc2UgaWYgKFwiKygzPT09dSkrXCIpIHtcXG4gICAgICAgICAgdmVjNCB2YWx1ZXMgPSB2ZWM0KFxcbiAgICAgICAgICAgIGdldFZhbHVlKGJhdGNoLCBpbklkeCksXFxuICAgICAgICAgICAgZ2V0VmFsdWUoYmF0Y2gsIGluSWR4ICsgMSksXFxuICAgICAgICAgICAgZ2V0VmFsdWUoYmF0Y2gsIGluSWR4ICsgMiksXFxuICAgICAgICAgICAgaW5pdGlhbGl6YXRpb25WYWx1ZVxcbiAgICAgICAgICApO1xcblxcbiAgICAgICAgICB2ZWM0IHNlZ0ZpbHRlciA9IHZlYzQoXFxuICAgICAgICAgICAgaW50KGdldFNlZ21lbnRJZEF0SW5kZXgoaW5JZHgpKSA9PSBjdXJyZW50U2VnID8gMSA6IDAsXFxuICAgICAgICAgICAgaW50KGdldFNlZ21lbnRJZEF0SW5kZXgoaW5JZHggKyAxKSkgPT0gY3VycmVudFNlZyA/IDEgOiAwLFxcbiAgICAgICAgICAgIGludChnZXRTZWdtZW50SWRBdEluZGV4KGluSWR4ICsgMikpID09IGN1cnJlbnRTZWcgPyAxIDogMCxcXG4gICAgICAgICAgICAwXFxuICAgICAgICAgICk7XFxuXFxuICAgICAgICAgIFwiK2MrXCJcXG4gICAgICAgIH1cXG4gICAgICAgIHNldE91dHB1dChzdW1WYWx1ZSk7XFxuICAgICAgfVxcbiAgICBcIn0sY3M9ZnVuY3Rpb24odCxlLG4pe3ZhciByLG87aWYodGhpcy52YXJpYWJsZU5hbWVzPVtcImNcIixcImFcIixcImJcIl0sdGhpcy5vdXRwdXRTaGFwZT1lLG4+NCl0aHJvdyBFcnJvcihcIldoZXJlIGZvciByYW5rIFwiK24rXCIgaXMgbm90IHlldCBzdXBwb3J0ZWRcIik7aWYoMT09PW4pbz1cInJlc1JDXCIscj1cInJlc1JDXCI7ZWxzZXtmb3IodmFyIGE9W1wicmVzUkMueFwiLFwicmVzUkMueVwiLFwicmVzUkMuelwiLFwicmVzUkMud1wiXSxpPVtdLHM9W10sdT0wO3U8ZS5sZW5ndGg7dSsrKXMucHVzaChcIlwiK2FbdV0pLHU8dCYmaS5wdXNoKFwiXCIrYVt1XSk7cj1pLmpvaW4oKSxvPXMuam9pbigpfXZhciBjPXdhKG4pO3RoaXMudXNlckNvZGU9XCJcXG4gICAgICB2b2lkIG1haW4oKSB7XFxuICAgICAgICBcIitjK1wiIHJlc1JDID0gZ2V0T3V0cHV0Q29vcmRzKCk7XFxuICAgICAgICBmbG9hdCBjVmFsID0gZ2V0QyhcIityK1wiKTtcXG4gICAgICAgIGlmIChjVmFsID49IDEuMCkge1xcbiAgICAgICAgICBzZXRPdXRwdXQoZ2V0QShcIitvK1wiKSk7XFxuICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICBzZXRPdXRwdXQoZ2V0QihcIitvK1wiKSk7XFxuICAgICAgICB9XFxuICAgICAgfVxcbiAgICBcIn0sbHM9ZnVuY3Rpb24oKXtmdW5jdGlvbiB0KHQpe3RoaXMudmFyaWFibGVOYW1lcz1bXCJzb3VyY2VcIl0sdGhpcy5vdXRwdXRTaGFwZT10LHRoaXMucmFuaz10Lmxlbmd0aDt2YXIgZSxuPXdhKHRoaXMucmFuaykscj1cInVuaWZvcm0gaW50IHN0YXJ0W1wiK3RoaXMucmFuaytcIl07XCIsbz1mdW5jdGlvbih0KXtpZigxPT09dClyZXR1cm5cInNvdXJjZUxvY1wiO2lmKHQ8PTYpcmV0dXJuIGhzLnNsaWNlKDAsdCkubWFwKChmdW5jdGlvbih0KXtyZXR1cm5cInNvdXJjZUxvYy5cIit0fSkpLmpvaW4oXCIsXCIpO3Rocm93IEVycm9yKFwiU2xpY2luZyBmb3IgcmFuayBcIit0K1wiIGlzIG5vdCB5ZXQgc3VwcG9ydGVkXCIpfSh0aGlzLnJhbmspO2U9XCJcXG4gICAgICAgIFwiK24rXCIgc291cmNlTG9jO1xcbiAgICAgICAgXCIrbitcIiBjb29yZHMgPSBnZXRPdXRwdXRDb29yZHMoKTtcXG4gICAgICAgIFwiK3QubWFwKChmdW5jdGlvbih0LGUpe3JldHVyblwic291cmNlTG9jLlwiK2hzW2VdK1wiID0gc3RhcnRbXCIrZStcIl0gKyBjb29yZHMuXCIraHNbZV0rXCI7XCJ9KSkuam9pbihcIlxcblwiKStcIlxcbiAgICAgIFwiLHRoaXMudXNlckNvZGU9XCJcXG4gICAgICBcIityK1wiXFxuICAgICAgdm9pZCBtYWluKCkge1xcbiAgICAgICAgXCIrZStcIlxcbiAgICAgICAgc2V0T3V0cHV0KGdldFNvdXJjZShcIitvK1wiKSk7XFxuICAgICAgfVxcbiAgICBcIn1yZXR1cm4gdC5wcm90b3R5cGUuZ2V0Q3VzdG9tU2V0dXBGdW5jPWZ1bmN0aW9uKHQpe3ZhciBlPXRoaXM7aWYodC5sZW5ndGghPT10aGlzLnJhbmspdGhyb3cgRXJyb3IoXCJUaGUgcmFuayAoXCIrdGhpcy5yYW5rK1wiKSBvZiB0aGUgcHJvZ3JhbSBtdXN0IG1hdGNoIHRoZSBsZW5ndGggb2Ygc3RhcnQgKFwiK3QubGVuZ3RoK1wiKVwiKTtyZXR1cm4gZnVuY3Rpb24obixyKXtudWxsPT1lLnN0YXJ0TG9jJiYoZS5zdGFydExvYz1uLmdldFVuaWZvcm1Mb2NhdGlvbk5vVGhyb3cocixcInN0YXJ0XCIpLG51bGw9PWUuc3RhcnRMb2MpfHxuLmdsLnVuaWZvcm0xaXYoZS5zdGFydExvYyx0KX19LHR9KCksaHM9W1wieFwiLFwieVwiLFwielwiLFwid1wiLFwidVwiLFwidlwiXTt2YXIgZnM9ZnVuY3Rpb24oKXtmdW5jdGlvbiB0KHQpe3RoaXMudmFyaWFibGVOYW1lcz1bXCJzb3VyY2VcIl0sdGhpcy5wYWNrZWRJbnB1dHM9ITAsdGhpcy5wYWNrZWRPdXRwdXQ9ITAsdGhpcy5vdXRwdXRTaGFwZT10LHRoaXMucmFuaz10Lmxlbmd0aDt2YXIgZT13YSh0aGlzLnJhbmspLG49c2EoXCJjb29yZHNcIix0aGlzLnJhbmspLHI9c2EoXCJzb3VyY2VMb2NcIix0aGlzLnJhbmspLG89MT09PXRoaXMucmFuaz9cInNvdXJjZUxvY1wiOlwidmVjMihcIityLnNsaWNlKC0yKS5qb2luKCkrXCIpXCIsYT1cImdldENoYW5uZWwoZ2V0U291cmNlKFwiK3Iuam9pbigpK1wiKSwgXCIrbytcIilcIixpPVwiXFxuICAgICAgcmVzdWx0LnggPSBcIithK1wiO1xcbiAgICAgIGlmICgrK1wiK25bdGhpcy5yYW5rLTFdK1wiIDwgXCIrdFt0aGlzLnJhbmstMV0rXCIpIHtcXG4gICAgICAgICsrXCIrclt0aGlzLnJhbmstMV0rXCI7XFxuICAgICAgICByZXN1bHQueSA9IFwiK2ErXCI7XFxuICAgICAgICAtLVwiK3JbdGhpcy5yYW5rLTFdK1wiO1xcbiAgICAgIH1cXG4gICAgXCIscz0xPT09dGhpcy5yYW5rP1wiXCI6XCJcXG4gICAgICAtLVwiK25bdGhpcy5yYW5rLTFdK1wiO1xcbiAgICAgIGlmICgrK1wiK25bdGhpcy5yYW5rLTJdK1wiIDwgXCIrdFt0aGlzLnJhbmstMl0rXCIpIHtcXG4gICAgICAgICsrXCIrclt0aGlzLnJhbmstMl0rXCI7XFxuICAgICAgICByZXN1bHQueiA9IFwiK2ErXCI7XFxuICAgICAgICBpZiAoKytcIituW3RoaXMucmFuay0xXStcIiA8IFwiK3RbdGhpcy5yYW5rLTFdK1wiKSB7XFxuICAgICAgICAgICsrXCIrclt0aGlzLnJhbmstMV0rXCI7XFxuICAgICAgICAgIHJlc3VsdC53ID0gXCIrYStcIjtcXG4gICAgICAgIH1cXG4gICAgICB9XFxuICAgIFwiLHU9dGhpcy5yYW5rPD00P1wic291cmNlTG9jID0gY29vcmRzICtcXG4gICAgICAgICAgICBcIitlK1wiKFwiK3QubWFwKChmdW5jdGlvbih0LGUpe3JldHVyblwic3RhcnRbXCIrZStcIl1cIn0pKS5qb2luKCkrXCIpO1wiOnQubWFwKChmdW5jdGlvbih0LGUpe3JldHVybiByW2VdK1wiID0gXCIrbltlXStcIiArIHN0YXJ0W1wiK2UrXCJdO1wifSkpLmpvaW4oXCJcXG5cIik7dGhpcy51c2VyQ29kZT1cIlxcbiAgICAgIHVuaWZvcm0gaW50IHN0YXJ0W1wiK3RoaXMucmFuaytcIl07XFxuICAgICAgdm9pZCBtYWluKCkge1xcbiAgICAgICAgXCIrZStcIiBjb29yZHMgPSBnZXRPdXRwdXRDb29yZHMoKTtcXG4gICAgICAgIFwiK2UrXCIgc291cmNlTG9jO1xcbiAgICAgICAgXCIrdStcIlxcbiAgICAgICAgdmVjNCByZXN1bHQgPSB2ZWM0KDAuKTtcXG4gICAgICAgIFwiK2krXCJcXG4gICAgICAgIFwiK3MrXCJcXG4gICAgICAgIHNldE91dHB1dChyZXN1bHQpO1xcbiAgICAgIH1cXG4gICAgXCJ9cmV0dXJuIHQucHJvdG90eXBlLmdldEN1c3RvbVNldHVwRnVuYz1mdW5jdGlvbih0KXt2YXIgZT10aGlzO2lmKHQubGVuZ3RoIT09dGhpcy5yYW5rKXRocm93IEVycm9yKFwiVGhlIHJhbmsgKFwiK3RoaXMucmFuaytcIikgb2YgdGhlIHByb2dyYW0gbXVzdCBtYXRjaCB0aGUgbGVuZ3RoIG9mIHN0YXJ0IChcIit0Lmxlbmd0aCtcIilcIik7cmV0dXJuIGZ1bmN0aW9uKG4scil7bnVsbD09ZS5zdGFydExvYyYmKGUuc3RhcnRMb2M9bi5nZXRVbmlmb3JtTG9jYXRpb25Ob1Rocm93KHIsXCJzdGFydFwiKSxudWxsPT1lLnN0YXJ0TG9jKXx8bi5nbC51bmlmb3JtMWl2KGUuc3RhcnRMb2MsdCl9fSx0fSgpLGRzPWZ1bmN0aW9uKHQsZSxuKXt0aGlzLnZhcmlhYmxlTmFtZXM9W1wieFwiXSx0aGlzLm91dHB1dFNoYXBlPW47dmFyIHI9bi5sZW5ndGgsbz13YShuLmxlbmd0aCksYT13YShuLmxlbmd0aCksaT1cIlwiO2lmKDE9PT1yKWk9XCJjb29yZHMgKiBzdHJpZGVzICsgYmVnaW5cIjtlbHNle3ZhciBzPTA7aT1uLm1hcCgoZnVuY3Rpb24odCxlKXtyZXR1cm4gcysrLDE9PT1uLmxlbmd0aD9cImNvb3JkcyAqIHN0cmlkZXNbXCIrZStcIl0gKyBiZWdpbltcIitlK1wiXVwiOlwiY29vcmRzW1wiKyhzLTEpK1wiXSAqIHN0cmlkZXNbXCIrZStcIl0gKyBiZWdpbltcIitlK1wiXVwifSkpLmpvaW4oXCIsXCIpfXRoaXMudXNlckNvZGU9XCJcXG4gICAgICBcIitvK1wiIGJlZ2luID0gXCIrbytcIihcIit0K1wiKTtcXG4gICAgICBcIitvK1wiIHN0cmlkZXMgPSBcIitvK1wiKFwiK2UrXCIpO1xcblxcbiAgICAgIHZvaWQgbWFpbigpIHtcXG4gICAgICAgIFwiK2ErXCIgY29vcmRzID0gZ2V0T3V0cHV0Q29vcmRzKCk7XFxuICAgICAgICBzZXRPdXRwdXQoZ2V0WChcIitpK1wiKSk7XFxuICAgICAgfVxcbiAgICBcIn0scHM9ZnVuY3Rpb24oKXtmdW5jdGlvbiB0KHQpe3RoaXMuZ3BncHU9dCx0aGlzLm51bVVzZWRUZXh0dXJlcz0wLHRoaXMubnVtRnJlZVRleHR1cmVzPTAsdGhpcy5mcmVlVGV4dHVyZXM9e30sdGhpcy5sb2dFbmFibGVkPSExLHRoaXMudXNlZFRleHR1cmVzPXt9fXJldHVybiB0LnByb3RvdHlwZS5hY3F1aXJlVGV4dHVyZT1mdW5jdGlvbih0LGUsbil7dmFyIHIsbz12cyhlLG4pLGE9bXModCxvLG4pO2lmKGEgaW4gdGhpcy5mcmVlVGV4dHVyZXN8fCh0aGlzLmZyZWVUZXh0dXJlc1thXT1bXSksYSBpbiB0aGlzLnVzZWRUZXh0dXJlc3x8KHRoaXMudXNlZFRleHR1cmVzW2FdPVtdKSx0aGlzLmZyZWVUZXh0dXJlc1thXS5sZW5ndGg+MCl7dGhpcy5udW1GcmVlVGV4dHVyZXMtLSx0aGlzLm51bVVzZWRUZXh0dXJlcysrLHRoaXMubG9nKCk7dmFyIGk9dGhpcy5mcmVlVGV4dHVyZXNbYV0uc2hpZnQoKTtyZXR1cm4gdGhpcy51c2VkVGV4dHVyZXNbYV0ucHVzaChpKSxpfXJldHVybiB0aGlzLm51bVVzZWRUZXh0dXJlcysrLHRoaXMubG9nKCksbz09PUd0LlBBQ0tFRF8yWDJfRkxPQVQzMj9yPXRoaXMuZ3BncHUuY3JlYXRlUGFja2VkTWF0cml4VGV4dHVyZSh0WzBdLHRbMV0pOm89PT1HdC5QQUNLRURfMlgyX0ZMT0FUMTY/cj10aGlzLmdwZ3B1LmNyZWF0ZUZsb2F0MTZQYWNrZWRNYXRyaXhUZXh0dXJlKHRbMF0sdFsxXSk6bz09PUd0LlVOUEFDS0VEX0ZMT0FUMzI/cj10aGlzLmdwZ3B1LmNyZWF0ZUZsb2F0MzJNYXRyaXhUZXh0dXJlKHRbMF0sdFsxXSk6bz09PUd0LlVOUEFDS0VEX0ZMT0FUMTY/cj10aGlzLmdwZ3B1LmNyZWF0ZUZsb2F0MTZNYXRyaXhUZXh0dXJlKHRbMF0sdFsxXSk6bz09PUd0LlBBQ0tFRF80WDFfVU5TSUdORURfQllURSYmKHI9dGhpcy5ncGdwdS5jcmVhdGVVbnNpZ25lZEJ5dGVzTWF0cml4VGV4dHVyZSh0WzBdLHRbMV0pKSx0aGlzLnVzZWRUZXh0dXJlc1thXS5wdXNoKHIpLHJ9LHQucHJvdG90eXBlLnJlbGVhc2VUZXh0dXJlPWZ1bmN0aW9uKHQsZSxuLHIpe2lmKG51bGwhPXRoaXMuZnJlZVRleHR1cmVzKXt2YXIgbz1tcyhlLHZzKG4scikscik7byBpbiB0aGlzLmZyZWVUZXh0dXJlc3x8KHRoaXMuZnJlZVRleHR1cmVzW29dPVtdKSx0aGlzLmZyZWVUZXh0dXJlc1tvXS5wdXNoKHQpLHRoaXMubnVtRnJlZVRleHR1cmVzKyssdGhpcy5udW1Vc2VkVGV4dHVyZXMtLTt2YXIgYT10aGlzLnVzZWRUZXh0dXJlc1tvXSxpPWEuaW5kZXhPZih0KTtpZihpPDApdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IHJlbGVhc2UgYSB0ZXh0dXJlIHRoYXQgd2FzIG5ldmVyIHByb3ZpZGVkIGJ5IHRoaXMgdGV4dHVyZSBtYW5hZ2VyXCIpO2Euc3BsaWNlKGksMSksdGhpcy5sb2coKX19LHQucHJvdG90eXBlLmxvZz1mdW5jdGlvbigpe2lmKHRoaXMubG9nRW5hYmxlZCl7dmFyIHQ9dGhpcy5udW1GcmVlVGV4dHVyZXMrdGhpcy5udW1Vc2VkVGV4dHVyZXM7Y29uc29sZS5sb2coXCJGcmVlL1VzZWRcIix0aGlzLm51bUZyZWVUZXh0dXJlcytcIiAvIFwiK3RoaXMubnVtVXNlZFRleHR1cmVzLFwiKFwiK3QrXCIpXCIpfX0sdC5wcm90b3R5cGUuZ2V0TnVtVXNlZFRleHR1cmVzPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMubnVtVXNlZFRleHR1cmVzfSx0LnByb3RvdHlwZS5nZXROdW1GcmVlVGV4dHVyZXM9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5udW1GcmVlVGV4dHVyZXN9LHQucHJvdG90eXBlLmRpc3Bvc2U9ZnVuY3Rpb24oKXt2YXIgdD10aGlzO2lmKG51bGwhPXRoaXMuZnJlZVRleHR1cmVzKXtmb3IodmFyIGUgaW4gdGhpcy5mcmVlVGV4dHVyZXMpdGhpcy5mcmVlVGV4dHVyZXNbZV0uZm9yRWFjaCgoZnVuY3Rpb24oZSl7dC5ncGdwdS5kZWxldGVNYXRyaXhUZXh0dXJlKGUpfSkpO2Zvcih2YXIgZSBpbiB0aGlzLnVzZWRUZXh0dXJlcyl0aGlzLnVzZWRUZXh0dXJlc1tlXS5mb3JFYWNoKChmdW5jdGlvbihlKXt0LmdwZ3B1LmRlbGV0ZU1hdHJpeFRleHR1cmUoZSl9KSk7dGhpcy5mcmVlVGV4dHVyZXM9bnVsbCx0aGlzLnVzZWRUZXh0dXJlcz1udWxsLHRoaXMubnVtVXNlZFRleHR1cmVzPTAsdGhpcy5udW1GcmVlVGV4dHVyZXM9MH19LHR9KCk7ZnVuY3Rpb24gdnModCxlKXtpZih0PT09enQuVVBMT0FEKXJldHVybiBHdC5QQUNLRURfMlgyX0ZMT0FUMzI7aWYodD09PXp0LlJFTkRFUnx8bnVsbD09dClyZXR1cm4gZnVuY3Rpb24odCl7cmV0dXJuIGkoKS5nZXRCb29sKFwiV0VCR0xfUkVOREVSX0ZMT0FUMzJfRU5BQkxFRFwiKT90P0d0LlBBQ0tFRF8yWDJfRkxPQVQzMjpHdC5VTlBBQ0tFRF9GTE9BVDMyOnQ/R3QuUEFDS0VEXzJYMl9GTE9BVDE2Okd0LlVOUEFDS0VEX0ZMT0FUMTZ9KGUpO2lmKHQ9PT16dC5ET1dOTE9BRHx8dD09PXp0LlBJWEVMUylyZXR1cm4gR3QuUEFDS0VEXzRYMV9VTlNJR05FRF9CWVRFO3Rocm93IG5ldyBFcnJvcihcIlVua25vd24gbG9naWNhbCB0ZXh0dXJlIHR5cGUgXCIrdCl9ZnVuY3Rpb24gbXModCxlLG4pe3JldHVybiB0WzBdK1wiX1wiK3RbMV0rXCJfXCIrZStcIl9cIitufXZhciBncz1mdW5jdGlvbih0LGUpe3RoaXMudmFyaWFibGVOYW1lcz1bXCJBXCJdO2Zvcih2YXIgbj1uZXcgQXJyYXkodC5sZW5ndGgpLHI9MDtyPG4ubGVuZ3RoO3IrKyluW3JdPXRbcl0qZVtyXTt0aGlzLm91dHB1dFNoYXBlPW4sdGhpcy5yYW5rPW4ubGVuZ3RoO3ZhciBvPXdhKHRoaXMucmFuayksYT1mdW5jdGlvbih0KXt2YXIgZT10Lmxlbmd0aDtpZihlPjUpdGhyb3cgRXJyb3IoXCJUaWxlIGZvciByYW5rIFwiK2UrXCIgaXMgbm90IHlldCBzdXBwb3J0ZWRcIik7aWYoMT09PWUpcmV0dXJuXCJpbW9kKHJlc1JDLCBcIit0WzBdK1wiKVwiO2Zvcih2YXIgbj1bXCJyZXNSQy54XCIsXCJyZXNSQy55XCIsXCJyZXNSQy56XCIsXCJyZXNSQy53XCIsXCJyZXNSQy51XCJdLHI9W10sbz0wO288dC5sZW5ndGg7bysrKXIucHVzaChcImltb2QoXCIrbltvXStcIiwgXCIrdFtvXStcIilcIik7cmV0dXJuIHIuam9pbigpfSh0KTt0aGlzLnVzZXJDb2RlPVwiXFxuICAgICAgdm9pZCBtYWluKCkge1xcbiAgICAgICAgXCIrbytcIiByZXNSQyA9IGdldE91dHB1dENvb3JkcygpO1xcbiAgICAgICAgc2V0T3V0cHV0KGdldEEoXCIrYStcIikpO1xcbiAgICAgIH1cXG4gICAgXCJ9O3ZhciB5cz1mdW5jdGlvbih0LGUpe3RoaXMudmFyaWFibGVOYW1lcz1bXCJBXCJdO2Zvcih2YXIgbj1uZXcgQXJyYXkodC5sZW5ndGgpLHI9MDtyPG4ubGVuZ3RoO3IrKyluW3JdPXRbZVtyXV07dGhpcy5vdXRwdXRTaGFwZT1uLHRoaXMucmFuaz1uLmxlbmd0aDt2YXIgbz13YSh0aGlzLnJhbmspLGE9ZnVuY3Rpb24odCl7dmFyIGU9dC5sZW5ndGg7aWYoZT42KXRocm93IEVycm9yKFwiVHJhbnNwb3NlIGZvciByYW5rIFwiK2UrXCIgaXMgbm90IHlldCBzdXBwb3J0ZWRcIik7Zm9yKHZhciBuPVtcInJlc1JDLnhcIixcInJlc1JDLnlcIixcInJlc1JDLnpcIixcInJlc1JDLndcIixcInJlc1JDLnVcIixcInJlc1JDLnZcIl0scj1uZXcgQXJyYXkoZSksbz0wO288dC5sZW5ndGg7bysrKXJbdFtvXV09bltvXTtyZXR1cm4gci5qb2luKCl9KGUpO3RoaXMudXNlckNvZGU9XCJcXG4gICAgdm9pZCBtYWluKCkge1xcbiAgICAgIFwiK28rXCIgcmVzUkMgPSBnZXRPdXRwdXRDb29yZHMoKTtcXG4gICAgICBzZXRPdXRwdXQoZ2V0QShcIithK1wiKSk7XFxuICAgIH1cXG4gICAgXCJ9O3ZhciB4cz1mdW5jdGlvbih0LGUpe3RoaXMudmFyaWFibGVOYW1lcz1bXCJBXCJdLHRoaXMucGFja2VkSW5wdXRzPSEwLHRoaXMucGFja2VkT3V0cHV0PSEwO2Zvcih2YXIgbj1uZXcgQXJyYXkodC5sZW5ndGgpLHI9MDtyPG4ubGVuZ3RoO3IrKyluW3JdPXRbZVtyXV07aWYodGhpcy5vdXRwdXRTaGFwZT1uLHRoaXMucmFuaz1uLmxlbmd0aCx0aGlzLnJhbms+Nil0aHJvdyBFcnJvcihcIlBhY2tlZCB0cmFuc3Bvc2UgZm9yIHJhbmsgXCIrdGhpcy5yYW5rK1wiIGlzIG5vdCB5ZXQgc3VwcG9ydGVkLlwiKTt2YXIgbz13YSh0aGlzLnJhbmspLGE9aWEoXCJyY1wiLHRoaXMucmFuayksaT1uZXcgQXJyYXkodGhpcy5yYW5rKTtmb3Iocj0wO3I8ZS5sZW5ndGg7cisrKWlbZVtyXV09YVtyXTt2YXIgcz1cInZlYzIoXCIraS5zbGljZSgtMikuam9pbigpK1wiKVwiLHU9XCIrK1wiK2FbdGhpcy5yYW5rLTFdK1wiIDwgXCIrblt0aGlzLnJhbmstMV0sYz1cImdldENoYW5uZWwoZ2V0QShcIitpLmpvaW4oKStcIiksIFwiK3MrXCIpXCI7dGhpcy51c2VyQ29kZT1cIlxcbiAgICB2b2lkIG1haW4oKSB7XFxuICAgICAgXCIrbytcIiByYyA9IGdldE91dHB1dENvb3JkcygpO1xcbiAgICAgIHZlYzQgcmVzdWx0ID0gdmVjNCgwLik7XFxuICAgICAgcmVzdWx0WzBdID0gXCIrYytcIjtcXG4gICAgICBpZihcIit1K1wiKSB7XFxuICAgICAgICByZXN1bHRbMV0gPSBcIitjK1wiO1xcbiAgICAgIH1cXG4gICAgICAtLVwiK2FbdGhpcy5yYW5rLTFdK1wiO1xcbiAgICAgIGlmKCsrXCIrYVt0aGlzLnJhbmstMl0rXCIgPCBcIituW3RoaXMucmFuay0yXStcIikge1xcbiAgICAgICAgcmVzdWx0WzJdID0gXCIrYytcIjtcXG4gICAgICAgIGlmKFwiK3UrXCIpIHtcXG4gICAgICAgICAgcmVzdWx0WzNdID0gXCIrYytcIjtcXG4gICAgICAgIH1cXG4gICAgICB9XFxuICAgICAgc2V0T3V0cHV0KHJlc3VsdCk7XFxuICAgIH1cXG4gICAgXCJ9LGJzPTEuNzU4MDk5MzQwODQ3Mzc2OCx3cz0xLjA1MDcwMDk4NzM1NTQ4MDUsQ3M9ZnVuY3Rpb24odCxlKXt0aGlzLnZhcmlhYmxlTmFtZXM9W1wiQVwiXSx0aGlzLm91dHB1dFNoYXBlPXQsdGhpcy51c2VyQ29kZT1cIlxcbiAgICAgIGZsb2F0IHVuYXJ5T3BlcmF0aW9uKGZsb2F0IHgpIHtcXG4gICAgICAgIFwiK2UrXCJcXG4gICAgICB9XFxuXFxuICAgICAgdm9pZCBtYWluKCkge1xcbiAgICAgICAgZmxvYXQgeCA9IGdldEFBdE91dENvb3JkcygpO1xcbiAgICAgICAgZmxvYXQgeSA9IHVuYXJ5T3BlcmF0aW9uKHgpO1xcblxcbiAgICAgICAgc2V0T3V0cHV0KHkpO1xcbiAgICAgIH1cXG4gICAgXCJ9LEVzPVwiaWYgKGlzbmFuKHgpKSByZXR1cm4geDtcIixScz1cInJldHVybiB4O1wiLElzPVwicmV0dXJuIGFicyh4KTtcIixrcz1FcytcIlxcbiAgcmV0dXJuICh4IDwgMC4wKSA/IDAuMCA6IHg7XFxuXCIsU3M9RXMrXCJcXG4gIHJldHVybiAoeCA8IDAuMCkgPyAwLjAgOiBtaW4oNi4wLCB4KTtcXG5cIixBcz1cInJldHVybiAoeCA+PSAwLjApID8geCA6IChleHAoeCkgLSAxLjApO1wiLERzPVwiXFxuICAvLyBTdGFibGUgYW5kIEF0dHJhY3RpbmcgRml4ZWQgUG9pbnQgKDAsIDEpIGZvciBOb3JtYWxpemVkIFdlaWdodHMuXFxuICAvLyBzZWU6IGh0dHBzOi8vYXJ4aXYub3JnL2Ficy8xNzA2LjAyNTE1XFxuICBmbG9hdCBzY2FsZUFscGhhID0gXCIrYnMrXCI7XFxuICBmbG9hdCBzY2FsZSA9IFwiK3dzK1wiO1xcbiAgcmV0dXJuICh4ID49IDAuMCkgPyBzY2FsZSAqIHggOiBzY2FsZUFscGhhICogKGV4cCh4KSAtIDEuMCk7XFxuXCI7dmFyIFRzPVwicmV0dXJuIC14O1wiLE5zPVwicmV0dXJuIGNlaWwoeCk7XCIsRnM9XCJyZXR1cm4gZmxvb3IoeCk7XCIsX3M9XCJyZXR1cm4gZXhwKHgpO1wiLE9zPVwicmV0dXJuIGV4cCh4KSAtIDEuMDtcIixNcz1FcytcIlxcbiAgcmV0dXJuIHNpbih4KTtcXG5cIixCcz1FcytcIlxcbiAgcmV0dXJuIGNvcyh4KTtcXG5cIixQcz1FcytcIlxcbiAgaWYgKGFicyh4KSA+IDEuKSB7XFxuICAgIHJldHVybiBOQU47XFxuICB9XFxuICByZXR1cm4gYXNpbih4KTtcXG5cIixMcz1FcytcIlxcbiAgaWYgKGFicyh4KSA+IDEuKSB7XFxuICAgIHJldHVybiBOQU47XFxuICB9XFxuICByZXR1cm4gYWNvcyh4KTtcXG5cIixXcz1FcytcIlxcbiAgcmV0dXJuIGF0YW4oeCk7XFxuXCIsVXM9RXMrXCJyZXR1cm4gbG9nKHggKyBzcXJ0KHggKiB4ICsgMS4wKSk7XCIsVnM9RXMrXCJcXG4gIGlmICh4IDwgMS4wKSByZXR1cm4gTkFOO1xcbiAgcmV0dXJuIGxvZyh4ICsgc3FydCh4ICogeCAtIDEuMCkpO1wiLHpzPUVzK1wiXFxuICBpZiAoKHggPCAtMS4wKSB8fCAoeCA+IDEuMCkpIHJldHVybiBOQU47XFxuICByZXR1cm4gKGxvZygxLjAgKyB4KSAtIGxvZygxLjAgLSB4KSkgLyAyLjA7XCIsR3M9XCJyZXR1cm4geDtcIixIcz1cInJldHVybiB4O1wiLHFzPVwiXFxuICB2ZWM0IHJlc3VsdCA9IHggKiB2ZWM0KGdyZWF0ZXJUaGFuRXF1YWwoeCwgdmVjNCgwLjApKSk7XFxuICBidmVjNCBpc05hTiA9IGlzbmFuKHgpO1xcblxcbiAgcmVzdWx0LnIgPSBpc05hTi5yID8geC5yIDogcmVzdWx0LnI7XFxuICByZXN1bHQuZyA9IGlzTmFOLmcgPyB4LmcgOiByZXN1bHQuZztcXG4gIHJlc3VsdC5iID0gaXNOYU4uYiA/IHguYiA6IHJlc3VsdC5iO1xcbiAgcmVzdWx0LmEgPSBpc05hTi5hID8geC5hIDogcmVzdWx0LmE7XFxuXFxuICByZXR1cm4gcmVzdWx0O1xcblwiLEtzPVwiXFxuICB2ZWM0IHJlc3VsdCA9IG1pbih4LCB2ZWM0KDYuKSkgKiB2ZWM0KGdyZWF0ZXJUaGFuRXF1YWwoeCwgdmVjNCgwLjApKSk7XFxuICBidmVjNCBpc05hTiA9IGlzbmFuKHgpO1xcblxcbiAgcmVzdWx0LnIgPSBpc05hTi5yID8geC5yIDogcmVzdWx0LnI7XFxuICByZXN1bHQuZyA9IGlzTmFOLmcgPyB4LmcgOiByZXN1bHQuZztcXG4gIHJlc3VsdC5iID0gaXNOYU4uYiA/IHguYiA6IHJlc3VsdC5iO1xcbiAgcmVzdWx0LmEgPSBpc05hTi5hID8geC5hIDogcmVzdWx0LmE7XFxuXFxuICByZXR1cm4gcmVzdWx0O1xcblwiLGpzPVwiXFxuICB2ZWM0IHJlc3VsdDtcXG5cXG4gIHJlc3VsdC5yID0gKHguciA+PSAwLjApID8geC5yIDogKGV4cCh4LnIpIC0gMS4wKTtcXG4gIHJlc3VsdC5nID0gKHguZyA+PSAwLjApID8geC5nIDogKGV4cCh4LmcpIC0gMS4wKTtcXG4gIHJlc3VsdC5iID0gKHguYiA+PSAwLjApID8geC5iIDogKGV4cCh4LmIpIC0gMS4wKTtcXG4gIHJlc3VsdC5hID0gKHguYSA+PSAwLjApID8geC5hIDogKGV4cCh4LmEpIC0gMS4wKTtcXG5cXG4gIHJldHVybiByZXN1bHQ7XFxuXCIsWHM9ZnVuY3Rpb24odCxlKXt0aGlzLnZhcmlhYmxlTmFtZXM9W1wiQVwiXSx0aGlzLnBhY2tlZElucHV0cz0hMCx0aGlzLnBhY2tlZE91dHB1dD0hMCx0aGlzLm91dHB1dFNoYXBlPXQsdGhpcy51c2VyQ29kZT1cIlxcbiAgICAgIHZlYzQgdW5hcnlPcGVyYXRpb24odmVjNCB4KSB7XFxuICAgICAgICBcIitlK1wiXFxuICAgICAgfVxcblxcbiAgICAgIHZvaWQgbWFpbigpIHtcXG4gICAgICAgIHZlYzQgeCA9IGdldEFBdE91dENvb3JkcygpO1xcbiAgICAgICAgdmVjNCB5ID0gdW5hcnlPcGVyYXRpb24oeCk7XFxuXFxuICAgICAgICBzZXRPdXRwdXQoeSk7XFxuICAgICAgfVxcbiAgICBcIn0sWXM9ZnVuY3Rpb24odCl7dGhpcy52YXJpYWJsZU5hbWVzPVtcIkFcIl0sdGhpcy5wYWNrZWRJbnB1dHM9ITAsdGhpcy5wYWNrZWRPdXRwdXQ9ITEsdGhpcy5vdXRwdXRTaGFwZT10O3ZhciBlPXQubGVuZ3RoLG49c2EoXCJyY1wiLGUpLHI9d2EoZSksbz1mdW5jdGlvbih0LGUpe2lmKDE9PT10KXJldHVyblwicmNcIjtmb3IodmFyIG49XCJcIixyPTA7cjx0O3IrKyluKz1lW3JdLHI8dC0xJiYobis9XCIsXCIpO3JldHVybiBufShlLG4pLGE9bi5zbGljZSgtMiksaT1lPD0xP1wicmNcIjpcInZlYzIoXCIrYS5qb2luKFwiLFwiKStcIilcIjt0aGlzLnVzZXJDb2RlPVwiXFxuICAgICAgdm9pZCBtYWluKCkge1xcbiAgICAgICAgXCIrcitcIiByYyA9IGdldE91dHB1dENvb3JkcygpO1xcbiAgICAgICAgdmVjNCBwYWNrZWRJbnB1dCA9IGdldEEoXCIrbytcIik7XFxuXFxuICAgICAgICBzZXRPdXRwdXQoZ2V0Q2hhbm5lbChwYWNrZWRJbnB1dCwgXCIraStcIikpO1xcbiAgICAgIH1cXG4gICAgXCJ9LCRzPXt9O2Z1bmN0aW9uIFFzKHQsZSl7aWYodm9pZCAwPT09ZSYmKGU9ITEpLFwibGluZWFyXCI9PT10KXJldHVybiBlP0hzOlJzO2lmKFwicmVsdVwiPT09dClyZXR1cm4gZT9xczprcztpZihcImVsdVwiPT09dClyZXR1cm4gZT9qczpBcztpZihcInJlbHU2XCI9PT10KXJldHVybiBlP0tzOlNzO2lmKFwicHJlbHVcIj09PXQpcmV0dXJuIGU/UGE6TWE7dGhyb3cgbmV3IEVycm9yKFwiQWN0aXZhdGlvbiBcIit0K1wiIGhhcyBub3QgYmVlbiBpbXBsZW1lbnRlZCBmb3IgdGhlIFdlYkdMIGJhY2tlbmQuXCIpfXZhciBKcz02MDA7dmFyIFpzPWZ1bmN0aW9uKHQpe2Z1bmN0aW9uIG8oZSl7dmFyIG4scj10LmNhbGwodGhpcyl8fHRoaXM7aWYoci5wZW5kaW5nUmVhZD1uZXcgV2Vha01hcCxyLnBlbmRpbmdEaXNwb3NhbD1uZXcgV2Vha1NldCxyLmRhdGFSZWZDb3VudD1uZXcgV2Vha01hcCxyLm51bUJ5dGVzSW5HUFU9MCxyLnVwbG9hZFdhaXRNcz0wLHIuZG93bmxvYWRXYWl0TXM9MCxyLndhcm5lZEFib3V0TWVtb3J5PSExLHIucGVuZGluZ0RlbGV0ZXM9MCxyLmRpc3Bvc2VkPSExLCFpKCkuZ2V0Qm9vbChcIkhBU19XRUJHTFwiKSl0aHJvdyBuZXcgRXJyb3IoXCJXZWJHTCBpcyBub3Qgc3VwcG9ydGVkIG9uIHRoaXMgZGV2aWNlXCIpO2lmKG51bGw9PWUpe3ZhciBvPWp0KGkoKS5nZXROdW1iZXIoXCJXRUJHTF9WRVJTSU9OXCIpKTtyLmJpbmFyeUNhY2hlPShuPWkoKS5nZXROdW1iZXIoXCJXRUJHTF9WRVJTSU9OXCIpKWluICRzPyRzW25dOigkc1tuXT17fSwkc1tuXSksci5ncGdwdT1uZXcgQmkobyksci5jYW52YXM9by5jYW52YXMsci5ncGdwdUNyZWF0ZWRMb2NhbGx5PSEwfWVsc2Ugci5ncGdwdT1lLHIuYmluYXJ5Q2FjaGU9e30sci5ncGdwdUNyZWF0ZWRMb2NhbGx5PSExLHIuY2FudmFzPWUuZ2wuY2FudmFzO3JldHVybiByLnRleHR1cmVNYW5hZ2VyPW5ldyBwcyhyLmdwZ3B1KSxyLm51bU1CQmVmb3JlV2FybmluZz1udWxsPT1pKCkuZ2xvYmFsLnNjcmVlbj8xMDI0OmkoKS5nbG9iYWwuc2NyZWVuLmhlaWdodCppKCkuZ2xvYmFsLnNjcmVlbi53aWR0aCp3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbypKcy8xMDI0LzEwMjQsci50ZXhEYXRhPW5ldyB4byhyLEx0KSxyfXJldHVybiBlKG8sdCksby5wcm90b3R5cGUubnVtRGF0YUlkcz1mdW5jdGlvbigpe3JldHVybiB0aGlzLnRleERhdGEubnVtRGF0YUlkcygpKyh0aGlzLmNwdUJhY2tlbmQ/dGhpcy5jcHVCYWNrZW5kLm51bURhdGFJZHMoKTowKS10aGlzLnBlbmRpbmdEZWxldGVzfSxvLnByb3RvdHlwZS53cml0ZT1mdW5jdGlvbih0LGUsbil7aWYoaSgpLmdldEJvb2woXCJERUJVR1wiKSYmdGhpcy5jaGVja051bWVyaWNhbFByb2JsZW1zKHQpLFwiY29tcGxleDY0XCI9PT1uJiZudWxsIT10KXRocm93IG5ldyBFcnJvcihcIkNhbm5vdCB3cml0ZSB0byBhIGNvbXBsZXg2NCBkdHlwZS4gUGxlYXNlIHVzZSB0Zi5jb21wbGV4KHJlYWwsIGltYWcpLlwiKTt2YXIgcj17fTtyZXR1cm4gdGhpcy50ZXhEYXRhLnNldChyLHtzaGFwZTplLGR0eXBlOm4sdmFsdWVzOnQsdXNhZ2U6enQuVVBMT0FEfSkscn0sby5wcm90b3R5cGUubW92ZT1mdW5jdGlvbih0LGUsbixyKXtpZihpKCkuZ2V0Qm9vbChcIkRFQlVHXCIpJiZ0aGlzLmNoZWNrTnVtZXJpY2FsUHJvYmxlbXMoZSksXCJjb21wbGV4NjRcIj09PXIpdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IHdyaXRlIHRvIGEgY29tcGxleDY0IGR0eXBlLiBQbGVhc2UgdXNlIHRmLmNvbXBsZXgocmVhbCwgaW1hZykuXCIpO3RoaXMudGV4RGF0YS5zZXQodCx7c2hhcGU6bixkdHlwZTpyLHZhbHVlczplLHVzYWdlOnp0LlVQTE9BRH0pfSxvLnByb3RvdHlwZS5yZWFkU3luYz1mdW5jdGlvbih0KXt2YXIgZT10aGlzLnRleERhdGEuZ2V0KHQpLG49ZS52YWx1ZXMscj1lLmR0eXBlLG89ZS5jb21wbGV4VGVuc29ycyxhPWUuc2xpY2UsaT1lLnNoYXBlLHM9ZS5pc1BhY2tlZDtpZihudWxsIT1hKXt2YXIgdT12b2lkIDA7dT1zP25ldyBYcyhpLEdzKTpuZXcgQ3MoaSxHcyk7dmFyIGM9dGhpcy5ydW5XZWJHTFByb2dyYW0odSxbe2RhdGFJZDp0LHNoYXBlOmksZHR5cGU6cn1dLHIpLGw9dGhpcy5yZWFkU3luYyhjLmRhdGFJZCk7cmV0dXJuIHRoaXMuZGlzcG9zZURhdGEoYy5kYXRhSWQpLGx9aWYobnVsbCE9bilyZXR1cm4gdGhpcy5jb252ZXJ0QW5kQ2FjaGVPbkNQVSh0KTtpZihcInN0cmluZ1wiPT09cilyZXR1cm4gbjt2YXIgaCxmLGQ9bnVsbCE9dGhpcy5hY3RpdmVUaW1lcnM7KGQmJihoPWV0KCkpLFwiY29tcGxleDY0XCI9PT1yKT9mPVZvKG8ucmVhbC5kYXRhU3luYygpLG8uaW1hZy5kYXRhU3luYygpKTpmPXRoaXMuZ2V0VmFsdWVzRnJvbVRleHR1cmUodCk7cmV0dXJuIGQmJih0aGlzLmRvd25sb2FkV2FpdE1zKz1ldCgpLWgpLHRoaXMuY29udmVydEFuZENhY2hlT25DUFUodCxmKX0sby5wcm90b3R5cGUucmVhZD1mdW5jdGlvbih0KXtyZXR1cm4gbih0aGlzLHZvaWQgMCx2b2lkIDAsKGZ1bmN0aW9uKCl7dmFyIGUsbixvLGEscyx1LGMsbCxoLGYsZCxwLHYsbSxnLHkseCxiLHcsQyxFLFI7cmV0dXJuIHIodGhpcywoZnVuY3Rpb24ocil7c3dpdGNoKHIubGFiZWwpe2Nhc2UgMDppZih0aGlzLnBlbmRpbmdSZWFkLmhhcyh0KSlyZXR1cm4gZT10aGlzLnBlbmRpbmdSZWFkLmdldCh0KSxbMixuZXcgUHJvbWlzZSgoZnVuY3Rpb24odCl7cmV0dXJuIGUucHVzaCh0KX0pKV07aWYobj10aGlzLnRleERhdGEuZ2V0KHQpLG89bi52YWx1ZXMsYT1uLnNoYXBlLHM9bi5zbGljZSx1PW4uZHR5cGUsYz1uLmNvbXBsZXhUZW5zb3JzLGw9bi5pc1BhY2tlZCxudWxsIT1zKXJldHVybiBoPXZvaWQgMCxoPWw/bmV3IFhzKGEsR3MpOm5ldyBDcyhhLEdzKSxmPXRoaXMucnVuV2ViR0xQcm9ncmFtKGgsW3tkYXRhSWQ6dCxzaGFwZTphLGR0eXBlOnV9XSx1KSxkPXRoaXMucmVhZChmLmRhdGFJZCksdGhpcy5kaXNwb3NlRGF0YShmLmRhdGFJZCksWzIsZF07aWYobnVsbCE9bylyZXR1cm5bMix0aGlzLmNvbnZlcnRBbmRDYWNoZU9uQ1BVKHQpXTtpZighaSgpLmdldEJvb2woXCJXRUJHTF9ET1dOTE9BRF9GTE9BVF9FTkFCTEVEXCIpJiYyPT09aSgpLmdldE51bWJlcihcIldFQkdMX1ZFUlNJT05cIikpdGhyb3cgbmV3IEVycm9yKFwidGVuc29yLmRhdGEoKSB3aXRoIFdFQkdMX0RPV05MT0FEX0ZMT0FUX0VOQUJMRUQ9ZmFsc2UgYW5kIFdFQkdMX1ZFUlNJT049MiBub3QgeWV0IHN1cHBvcnRlZC5cIik7cmV0dXJuIHA9bnVsbCxcImNvbXBsZXg2NFwiIT09dSYmaSgpLmdldChcIldFQkdMX0JVRkZFUl9TVVBQT1JURURcIikmJih2PXRoaXMuZGVjb2RlKHQpLG09dGhpcy50ZXhEYXRhLmdldCh2LmRhdGFJZCkscD0oUj10aGlzLmdwZ3B1KS5jcmVhdGVCdWZmZXJGcm9tVGV4dHVyZS5hcHBseShSLFttLnRleHR1cmVdLmNvbmNhdChZdChhKSkpKSx0aGlzLnBlbmRpbmdSZWFkLnNldCh0LFtdKSxcImNvbXBsZXg2NFwiPT09dT9bMywyXTpbNCx0aGlzLmdwZ3B1LmNyZWF0ZUFuZFdhaXRGb3JGZW5jZSgpXTtjYXNlIDE6ci5zZW50KCksci5sYWJlbD0yO2Nhc2UgMjpyZXR1cm5cImNvbXBsZXg2NFwiIT09dT9bMyw0XTpbNCxQcm9taXNlLmFsbChbYy5yZWFsLmRhdGEoKSxjLmltYWcuZGF0YSgpXSldO2Nhc2UgMzpyZXR1cm4geT1yLnNlbnQoKSx4PXlbMF0sYj15WzFdLGc9Vm8oeCxiKSxbMyw1XTtjYXNlIDQ6bnVsbD09cD9nPXRoaXMuZ2V0VmFsdWVzRnJvbVRleHR1cmUodCk6KHc9ayhhKSxnPXRoaXMuZ3BncHUuZG93bmxvYWRGbG9hdDMyTWF0cml4RnJvbUJ1ZmZlcihwLHcpKSxyLmxhYmVsPTU7Y2FzZSA1OnJldHVybiBudWxsIT12JiZ0aGlzLmRpc3Bvc2VEYXRhKHYuZGF0YUlkKSxDPXRoaXMuY29udmVydEFuZENhY2hlT25DUFUodCxnKSxFPXRoaXMucGVuZGluZ1JlYWQuZ2V0KHQpLHRoaXMucGVuZGluZ1JlYWQuZGVsZXRlKHQpLEUuZm9yRWFjaCgoZnVuY3Rpb24odCl7cmV0dXJuIHQoQyl9KSksdGhpcy5wZW5kaW5nRGlzcG9zYWwuaGFzKHQpJiYodGhpcy5wZW5kaW5nRGlzcG9zYWwuZGVsZXRlKHQpLHRoaXMuZGlzcG9zZURhdGEodCksdGhpcy5wZW5kaW5nRGVsZXRlcy0tKSxbMixDXX19KSl9KSl9LG8ucHJvdG90eXBlLmNoZWNrTnVtZXJpY2FsUHJvYmxlbXM9ZnVuY3Rpb24odCl7aWYobnVsbCE9dClmb3IodmFyIGU9MDtlPHQubGVuZ3RoO2UrKyl7dmFyIG49dFtlXTtpZighZWUobikpe2lmKGkoKS5nZXRCb29sKFwiV0VCR0xfUkVOREVSX0ZMT0FUMzJfQ0FQQUJMRVwiKSl0aHJvdyBFcnJvcihcIlRoZSB2YWx1ZSBcIituK1wiIGNhbm5vdCBiZSByZXByZXNlbnRlZCB3aXRoIHlvdXIgY3VycmVudCBzZXR0aW5ncy4gQ29uc2lkZXIgZW5hYmxpbmcgZmxvYXQzMiByZW5kZXJpbmc6ICd0Zi5lbnYoKS5zZXQoJ1dFQkdMX1JFTkRFUl9GTE9BVDMyX0VOQUJMRUQnLCB0cnVlKTsnXCIpO3Rocm93IEVycm9yKFwiVGhlIHZhbHVlIFwiK24rXCIgY2Fubm90IGJlIHJlcHJlc2VudGVkIG9uIHRoaXMgZGV2aWNlLlwiKX19fSxvLnByb3RvdHlwZS5nZXRWYWx1ZXNGcm9tVGV4dHVyZT1mdW5jdGlvbih0KXt2YXIgZSxuPXRoaXMudGV4RGF0YS5nZXQodCkscj1uLnNoYXBlLG89bi5kdHlwZSxhPW4uaXNQYWNrZWQscz1rKHIpO2lmKGkoKS5nZXRCb29sKFwiV0VCR0xfRE9XTkxPQURfRkxPQVRfRU5BQkxFRFwiKSl7dmFyIHU9dGhpcy5kZWNvZGUodCksYz10aGlzLnRleERhdGEuZ2V0KHUuZGF0YUlkKSxsPShlPXRoaXMuZ3BncHUpLmRvd25sb2FkTWF0cml4RnJvbVBhY2tlZFRleHR1cmUuYXBwbHkoZSxbYy50ZXh0dXJlXS5jb25jYXQoWXQocikpKS5zdWJhcnJheSgwLHMpO3JldHVybiB0aGlzLmRpc3Bvc2VEYXRhKHUuZGF0YUlkKSxsfXZhciBoPWkoKS5nZXRCb29sKFwiV0VCR0xfUEFDS1wiKSYmITA9PT1hLGY9aD9UZShyKTpyLGQ9aD9uZXcgY2koZik6bmV3IHVpKGYpLHA9dGhpcy5ydW5XZWJHTFByb2dyYW0oZCxbe3NoYXBlOmYsZHR5cGU6byxkYXRhSWQ6dH1dLFwiZmxvYXQzMlwiKSx2PXRoaXMudGV4RGF0YS5nZXQocC5kYXRhSWQpLG09dGhpcy5ncGdwdS5kb3dubG9hZEJ5dGVFbmNvZGVkRmxvYXRNYXRyaXhGcm9tT3V0cHV0VGV4dHVyZSh2LnRleHR1cmUsdi50ZXhTaGFwZVswXSx2LnRleFNoYXBlWzFdKS5zdWJhcnJheSgwLHMpO3JldHVybiB0aGlzLmRpc3Bvc2VEYXRhKHAuZGF0YUlkKSxtfSxvLnByb3RvdHlwZS50aW1lPWZ1bmN0aW9uKHQpe3JldHVybiBuKHRoaXMsdm9pZCAwLHZvaWQgMCwoZnVuY3Rpb24oKXt2YXIgZSxuLG8sYSxzLHUsYztyZXR1cm4gcih0aGlzLChmdW5jdGlvbihyKXtzd2l0Y2goci5sYWJlbCl7Y2FzZSAwOnJldHVybiBlPXRoaXMuYWN0aXZlVGltZXJzLG49W10sbz0hMSxudWxsPT10aGlzLnByb2dyYW1UaW1lcnNTdGFjaz8odGhpcy5wcm9ncmFtVGltZXJzU3RhY2s9bixvPSEwKTp0aGlzLmFjdGl2ZVRpbWVycy5wdXNoKG4pLHRoaXMuYWN0aXZlVGltZXJzPW4sdCgpLGE9SSh0aGlzLmFjdGl2ZVRpbWVycy5tYXAoKGZ1bmN0aW9uKHQpe3JldHVybiB0LnF1ZXJ5fSkpKS5maWx0ZXIoKGZ1bmN0aW9uKHQpe3JldHVybiBudWxsIT10fSkpLHM9SSh0aGlzLmFjdGl2ZVRpbWVycy5tYXAoKGZ1bmN0aW9uKHQpe3JldHVybiB0Lm5hbWV9KSkpLmZpbHRlcigoZnVuY3Rpb24odCl7cmV0dXJuIG51bGwhPXR9KSksdGhpcy5hY3RpdmVUaW1lcnM9ZSxvJiYodGhpcy5wcm9ncmFtVGltZXJzU3RhY2s9bnVsbCksdT17dXBsb2FkV2FpdE1zOnRoaXMudXBsb2FkV2FpdE1zLGRvd25sb2FkV2FpdE1zOnRoaXMuZG93bmxvYWRXYWl0TXMsa2VybmVsTXM6bnVsbCx3YWxsTXM6bnVsbH0saSgpLmdldE51bWJlcihcIldFQkdMX0RJU0pPSU5UX1FVRVJZX1RJTUVSX0VYVEVOU0lPTl9SRUxJQUJMRVwiKT4wP1s0LFByb21pc2UuYWxsKGEpXTpbMywyXTtjYXNlIDE6cmV0dXJuIGM9ci5zZW50KCksdS5rZXJuZWxNcz13KGMpLHUuZ2V0RXh0cmFQcm9maWxlSW5mbz1mdW5jdGlvbigpe3JldHVybiBjLm1hcCgoZnVuY3Rpb24odCxlKXtyZXR1cm57bmFtZTpzW2VdLG1zOnR9fSkpLm1hcCgoZnVuY3Rpb24odCl7cmV0dXJuIHQubmFtZStcIjogXCIrdC5tc30pKS5qb2luKFwiLCBcIil9LFszLDNdO2Nhc2UgMjp1Lmtlcm5lbE1zPXtlcnJvcjpcIldlYkdMIHF1ZXJ5IHRpbWVycyBhcmUgbm90IHN1cHBvcnRlZCBpbiB0aGlzIGVudmlyb25tZW50LlwifSxyLmxhYmVsPTM7Y2FzZSAzOnJldHVybiB0aGlzLnVwbG9hZFdhaXRNcz0wLHRoaXMuZG93bmxvYWRXYWl0TXM9MCxbMix1XX19KSl9KSl9LG8ucHJvdG90eXBlLm1lbW9yeT1mdW5jdGlvbigpe3JldHVybnt1bnJlbGlhYmxlOiExLG51bUJ5dGVzSW5HUFU6dGhpcy5udW1CeXRlc0luR1BVfX0sby5wcm90b3R5cGUuc3RhcnRUaW1lcj1mdW5jdGlvbigpe3JldHVybiBpKCkuZ2V0TnVtYmVyKFwiV0VCR0xfRElTSk9JTlRfUVVFUllfVElNRVJfRVhURU5TSU9OX1JFTElBQkxFXCIpPjA/dGhpcy5ncGdwdS5iZWdpblF1ZXJ5KCk6e3N0YXJ0TXM6ZXQoKSxlbmRNczpudWxsfX0sby5wcm90b3R5cGUuZW5kVGltZXI9ZnVuY3Rpb24odCl7cmV0dXJuIGkoKS5nZXROdW1iZXIoXCJXRUJHTF9ESVNKT0lOVF9RVUVSWV9USU1FUl9FWFRFTlNJT05fUkVMSUFCTEVcIik+MD8odGhpcy5ncGdwdS5lbmRRdWVyeSgpLHQpOih0LmVuZE1zPWV0KCksdCl9LG8ucHJvdG90eXBlLmdldFF1ZXJ5VGltZT1mdW5jdGlvbih0KXtyZXR1cm4gbih0aGlzLHZvaWQgMCx2b2lkIDAsKGZ1bmN0aW9uKCl7dmFyIGU7cmV0dXJuIHIodGhpcywoZnVuY3Rpb24obil7cmV0dXJuIGkoKS5nZXROdW1iZXIoXCJXRUJHTF9ESVNKT0lOVF9RVUVSWV9USU1FUl9FWFRFTlNJT05fUkVMSUFCTEVcIik+MD9bMix0aGlzLmdwZ3B1LndhaXRGb3JRdWVyeUFuZEdldFRpbWUodCldOlsyLChlPXQpLmVuZE1zLWUuc3RhcnRNc119KSl9KSl9LG8ucHJvdG90eXBlLmRpc3Bvc2VEYXRhPWZ1bmN0aW9uKHQpe2lmKCF0aGlzLnBlbmRpbmdEaXNwb3NhbC5oYXModCkpe2lmKHRoaXMucGVuZGluZ1JlYWQuaGFzKHQpKXJldHVybiB0aGlzLnBlbmRpbmdEaXNwb3NhbC5hZGQodCksdm9pZCB0aGlzLnBlbmRpbmdEZWxldGVzKys7aWYodGhpcy50ZXhEYXRhLmhhcyh0KSl7dGhpcy5yZWxlYXNlR1BVRGF0YSh0KTt2YXIgZT10aGlzLnRleERhdGEuZ2V0KHQpLmNvbXBsZXhUZW5zb3JzO251bGwhPWUmJihlLnJlYWwuZGlzcG9zZSgpLGUuaW1hZy5kaXNwb3NlKCkpLHRoaXMudGV4RGF0YS5kZWxldGUodCl9fX0sby5wcm90b3R5cGUucmVsZWFzZUdQVURhdGE9ZnVuY3Rpb24odCl7dmFyIGU9dGhpcy50ZXhEYXRhLmdldCh0KSxuPWUudGV4dHVyZSxyPWUuZHR5cGUsbz1lLnRleFNoYXBlLGE9ZS51c2FnZSxpPWUuaXNQYWNrZWQscz1lLnNsaWNlLHU9cyYmcy5vcmlnRGF0YUlkfHx0LGM9dGhpcy5kYXRhUmVmQ291bnQuZ2V0KHUpO2M+MT90aGlzLmRhdGFSZWZDb3VudC5zZXQodSxjLTEpOih0aGlzLmRhdGFSZWZDb3VudC5kZWxldGUodSksbnVsbCE9biYmKHRoaXMubnVtQnl0ZXNJbkdQVS09dGhpcy5jb21wdXRlQnl0ZXMobyxyKSx0aGlzLnRleHR1cmVNYW5hZ2VyLnJlbGVhc2VUZXh0dXJlKG4sbyxhLGkpKSk7dmFyIGw9dGhpcy50ZXhEYXRhLmdldCh0KTtsLnRleHR1cmU9bnVsbCxsLnRleFNoYXBlPW51bGwsbC5pc1BhY2tlZD0hMSxsLnNsaWNlPW51bGx9LG8ucHJvdG90eXBlLmdldFRleHR1cmU9ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMudXBsb2FkVG9HUFUodCksdGhpcy50ZXhEYXRhLmdldCh0KS50ZXh0dXJlfSxvLnByb3RvdHlwZS5nZXREYXRhSW5mbz1mdW5jdGlvbih0KXtyZXR1cm4gdGhpcy50ZXhEYXRhLmdldCh0KX0sby5wcm90b3R5cGUuZ2V0Q1BVQmFja2VuZD1mdW5jdGlvbigpe3JldHVybiBpKCkuZ2V0Qm9vbChcIldFQkdMX0NQVV9GT1JXQVJEXCIpPyhudWxsPT10aGlzLmNwdUJhY2tlbmQmJih0aGlzLmNwdUJhY2tlbmQ9THQuZmluZEJhY2tlbmQoXCJjcHVcIikpLHRoaXMuY3B1QmFja2VuZCk6bnVsbH0sby5wcm90b3R5cGUuc2hvdWxkRXhlY3V0ZU9uQ1BVPWZ1bmN0aW9uKHQsZSl7dmFyIG49dGhpcztyZXR1cm4gdm9pZCAwPT09ZSYmKGU9MTI4KSxudWxsIT10aGlzLmdldENQVUJhY2tlbmQoKSYmdC5ldmVyeSgoZnVuY3Rpb24odCl7cmV0dXJuIG51bGw9PW4udGV4RGF0YS5nZXQodC5kYXRhSWQpLnRleHR1cmUmJnQuc2l6ZTxlfSkpfSxvLnByb3RvdHlwZS5nZXRHUEdQVUNvbnRleHQ9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5ncGdwdX0sby5wcm90b3R5cGUuY29tcGxleD1mdW5jdGlvbih0LGUpe3ZhciBuPXRoaXMubWFrZU91dHB1dCh0LnNoYXBlLFwiY29tcGxleDY0XCIpO3JldHVybiB0aGlzLnRleERhdGEuZ2V0KG4uZGF0YUlkKS5jb21wbGV4VGVuc29ycz17cmVhbDpMdC5rZWVwKHQuY2xvbmUoKSksaW1hZzpMdC5rZWVwKGUuY2xvbmUoKSl9LG59LG8ucHJvdG90eXBlLnJlYWw9ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMudGV4RGF0YS5nZXQodC5kYXRhSWQpLmNvbXBsZXhUZW5zb3JzLnJlYWwuY2xvbmUoKX0sby5wcm90b3R5cGUuaW1hZz1mdW5jdGlvbih0KXtyZXR1cm4gdGhpcy50ZXhEYXRhLmdldCh0LmRhdGFJZCkuY29tcGxleFRlbnNvcnMuaW1hZy5jbG9uZSgpfSxvLnByb3RvdHlwZS5zbGljZT1mdW5jdGlvbih0LGUsbil7aWYodGhpcy5zaG91bGRFeGVjdXRlT25DUFUoW3RdKSlyZXR1cm4gdGhpcy5jcHVCYWNrZW5kLnNsaWNlKHQsZSxuKTtpZigwPT09ayhuKSlyZXR1cm4gRm4oW10sbix0LmR0eXBlKTt2YXIgcj10aGlzLnRleERhdGEuZ2V0KHQuZGF0YUlkKS5pc1BhY2tlZCxvPWlvKHQuc2hhcGUsZSxuKTtpZihyfHwhbyl7dmFyIGE9aSgpLmdldEJvb2woXCJXRUJHTF9QQUNLX0FSUkFZX09QRVJBVElPTlNcIik/bmV3IGZzKG4pOm5ldyBscyhuKSxzPWEuZ2V0Q3VzdG9tU2V0dXBGdW5jKGUpO3JldHVybiB0aGlzLmNvbXBpbGVBbmRSdW4oYSxbdF0sbnVsbCxzKX1yZXR1cm4gdGhpcy51cGxvYWRUb0dQVSh0LmRhdGFJZCksdGhpcy5zaGFsbG93U2xpY2UodCxlLG4pfSxvLnByb3RvdHlwZS5zaGFsbG93U2xpY2U9ZnVuY3Rpb24odCxlLG4pe3ZhciByPXRoaXMudGV4RGF0YS5nZXQodC5kYXRhSWQpLG89dGhpcy5tYWtlT3V0cHV0KG4sdC5kdHlwZSksYT10aGlzLnRleERhdGEuZ2V0KG8uZGF0YUlkKTtPYmplY3QuYXNzaWduKGEsciksYS5zaGFwZT1uLGEuZHR5cGU9dC5kdHlwZTt2YXIgaT1zbyhlLHQuc3RyaWRlcyk7ci5zbGljZSYmKGkrPXIuc2xpY2UuZmxhdE9mZnNldCksYS5zbGljZT17ZmxhdE9mZnNldDppLG9yaWdEYXRhSWQ6ci5zbGljZSYmci5zbGljZS5vcmlnRGF0YUlkfHx0LmRhdGFJZH07dmFyIHM9dGhpcy5kYXRhUmVmQ291bnQuZ2V0KGEuc2xpY2Uub3JpZ0RhdGFJZCl8fDE7cmV0dXJuIHRoaXMuZGF0YVJlZkNvdW50LnNldChhLnNsaWNlLm9yaWdEYXRhSWQscysxKSxvfSxvLnByb3RvdHlwZS5zdHJpZGVkU2xpY2U9ZnVuY3Rpb24odCxlLG4scil7aWYodGhpcy5zaG91bGRFeGVjdXRlT25DUFUoW3RdKSlyZXR1cm4gdGhpcy5jcHVCYWNrZW5kLnN0cmlkZWRTbGljZSh0LGUsbixyKTt2YXIgbz1ybyhlLG4scik7aWYoby5zb21lKChmdW5jdGlvbih0KXtyZXR1cm4gMD09PXR9KSkpcmV0dXJuIEZuKFtdLG8pO3ZhciBhPW5ldyBkcyhlLHIsbyk7cmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bihhLFt0XSl9LG8ucHJvdG90eXBlLnJldmVyc2U9ZnVuY3Rpb24odCxlKXt2YXIgbj1pKCkuZ2V0Qm9vbChcIldFQkdMX1BBQ0tfQVJSQVlfT1BFUkFUSU9OU1wiKT9uZXcgaXModC5zaGFwZSxlKTpuZXcgYXModC5zaGFwZSxlKTtyZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKG4sW3RdKX0sby5wcm90b3R5cGUuY29uY2F0PWZ1bmN0aW9uKHQsZSl7aWYoXCJjb21wbGV4NjRcIj09PXRbMF0uZHR5cGUpe3ZhciBuPXQubWFwKChmdW5jdGlvbih0KXtyZXR1cm4gVG4odCl9KSkscj10Lm1hcCgoZnVuY3Rpb24odCl7cmV0dXJuIE5uKHQpfSkpO3JldHVybiBEbih0aGlzLmNvbmNhdChuLGUpLHRoaXMuY29uY2F0KHIsZSkpfWlmKHRoaXMuc2hvdWxkRXhlY3V0ZU9uQ1BVKHQpKXJldHVybiB0aGlzLmNwdUJhY2tlbmQuY29uY2F0KHQsZSk7aWYoMT09PXQubGVuZ3RoKXJldHVybiB0WzBdO2lmKHQubGVuZ3RoPmkoKS5nZXROdW1iZXIoXCJXRUJHTF9NQVhfVEVYVFVSRVNfSU5fU0hBREVSXCIpKXt2YXIgbz1NYXRoLmZsb29yKHQubGVuZ3RoLzIpLGE9dGhpcy5jb25jYXQodC5zbGljZSgwLG8pLGUpLHM9dGhpcy5jb25jYXQodC5zbGljZShvKSxlKTtyZXR1cm4gdGhpcy5jb25jYXQoW2Esc10sZSl9aWYoaSgpLmdldEJvb2woXCJXRUJHTF9QQUNLX0FSUkFZX09QRVJBVElPTlNcIikmJnRbMF0ucmFuaz4xKXt2YXIgdT1uZXcgR2EodC5tYXAoKGZ1bmN0aW9uKHQpe3JldHVybiB0LnNoYXBlfSkpLGUpO3JldHVybiB0aGlzLmNvbXBpbGVBbmRSdW4odSx0KX12YXIgYz1Tbih0Lm1hcCgoZnVuY3Rpb24odCl7cmV0dXJuIHQuc2hhcGV9KSksZSksbD10Lm1hcCgoZnVuY3Rpb24odCl7cmV0dXJuIHQuYXMyRCgtMSxrKHQuc2hhcGUuc2xpY2UoZSkpKX0pKSxoPW5ldyB6YShsLm1hcCgoZnVuY3Rpb24odCl7cmV0dXJuIHQuc2hhcGV9KSkpO3JldHVybiB0aGlzLmNvbXBpbGVBbmRSdW4oaCxsKS5yZXNoYXBlKGMpfSxvLnByb3RvdHlwZS5uZWc9ZnVuY3Rpb24odCl7aWYodGhpcy5zaG91bGRFeGVjdXRlT25DUFUoW3RdKSlyZXR1cm4gdGhpcy5jcHVCYWNrZW5kLm5lZyh0KTtpZihpKCkuZ2V0Qm9vbChcIldFQkdMX1BBQ0tfVU5BUllfT1BFUkFUSU9OU1wiKSlyZXR1cm4gdGhpcy5wYWNrZWRVbmFyeU9wKHQsVHMsdC5kdHlwZSk7dmFyIGU9bmV3IENzKHQuc2hhcGUsVHMpO3JldHVybiB0aGlzLmNvbXBpbGVBbmRSdW4oZSxbdF0pfSxvLnByb3RvdHlwZS5iYXRjaE1hdE11bD1mdW5jdGlvbih0LGUsbixyKXt2YXIgbz1uP3Quc2hhcGVbMl06dC5zaGFwZVsxXSxhPXI/ZS5zaGFwZVsxXTplLnNoYXBlWzJdLGk9bj90LnNoYXBlWzFdOnQuc2hhcGVbMl0scz10LnNoYXBlWzBdO2lmKCgxPT09b3x8MT09PWEpJiZpPjFlMyl7biYmKHQ9dC50cmFuc3Bvc2UoWzAsMiwxXSkpLHImJihlPWUudHJhbnNwb3NlKFswLDIsMV0pKTt2YXIgdT0xPT09YT90OnQuYXMzRChzLGksMSksYz0xPT09YT8yOjEsbD0xPT09YT9lLmFzM0QocywxLGkpOmU7cmV0dXJuIHRoaXMubXVsdGlwbHkodSxsKS5zdW0oYywhMCl9dmFyIGg9RHQodC5kdHlwZSxlLmR0eXBlKSxmPW5ldyBIaSh0LnNoYXBlLFtzLG8sYV0sbixyKTtyZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKGYsW3QsZV0saCl9LG8ucHJvdG90eXBlLmZ1c2VkQmF0Y2hNYXRNdWw9ZnVuY3Rpb24odCl7dmFyIGU9dC5hLG49dC5iLHI9dC50cmFuc3Bvc2VBLG89dC50cmFuc3Bvc2VCLGE9dC5iaWFzLGk9dC5hY3RpdmF0aW9uLHM9dC5wcmVsdUFjdGl2YXRpb25XZWlnaHRzLHU9cj9lLnNoYXBlWzJdOmUuc2hhcGVbMV0sYz1vP24uc2hhcGVbMV06bi5zaGFwZVsyXSxsPWUuc2hhcGVbMF0saD1EdChlLmR0eXBlLG4uZHR5cGUpLGY9bnVsbCE9YSxkPW51bGwhPXMscD1pP1FzKGksITApOm51bGwsdj1uZXcgSGkoZS5zaGFwZSxbbCx1LGNdLHIsbyxmLHAsZCksbT1bZSxuXTtyZXR1cm4gYSYmbS5wdXNoKGEpLHMmJm0ucHVzaChzKSx0aGlzLmNvbXBpbGVBbmRSdW4odixtLGgpfSxvLnByb3RvdHlwZS5tdWx0aXBseT1mdW5jdGlvbih0LGUpe2lmKFwiY29tcGxleDY0XCI9PT10LmR0eXBlKXt2YXIgbj10aGlzLnRleERhdGEuZ2V0KHQuZGF0YUlkKSxyPXRoaXMudGV4RGF0YS5nZXQoZS5kYXRhSWQpLG89bmV3IE5hKERhLHQuc2hhcGUsZS5zaGFwZSksYT1uZXcgTmEoVGEsdC5zaGFwZSxlLnNoYXBlKSxzPVt0aGlzLm1ha2VDb21wbGV4Q29tcG9uZW50VGVuc29ySW5mbyh0LG4uY29tcGxleFRlbnNvcnMucmVhbCksdGhpcy5tYWtlQ29tcGxleENvbXBvbmVudFRlbnNvckluZm8odCxuLmNvbXBsZXhUZW5zb3JzLmltYWcpLHRoaXMubWFrZUNvbXBsZXhDb21wb25lbnRUZW5zb3JJbmZvKGUsci5jb21wbGV4VGVuc29ycy5yZWFsKSx0aGlzLm1ha2VDb21wbGV4Q29tcG9uZW50VGVuc29ySW5mbyhlLHIuY29tcGxleFRlbnNvcnMuaW1hZyldLHU9dGhpcy5jb21waWxlQW5kUnVuKG8scyksYz10aGlzLmNvbXBpbGVBbmRSdW4oYSxzKSxsPXRoaXMuY29tcGxleCh1LGMpO3JldHVybiB1LmRpc3Bvc2UoKSxjLmRpc3Bvc2UoKSxsfWlmKHRoaXMuc2hvdWxkRXhlY3V0ZU9uQ1BVKFt0LGVdKSlyZXR1cm4gdGhpcy5jcHVCYWNrZW5kLm11bHRpcGx5KHQsZSk7aWYoaSgpLmdldEJvb2woXCJXRUJHTF9QQUNLX0JJTkFSWV9PUEVSQVRJT05TXCIpKXJldHVybiB0aGlzLnBhY2tlZEJpbmFyeU9wKHQsZSxPYSx0LmR0eXBlKTt2YXIgaD1uZXcgQmEoT2EsdC5zaGFwZSxlLnNoYXBlKTtyZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKGgsW3QsZV0sdC5kdHlwZSl9LG8ucHJvdG90eXBlLmJhdGNoTm9ybWFsaXphdGlvbj1mdW5jdGlvbih0LGUsbixyLG8sYSl7dmFyIHM9W3QsZSxuXSx1PW51bGw7bnVsbCE9YSYmKHU9YS5zaGFwZSxzLnB1c2goYSkpO3ZhciBjPW51bGw7aWYobnVsbCE9byYmKGM9by5zaGFwZSxzLnB1c2gobykpLGkoKS5nZXRCb29sKFwiV0VCR0xfUEFDS19OT1JNQUxJWkFUSU9OXCIpKXt2YXIgbD1uZXcgQWEodC5zaGFwZSxlLnNoYXBlLG4uc2hhcGUsdSxjLHIpO3JldHVybiB0aGlzLmNvbXBpbGVBbmRSdW4obCxzKX12YXIgaD1uZXcgU2EodC5zaGFwZSxlLnNoYXBlLG4uc2hhcGUsdSxjLHIpO3JldHVybiB0aGlzLmNvbXBpbGVBbmRSdW4oaCxzKX0sby5wcm90b3R5cGUubG9jYWxSZXNwb25zZU5vcm1hbGl6YXRpb240RD1mdW5jdGlvbih0LGUsbixyLG8pe3ZhciBhPWkoKS5nZXRCb29sKFwiV0VCR0xfUEFDS19OT1JNQUxJWkFUSU9OXCIpP25ldyBWaSh0LnNoYXBlLGUsbixyLG8pOm5ldyBXaSh0LnNoYXBlLGUsbixyLG8pO3JldHVybiB0aGlzLmNvbXBpbGVBbmRSdW4oYSxbdF0pfSxvLnByb3RvdHlwZS5MUk5HcmFkPWZ1bmN0aW9uKHQsZSxuLHIsbyxhLGkpe3ZhciBzPW5ldyBVaShlLnNoYXBlLHIsbyxhLGkpO3JldHVybiB0aGlzLmNvbXBpbGVBbmRSdW4ocyxbZSxuLHRdKX0sby5wcm90b3R5cGUudGlsZT1mdW5jdGlvbih0LGUpe2lmKFwic3RyaW5nXCI9PT10LmR0eXBlKXt2YXIgbj10aGlzLnJlYWRTeW5jKHQuZGF0YUlkKS5tYXAoKGZ1bmN0aW9uKHQpe3JldHVybiBvdCh0KX0pKTtyZXR1cm4gdGEoZHIodC5zaGFwZSx0LmR0eXBlLG4pLGUpfXZhciByPW5ldyBncyh0LnNoYXBlLGUpO3JldHVybiB0aGlzLmNvbXBpbGVBbmRSdW4ocixbdF0pfSxvLnByb3RvdHlwZS5wYWQ9ZnVuY3Rpb24odCxlLG4pe3ZhciByPWkoKS5nZXRCb29sKFwiV0VCR0xfUEFDS19BUlJBWV9PUEVSQVRJT05TXCIpP25ldyBZaSh0LnNoYXBlLGUsbik6bmV3IFhpKHQuc2hhcGUsZSxuKTtyZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKHIsW3RdKX0sby5wcm90b3R5cGUudHJhbnNwb3NlPWZ1bmN0aW9uKHQsZSl7aWYodGhpcy5zaG91bGRFeGVjdXRlT25DUFUoW3RdKSlyZXR1cm4gdGhpcy5jcHVCYWNrZW5kLnRyYW5zcG9zZSh0LGUpO3ZhciBuPWkoKS5nZXRCb29sKFwiV0VCR0xfUEFDS19BUlJBWV9PUEVSQVRJT05TXCIpP25ldyB4cyh0LnNoYXBlLGUpOm5ldyB5cyh0LnNoYXBlLGUpO3JldHVybiB0aGlzLmNvbXBpbGVBbmRSdW4obixbdF0pfSxvLnByb3RvdHlwZS5nYXRoZXI9ZnVuY3Rpb24odCxlLG4pe2lmKHRoaXMuc2hvdWxkRXhlY3V0ZU9uQ1BVKFt0LGVdKSlyZXR1cm4gdGhpcy5jcHVCYWNrZW5kLmdhdGhlcih0LGUsbik7dmFyIHI9bmV3IG1pKHQuc2hhcGUsZS5zaXplLG4pO3JldHVybiB0aGlzLmNvbXBpbGVBbmRSdW4ocixbdCxlXSl9LG8ucHJvdG90eXBlLmJhdGNoVG9TcGFjZU5EPWZ1bmN0aW9uKHQsZSxuKXtDKHQucmFuazw9NCwoZnVuY3Rpb24oKXtyZXR1cm5cImJhdGNoVG9TcGFjZU5EIGZvciByYW5rID4gNCB3aXRoIGEgV2ViR0wgYmFja2VuZCBub3QgaW1wbGVtZW50ZWQgeWV0XCJ9KSk7dmFyIHI9ZS5yZWR1Y2UoKGZ1bmN0aW9uKHQsZSl7cmV0dXJuIHQqZX0pKSxvPXpyKHQuc2hhcGUsZSxyKSxhPUdyKG8ubGVuZ3RoLGUubGVuZ3RoKSxpPUhyKHQuc2hhcGUsZSxyKSxzPXFyKG4sZS5sZW5ndGgpLHU9S3IoaSxuLGUubGVuZ3RoKTtyZXR1cm4gdC5yZXNoYXBlKG8pLnRyYW5zcG9zZShhKS5yZXNoYXBlKGkpLnNsaWNlKHMsdSl9LG8ucHJvdG90eXBlLnNwYWNlVG9CYXRjaE5EPWZ1bmN0aW9uKHQsZSxuKXtDKHQucmFuazw9NCwoZnVuY3Rpb24oKXtyZXR1cm5cInNwYWNlVG9CYXRjaE5EIGZvciByYW5rID4gNCB3aXRoIGEgV2ViR0wgYmFja2VuZCBub3QgaW1wbGVtZW50ZWQgeWV0XCJ9KSk7dmFyIHI9ZS5yZWR1Y2UoKGZ1bmN0aW9uKHQsZSl7cmV0dXJuIHQqZX0pKSxvPVtbMCwwXV07by5wdXNoLmFwcGx5KG8sbik7Zm9yKHZhciBhPTErZS5sZW5ndGg7YTx0LnNoYXBlLmxlbmd0aDsrK2Epby5wdXNoKFswLDBdKTt2YXIgaT10LnBhZChvKSxzPXpyKGkuc2hhcGUsZSxyLCExKSx1PUdyKHMubGVuZ3RoLGUubGVuZ3RoLCExKSxjPUhyKGkuc2hhcGUsZSxyLCExKTtyZXR1cm4gaS5yZXNoYXBlKHMpLnRyYW5zcG9zZSh1KS5yZXNoYXBlKGMpfSxvLnByb3RvdHlwZS5yZWR1Y2U9ZnVuY3Rpb24odCxlLG4pe3ZhciByPXQuc2hhcGVbMF0sbz10LnNoYXBlWzFdLGE9JHIobyksaT1uZXcgSmkoe3dpbmRvd1NpemU6YSxpblNpemU6byxiYXRjaFNpemU6cn0sZSkscz10aGlzLmNvbXBpbGVBbmRSdW4oaSxbdF0sbik7cmV0dXJuIDE9PT1zLnNoYXBlWzFdP3M6dGhpcy5yZWR1Y2UocyxlLG4pfSxvLnByb3RvdHlwZS5hcmdSZWR1Y2U9ZnVuY3Rpb24odCxlLG4pe3ZvaWQgMD09PW4mJihuPW51bGwpO3ZhciByPXQuc2hhcGVbMF0sbz10LnNoYXBlWzFdO251bGwhPW4mJihyPW4uc2hhcGVbMF0sbz1uLnNoYXBlWzFdKTt2YXIgYT0kcihvKSxpPW5ldyBhYSh7d2luZG93U2l6ZTphLGluU2l6ZTpvLGJhdGNoU2l6ZTpyfSxlLG51bGw9PW4pLHM9W3RdO251bGwhPW4mJnMucHVzaChuKTt2YXIgdT10aGlzLmNvbXBpbGVBbmRSdW4oaSxzLFwiaW50MzJcIik7cmV0dXJuIDE9PT11LnNoYXBlWzFdP3U6dGhpcy5hcmdSZWR1Y2UodCxlLHUpfSxvLnByb3RvdHlwZS5hcmdSZWR1Y2VQYWNrZWQ9ZnVuY3Rpb24odCxlLG4pe3ZvaWQgMD09PW4mJihuPW51bGwpO3ZhciByPW51bGwhPW4/bi5zaGFwZTp0LnNoYXBlLG89JHIocltyLmxlbmd0aC0xXSksYT1uZXcgUmEocixvLGUsbnVsbD09biksaT1udWxsPT1uP1t0XTpbdCxuXSxzPXRoaXMuY29tcGlsZUFuZFJ1bihhLGksXCJpbnQzMlwiKTtyZXR1cm4gcy5yYW5rPT09dC5yYW5rP3RoaXMuYXJnUmVkdWNlUGFja2VkKHQsZSxzKTpzfSxvLnByb3RvdHlwZS5zdW09ZnVuY3Rpb24odCxlKXtDbihcInN1bVwiLGUsdC5yYW5rKTt2YXIgbj1ibih0LnNoYXBlLGUpLHI9blswXSxvPWsoblsxXSksYT10LmFzMkQoLTEsbyksaT1UdCh0LmR0eXBlKTtyZXR1cm4gdGhpcy5yZWR1Y2UoYSxcInN1bVwiLGkpLnJlc2hhcGUocil9LG8ucHJvdG90eXBlLnByb2Q9ZnVuY3Rpb24odCxlKXtpZih0aGlzLnNob3VsZEV4ZWN1dGVPbkNQVShbdF0pKXJldHVybiB0aGlzLmNwdUJhY2tlbmQucHJvZCh0LGUpO3ZhciBuPWJuKHQuc2hhcGUsZSkscj1uWzBdLG89ayhuWzFdKSxhPXQuYXMyRCgtMSxvKSxpPVR0KHQuZHR5cGUpO3JldHVybiB0aGlzLnJlZHVjZShhLFwicHJvZFwiLGkpLnJlc2hhcGUocil9LG8ucHJvdG90eXBlLnVuc29ydGVkU2VnbWVudFN1bT1mdW5jdGlvbih0LGUsbil7dmFyIHI9MCxvPUVuKFtyXSx0LnJhbmspLGE9dDtudWxsIT1vJiYoYT10LnRyYW5zcG9zZShvKSxyPUluKDEsdC5yYW5rKVswXSk7dmFyIGk9ZnVuY3Rpb24odCxlLG4pe2Zvcih2YXIgcj1bXSxvPXQubGVuZ3RoLGE9MDthPG87YSsrKWEhPT1lP3IucHVzaCh0W2FdKTpyLnB1c2gobik7cmV0dXJuIHJ9KGEuc2hhcGUscixuKSxzPWsoW2Euc2hhcGVbcl1dKSx1PWEuYXMyRCgtMSxzKSxjPVR0KHQuZHR5cGUpLGw9dGhpcy5zZWdPcENvbXB1dGUodSxcInVuc29ydGVkU2VnbWVudFN1bVwiLGUsYyxuKS5yZXNoYXBlKGkpO3JldHVybiBudWxsIT1vJiYobD1sLnRyYW5zcG9zZShSbihvKSkpLGx9LG8ucHJvdG90eXBlLnNlZ09wQ29tcHV0ZT1mdW5jdGlvbih0LGUsbixyLG8pe3ZhciBhPXQuc2hhcGVbMF0saT10LnNoYXBlWzFdLHM9ZnVuY3Rpb24odCxlKXt2YXIgbixyPSExO2Zvcih0PD1Zcj8obj10LHI9ITApOm49WSh0LE1hdGguZmxvb3IoTWF0aC5zcXJ0KHQpKSk7IXI7KW4+ZXx8bj09PXQ/cj0hMDpuPVkodCxuKzEpO3JldHVybiBufShpLG8pLHU9bmV3IHVzKHt3aW5kb3dTaXplOnMsaW5TaXplOmksYmF0Y2hTaXplOmEsbnVtU2VnbWVudHM6b30sZSksYz10aGlzLmNvbXBpbGVBbmRSdW4odSxbdCxuXSxyKTtyZXR1cm4gYy5zaGFwZVsxXT09PW8/Yzoobj1LbigwLG8pLnRpbGUoW2kvc10pLHRoaXMuc2VnT3BDb21wdXRlKGMsZSxuLHIsbykpfSxvLnByb3RvdHlwZS5hcmdNaW5NYXhSZWR1Y2U9ZnVuY3Rpb24odCxlLG4pe3ZhciByPVtlXTtpZihDbihcImFyZ1wiK24uY2hhckF0KDApLnRvVXBwZXJDYXNlKCkrbi5zbGljZSgxKSxyLHQucmFuayksIWkoKS5nZXRCb29sKFwiV0VCR0xfUEFDS19SRURVQ0VcIil8fHQucmFuazw9Mil7dmFyIG89Ym4odC5zaGFwZSxyKSxhPW9bMF0scz1rKG9bMV0pLHU9dC5hczJEKC0xLHMpO3JldHVybiB0aGlzLmFyZ1JlZHVjZSh1LG4pLnJlc2hhcGUoYSl9cmV0dXJuIHRoaXMuYXJnUmVkdWNlUGFja2VkKHQsbil9LG8ucHJvdG90eXBlLmFyZ01pbj1mdW5jdGlvbih0LGUpe3JldHVybiB0aGlzLmFyZ01pbk1heFJlZHVjZSh0LGUsXCJtaW5cIil9LG8ucHJvdG90eXBlLmFyZ01heD1mdW5jdGlvbih0LGUpe3JldHVybiB0aGlzLmFyZ01pbk1heFJlZHVjZSh0LGUsXCJtYXhcIil9LG8ucHJvdG90eXBlLmN1bXN1bT1mdW5jdGlvbih0LGUsbixyKXtpZihlIT09dC5yYW5rLTEpdGhyb3cgbmV3IEVycm9yKFwiV2ViR0wgY3Vtc3VtIHNoYWRlciBleHBlY3RzIGFuIGlubmVyLW1vc3QgYXhpcz1cIisodC5yYW5rLTEpK1wiIGJ1dCBnb3QgYXhpcz1cIitlKTt2YXIgbz1uZXcgbmkodC5zaGFwZSxuLHIpO3JldHVybiB0aGlzLmNvbXBpbGVBbmRSdW4obyxbdF0pfSxvLnByb3RvdHlwZS5lcXVhbD1mdW5jdGlvbih0LGUpe2lmKGkoKS5nZXRCb29sKFwiV0VCR0xfUEFDS19CSU5BUllfT1BFUkFUSU9OU1wiKSlyZXR1cm4gdGhpcy5wYWNrZWRCaW5hcnlPcCh0LGUsXCJcXG4gIHJldHVybiB2ZWM0KGVxdWFsKGEsIGIpKTtcXG5cIixcImJvb2xcIik7dmFyIG49bmV3IEJhKFwicmV0dXJuIGZsb2F0KGEgPT0gYik7XCIsdC5zaGFwZSxlLnNoYXBlKTtyZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKG4sW3QsZV0sXCJib29sXCIpfSxvLnByb3RvdHlwZS5ub3RFcXVhbD1mdW5jdGlvbih0LGUpe2lmKGkoKS5nZXRCb29sKFwiV0VCR0xfUEFDS19CSU5BUllfT1BFUkFUSU9OU1wiKSlyZXR1cm4gdGhpcy5wYWNrZWRCaW5hcnlPcCh0LGUsXCJcXG4gIHJldHVybiB2ZWM0KG5vdEVxdWFsKGEsIGIpKTtcXG5cIixcImJvb2xcIik7dmFyIG49bmV3IEJhKFwicmV0dXJuIGZsb2F0KGEgIT0gYik7XCIsdC5zaGFwZSxlLnNoYXBlKTtyZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKG4sW3QsZV0sXCJib29sXCIpfSxvLnByb3RvdHlwZS5sZXNzPWZ1bmN0aW9uKHQsZSl7aWYodGhpcy5zaG91bGRFeGVjdXRlT25DUFUoW3QsZV0pKXJldHVybiB0aGlzLmNwdUJhY2tlbmQubGVzcyh0LGUpO2lmKGkoKS5nZXRCb29sKFwiV0VCR0xfUEFDS19CSU5BUllfT1BFUkFUSU9OU1wiKSlyZXR1cm4gdGhpcy5wYWNrZWRCaW5hcnlPcCh0LGUsXCJcXG4gIHJldHVybiB2ZWM0KGxlc3NUaGFuKGEsIGIpKTtcXG5cIixcImJvb2xcIik7dmFyIG49bmV3IEJhKFwicmV0dXJuIGZsb2F0KGEgPCBiKTtcIix0LnNoYXBlLGUuc2hhcGUpO3JldHVybiB0aGlzLmNvbXBpbGVBbmRSdW4obixbdCxlXSxcImJvb2xcIil9LG8ucHJvdG90eXBlLmxlc3NFcXVhbD1mdW5jdGlvbih0LGUpe2lmKGkoKS5nZXRCb29sKFwiV0VCR0xfUEFDS19CSU5BUllfT1BFUkFUSU9OU1wiKSlyZXR1cm4gdGhpcy5wYWNrZWRCaW5hcnlPcCh0LGUsXCJcXG4gIHJldHVybiB2ZWM0KGxlc3NUaGFuRXF1YWwoYSwgYikpO1xcblwiLFwiYm9vbFwiKTt2YXIgbj1uZXcgQmEoXCJyZXR1cm4gZmxvYXQoYSA8PSBiKTtcIix0LnNoYXBlLGUuc2hhcGUpO3JldHVybiB0aGlzLmNvbXBpbGVBbmRSdW4obixbdCxlXSxcImJvb2xcIil9LG8ucHJvdG90eXBlLmdyZWF0ZXI9ZnVuY3Rpb24odCxlKXtpZih0aGlzLnNob3VsZEV4ZWN1dGVPbkNQVShbdCxlXSkpcmV0dXJuIHRoaXMuY3B1QmFja2VuZC5ncmVhdGVyKHQsZSk7aWYoaSgpLmdldEJvb2woXCJXRUJHTF9QQUNLX0JJTkFSWV9PUEVSQVRJT05TXCIpKXJldHVybiB0aGlzLnBhY2tlZEJpbmFyeU9wKHQsZSxcIlxcbiAgcmV0dXJuIHZlYzQoZ3JlYXRlclRoYW4oYSwgYikpO1xcblwiLFwiYm9vbFwiKTt2YXIgbj1uZXcgQmEoXCJyZXR1cm4gZmxvYXQoYSA+IGIpO1wiLHQuc2hhcGUsZS5zaGFwZSk7cmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bihuLFt0LGVdLFwiYm9vbFwiKX0sby5wcm90b3R5cGUuZ3JlYXRlckVxdWFsPWZ1bmN0aW9uKHQsZSl7aWYoaSgpLmdldEJvb2woXCJXRUJHTF9QQUNLX0JJTkFSWV9PUEVSQVRJT05TXCIpKXJldHVybiB0aGlzLnBhY2tlZEJpbmFyeU9wKHQsZSxcIlxcbiAgcmV0dXJuIHZlYzQoZ3JlYXRlclRoYW5FcXVhbChhLCBiKSk7XFxuXCIsXCJib29sXCIpO3ZhciBuPW5ldyBCYShcInJldHVybiBmbG9hdChhID49IGIpO1wiLHQuc2hhcGUsZS5zaGFwZSk7cmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bihuLFt0LGVdLFwiYm9vbFwiKX0sby5wcm90b3R5cGUubG9naWNhbE5vdD1mdW5jdGlvbih0KXt2YXIgZT1uZXcgQ3ModC5zaGFwZSxcInJldHVybiBmbG9hdCghKHggPj0gMS4wKSk7XCIpO3JldHVybiB0aGlzLmNvbXBpbGVBbmRSdW4oZSxbdF0pfSxvLnByb3RvdHlwZS5sb2dpY2FsQW5kPWZ1bmN0aW9uKHQsZSl7aWYoaSgpLmdldEJvb2woXCJXRUJHTF9QQUNLX0JJTkFSWV9PUEVSQVRJT05TXCIpKXJldHVybiB0aGlzLnBhY2tlZEJpbmFyeU9wKHQsZSxcIlxcbiAgcmV0dXJuIHZlYzQoXFxuICAgIHZlYzQoZ3JlYXRlclRoYW5FcXVhbChhLCB2ZWM0KDEuMCkpKSAqXFxuICAgIHZlYzQoZ3JlYXRlclRoYW5FcXVhbChiLCB2ZWM0KDEuMCkpKSk7XFxuXCIsXCJib29sXCIpO3ZhciBuPW5ldyBCYShcInJldHVybiBmbG9hdChhID49IDEuMCAmJiBiID49IDEuMCk7XCIsdC5zaGFwZSxlLnNoYXBlKTtyZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKG4sW3QsZV0sXCJib29sXCIpfSxvLnByb3RvdHlwZS5sb2dpY2FsT3I9ZnVuY3Rpb24odCxlKXtpZihpKCkuZ2V0Qm9vbChcIldFQkdMX1BBQ0tfQklOQVJZX09QRVJBVElPTlNcIikpcmV0dXJuIHRoaXMucGFja2VkQmluYXJ5T3AodCxlLFwiXFxuICByZXR1cm4gbWluKFxcbiAgICB2ZWM0KGdyZWF0ZXJUaGFuRXF1YWwoYSwgdmVjNCgxLjApKSkgK1xcbiAgICB2ZWM0KGdyZWF0ZXJUaGFuRXF1YWwoYiwgdmVjNCgxLjApKSksXFxuICAgIHZlYzQoMS4wKSk7XFxuXCIsXCJib29sXCIpO3ZhciBuPW5ldyBCYShcInJldHVybiBmbG9hdChhID49IDEuMCB8fCBiID49IDEuMCk7XCIsdC5zaGFwZSxlLnNoYXBlKTtyZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKG4sW3QsZV0sXCJib29sXCIpfSxvLnByb3RvdHlwZS5zZWxlY3Q9ZnVuY3Rpb24odCxlLG4pe3ZhciByPW5ldyBjcyh0LnJhbmssZS5zaGFwZSxlLnJhbmspO3JldHVybiB0aGlzLmNvbXBpbGVBbmRSdW4ocixbdCxlLG5dLER0KGUuZHR5cGUsbi5kdHlwZSkpfSxvLnByb3RvdHlwZS53aGVyZT1mdW5jdGlvbih0KXtkbihcInRmLndoZXJlKCkgaW4gd2ViZ2wgbG9ja3MgdGhlIFVJIHRocmVhZC4gQ2FsbCB0Zi53aGVyZUFzeW5jKCkgaW5zdGVhZFwiKTt2YXIgZT10LmRhdGFTeW5jKCk7cmV0dXJuIG5hKHQuc2hhcGUsZSl9LG8ucHJvdG90eXBlLnRvcGs9ZnVuY3Rpb24odCxlLG4pe3JldHVybiBlYSh0LmRhdGFTeW5jKCksdC5zaGFwZSx0LmR0eXBlLGUpfSxvLnByb3RvdHlwZS5taW49ZnVuY3Rpb24odCxlKXtDbihcIm1pblwiLGUsdC5yYW5rKTt2YXIgbj1ibih0LnNoYXBlLGUpLHI9blswXSxvPWsoblsxXSksYT10LmFzMkQoLTEsbyk7cmV0dXJuIHRoaXMucmVkdWNlKGEsXCJtaW5cIixhLmR0eXBlKS5yZXNoYXBlKHIpfSxvLnByb3RvdHlwZS5taW5pbXVtPWZ1bmN0aW9uKHQsZSl7aWYodGhpcy5zaG91bGRFeGVjdXRlT25DUFUoW3QsZV0pKXJldHVybiB0aGlzLmNwdUJhY2tlbmQubWluaW11bSh0LGUpO3ZhciBuPWkoKS5nZXRCb29sKFwiV0VCR0xfUEFDS19CSU5BUllfT1BFUkFUSU9OU1wiKT9uZXcgTGEoXCJcXG4gIHZlYzQgcmVzdWx0ID0gdmVjNChtaW4oYSwgYikpO1xcbiAgdmVjNCBpc05hTiA9IG1pbih2ZWM0KGlzbmFuKGEpKSArIHZlYzQoaXNuYW4oYikpLCB2ZWM0KDEuMCkpO1xcbiAgXFxuICByZXN1bHQuciA9IGlzTmFOLnIgPiAwLiA/IE5BTiA6IHJlc3VsdC5yO1xcbiAgcmVzdWx0LmcgPSBpc05hTi5nID4gMC4gPyBOQU4gOiByZXN1bHQuZztcXG4gIHJlc3VsdC5iID0gaXNOYU4uYiA+IDAuID8gTkFOIDogcmVzdWx0LmI7XFxuICByZXN1bHQuYSA9IGlzTmFOLmEgPiAwLiA/IE5BTiA6IHJlc3VsdC5hO1xcblxcbiAgcmV0dXJuIHJlc3VsdDtcXG5cIix0LnNoYXBlLGUuc2hhcGUpOm5ldyBCYShcIlxcbiAgaWYgKGlzbmFuKGEpKSByZXR1cm4gYTtcXG4gIGlmIChpc25hbihiKSkgcmV0dXJuIGI7XFxuXFxuICByZXR1cm4gbWluKGEsIGIpO1xcblwiLHQuc2hhcGUsZS5zaGFwZSk7cmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bihuLFt0LGVdKX0sby5wcm90b3R5cGUubW9kPWZ1bmN0aW9uKHQsZSl7dmFyIG49aSgpLmdldEJvb2woXCJXRUJHTF9QQUNLX0JJTkFSWV9PUEVSQVRJT05TXCIpP25ldyBMYShcIlxcbiAgdmVjNCByZXN1bHQgPSBtb2QoYSwgYik7XFxuICB2ZWM0IGlzTmFOID0gdmVjNChlcXVhbChiLCB2ZWM0KDAuMCkpKTtcXG4gIFxcbiAgcmVzdWx0LnIgPSBpc05hTi5yID4gMC4gPyBOQU4gOiByZXN1bHQucjtcXG4gIHJlc3VsdC5nID0gaXNOYU4uZyA+IDAuID8gTkFOIDogcmVzdWx0Lmc7XFxuICByZXN1bHQuYiA9IGlzTmFOLmIgPiAwLiA/IE5BTiA6IHJlc3VsdC5iO1xcbiAgcmVzdWx0LmEgPSBpc05hTi5hID4gMC4gPyBOQU4gOiByZXN1bHQuYTtcXG5cXG4gIHJldHVybiByZXN1bHQ7XFxuXCIsdC5zaGFwZSxlLnNoYXBlKTpuZXcgQmEoXCJpZiAoYiA9PSAwLjApIHJldHVybiBOQU47XFxuICByZXR1cm4gbW9kKGEsIGIpO1wiLHQuc2hhcGUsZS5zaGFwZSk7cmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bihuLFt0LGVdKX0sby5wcm90b3R5cGUubWF4PWZ1bmN0aW9uKHQsZSl7aWYodGhpcy5zaG91bGRFeGVjdXRlT25DUFUoW3RdKSlyZXR1cm4gdGhpcy5jcHVCYWNrZW5kLm1heCh0LGUpO0NuKFwibWF4XCIsZSx0LnJhbmspO3ZhciBuPWJuKHQuc2hhcGUsZSkscj1uWzBdLG89ayhuWzFdKSxhPXQuYXMyRCgtMSxvKTtyZXR1cm4gdGhpcy5yZWR1Y2UoYSxcIm1heFwiLGEuZHR5cGUpLnJlc2hhcGUocil9LG8ucHJvdG90eXBlLm1heGltdW09ZnVuY3Rpb24odCxlKXtpZih0aGlzLnNob3VsZEV4ZWN1dGVPbkNQVShbdCxlXSkpcmV0dXJuIHRoaXMuY3B1QmFja2VuZC5tYXhpbXVtKHQsZSk7dmFyIG49aSgpLmdldEJvb2woXCJXRUJHTF9QQUNLX0JJTkFSWV9PUEVSQVRJT05TXCIpP25ldyBMYShcIlxcbiAgdmVjNCByZXN1bHQgPSB2ZWM0KG1heChhLCBiKSk7XFxuICB2ZWM0IGlzTmFOID0gbWluKHZlYzQoaXNuYW4oYSkpICsgdmVjNChpc25hbihiKSksIHZlYzQoMS4wKSk7XFxuICBcXG4gIHJlc3VsdC5yID0gaXNOYU4uciA+IDAuID8gTkFOIDogcmVzdWx0LnI7XFxuICByZXN1bHQuZyA9IGlzTmFOLmcgPiAwLiA/IE5BTiA6IHJlc3VsdC5nO1xcbiAgcmVzdWx0LmIgPSBpc05hTi5iID4gMC4gPyBOQU4gOiByZXN1bHQuYjtcXG4gIHJlc3VsdC5hID0gaXNOYU4uYSA+IDAuID8gTkFOIDogcmVzdWx0LmE7XFxuXFxuICByZXR1cm4gcmVzdWx0O1xcblwiLHQuc2hhcGUsZS5zaGFwZSk6bmV3IEJhKFwiXFxuICBpZiAoaXNuYW4oYSkpIHJldHVybiBhO1xcbiAgaWYgKGlzbmFuKGIpKSByZXR1cm4gYjtcXG5cXG4gIHJldHVybiBtYXgoYSwgYik7XFxuXCIsdC5zaGFwZSxlLnNoYXBlKTtyZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKG4sW3QsZV0pfSxvLnByb3RvdHlwZS5hbGw9ZnVuY3Rpb24odCxlKXtDbihcImFsbFwiLGUsdC5yYW5rKTt2YXIgbj1ibih0LnNoYXBlLGUpLHI9blswXSxvPWsoblsxXSksYT10LmFzMkQoLTEsbyk7cmV0dXJuIHRoaXMucmVkdWNlKGEsXCJhbGxcIixhLmR0eXBlKS5yZXNoYXBlKHIpfSxvLnByb3RvdHlwZS5hbnk9ZnVuY3Rpb24odCxlKXtDbihcImFueVwiLGUsdC5yYW5rKTt2YXIgbj1ibih0LnNoYXBlLGUpLHI9blswXSxvPWsoblsxXSksYT10LmFzMkQoLTEsbyk7cmV0dXJuIHRoaXMucmVkdWNlKGEsXCJhbnlcIixhLmR0eXBlKS5yZXNoYXBlKHIpfSxvLnByb3RvdHlwZS5yZWFsRGl2aWRlPWZ1bmN0aW9uKHQsZSl7aWYoaSgpLmdldEJvb2woXCJXRUJHTF9QQUNLX0JJTkFSWV9PUEVSQVRJT05TXCIpKXtyZXR1cm4gdGhpcy5wYWNrZWRCaW5hcnlPcCh0LGUsXCJcXG4gIC8vIHZlYzQgb25lID0gdmVjNChlcXVhbChhLCBiKSk7XFxuICAvLyByZXR1cm4gb25lICsgKHZlYzQoMS4wKSAtIG9uZSkgKiBhIC8gYjtcXG4gIHZlYzQgcmVzdWx0ID0gYSAvIGI7XFxuICBpZihhLnggPT0gYi54KSB7XFxuICAgIHJlc3VsdC54ID0gMS47XFxuICB9XFxuICBpZihhLnkgPT0gYi55KSB7XFxuICAgIHJlc3VsdC55ID0gMS47XFxuICB9XFxuICBpZihhLnogPT0gYi56KSB7XFxuICAgIHJlc3VsdC56ID0gMS47XFxuICB9XFxuICBpZihhLncgPT0gYi53KSB7XFxuICAgIHJlc3VsdC53ID0gMS47XFxuICB9XFxuXFxuICByZXR1cm4gcmVzdWx0O1xcblwiLFwiZmxvYXQzMlwiLCEwKX12YXIgbj1uZXcgQmEoXCJcXG5pZiAoYSA9PSBiKSB7XFxuICByZXR1cm4gMS4wO1xcbn07XFxucmV0dXJuIGEgLyBiO1wiLHQuc2hhcGUsZS5zaGFwZSk7cmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bihuLFt0LGVdLFwiZmxvYXQzMlwiKX0sby5wcm90b3R5cGUuZmxvb3JEaXY9ZnVuY3Rpb24odCxlKXtpZihpKCkuZ2V0Qm9vbChcIldFQkdMX1BBQ0tfQklOQVJZX09QRVJBVElPTlNcIikpcmV0dXJuIHRoaXMucGFja2VkQmluYXJ5T3AodCxlLFwiXFxuICBpdmVjNCBpYSA9IHJvdW5kKGEpO1xcbiAgaXZlYzQgaWIgPSByb3VuZChiKTtcXG4gIGJ2ZWM0IGNvbmQgPSBub3RFcXVhbChpYiwgaXZlYzQoMCkpO1xcbiAgaXZlYzQgcmVzdWx0ID0gaXZlYzQoMCk7XFxuICB2ZWM0IHMgPSBzaWduKGEpICogc2lnbihiKTtcXG5cXG4gIC8vIFdpbmRvd3MgKEQzRCkgd2FudHMgZ3VhcmFudGVlZCBub24temVybyBpbnQgZGl2aXNpb24gYXQgY29tcGlsZS10aW1lLlxcbiAgaWYgKGNvbmRbMF0pIHtcXG4gICAgcmVzdWx0WzBdID0gaWRpdihpYVswXSwgaWJbMF0sIHNbMF0pO1xcbiAgfVxcbiAgaWYgKGNvbmRbMV0pIHtcXG4gICAgcmVzdWx0WzFdID0gaWRpdihpYVsxXSwgaWJbMV0sIHNbMV0pO1xcbiAgfVxcbiAgaWYgKGNvbmRbMl0pIHtcXG4gICAgcmVzdWx0WzJdID0gaWRpdihpYVsyXSwgaWJbMl0sIHNbMl0pO1xcbiAgfVxcbiAgaWYgKGNvbmRbM10pIHtcXG4gICAgcmVzdWx0WzNdID0gaWRpdihpYVszXSwgaWJbM10sIHNbM10pO1xcbiAgfVxcbiAgcmV0dXJuIHZlYzQocmVzdWx0KTtcXG5cIixcImludDMyXCIpO3ZhciBuPW5ldyBCYShcIlxcbiAgZmxvYXQgcyA9IHNpZ24oYSkgKiBzaWduKGIpO1xcbiAgaW50IGlhID0gcm91bmQoYSk7XFxuICBpbnQgaWIgPSByb3VuZChiKTtcXG4gIGlmIChpYiAhPSAwKSB7XFxuICAgIC8vIFdpbmRvd3MgKEQzRCkgd2FudHMgZ3VhcmFudGVlZCBub24temVybyBpbnQgZGl2aXNpb24gYXQgY29tcGlsZS10aW1lLlxcbiAgICByZXR1cm4gZmxvYXQoaWRpdihpYSwgaWIsIHMpKTtcXG4gIH0gZWxzZSB7XFxuICAgIHJldHVybiBOQU47XFxuICB9XFxuXCIsdC5zaGFwZSxlLnNoYXBlKTtyZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKG4sW3QsZV0sXCJpbnQzMlwiKX0sby5wcm90b3R5cGUuYWRkPWZ1bmN0aW9uKHQsZSl7aWYoXCJjb21wbGV4NjRcIj09PXQuZHR5cGUmJlwiY29tcGxleDY0XCI9PT1lLmR0eXBlKXJldHVybiB0aGlzLmNvbXBsZXhTZXBhcmFibGVCaW5hcnlPcCh0LGUsRmEpO2lmKHRoaXMuc2hvdWxkRXhlY3V0ZU9uQ1BVKFt0LGVdKSlyZXR1cm4gdGhpcy5jcHVCYWNrZW5kLmFkZCh0LGUpO3ZhciBuPUR0KHQuZHR5cGUsZS5kdHlwZSk7aWYoaSgpLmdldEJvb2woXCJXRUJHTF9QQUNLX0JJTkFSWV9PUEVSQVRJT05TXCIpKXJldHVybiB0aGlzLnBhY2tlZEJpbmFyeU9wKHQsZSxGYSxuKTt2YXIgcj1uZXcgQmEoRmEsdC5zaGFwZSxlLnNoYXBlKTtyZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKHIsW3QsZV0sbil9LG8ucHJvdG90eXBlLnBhY2tlZFVuYXJ5T3A9ZnVuY3Rpb24odCxlLG4pe3ZhciByPW5ldyBYcyh0LnNoYXBlLGUpO3JldHVybiB0aGlzLmNvbXBpbGVBbmRSdW4ocixbdF0sbil9LG8ucHJvdG90eXBlLnBhY2tlZEJpbmFyeU9wPWZ1bmN0aW9uKHQsZSxuLHIsbyl7dm9pZCAwPT09byYmKG89ITEpO3ZhciBhPW5ldyBMYShuLHQuc2hhcGUsZS5zaGFwZSxvKTtyZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKGEsW3QsZV0scil9LG8ucHJvdG90eXBlLmNvbXBsZXhTZXBhcmFibGVCaW5hcnlPcD1mdW5jdGlvbih0LGUsbil7dmFyIHI9dGhpcyxvPXRoaXMudGV4RGF0YS5nZXQodC5kYXRhSWQpLGE9dGhpcy50ZXhEYXRhLmdldChlLmRhdGFJZCksaT1bW28uY29tcGxleFRlbnNvcnMucmVhbCxhLmNvbXBsZXhUZW5zb3JzLnJlYWxdLFtvLmNvbXBsZXhUZW5zb3JzLmltYWcsYS5jb21wbGV4VGVuc29ycy5pbWFnXV0ubWFwKChmdW5jdGlvbihvKXt2YXIgYT1vWzBdLGk9b1sxXSxzPXIubWFrZUNvbXBsZXhDb21wb25lbnRUZW5zb3JJbmZvKHQsYSksdT1yLm1ha2VDb21wbGV4Q29tcG9uZW50VGVuc29ySW5mbyhlLGkpLGM9bmV3IEJhKG4sdC5zaGFwZSxlLnNoYXBlKTtyZXR1cm4gci5jb21waWxlQW5kUnVuKGMsW3MsdV0sRHQoYS5kdHlwZSxpLmR0eXBlKSl9KSkscz1pWzBdLHU9aVsxXSxjPXRoaXMuY29tcGxleChzLHUpO3JldHVybiBzLmRpc3Bvc2UoKSx1LmRpc3Bvc2UoKSxjfSxvLnByb3RvdHlwZS5tYWtlQ29tcGxleENvbXBvbmVudFRlbnNvckluZm89ZnVuY3Rpb24odCxlKXtyZXR1cm57ZGF0YUlkOmUuZGF0YUlkLGR0eXBlOmUuZHR5cGUsc2hhcGU6dC5zaGFwZX19LG8ucHJvdG90eXBlLmFkZE49ZnVuY3Rpb24odCl7aWYoMT09PXQubGVuZ3RoKXJldHVybiB0WzBdO2lmKHQubGVuZ3RoPmkoKS5nZXQoXCJXRUJHTF9NQVhfVEVYVFVSRVNfSU5fU0hBREVSXCIpKXt2YXIgZT1NYXRoLmZsb29yKHQubGVuZ3RoLzIpLG49dGhpcy5hZGROKHQuc2xpY2UoMCxlKSkscj10aGlzLmFkZE4odC5zbGljZShlKSk7cmV0dXJuIHRoaXMuYWRkTihbbixyXSl9dmFyIG89dC5tYXAoKGZ1bmN0aW9uKHQpe3JldHVybiB0LmR0eXBlfSkpLnJlZHVjZSgoZnVuY3Rpb24odCxlKXtyZXR1cm4gRHQodCxlKX0pKSxhPXQubWFwKChmdW5jdGlvbih0KXtyZXR1cm4gdC5zaGFwZX0pKSxzPWkoKS5nZXRCb29sKFwiV0VCR0xfUEFDS1wiKT9uZXcgb2EodFswXS5zaGFwZSxhKTpuZXcgcmEodFswXS5zaGFwZSxhKTtyZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKHMsdCxvKX0sby5wcm90b3R5cGUuc3VidHJhY3Q9ZnVuY3Rpb24odCxlKXtpZihcImNvbXBsZXg2NFwiPT09dC5kdHlwZSYmXCJjb21wbGV4NjRcIj09PWUuZHR5cGUpcmV0dXJuIHRoaXMuY29tcGxleFNlcGFyYWJsZUJpbmFyeU9wKHQsZSxfYSk7aWYodGhpcy5zaG91bGRFeGVjdXRlT25DUFUoW3QsZV0pKXJldHVybiB0aGlzLmNwdUJhY2tlbmQuc3VidHJhY3QodCxlKTt2YXIgbj1EdCh0LmR0eXBlLGUuZHR5cGUpO2lmKGkoKS5nZXRCb29sKFwiV0VCR0xfUEFDS19CSU5BUllfT1BFUkFUSU9OU1wiKSlyZXR1cm4gdGhpcy5wYWNrZWRCaW5hcnlPcCh0LGUsX2EsdC5kdHlwZSk7dmFyIHI9bmV3IEJhKF9hLHQuc2hhcGUsZS5zaGFwZSk7cmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bihyLFt0LGVdLG4pfSxvLnByb3RvdHlwZS5wb3c9ZnVuY3Rpb24odCxlKXt2YXIgbj1pKCkuZ2V0Qm9vbChcIldFQkdMX1BBQ0tfQklOQVJZX09QRVJBVElPTlNcIik/bmV3IExhKFwiXFxuICAvLyBpc01vZFJvdW5kMSBoYXMgMSBmb3IgY29tcG9uZW50cyB3aXRoIHJvdW5kKG1vZChiLCAyLjApKSA9PSAxLCAwIG90aGVyd2lzZS5cXG4gIHZlYzQgaXNNb2RSb3VuZDEgPSB2ZWM0KGVxdWFsKHJvdW5kKG1vZChiLCAyLjApKSwgaXZlYzQoMSkpKTtcXG4gIHZlYzQgbXVsdGlwbGllciA9IHNpZ24oYSkgKiBpc01vZFJvdW5kMSArICh2ZWM0KDEuMCkgLSBpc01vZFJvdW5kMSk7XFxuICB2ZWM0IHJlc3VsdCA9IG11bHRpcGxpZXIgKiBwb3coYWJzKGEpLCBiKTtcXG5cXG4gIC8vIEVuc3VyZSB0aGF0IGFeMCA9IDEsIGluY2x1ZGluZyAwXjAgPSAxIGFzIHRoaXMgY29ycmVzcG9uZCB0byBURiBhbmQgSlNcXG4gIGJ2ZWM0IGlzRXhwWmVybyA9IGVxdWFsKGIsIHZlYzQoMC4wKSk7XFxuICByZXN1bHQuciA9IGlzRXhwWmVyby5yID8gMS4wIDogcmVzdWx0LnI7XFxuICByZXN1bHQuZyA9IGlzRXhwWmVyby5nID8gMS4wIDogcmVzdWx0Lmc7XFxuICByZXN1bHQuYiA9IGlzRXhwWmVyby5iID8gMS4wIDogcmVzdWx0LmI7XFxuICByZXN1bHQuYSA9IGlzRXhwWmVyby5hID8gMS4wIDogcmVzdWx0LmE7XFxuXFxuICB2ZWM0IGlzTmFOID0gdmVjNChsZXNzVGhhbihhLCB2ZWM0KDAuMCkpKSAqIHZlYzQobGVzc1RoYW4oZmxvb3IoYiksIGIpKTtcXG4gIFxcbiAgcmVzdWx0LnIgPSBpc05hTi5yID4gMC4gPyBOQU4gOiByZXN1bHQucjtcXG4gIHJlc3VsdC5nID0gaXNOYU4uZyA+IDAuID8gTkFOIDogcmVzdWx0Lmc7XFxuICByZXN1bHQuYiA9IGlzTmFOLmIgPiAwLiA/IE5BTiA6IHJlc3VsdC5iO1xcbiAgcmVzdWx0LmEgPSBpc05hTi5hID4gMC4gPyBOQU4gOiByZXN1bHQuYTtcXG5cXG4gIHJldHVybiByZXN1bHQ7XFxuXCIsdC5zaGFwZSxlLnNoYXBlKTpuZXcgQmEoXCJcXG5pZihhIDwgMC4wICYmIGZsb29yKGIpIDwgYil7XFxuICByZXR1cm4gTkFOO1xcbn1cXG5pZiAoYiA9PSAwLjApIHtcXG4gIHJldHVybiAxLjA7XFxufVxcbnJldHVybiAocm91bmQobW9kKGIsIDIuMCkpICE9IDEpID9cXG4gICAgcG93KGFicyhhKSwgYikgOiBzaWduKGEpICogcG93KGFicyhhKSwgYik7XFxuXCIsdC5zaGFwZSxlLnNoYXBlKSxyPUR0KHQuZHR5cGUsZS5kdHlwZSk7cmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bihuLFt0LGVdLHIpfSxvLnByb3RvdHlwZS5jZWlsPWZ1bmN0aW9uKHQpe2lmKHRoaXMuc2hvdWxkRXhlY3V0ZU9uQ1BVKFt0XSkpcmV0dXJuIHRoaXMuY3B1QmFja2VuZC5jZWlsKHQpO2lmKGkoKS5nZXRCb29sKFwiV0VCR0xfUEFDS19VTkFSWV9PUEVSQVRJT05TXCIpKXJldHVybiB0aGlzLnBhY2tlZFVuYXJ5T3AodCxOcyx0LmR0eXBlKTt2YXIgZT1uZXcgQ3ModC5zaGFwZSxOcyk7cmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bihlLFt0XSl9LG8ucHJvdG90eXBlLmZsb29yPWZ1bmN0aW9uKHQpe2lmKHRoaXMuc2hvdWxkRXhlY3V0ZU9uQ1BVKFt0XSkpcmV0dXJuIHRoaXMuY3B1QmFja2VuZC5mbG9vcih0KTtpZihpKCkuZ2V0Qm9vbChcIldFQkdMX1BBQ0tfVU5BUllfT1BFUkFUSU9OU1wiKSlyZXR1cm4gdGhpcy5wYWNrZWRVbmFyeU9wKHQsRnMsdC5kdHlwZSk7dmFyIGU9bmV3IENzKHQuc2hhcGUsRnMpO3JldHVybiB0aGlzLmNvbXBpbGVBbmRSdW4oZSxbdF0pfSxvLnByb3RvdHlwZS5zaWduPWZ1bmN0aW9uKHQpe3ZhciBlPW5ldyBDcyh0LnNoYXBlLFwiXFxuICBpZiAoaXNuYW4oeCkpIHsgcmV0dXJuIDAuMDsgfVxcbiAgcmV0dXJuIHNpZ24oeCk7XFxuXCIpO3JldHVybiB0aGlzLmNvbXBpbGVBbmRSdW4oZSxbdF0pfSxvLnByb3RvdHlwZS5pc05hTj1mdW5jdGlvbih0KXt2YXIgZT1uZXcgQ3ModC5zaGFwZSxcInJldHVybiBmbG9hdChpc25hbih4KSk7XCIpO3JldHVybiB0aGlzLmNvbXBpbGVBbmRSdW4oZSxbdF0sXCJib29sXCIpfSxvLnByb3RvdHlwZS5pc0luZj1mdW5jdGlvbih0KXt2YXIgZT1uZXcgQ3ModC5zaGFwZSxcInJldHVybiBmbG9hdChpc2luZih4KSk7XCIpO3JldHVybiB0aGlzLmNvbXBpbGVBbmRSdW4oZSxbdF0sXCJib29sXCIpfSxvLnByb3RvdHlwZS5pc0Zpbml0ZT1mdW5jdGlvbih0KXt2YXIgZT1uZXcgQ3ModC5zaGFwZSxcInJldHVybiBmbG9hdCghaXNuYW4oeCkgJiYgIWlzaW5mKHgpKTtcIik7cmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bihlLFt0XSxcImJvb2xcIil9LG8ucHJvdG90eXBlLnJvdW5kPWZ1bmN0aW9uKHQpe3ZhciBlPW5ldyBDcyh0LnNoYXBlLFwiXFxuICAvLyBPcGVuR0wgRVMgZG9lcyBub3Qgc3VwcG9ydCByb3VuZCBmdW5jdGlvbi5cXG4gIC8vIFRoZSBhbGdvcml0aG0gaXMgYmFzZWQgb24gYmFua2VyJ3Mgcm91bmRpbmcuXFxuICBmbG9hdCBiYXNlID0gZmxvb3IoeCk7XFxuICBpZiAoKHggLSBiYXNlKSA8IDAuNSkge1xcbiAgICByZXR1cm4gZmxvb3IoeCk7XFxuICB9IGVsc2UgaWYgKCh4IC0gYmFzZSkgPiAwLjUpIHtcXG4gICAgcmV0dXJuIGNlaWwoeCk7XFxuICB9IGVsc2Uge1xcbiAgICBpZiAobW9kKGJhc2UsIDIuMCkgPT0gMC4wKSB7XFxuICAgICAgcmV0dXJuIGJhc2U7XFxuICAgIH0gZWxzZSB7XFxuICAgICAgcmV0dXJuIGJhc2UgKyAxLjA7XFxuICAgIH1cXG4gIH1cXG5cIik7cmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bihlLFt0XSl9LG8ucHJvdG90eXBlLmV4cD1mdW5jdGlvbih0KXtpZih0aGlzLnNob3VsZEV4ZWN1dGVPbkNQVShbdF0pKXJldHVybiB0aGlzLmNwdUJhY2tlbmQuZXhwKHQpO2lmKGkoKS5nZXRCb29sKFwiV0VCR0xfUEFDS19VTkFSWV9PUEVSQVRJT05TXCIpKXJldHVybiB0aGlzLnBhY2tlZFVuYXJ5T3AodCxfcyx0LmR0eXBlKTt2YXIgZT1uZXcgQ3ModC5zaGFwZSxfcyk7cmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bihlLFt0XSl9LG8ucHJvdG90eXBlLmV4cG0xPWZ1bmN0aW9uKHQpe2lmKHRoaXMuc2hvdWxkRXhlY3V0ZU9uQ1BVKFt0XSkpcmV0dXJuIHRoaXMuY3B1QmFja2VuZC5leHBtMSh0KTtpZihpKCkuZ2V0Qm9vbChcIldFQkdMX1BBQ0tfVU5BUllfT1BFUkFUSU9OU1wiKSlyZXR1cm4gdGhpcy5wYWNrZWRVbmFyeU9wKHQsT3MsdC5kdHlwZSk7dmFyIGU9bmV3IENzKHQuc2hhcGUsT3MpO3JldHVybiB0aGlzLmNvbXBpbGVBbmRSdW4oZSxbdF0pfSxvLnByb3RvdHlwZS5zb2Z0bWF4PWZ1bmN0aW9uKHQsZSl7dmFyIG49TyhbZV0sdC5zaGFwZSkscj10aGlzLm1heCh0LG4pLG89d24oci5zaGFwZSxuKSxhPXRoaXMuc3VidHJhY3QodCxyLnJlc2hhcGUobykpLGk9dGhpcy5leHAoYSkscz10aGlzLnN1bShpLG4pLnJlc2hhcGUobyk7cmV0dXJuIHRoaXMucmVhbERpdmlkZShpLHMpfSxvLnByb3RvdHlwZS5sb2c9ZnVuY3Rpb24odCl7aWYodGhpcy5zaG91bGRFeGVjdXRlT25DUFUoW3RdKSlyZXR1cm4gdGhpcy5jcHVCYWNrZW5kLmxvZyh0KTtpZihpKCkuZ2V0Qm9vbChcIldFQkdMX1BBQ0tfVU5BUllfT1BFUkFUSU9OU1wiKSlyZXR1cm4gdGhpcy5wYWNrZWRVbmFyeU9wKHQsXCJcXG4gIHZlYzQgcmVzdWx0ID0gbG9nKHgpO1xcbiAgdmVjNCBpc05hTiA9IHZlYzQobGVzc1RoYW4oeCwgdmVjNCgwLjApKSk7XFxuICByZXN1bHQuciA9IGlzTmFOLnIgPT0gMS4wID8gTkFOIDogcmVzdWx0LnI7XFxuICByZXN1bHQuZyA9IGlzTmFOLmcgPT0gMS4wID8gTkFOIDogcmVzdWx0Lmc7XFxuICByZXN1bHQuYiA9IGlzTmFOLmIgPT0gMS4wID8gTkFOIDogcmVzdWx0LmI7XFxuICByZXN1bHQuYSA9IGlzTmFOLmEgPT0gMS4wID8gTkFOIDogcmVzdWx0LmE7XFxuXFxuICByZXR1cm4gcmVzdWx0O1xcblwiLHQuZHR5cGUpO3ZhciBlPW5ldyBDcyh0LnNoYXBlLFwiaWYgKHggPCAwLjApIHJldHVybiBOQU47XFxuICByZXR1cm4gbG9nKHgpO1wiKTtyZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKGUsW3RdKX0sby5wcm90b3R5cGUubG9nMXA9ZnVuY3Rpb24odCl7dmFyIGU9bmV3IENzKHQuc2hhcGUsXCJyZXR1cm4gbG9nKDEuMCArIHgpO1wiKTtyZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKGUsW3RdKX0sby5wcm90b3R5cGUuc3FydD1mdW5jdGlvbih0KXt2YXIgZT1uZXcgQ3ModC5zaGFwZSxcInJldHVybiBzcXJ0KHgpO1wiKTtyZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKGUsW3RdKX0sby5wcm90b3R5cGUucnNxcnQ9ZnVuY3Rpb24odCl7aWYodGhpcy5zaG91bGRFeGVjdXRlT25DUFUoW3RdKSlyZXR1cm4gdGhpcy5jcHVCYWNrZW5kLnJzcXJ0KHQpO3ZhciBlPW5ldyBDcyh0LnNoYXBlLFwicmV0dXJuIGludmVyc2VzcXJ0KHgpO1wiKTtyZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKGUsW3RdKX0sby5wcm90b3R5cGUucmVjaXByb2NhbD1mdW5jdGlvbih0KXt2YXIgZT1uZXcgQ3ModC5zaGFwZSxcInJldHVybiAxLjAgLyB4O1wiKTtyZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKGUsW3RdKX0sby5wcm90b3R5cGUucmVsdT1mdW5jdGlvbih0KXt2YXIgZTtyZXR1cm4gZT1pKCkuZ2V0Qm9vbChcIldFQkdMX1BBQ0tcIik/bmV3IFhzKHQuc2hhcGUscXMpOm5ldyBDcyh0LnNoYXBlLGtzKSx0aGlzLmNvbXBpbGVBbmRSdW4oZSxbdF0pfSxvLnByb3RvdHlwZS5yZWx1Nj1mdW5jdGlvbih0KXt2YXIgZTtyZXR1cm4gZT1pKCkuZ2V0Qm9vbChcIldFQkdMX1BBQ0tcIik/bmV3IFhzKHQuc2hhcGUsS3MpOm5ldyBDcyh0LnNoYXBlLFNzKSx0aGlzLmNvbXBpbGVBbmRSdW4oZSxbdF0pfSxvLnByb3RvdHlwZS5wcmVsdT1mdW5jdGlvbih0LGUpe3ZhciBuPWkoKS5nZXRCb29sKFwiV0VCR0xfUEFDS19CSU5BUllfT1BFUkFUSU9OU1wiKT9uZXcgTGEoUGEsdC5zaGFwZSxlLnNoYXBlKTpuZXcgQmEoTWEsdC5zaGFwZSxlLnNoYXBlKTtyZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKG4sW3QsZV0pfSxvLnByb3RvdHlwZS5lbHU9ZnVuY3Rpb24odCl7aWYoaSgpLmdldEJvb2woXCJXRUJHTF9QQUNLX1VOQVJZX09QRVJBVElPTlNcIikpcmV0dXJuIHRoaXMucGFja2VkVW5hcnlPcCh0LGpzLHQuZHR5cGUpO3ZhciBlPW5ldyBDcyh0LnNoYXBlLEFzKTtyZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKGUsW3RdKX0sby5wcm90b3R5cGUuZWx1RGVyPWZ1bmN0aW9uKHQsZSl7dmFyIG49aSgpLmdldEJvb2woXCJXRUJHTF9QQUNLX0JJTkFSWV9PUEVSQVRJT05TXCIpP25ldyBMYShcIlxcbiAgdmVjNCBiR1RFWmVybyA9IHZlYzQoZ3JlYXRlclRoYW5FcXVhbChiLCB2ZWM0KDAuKSkpO1xcbiAgcmV0dXJuIChiR1RFWmVybyAqIGEpICsgKCh2ZWM0KDEuMCkgLSBiR1RFWmVybykgKiAoYSAqIChiICsgdmVjNCgxLjApKSkpO1xcblwiLHQuc2hhcGUsZS5zaGFwZSk6bmV3IEJhKFwicmV0dXJuIChiID49IDEuMCkgPyBhIDogYSAqIChiICsgMS4wKTtcIix0LnNoYXBlLGUuc2hhcGUpO3JldHVybiB0aGlzLmNvbXBpbGVBbmRSdW4obixbdCxlXSl9LG8ucHJvdG90eXBlLnNlbHU9ZnVuY3Rpb24odCl7dmFyIGU9bmV3IENzKHQuc2hhcGUsRHMpO3JldHVybiB0aGlzLmNvbXBpbGVBbmRSdW4oZSxbdF0pfSxvLnByb3RvdHlwZS5pbnQ9ZnVuY3Rpb24odCl7dmFyIGU9bmV3IENzKHQuc2hhcGUsXCJyZXR1cm4gZmxvYXQoaW50KHgpKTtcIik7cmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bihlLFt0XSxcImludDMyXCIpfSxvLnByb3RvdHlwZS5jbGlwPWZ1bmN0aW9uKHQsZSxuKXt2YXIgcixvPShyPWkoKS5nZXRCb29sKFwiV0VCR0xfUEFDS19DTElQXCIpP25ldyBVYSh0LnNoYXBlKTpuZXcgV2EodC5zaGFwZSkpLmdldEN1c3RvbVNldHVwRnVuYyhlLG4pO3JldHVybiB0aGlzLmNvbXBpbGVBbmRSdW4ocixbdF0sbnVsbCxvKX0sby5wcm90b3R5cGUuYWJzPWZ1bmN0aW9uKHQpe2lmKHRoaXMuc2hvdWxkRXhlY3V0ZU9uQ1BVKFt0XSkpcmV0dXJuIHRoaXMuY3B1QmFja2VuZC5hYnModCk7aWYoaSgpLmdldEJvb2woXCJXRUJHTF9QQUNLX1VOQVJZX09QRVJBVElPTlNcIikpcmV0dXJuIHRoaXMucGFja2VkVW5hcnlPcCh0LElzLHQuZHR5cGUpO3ZhciBlPW5ldyBDcyh0LnNoYXBlLElzKTtyZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKGUsW3RdKX0sby5wcm90b3R5cGUuY29tcGxleEFicz1mdW5jdGlvbih0KXt2YXIgZT10aGlzLnRleERhdGEuZ2V0KHQuZGF0YUlkKSxuPW5ldyBWYSh0LnNoYXBlKSxyPVt0aGlzLm1ha2VDb21wbGV4Q29tcG9uZW50VGVuc29ySW5mbyh0LGUuY29tcGxleFRlbnNvcnMucmVhbCksdGhpcy5tYWtlQ29tcGxleENvbXBvbmVudFRlbnNvckluZm8odCxlLmNvbXBsZXhUZW5zb3JzLmltYWcpXTtyZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKG4scil9LG8ucHJvdG90eXBlLnNpZ21vaWQ9ZnVuY3Rpb24odCl7dmFyIGU9bmV3IENzKHQuc2hhcGUsXCJyZXR1cm4gMS4wIC8gKDEuMCArIGV4cCgtMS4wICogeCkpO1wiKTtyZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKGUsW3RdKX0sby5wcm90b3R5cGUuc29mdHBsdXM9ZnVuY3Rpb24odCl7dmFyIGU9bmV3IENzKHQuc2hhcGUsXCJcXG4gIGZsb2F0IGVwc2lsb24gPSAxLjE5MjA5Mjg5NTUwNzgxMjVlLTc7XFxuICBmbG9hdCB0aHJlc2hvbGQgPSBsb2coZXBzaWxvbikgKyAyLjA7XFxuXFxuICBib29sIHRvb19sYXJnZSA9IHggPiAtdGhyZXNob2xkO1xcbiAgYm9vbCB0b29fc21hbGwgPSB4IDwgdGhyZXNob2xkO1xcblxcbiAgZmxvYXQgcmVzdWx0O1xcbiAgZmxvYXQgZXhwX3ggPSBleHAoeCk7XFxuXFxuICBpZiAodG9vX2xhcmdlKXtcXG4gICAgcmVzdWx0ID0geDtcXG4gIH1cXG4gIGVsc2UgaWYgKHRvb19zbWFsbCl7XFxuICAgIHJlc3VsdCA9IGV4cF94O1xcbiAgfVxcbiAgZWxzZXtcXG4gICAgcmVzdWx0ID0gbG9nKGV4cF94ICsgMS4wKTtcXG4gIH1cXG4gIHJldHVybiByZXN1bHQ7XFxuXCIpO3JldHVybiB0aGlzLmNvbXBpbGVBbmRSdW4oZSxbdF0pfSxvLnByb3RvdHlwZS5zaW49ZnVuY3Rpb24odCl7dmFyIGU9bmV3IENzKHQuc2hhcGUsTXMpO3JldHVybiB0aGlzLmNvbXBpbGVBbmRSdW4oZSxbdF0pfSxvLnByb3RvdHlwZS5jb3M9ZnVuY3Rpb24odCl7dmFyIGU9bmV3IENzKHQuc2hhcGUsQnMpO3JldHVybiB0aGlzLmNvbXBpbGVBbmRSdW4oZSxbdF0pfSxvLnByb3RvdHlwZS50YW49ZnVuY3Rpb24odCl7dmFyIGU9bmV3IENzKHQuc2hhcGUsXCJyZXR1cm4gdGFuKHgpO1wiKTtyZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKGUsW3RdKX0sby5wcm90b3R5cGUuYXNpbj1mdW5jdGlvbih0KXt2YXIgZT1uZXcgQ3ModC5zaGFwZSxQcyk7cmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bihlLFt0XSl9LG8ucHJvdG90eXBlLmFjb3M9ZnVuY3Rpb24odCl7dmFyIGU9bmV3IENzKHQuc2hhcGUsTHMpO3JldHVybiB0aGlzLmNvbXBpbGVBbmRSdW4oZSxbdF0pfSxvLnByb3RvdHlwZS5hdGFuPWZ1bmN0aW9uKHQpe3ZhciBlPW5ldyBDcyh0LnNoYXBlLFdzKTtyZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKGUsW3RdKX0sby5wcm90b3R5cGUuYXRhbjI9ZnVuY3Rpb24odCxlKXt2YXIgbj1pKCkuZ2V0Qm9vbChcIldFQkdMX1BBQ0tfQklOQVJZX09QRVJBVElPTlNcIik/bmV3IExhKFwiXFxuICB2ZWM0IHJlc3VsdCA9IGF0YW4oYSwgYik7XFxuICB2ZWM0IGlzTmFOID0gbWluKHZlYzQoaXNuYW4oYSkpICsgdmVjNChpc25hbihiKSksIHZlYzQoMS4wKSk7XFxuICBcXG4gIHJlc3VsdC5yID0gaXNOYU4uciA+IDAuID8gTkFOIDogcmVzdWx0LnI7XFxuICByZXN1bHQuZyA9IGlzTmFOLmcgPiAwLiA/IE5BTiA6IHJlc3VsdC5nO1xcbiAgcmVzdWx0LmIgPSBpc05hTi5iID4gMC4gPyBOQU4gOiByZXN1bHQuYjtcXG4gIHJlc3VsdC5hID0gaXNOYU4uYSA+IDAuID8gTkFOIDogcmVzdWx0LmE7XFxuXFxuICByZXR1cm4gcmVzdWx0O1xcblwiLHQuc2hhcGUsZS5zaGFwZSk6bmV3IEJhKFwiXFxuICBpZiAoaXNuYW4oYSkpIHJldHVybiBhO1xcbiAgaWYgKGlzbmFuKGIpKSByZXR1cm4gYjtcXG5cXG4gIHJldHVybiBhdGFuKGEsIGIpO1xcblwiLHQuc2hhcGUsZS5zaGFwZSk7cmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bihuLFt0LGVdKX0sby5wcm90b3R5cGUuc2luaD1mdW5jdGlvbih0KXt2YXIgZT1uZXcgQ3ModC5zaGFwZSxcIlxcbiAgZmxvYXQgZTJ4ID0gZXhwKHgpO1xcbiAgcmV0dXJuIChlMnggLSAxLjAgLyBlMngpIC8gMi4wO1xcblwiKTtyZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKGUsW3RdKX0sby5wcm90b3R5cGUuY29zaD1mdW5jdGlvbih0KXt2YXIgZT1uZXcgQ3ModC5zaGFwZSxcIlxcbiAgZmxvYXQgZTJ4ID0gZXhwKC14KTtcXG4gIHJldHVybiAoZTJ4ICsgMS4wIC8gZTJ4KSAvIDIuMDtcXG5cIik7cmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bihlLFt0XSl9LG8ucHJvdG90eXBlLnRhbmg9ZnVuY3Rpb24odCl7dmFyIGU9bmV3IENzKHQuc2hhcGUsXCJcXG4gIGZsb2F0IGUyeCA9IGV4cCgtMi4wICogYWJzKHgpKTtcXG4gIHJldHVybiBzaWduKHgpICogKDEuMCAtIGUyeCkgLyAoMS4wICsgZTJ4KTtcXG5cIik7cmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bihlLFt0XSl9LG8ucHJvdG90eXBlLmFzaW5oPWZ1bmN0aW9uKHQpe3ZhciBlPW5ldyBDcyh0LnNoYXBlLFVzKTtyZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKGUsW3RdKX0sby5wcm90b3R5cGUuYWNvc2g9ZnVuY3Rpb24odCl7dmFyIGU9bmV3IENzKHQuc2hhcGUsVnMpO3JldHVybiB0aGlzLmNvbXBpbGVBbmRSdW4oZSxbdF0pfSxvLnByb3RvdHlwZS5hdGFuaD1mdW5jdGlvbih0KXt2YXIgZT1uZXcgQ3ModC5zaGFwZSx6cyk7cmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bihlLFt0XSl9LG8ucHJvdG90eXBlLmVyZj1mdW5jdGlvbih0KXt2YXIgZT1uZXcgQ3ModC5zaGFwZSwnXFxuICAvLyBFcnJvciBmdW5jdGlvbiBpcyBjYWxjdWxhdGVkIGFwcHJveGltYXRlbHkgd2l0aCBlbGVtZW50YXJ5IGZ1bmN0aW9uLlxcbiAgLy8gU2VlIFwiSGFuZGJvb2sgb2YgTWF0aGVtYXRpY2FsIEZ1bmN0aW9ucyB3aXRoIEZvcm11bGFzLFxcbiAgLy8gR3JhcGhzLCBhbmQgTWF0aGVtYXRpY2FsIFRhYmxlc1wiLCBBYnJhbW93aXR6IGFuZCBTdGVndW4uXFxuICBmbG9hdCBwID0gMC4zMjc1OTExO1xcbiAgZmxvYXQgYTEgPSAwLjI1NDgyOTU5MjtcXG4gIGZsb2F0IGEyID0gLTAuMjg0NDk2NzM2O1xcbiAgZmxvYXQgYTMgPSAxLjQyMTQxMzc0MTtcXG4gIGZsb2F0IGE0ID0gLTEuNDUzMTUyMDI3O1xcbiAgZmxvYXQgYTUgPSAxLjA2MTQwNTQyOTtcXG5cXG4gIGZsb2F0IHNpZ24gPSBzaWduKHgpO1xcbiAgeCA9IGFicyh4KTtcXG4gIGZsb2F0IHQgPSAxLjAgLyAoMS4wICsgcCAqIHgpO1xcbiAgcmV0dXJuIHNpZ24gKiAoMS4wIC0gKCgoKChhNSp0ICsgYTQpKnQpICsgYTMpKnQgKyBhMikqdCArIGExKSp0KmV4cCgteCp4KSk7XFxuJyk7cmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bihlLFt0XSl9LG8ucHJvdG90eXBlLnN0ZXA9ZnVuY3Rpb24odCxlKXt2YXIgbj1uZXcgQ3ModC5zaGFwZSxmdW5jdGlvbih0KXtyZXR1cm4gdm9pZCAwPT09dCYmKHQ9MCksRXMrXCJcXG4gICAgcmV0dXJuIHggPiAwLjAgPyAxLjAgOiBmbG9hdChcIit0K1wiKTtcXG4gIFwifShlKSk7cmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bihuLFt0XSl9LG8ucHJvdG90eXBlLmNvbnYyZEJ5TWF0TXVsPWZ1bmN0aW9uKHQsZSxuLHIsbyxhKXt2YXIgcz10LnNoYXBlLHU9dGhpcy50ZXhEYXRhLmdldCh0LmRhdGFJZCksYz1uLmluQ2hhbm5lbHMsbD1zWzBdKnNbMV0qc1syXSxoPW4ub3V0Q2hhbm5lbHMsZj1cImNoYW5uZWxzTGFzdFwiPT09bi5kYXRhRm9ybWF0LGQ9KDE9PT1sfHwxPT09aCkmJmM+MWUzLHA9c1syXSUyIT0wJiYhIXUuaXNQYWNrZWQ7aWYoZHx8IWkoKS5nZXRCb29sKFwiV0VCR0xfTEFaSUxZX1VOUEFDS1wiKXx8IWkoKS5nZXRCb29sKFwiV0VCR0xfUEFDS19CSU5BUllfT1BFUkFUSU9OU1wiKXx8IXApe3ZhciB2PWY/c1swXSpzWzFdKnNbMl06c1swXSpzWzJdKnNbM10sbT10aGlzLnJlc2hhcGUodCxbMSx2LG4uaW5DaGFubmVsc10pLGc9dGhpcy5yZXNoYXBlKGUsWzEsbi5pbkNoYW5uZWxzLG4ub3V0Q2hhbm5lbHNdKTtyZXR1cm4gdGhpcy5yZXNoYXBlKHRoaXMuZnVzZWRCYXRjaE1hdE11bCh7YTptLGI6Zyx0cmFuc3Bvc2VBOiExLHRyYW5zcG9zZUI6ITEsYmlhczpyLGFjdGl2YXRpb246byxwcmVsdUFjdGl2YXRpb25XZWlnaHRzOmF9KSxuLm91dFNoYXBlKX12YXIgeT1mP3NbMF0qc1sxXSooc1syXSsxKTpzWzBdKnNbMl0qKHNbM10rMSkseD17ZGF0YUlkOnQuZGF0YUlkLHNoYXBlOlsxLHksbi5pbkNoYW5uZWxzXSxkdHlwZTp0LmR0eXBlfSxiPXUuc2hhcGU7dS5zaGFwZT11LnNoYXBlLnNsaWNlKCksdS5zaGFwZVt1LnNoYXBlLmxlbmd0aC0yXSsrLEMoX2UodS5zaGFwZSx4LnNoYXBlKSwoZnVuY3Rpb24oKXtyZXR1cm5cInBhY2tlZCByZXNoYXBlIFwiK3Uuc2hhcGUrXCIgdG8gXCIreC5zaGFwZStcIiBpc24ndCBmcmVlXCJ9KSk7dmFyIHc9dGhpcy5yZXNoYXBlKGUsWzEsbi5pbkNoYW5uZWxzLG4ub3V0Q2hhbm5lbHNdKSxFPXRoaXMuZnVzZWRCYXRjaE1hdE11bCh7YTp4LGI6dyx0cmFuc3Bvc2VBOiExLHRyYW5zcG9zZUI6ITEsYmlhczpyLGFjdGl2YXRpb246byxwcmVsdUFjdGl2YXRpb25XZWlnaHRzOmF9KSxSPXRoaXMudGV4RGF0YS5nZXQoRS5kYXRhSWQpO3JldHVybiBDKFIuaXNQYWNrZWQsKGZ1bmN0aW9uKCl7cmV0dXJuXCJiYXRjaE1hdE11bCByZXN1bHQgaXMgZXhwZWN0ZWQgdG8gYmUgcGFja2VkXCJ9KSksdS5zaGFwZT1iLFIuc2hhcGU9bi5vdXRTaGFwZSxMdC5tYWtlVGVuc29yRnJvbURhdGFJZChFLmRhdGFJZCxuLm91dFNoYXBlLEUuZHR5cGUpfSxvLnByb3RvdHlwZS5jb252MmRXaXRoSW0yUm93PWZ1bmN0aW9uKHQsZSxuLHIsbyxhKXt2YXIgaT1uLmZpbHRlcldpZHRoLHM9bi5maWx0ZXJIZWlnaHQsdT1uLmluQ2hhbm5lbHMsYz1uLm91dFdpZHRoLGw9bi5vdXRIZWlnaHQsaD1cImNoYW5uZWxzTGFzdFwiPT09bi5kYXRhRm9ybWF0LGY9aSpzKnUsZD1sKmMscD1bZixkXSx2PXQuc3F1ZWV6ZShbMF0pLG09ZS5yZXNoYXBlKFsxLGYsLTFdKSxnPW5ldyBMaShwLHYuc2hhcGUsbikseT10aGlzLmNvbXBpbGVBbmRSdW4oZyxbdl0pLnJlc2hhcGUoWzEscFswXSxwWzFdXSkseD1udWxsIT1yLGI9bnVsbCE9YSx3PW8/UXMobywhMCk6bnVsbCxDPW5ldyBIaSh5LnNoYXBlLFsxLGQsbi5vdXRDaGFubmVsc10sITAsITEseCx3LGIpLEU9W3ksbV07ciYmRS5wdXNoKHIpLGImJkUucHVzaChhKTt2YXIgUj10aGlzLmNvbXBpbGVBbmRSdW4oQyxFKTtyZXR1cm4gaD9SLnJlc2hhcGUoWzEsbCxjLG4ub3V0Q2hhbm5lbHNdKTpSLnJlc2hhcGUoWzEsbi5vdXRDaGFubmVscyxsLGNdKX0sby5wcm90b3R5cGUuZnVzZWRDb252MmQ9ZnVuY3Rpb24odCl7dmFyIGU9dC5pbnB1dCxuPXQuZmlsdGVyLHI9dC5jb252SW5mbyxvPXQuYmlhcyxhPXQuYWN0aXZhdGlvbixzPXQucHJlbHVBY3RpdmF0aW9uV2VpZ2h0cztpZigxPT09ci5maWx0ZXJIZWlnaHQmJjE9PT1yLmZpbHRlcldpZHRoJiYxPT09ci5kaWxhdGlvbkhlaWdodCYmMT09PXIuZGlsYXRpb25XaWR0aCYmMT09PXIuc3RyaWRlSGVpZ2h0JiYxPT09ci5zdHJpZGVXaWR0aCYmKFwiU0FNRVwiPT09ci5wYWRJbmZvLnR5cGV8fFwiVkFMSURcIj09PXIucGFkSW5mby50eXBlKSlyZXR1cm4gdGhpcy5jb252MmRCeU1hdE11bChlLG4scixvLGEscyk7aWYoaSgpLmdldEJvb2woXCJXRUJHTF9DT05WX0lNMkNPTFwiKSYmMT09PWUuc2hhcGVbMF0pcmV0dXJuIHRoaXMuY29udjJkV2l0aEltMlJvdyhlLG4scixvLGEscyk7dmFyIHU9bnVsbCE9byxjPW51bGwhPXMsbD1hP1FzKGEsITEpOm51bGwsaD1uZXcgUWEocix1LGwsYyksZj1bZSxuXTtyZXR1cm4gbyYmZi5wdXNoKG8pLHMmJmYucHVzaChzKSx0aGlzLmNvbXBpbGVBbmRSdW4oaCxmKX0sby5wcm90b3R5cGUuY29udjJkPWZ1bmN0aW9uKHQsZSxuKXtpZigxPT09bi5maWx0ZXJIZWlnaHQmJjE9PT1uLmZpbHRlcldpZHRoJiYxPT09bi5kaWxhdGlvbkhlaWdodCYmMT09PW4uZGlsYXRpb25XaWR0aCYmMT09PW4uc3RyaWRlSGVpZ2h0JiYxPT09bi5zdHJpZGVXaWR0aCYmKFwiU0FNRVwiPT09bi5wYWRJbmZvLnR5cGV8fFwiVkFMSURcIj09PW4ucGFkSW5mby50eXBlKSlyZXR1cm4gdGhpcy5jb252MmRCeU1hdE11bCh0LGUsbik7aWYoaSgpLmdldEJvb2woXCJXRUJHTF9DT05WX0lNMkNPTFwiKSYmMT09PXQuc2hhcGVbMF0pcmV0dXJuIHRoaXMuY29udjJkV2l0aEltMlJvdyh0LGUsbik7dmFyIHI9bmV3IFFhKG4pO3JldHVybiB0aGlzLmNvbXBpbGVBbmRSdW4ocixbdCxlXSl9LG8ucHJvdG90eXBlLmNvbnYyZERlcklucHV0PWZ1bmN0aW9uKHQsZSxuKXt2YXIgcj1uZXcgS2Eobik7cmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bihyLFt0LGVdKX0sby5wcm90b3R5cGUuY29udjJkRGVyRmlsdGVyPWZ1bmN0aW9uKHQsZSxuKXt2YXIgcj1uZXcgcWEobik7cmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bihyLFt0LGVdKX0sby5wcm90b3R5cGUuZnVzZWREZXB0aHdpc2VDb252MkQ9ZnVuY3Rpb24odCl7dmFyIGUsbj10LmlucHV0LHI9dC5maWx0ZXIsbz10LmNvbnZJbmZvLGE9dC5iaWFzLHM9dC5hY3RpdmF0aW9uLHU9dC5wcmVsdUFjdGl2YXRpb25XZWlnaHRzLGM9aSgpLmdldEJvb2woXCJXRUJHTF9QQUNLX0RFUFRIV0lTRUNPTlZcIikmJm8uc3RyaWRlV2lkdGg8PTImJm8ub3V0Q2hhbm5lbHMvby5pbkNoYW5uZWxzPT0xLGw9cz9RcyhzLGMpOm51bGwsaD1bbixyXSxmPW51bGwhPWEsZD1udWxsIT11O3JldHVybiBmJiZoLnB1c2goYSksZCYmaC5wdXNoKHUpLGM/KGU9bmV3IHRpKG8sZixsLGQpLHRoaXMuY29tcGlsZUFuZFJ1bihlLGgpKTooZT1uZXcgWmEobyxmLGwsZCksdGhpcy5jb21waWxlQW5kUnVuKGUsaCkpfSxvLnByb3RvdHlwZS5kZXB0aHdpc2VDb252MkQ9ZnVuY3Rpb24odCxlLG4pe3ZhciByO3JldHVybiBpKCkuZ2V0Qm9vbChcIldFQkdMX1BBQ0tfREVQVEhXSVNFQ09OVlwiKSYmbi5zdHJpZGVXaWR0aDw9MiYmbi5vdXRDaGFubmVscy9uLmluQ2hhbm5lbHM9PTE/KHI9bmV3IHRpKG4pLHRoaXMuY29tcGlsZUFuZFJ1bihyLFt0LGVdKSk6KHI9bmV3IFphKG4pLHRoaXMuY29tcGlsZUFuZFJ1bihyLFt0LGVdKSl9LG8ucHJvdG90eXBlLmRlcHRod2lzZUNvbnYyRERlcklucHV0PWZ1bmN0aW9uKHQsZSxuKXt2YXIgcj1uZXcgJGEobik7cmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bihyLFt0LGVdKX0sby5wcm90b3R5cGUuZGVwdGh3aXNlQ29udjJERGVyRmlsdGVyPWZ1bmN0aW9uKHQsZSxuKXt2YXIgcj1uZXcgWWEobik7cmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bihyLFt0LGVdKX0sby5wcm90b3R5cGUuY29udjNkPWZ1bmN0aW9uKHQsZSxuKXt2YXIgcj1uZXcgSmEobik7cmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bihyLFt0LGVdKX0sby5wcm90b3R5cGUuY29udjNkRGVySW5wdXQ9ZnVuY3Rpb24odCxlLG4pe3ZhciByPW5ldyBYYShuKTtyZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKHIsW3QsZV0pfSxvLnByb3RvdHlwZS5jb252M2REZXJGaWx0ZXI9ZnVuY3Rpb24odCxlLG4pe3ZhciByPW5ldyBqYShuKTtyZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKHIsW3QsZV0pfSxvLnByb3RvdHlwZS5tYXhQb29sPWZ1bmN0aW9uKHQsZSl7dmFyIG49bmV3ICRpKGUsXCJtYXhcIiwhMSk7cmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bihuLFt0XSl9LG8ucHJvdG90eXBlLmF2Z1Bvb2w9ZnVuY3Rpb24odCxlKXt2YXIgbj1uZXcgJGkoZSxcImF2Z1wiLCExKTtyZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKG4sW3RdLFwiZmxvYXQzMlwiKX0sby5wcm90b3R5cGUubWF4UG9vbEJhY2twcm9wPWZ1bmN0aW9uKHQsZSxuLHIpe3ZhciBvPW5ldyAkaShyLFwibWF4XCIsITApLGE9dGhpcy5jb21waWxlQW5kUnVuKG8sW2VdKSxpPW5ldyB6aShyKSxzPXRoaXMuY29tcGlsZUFuZFJ1bihpLFt0LGFdLGUuZHR5cGUpO3JldHVybiBhLmRpc3Bvc2UoKSxzfSxvLnByb3RvdHlwZS5hdmdQb29sQmFja3Byb3A9ZnVuY3Rpb24odCxlLG4pe3ZhciByPW5ldyBJYShuKTtyZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKHIsW3RdLGUuZHR5cGUpfSxvLnByb3RvdHlwZS5jYXN0PWZ1bmN0aW9uKHQsZSl7cmV0dXJuIFBvKHQsZSx0aGlzKX0sby5wcm90b3R5cGUudW5zdGFjaz1mdW5jdGlvbih0LGUpe2Zvcih2YXIgbj10LnNoYXBlW2VdLHI9bmV3IEFycmF5KHQucmFuay0xKSxvPTAsYT0wO2E8dC5yYW5rO2ErKylhIT09ZSYmKHJbbysrXT10LnNoYXBlW2FdKTt2YXIgaT1uZXcgQXJyYXkodC5yYW5rKS5maWxsKDApLHM9dC5zaGFwZS5zbGljZSgpO3NbZV09MTt2YXIgdT1uZXcgQXJyYXkobik7Zm9yKGE9MDthPHUubGVuZ3RoO2ErKylpW2VdPWEsdVthXT10aGlzLnNsaWNlKHQsaSxzKS5yZXNoYXBlKHIpO3JldHVybiB1fSxvLnByb3RvdHlwZS5hdmdQb29sM2Q9ZnVuY3Rpb24odCxlKXt2YXIgbj1uZXcgUWkoZSxcImF2Z1wiLCExKTtyZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKG4sW3RdLFwiZmxvYXQzMlwiKX0sby5wcm90b3R5cGUuYXZnUG9vbDNkQmFja3Byb3A9ZnVuY3Rpb24odCxlLG4pe3ZhciByPW5ldyBrYShuKTtyZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKHIsW3RdLGUuZHR5cGUpfSxvLnByb3RvdHlwZS5tYXhQb29sM2Q9ZnVuY3Rpb24odCxlKXt2YXIgbj1uZXcgUWkoZSxcIm1heFwiLCExKTtyZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKG4sW3RdLFwiZmxvYXQzMlwiKX0sby5wcm90b3R5cGUubWF4UG9vbDNkQmFja3Byb3A9ZnVuY3Rpb24odCxlLG4scil7dmFyIG89bmV3IFFpKHIsXCJtYXhcIiwhMCksYT10aGlzLmNvbXBpbGVBbmRSdW4obyxbZV0pLGk9bmV3IEdpKHIpLHM9dGhpcy5jb21waWxlQW5kUnVuKGksW3QsYV0sZS5kdHlwZSk7cmV0dXJuIGEuZGlzcG9zZSgpLHN9LG8ucHJvdG90eXBlLnJlc2hhcGU9ZnVuY3Rpb24odCxlKXt2YXIgbj10aGlzLnRleERhdGEuZ2V0KHQuZGF0YUlkKTtpZihuLmlzUGFja2VkJiYhX2UodC5zaGFwZSxlKSYmKG51bGw9PT1uLnRleHR1cmV8fCFfZShuLnNoYXBlLGUpKSl7dmFyIHI9dGhpcy5wYWNrZWRSZXNoYXBlKHQsZSk7cmV0dXJuIEx0Lm1ha2VUZW5zb3JGcm9tRGF0YUlkKHIuZGF0YUlkLHIuc2hhcGUsci5kdHlwZSl9cmV0dXJuIExvKHQsZSl9LG8ucHJvdG90eXBlLnJlc2l6ZUJpbGluZWFyPWZ1bmN0aW9uKHQsZSxuLHIpe3ZhciBvPWkoKS5nZXRCb29sKFwiV0VCR0xfUEFDS19JTUFHRV9PUEVSQVRJT05TXCIpP25ldyBucyh0LnNoYXBlLGUsbixyKTpuZXcgZXModC5zaGFwZSxlLG4scik7cmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bihvLFt0XSxcImZsb2F0MzJcIil9LG8ucHJvdG90eXBlLnJlc2l6ZUJpbGluZWFyQmFja3Byb3A9ZnVuY3Rpb24odCxlLG4pe3ZhciByPW5ldyB0cyh0LGUsbik7cmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bihyLFt0XSl9LG8ucHJvdG90eXBlLnJlc2l6ZU5lYXJlc3ROZWlnaGJvcj1mdW5jdGlvbih0LGUsbixyKXt2YXIgbz1uZXcgb3ModC5zaGFwZSxlLG4scik7cmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bihvLFt0XSl9LG8ucHJvdG90eXBlLnJlc2l6ZU5lYXJlc3ROZWlnaGJvckJhY2twcm9wPWZ1bmN0aW9uKHQsZSxuKXt2YXIgcj1uZXcgcnModCxlLG4pO3JldHVybiB0aGlzLmNvbXBpbGVBbmRSdW4ocixbdF0pfSxvLnByb3RvdHlwZS5tdWx0aW5vbWlhbD1mdW5jdGlvbih0LGUsbixyKXt2YXIgbz1lP3Q6Z28odCksYT1vLnNoYXBlWzBdLGk9by5zaGFwZVsxXSxzPW5ldyBxaShhLGksbiksdT1zLmdldEN1c3RvbVNldHVwRnVuYyhyKTtyZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKHMsW29dLFwiaW50MzJcIix1KX0sby5wcm90b3R5cGUub25lSG90PWZ1bmN0aW9uKHQsZSxuLHIpe3ZhciBvPW5ldyBLaSh0LnNpemUsZSxuLHIpO3JldHVybiB0aGlzLmNvbXBpbGVBbmRSdW4obyxbdF0pfSxvLnByb3RvdHlwZS5kaWFnPWZ1bmN0aW9uKHQpe3ZhciBlPW5ldyBzaSh0LnNpemUpO3JldHVybiB0aGlzLmNvbXBpbGVBbmRSdW4oZSxbdF0pfSxvLnByb3RvdHlwZS5ub25NYXhTdXBwcmVzc2lvbj1mdW5jdGlvbih0LGUsbixyLG8pe3JldHVybiBkbihcInRmLm5vbk1heFN1cHByZXNzaW9uKCkgaW4gd2ViZ2wgbG9ja3MgdGhlIFVJIHRocmVhZC4gQ2FsbCB0Zi5ub25NYXhTdXBwcmVzc2lvbkFzeW5jKCkgaW5zdGVhZFwiKSxqbyh0LmRhdGFTeW5jKCksZS5kYXRhU3luYygpLG4scixvKX0sby5wcm90b3R5cGUuY3JvcEFuZFJlc2l6ZT1mdW5jdGlvbih0LGUsbixyLG8sYSl7dmFyIGk9bmV3IGVpKHQuc2hhcGUsZS5zaGFwZSxyLG8sYSk7cmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bihpLFt0LGUsbl0sXCJmbG9hdDMyXCIpfSxvLnByb3RvdHlwZS5kZXB0aFRvU3BhY2U9ZnVuY3Rpb24odCxlLG4pe0MoZT4xLChmdW5jdGlvbigpe3JldHVyblwiYmxvY2tTaXplIHNob3VsZCBiZSA+IDEgZm9yIGRlcHRoVG9TcGFjZSwgYnV0IHdhczogXCIrZX0pKTt2YXIgcj10LnNoYXBlWzBdLG89XCJOSFdDXCI9PT1uP3Quc2hhcGVbMV06dC5zaGFwZVsyXSxhPVwiTkhXQ1wiPT09bj90LnNoYXBlWzJdOnQuc2hhcGVbM10saT1cIk5IV0NcIj09PW4/dC5zaGFwZVszXTp0LnNoYXBlWzFdLHM9byplLHU9YSplLGM9aS8oZSplKSxsPW5ldyBpaShcIk5IV0NcIj09PW4/W3Iscyx1LGNdOltyLGMscyx1XSxlLG4pO3JldHVybiB0aGlzLmNvbXBpbGVBbmRSdW4obCxbdF0pfSxvLnByb3RvdHlwZS5zcGxpdD1mdW5jdGlvbih0LGUsbil7cmV0dXJuIFpvKHQsZSxuKX0sby5wcm90b3R5cGUuc2NhdHRlck5EPWZ1bmN0aW9uKHQsZSxuKXt2YXIgcj1acigwLHQsbiksbz1yLnNsaWNlUmFuayxhPXIubnVtVXBkYXRlcyxpPXIuc2xpY2VTaXplLHM9ci5zdHJpZGVzLHU9ci5vdXRwdXRTaXplLGM9W3UvaSxpXSxsPXQucmVzaGFwZShbYSxvXSksaD1lLnJlc2hhcGUoW2EsaV0pO2lmKDA9PT11KXJldHVybiBMbyhGbihbXSksbik7dmFyIGY9T24oMCksZD1uZXcgc3MoYSxvLGwucmFuayxoLnJhbmsscyxjKTtyZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKGQsW2gsbCxmXSkucmVzaGFwZShuKX0sby5wcm90b3R5cGUuc3BhcnNlVG9EZW5zZT1mdW5jdGlvbih0LGUsbixyKXt2YXIgbz1acigwLHQsbiksYT1vLnNsaWNlUmFuayxpPW8ubnVtVXBkYXRlcyxzPW8uc3RyaWRlcyx1PW8ub3V0cHV0U2l6ZSxjPW5ldyBzcyhpLGEsdC5yYW5rLGUucmFuayxzLFt1LDFdLCExKTtyZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKGMsW2UsdCxyXSkucmVzaGFwZShuKX0sby5wcm90b3R5cGUuZmZ0PWZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLmZmdEltcGwodCwhMSl9LG8ucHJvdG90eXBlLmlmZnQ9ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMuZmZ0SW1wbCh0LCEwKX0sby5wcm90b3R5cGUuZmZ0SW1wbD1mdW5jdGlvbih0LGUpe3ZhciBuPXRoaXMudGV4RGF0YS5nZXQodC5kYXRhSWQpLHI9bmV3IHBpKGZpLHQuc2hhcGUsZSksbz1uZXcgcGkoZGksdC5zaGFwZSxlKSxhPVt0aGlzLm1ha2VDb21wbGV4Q29tcG9uZW50VGVuc29ySW5mbyh0LG4uY29tcGxleFRlbnNvcnMucmVhbCksdGhpcy5tYWtlQ29tcGxleENvbXBvbmVudFRlbnNvckluZm8odCxuLmNvbXBsZXhUZW5zb3JzLmltYWcpXSxpPXRoaXMuY29tcGlsZUFuZFJ1bihyLGEpLHM9dGhpcy5jb21waWxlQW5kUnVuKG8sYSksdT10aGlzLmNvbXBsZXgoaSxzKS5hczJEKHQuc2hhcGVbMF0sdC5zaGFwZVsxXSk7cmV0dXJuIGkuZGlzcG9zZSgpLHMuZGlzcG9zZSgpLHV9LG8ucHJvdG90eXBlLmdhdGhlck5EPWZ1bmN0aW9uKHQsZSl7dmFyIG49ZS5zaGFwZSxyPW5bbi5sZW5ndGgtMV0sbz1qcih0LGUpLGE9b1swXSxpPW9bMV0scz1vWzJdLHU9b1szXSxjPWUucmVzaGFwZShbaSxyXSksbD10LnJlc2hhcGUoW3Quc2l6ZS9zLHNdKSxoPW5ldyBnaShyLHUsW2ksc10pO3JldHVybiB0aGlzLmNvbXBpbGVBbmRSdW4oaCxbbCxjXSkucmVzaGFwZShhKX0sby5wcm90b3R5cGUuZmlsbD1mdW5jdGlvbih0LGUsbil7aWYoXCJzdHJpbmdcIj09PShuPW58fGooZSkpKXt2YXIgcj1QKG4sayh0KSk7cmV0dXJuIHIuZmlsbChlKSxMdC5tYWtlVGVuc29yKHIsdCxuLHRoaXMpfXZhciBvPW5ldyB2aSh0LGUpLGE9by5nZXRDdXN0b21TZXR1cEZ1bmMoZSk7cmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bihvLFtdLG4sYSl9LG8ucHJvdG90eXBlLm9uZXNMaWtlPWZ1bmN0aW9uKHQpe2lmKFwic3RyaW5nXCI9PT10LmR0eXBlKXRocm93IG5ldyBFcnJvcihcIm9uZXNMaWtlIGlzIG5vdCBzdXBwb3J0ZWQgdW5kZXIgc3RyaW5nIGR0eXBlXCIpO3JldHVybiB0aGlzLmZpbGwodC5zaGFwZSwxLHQuZHR5cGUpfSxvLnByb3RvdHlwZS56ZXJvc0xpa2U9ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMuZmlsbCh0LnNoYXBlLFwic3RyaW5nXCI9PT10LmR0eXBlP1wiXCI6MCx0LmR0eXBlKX0sby5wcm90b3R5cGUubGluc3BhY2U9ZnVuY3Rpb24odCxlLG4pe3JldHVybiBXbyh0LGUsbil9LG8ucHJvdG90eXBlLm1ha2VUZW5zb3JJbmZvPWZ1bmN0aW9uKHQsZSl7dmFyIG49dGhpcy53cml0ZShudWxsLHQsZSk7cmV0dXJuIHRoaXMudGV4RGF0YS5nZXQobikudXNhZ2U9bnVsbCx7ZGF0YUlkOm4sc2hhcGU6dCxkdHlwZTplfX0sby5wcm90b3R5cGUubWFrZU91dHB1dD1mdW5jdGlvbih0LGUpe3ZhciBuPXRoaXMubWFrZVRlbnNvckluZm8odCxlKS5kYXRhSWQ7cmV0dXJuIEx0Lm1ha2VUZW5zb3JGcm9tRGF0YUlkKG4sdCxlLHRoaXMpfSxvLnByb3RvdHlwZS51bnBhY2tUZW5zb3I9ZnVuY3Rpb24odCl7dmFyIGU9bmV3IFlzKHQuc2hhcGUpO3JldHVybiB0aGlzLnJ1bldlYkdMUHJvZ3JhbShlLFt0XSx0LmR0eXBlKX0sby5wcm90b3R5cGUucGFja1RlbnNvcj1mdW5jdGlvbih0KXt2YXIgZT1uZXcgamkodC5zaGFwZSk7cmV0dXJuIHRoaXMucnVuV2ViR0xQcm9ncmFtKGUsW3RdLHQuZHR5cGUsbnVsbCwhMCl9LG8ucHJvdG90eXBlLnBhY2tlZFJlc2hhcGU9ZnVuY3Rpb24odCxlKXt2YXIgbj1bQWUodC5zaGFwZSldLmNvbmNhdChEZSh0LnNoYXBlKSkscj17ZHR5cGU6dC5kdHlwZSxzaGFwZTpuLGRhdGFJZDp0LmRhdGFJZH0sbz1bQWUoZSldLmNvbmNhdChEZShlKSksYT1uZXcgWmkobyxuKSxpPXRoaXMucnVuV2ViR0xQcm9ncmFtKGEsW3JdLHQuZHR5cGUsbnVsbCwhMCk7cmV0dXJue2RhdGFJZDppLmRhdGFJZCxzaGFwZTplLGR0eXBlOmkuZHR5cGV9fSxvLnByb3RvdHlwZS5kZWNvZGU9ZnVuY3Rpb24odCl7dmFyIGUsbj10aGlzLnRleERhdGEuZ2V0KHQpLHI9bi5pc1BhY2tlZCxvPW4uc2hhcGUsYT1uLmR0eXBlLGk9VGUobyk7ZT1yP25ldyBhaShpKTpuZXcgb2koaSk7cmV0dXJue2R0eXBlOmEsc2hhcGU6byxkYXRhSWQ6dGhpcy5ydW5XZWJHTFByb2dyYW0oZSxbe3NoYXBlOmksZHR5cGU6YSxkYXRhSWQ6dH1dLGEsbnVsbCwhMCkuZGF0YUlkfX0sby5wcm90b3R5cGUucnVuV2ViR0xQcm9ncmFtPWZ1bmN0aW9uKHQsZSxuLHIsbyl7dmFyIGE9dGhpczt2b2lkIDA9PT1vJiYobz0hMSk7dmFyIHM9dGhpcy5tYWtlVGVuc29ySW5mbyh0Lm91dHB1dFNoYXBlLG4pLHU9dGhpcy50ZXhEYXRhLmdldChzLmRhdGFJZCk7aWYodC5wYWNrZWRPdXRwdXQmJih1LmlzUGFja2VkPSEwKSx0Lm91dFBhY2tpbmdTY2hlbWU9PT1WdC5ERU5TRSl7dmFyIGM9WXQodC5vdXRwdXRTaGFwZSk7dS50ZXhTaGFwZT1jLm1hcCgoZnVuY3Rpb24odCl7cmV0dXJuIDIqdH0pKX1pZihudWxsIT10Lm91dFRleFVzYWdlJiYodS51c2FnZT10Lm91dFRleFVzYWdlKSwwPT09ayhzLnNoYXBlKSlyZXR1cm4gdS52YWx1ZXM9QihzLmR0eXBlLDApLHM7dmFyIGw9W10saD1lLm1hcCgoZnVuY3Rpb24oZSl7aWYoXCJjb21wbGV4NjRcIj09PWUuZHR5cGUpdGhyb3cgbmV3IEVycm9yKFwiR1BHUFVQcm9ncmFtIGRvZXMgbm90IHN1cHBvcnQgY29tcGxleDY0IGlucHV0LiBGb3IgY29tcGxleDY0IGR0eXBlcywgcGxlYXNlIHNlcGFyYXRlIHRoZSBwcm9ncmFtIGludG8gcmVhbCBhbmQgaW1hZ2luYXJ5IHBhcnRzLlwiKTt2YXIgbj1hLnRleERhdGEuZ2V0KGUuZGF0YUlkKTtpZihudWxsPT1uLnRleHR1cmUpe2lmKCF0LnBhY2tlZElucHV0cyYmayhlLnNoYXBlKTw9aSgpLmdldE51bWJlcihcIldFQkdMX1NJWkVfVVBMT0FEX1VOSUZPUk1cIikpcmV0dXJue3NoYXBlOmUuc2hhcGUsdGV4RGF0YTpudWxsLGlzVW5pZm9ybTohMCx1bmlmb3JtVmFsdWVzOm4udmFsdWVzfTt0LnBhY2tlZElucHV0cyYmKG4uaXNQYWNrZWQ9ITAsbi5zaGFwZT1lLnNoYXBlKX1lbHNlIGlmKCEhbi5pc1BhY2tlZCE9ISF0LnBhY2tlZElucHV0cyllPW4uaXNQYWNrZWQ/YS51bnBhY2tUZW5zb3IoZSk6YS5wYWNrVGVuc29yKGUpLGwucHVzaChlKSxuPWEudGV4RGF0YS5nZXQoZS5kYXRhSWQpO2Vsc2UgaWYobi5pc1BhY2tlZCYmIV9lKG4uc2hhcGUsZS5zaGFwZSkpe3ZhciByPWUsbz1lLnNoYXBlO2Uuc2hhcGU9bi5zaGFwZSxlPWEucGFja2VkUmVzaGFwZShlLG8pLGwucHVzaChlKSxuPWEudGV4RGF0YS5nZXQoZS5kYXRhSWQpLHIuc2hhcGU9b31yZXR1cm4gYS51cGxvYWRUb0dQVShlLmRhdGFJZCkse3NoYXBlOmUuc2hhcGUsdGV4RGF0YTpuLGlzVW5pZm9ybTohMX19KSk7dGhpcy51cGxvYWRUb0dQVShzLmRhdGFJZCk7dmFyIGYsZD17c2hhcGU6cy5zaGFwZSx0ZXhEYXRhOnUsaXNVbmlmb3JtOiExfSxwPWZ1bmN0aW9uKHQsZSxuKXt2YXIgcj1cIlwiO2UuY29uY2F0KG4pLmZvckVhY2goKGZ1bmN0aW9uKHQpe3ZhciBlPW51bGwhPXQudGV4RGF0YSYmbnVsbCE9dC50ZXhEYXRhLnNsaWNlJiZ0LnRleERhdGEuc2xpY2UuZmxhdE9mZnNldD4wLG49dC5pc1VuaWZvcm0/XCJ1bmlmb3JtXCI6dC50ZXhEYXRhLnRleFNoYXBlO3IrPXQuc2hhcGUrXCJfXCIrbitcIl9cIitlfSkpO3ZhciBvPXQudXNlckNvZGUsYT10LmNvbnN0cnVjdG9yLm5hbWU7cmV0dXJuIGErPVwiX1wiK3IrXCJfXCIrb30odCxoLGQpLHY9dGhpcy5nZXRBbmRTYXZlQmluYXJ5KHAsKGZ1bmN0aW9uKCl7cmV0dXJuIGZ1bmN0aW9uKHQsZSxuLHIpe3ZhciBvPWUudXNlckNvZGUsYT1uLm1hcCgoZnVuY3Rpb24odCxuKXt2YXIgcj17bG9naWNhbFNoYXBlOnQuc2hhcGUsdGV4U2hhcGU6dC5pc1VuaWZvcm0/bnVsbDp0LnRleERhdGEudGV4U2hhcGUsaXNVbmlmb3JtOnQuaXNVbmlmb3JtLGlzUGFja2VkOiF0LmlzVW5pZm9ybSYmdC50ZXhEYXRhLmlzUGFja2VkLGZsYXRPZmZzZXQ6bnVsbH07cmV0dXJuIG51bGwhPXQudGV4RGF0YSYmbnVsbCE9dC50ZXhEYXRhLnNsaWNlJiZ0LnRleERhdGEuc2xpY2UuZmxhdE9mZnNldD4wJiYoci5mbGF0T2Zmc2V0PXQudGV4RGF0YS5zbGljZS5mbGF0T2Zmc2V0KSx7bmFtZTplLnZhcmlhYmxlTmFtZXNbbl0sc2hhcGVJbmZvOnJ9fSkpLHM9YS5tYXAoKGZ1bmN0aW9uKHQpe3JldHVybiB0LnNoYXBlSW5mb30pKSx1PXtsb2dpY2FsU2hhcGU6ci5zaGFwZSx0ZXhTaGFwZTpyLnRleERhdGEudGV4U2hhcGUsaXNVbmlmb3JtOiExLGlzUGFja2VkOnIudGV4RGF0YS5pc1BhY2tlZCxmbGF0T2Zmc2V0Om51bGx9LGM9ZmEoYSx1LG8sZS5wYWNrZWRJbnB1dHMpLGw9dC5jcmVhdGVQcm9ncmFtKGMpLGg9bnVsbCxmPXQuZ2V0VW5pZm9ybUxvY2F0aW9uKGwsXCJOQU5cIiwhMSk7MT09PWkoKS5nZXROdW1iZXIoXCJXRUJHTF9WRVJTSU9OXCIpJiYoaD10LmdldFVuaWZvcm1Mb2NhdGlvbihsLFwiSU5GSU5JVFlcIiwhMSkpO2Zvcih2YXIgZD17fSxwPTA7cDxlLnZhcmlhYmxlTmFtZXMubGVuZ3RoO3ArKyl7dmFyIHY9ZS52YXJpYWJsZU5hbWVzW3BdO2Rbdl09dC5nZXRVbmlmb3JtTG9jYXRpb24obCx2LCExKSxkW1wib2Zmc2V0XCIrdl09dC5nZXRVbmlmb3JtTG9jYXRpb24obCxcIm9mZnNldFwiK3YsITEpfXJldHVybntwcm9ncmFtOmUsc291cmNlOmMsd2ViR0xQcm9ncmFtOmwsdW5pZm9ybUxvY2F0aW9uczpkLGluU2hhcGVJbmZvczpzLG91dFNoYXBlSW5mbzp1LGluZkxvYzpoLG5hbkxvYzpmfX0oYS5ncGdwdSx0LGgsZCl9KSksbT1udWxsIT10aGlzLmFjdGl2ZVRpbWVycztpZihtJiYoZj10aGlzLnN0YXJ0VGltZXIoKSksZnVuY3Rpb24odCxlLG4scixvKXtQaShlLmluU2hhcGVJbmZvcyxuKSxQaShbZS5vdXRTaGFwZUluZm9dLFtyXSk7dmFyIGE9ci50ZXhEYXRhLnRleHR1cmUscz1yLnRleERhdGEudGV4U2hhcGU7ci50ZXhEYXRhLmlzUGFja2VkP3Quc2V0T3V0cHV0UGFja2VkTWF0cml4VGV4dHVyZShhLHNbMF0sc1sxXSk6dC5zZXRPdXRwdXRNYXRyaXhUZXh0dXJlKGEsc1swXSxzWzFdKSx0LnNldFByb2dyYW0oZS53ZWJHTFByb2dyYW0pLDE9PT1pKCkuZ2V0TnVtYmVyKFwiV0VCR0xfVkVSU0lPTlwiKSYmbnVsbCE9PWUuaW5mTG9jJiZ0LmdsLnVuaWZvcm0xZihlLmluZkxvYywxLzApLG51bGwhPT1lLm5hbkxvYyYmdC5nbC51bmlmb3JtMWYoZS5uYW5Mb2MsTmFOKSxuLmZvckVhY2goKGZ1bmN0aW9uKG4scil7dmFyIG89ZS5wcm9ncmFtLnZhcmlhYmxlTmFtZXNbcl0sYT1lLnVuaWZvcm1Mb2NhdGlvbnNbb10saT1lLnVuaWZvcm1Mb2NhdGlvbnNbXCJvZmZzZXRcIitvXTtpZihudWxsIT1hKWlmKG4uaXNVbmlmb3JtKWlmKGsobi5zaGFwZSk8Mil0LmdsLnVuaWZvcm0xZihhLG4udW5pZm9ybVZhbHVlc1swXSk7ZWxzZXt2YXIgcz1uLnVuaWZvcm1WYWx1ZXM7cyBpbnN0YW5jZW9mIEZsb2F0MzJBcnJheXx8KHM9bmV3IEZsb2F0MzJBcnJheShzKSksdC5nbC51bmlmb3JtMWZ2KGEscyl9ZWxzZSBudWxsIT1uLnRleERhdGEuc2xpY2UmJm51bGwhPWkmJnQuZ2wudW5pZm9ybTFpKGksbi50ZXhEYXRhLnNsaWNlLmZsYXRPZmZzZXQpLHQuc2V0SW5wdXRNYXRyaXhUZXh0dXJlKG4udGV4RGF0YS50ZXh0dXJlLGEscil9KSksbnVsbCE9byYmbyh0LGUud2ViR0xQcm9ncmFtKSx0LmV4ZWN1dGVQcm9ncmFtKCl9KHRoaXMuZ3BncHUsdixoLGQsciksbC5mb3JFYWNoKChmdW5jdGlvbih0KXtyZXR1cm4gYS5kaXNwb3NlRGF0YSh0LmRhdGFJZCl9KSksbSYmKGY9dGhpcy5lbmRUaW1lcihmKSx0aGlzLmFjdGl2ZVRpbWVycy5wdXNoKHtuYW1lOnQuY29uc3RydWN0b3IubmFtZSxxdWVyeTp0aGlzLmdldFF1ZXJ5VGltZShmKX0pKSwhaSgpLmdldEJvb2woXCJXRUJHTF9MQVpJTFlfVU5QQUNLXCIpJiZ1LmlzUGFja2VkJiYhMT09PW8pe3ZhciBnPXRoaXMudW5wYWNrVGVuc29yKHMpO3JldHVybiB0aGlzLmRpc3Bvc2VEYXRhKHMuZGF0YUlkKSxnfXJldHVybiBzfSxvLnByb3RvdHlwZS5jb21waWxlQW5kUnVuPWZ1bmN0aW9uKHQsZSxuLHIsbyl7dm9pZCAwPT09byYmKG89ITEpLG49bnx8ZVswXS5kdHlwZTt2YXIgYT10aGlzLnJ1bldlYkdMUHJvZ3JhbSh0LGUsbixyLG8pO3JldHVybiBMdC5tYWtlVGVuc29yRnJvbURhdGFJZChhLmRhdGFJZCxhLnNoYXBlLGEuZHR5cGUpfSxvLnByb3RvdHlwZS5nZXRBbmRTYXZlQmluYXJ5PWZ1bmN0aW9uKHQsZSl7cmV0dXJuIHQgaW4gdGhpcy5iaW5hcnlDYWNoZXx8KHRoaXMuYmluYXJ5Q2FjaGVbdF09ZSgpKSx0aGlzLmJpbmFyeUNhY2hlW3RdfSxvLnByb3RvdHlwZS5nZXRUZXh0dXJlTWFuYWdlcj1mdW5jdGlvbigpe3JldHVybiB0aGlzLnRleHR1cmVNYW5hZ2VyfSxvLnByb3RvdHlwZS5kaXNwb3NlPWZ1bmN0aW9uKCl7dmFyIHQ9dGhpcztpZighdGhpcy5kaXNwb3NlZCl7aWYoIWkoKS5nZXRCb29sKFwiSVNfVEVTVFwiKSlPYmplY3Qua2V5cyh0aGlzLmJpbmFyeUNhY2hlKS5mb3JFYWNoKChmdW5jdGlvbihlKXt0LmdwZ3B1LmRlbGV0ZVByb2dyYW0odC5iaW5hcnlDYWNoZVtlXS53ZWJHTFByb2dyYW0pLGRlbGV0ZSB0LmJpbmFyeUNhY2hlW2VdfSkpO3RoaXMudGV4dHVyZU1hbmFnZXIuZGlzcG9zZSgpLG51bGwhPXRoaXMuY2FudmFzJiZcInVuZGVmaW5lZFwiIT10eXBlb2YgSFRNTENhbnZhc0VsZW1lbnQmJnRoaXMuY2FudmFzIGluc3RhbmNlb2YgSFRNTENhbnZhc0VsZW1lbnQ/dGhpcy5jYW52YXMucmVtb3ZlKCk6dGhpcy5jYW52YXM9bnVsbCx0aGlzLmdwZ3B1Q3JlYXRlZExvY2FsbHkmJih0aGlzLmdwZ3B1LnByb2dyYW09bnVsbCx0aGlzLmdwZ3B1LmRpc3Bvc2UoKSksdGhpcy5kaXNwb3NlZD0hMH19LG8ucHJvdG90eXBlLmZsb2F0UHJlY2lzaW9uPWZ1bmN0aW9uKCl7dmFyIHQ9dGhpcztyZXR1cm4gbnVsbD09dGhpcy5mbG9hdFByZWNpc2lvblZhbHVlJiYodGhpcy5mbG9hdFByZWNpc2lvblZhbHVlPVplKChmdW5jdGlvbigpe2lmKCFpKCkuZ2V0KFwiV0VCR0xfUkVOREVSX0ZMT0FUMzJfRU5BQkxFRFwiKSl7dmFyIGU9aSgpLmdldEJvb2woXCJERUJVR1wiKTtpKCkuc2V0KFwiREVCVUdcIiwhMSk7dmFyIG49dC5hYnMoT24oMWUtOCkpLmRhdGFTeW5jKClbMF07aWYoaSgpLnNldChcIkRFQlVHXCIsZSksbj4wKXJldHVybiAzMn1yZXR1cm4gMTZ9KSkpLHRoaXMuZmxvYXRQcmVjaXNpb25WYWx1ZX0sby5wcm90b3R5cGUuZXBzaWxvbj1mdW5jdGlvbigpe3JldHVybiAzMj09PXRoaXMuZmxvYXRQcmVjaXNpb24oKT8xZS03OjFlLTR9LG8ucHJvdG90eXBlLnVwbG9hZFRvR1BVPWZ1bmN0aW9uKHQpe3ZhciBlLG49dGhpcy50ZXhEYXRhLmdldCh0KSxyPW4uc2hhcGUsbz1uLmR0eXBlLGE9bi52YWx1ZXMsaT1uLnRleHR1cmUscz1uLnVzYWdlLHU9bi5pc1BhY2tlZDtpZihudWxsPT1pKXt2YXIgYyxsPW51bGwhPXRoaXMuYWN0aXZlVGltZXJzO2wmJihjPWV0KCkpO3ZhciBoPW4udGV4U2hhcGU7aWYobnVsbD09aCYmKGg9TmUocix1KSxuLnRleFNoYXBlPWgpLG51bGwhPWEpe3ZhciBmPVRlKHIpLGQ9dm9pZCAwLHA9aFsxXSx2PWhbMF0sbT1hIGluc3RhbmNlb2YgVWludDhBcnJheTt1PyhwPShlPSR0KGhbMF0saFsxXSkpWzBdLHY9ZVsxXSxkPW5ldyBoaShmLFt2LHBdLG0pKTpkPW5ldyBsaShmLFt2LHBdLG0pO3ZhciBnPXRoaXMubWFrZVRlbnNvckluZm8oW3YscF0sbyk7dGhpcy50ZXhEYXRhLmdldChnLmRhdGFJZCkudXNhZ2U9bT96dC5QSVhFTFM6enQuVVBMT0FELHRoaXMuZ3BncHUudXBsb2FkRGVuc2VNYXRyaXhUb1RleHR1cmUodGhpcy5nZXRUZXh0dXJlKGcuZGF0YUlkKSxwLHYsYSk7dmFyIHk9dGhpcy5ydW5XZWJHTFByb2dyYW0oZCxbZ10sbyxudWxsLCEwKSx4PXRoaXMudGV4RGF0YS5nZXQoeS5kYXRhSWQpO24udGV4dHVyZT14LnRleHR1cmUsbi50ZXhTaGFwZT14LnRleFNoYXBlLG4uaXNQYWNrZWQ9eC5pc1BhY2tlZCxuLnVzYWdlPXgudXNhZ2UsdGhpcy5kaXNwb3NlRGF0YShnLmRhdGFJZCksdGhpcy50ZXhEYXRhLmRlbGV0ZSh5LmRhdGFJZCksbi52YWx1ZXM9bnVsbCxsJiYodGhpcy51cGxvYWRXYWl0TXMrPWV0KCktYyl9ZWxzZXt2YXIgYj10aGlzLmFjcXVpcmVUZXh0dXJlKGgscyxvLHUpO24udGV4dHVyZT1ifX19LG8ucHJvdG90eXBlLmNvbnZlcnRBbmRDYWNoZU9uQ1BVPWZ1bmN0aW9uKHQsZSl7dmFyIG49dGhpcy50ZXhEYXRhLmdldCh0KSxyPW4uZHR5cGU7cmV0dXJuIHRoaXMucmVsZWFzZUdQVURhdGEodCksbnVsbCE9ZSYmKG4udmFsdWVzPWZ1bmN0aW9uKHQsZSl7aWYoXCJmbG9hdDMyXCI9PT1lfHxcImNvbXBsZXg2NFwiPT09ZSlyZXR1cm4gdDtpZihcImludDMyXCI9PT1lfHxcImJvb2xcIj09PWUpe2Zvcih2YXIgbj1cImludDMyXCI9PT1lP25ldyBJbnQzMkFycmF5KHQubGVuZ3RoKTpuZXcgVWludDhBcnJheSh0Lmxlbmd0aCkscj0wO3I8bi5sZW5ndGg7KytyKW5bcl09TWF0aC5yb3VuZCh0W3JdKTtyZXR1cm4gbn10aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIGR0eXBlIFwiK2UpfShlLHIpKSxuLnZhbHVlc30sby5wcm90b3R5cGUuYWNxdWlyZVRleHR1cmU9ZnVuY3Rpb24odCxlLG4scil7aWYodGhpcy5udW1CeXRlc0luR1BVKz10aGlzLmNvbXB1dGVCeXRlcyh0LG4pLCF0aGlzLndhcm5lZEFib3V0TWVtb3J5JiZ0aGlzLm51bUJ5dGVzSW5HUFU+MTAyNCp0aGlzLm51bU1CQmVmb3JlV2FybmluZyoxMDI0KXt2YXIgbz0odGhpcy5udW1CeXRlc0luR1BVLzEwMjQvMTAyNCkudG9GaXhlZCgyKTt0aGlzLndhcm5lZEFib3V0TWVtb3J5PSEwLGNvbnNvbGUud2FybihcIkhpZ2ggbWVtb3J5IHVzYWdlIGluIEdQVTogXCIrbytcIiBNQiwgbW9zdCBsaWtlbHkgZHVlIHRvIGEgbWVtb3J5IGxlYWtcIil9cmV0dXJuIHRoaXMudGV4dHVyZU1hbmFnZXIuYWNxdWlyZVRleHR1cmUodCxlLHIpfSxvLnByb3RvdHlwZS5jb21wdXRlQnl0ZXM9ZnVuY3Rpb24odCxlKXtyZXR1cm4gdFswXSp0WzFdKnooZSl9LG99KGJvKTtXdCgpJiZMdC5yZWdpc3RlckJhY2tlbmQoXCJ3ZWJnbFwiLChmdW5jdGlvbigpe3JldHVybiBuZXcgWnN9KSwyKTt2YXIgdHU9QW4oe3NxdWFyZV86ZnVuY3Rpb24odCl7dmFyIGU9bW4odCxcInhcIixcInNxdWFyZVwiKSxuPVtlXTtyZXR1cm4gTHQucnVuS2VybmVsRnVuYygoZnVuY3Rpb24odCxuKXtyZXR1cm4gbihbZV0pLHQuc3F1YXJlKGUpfSkse3g6ZX0sbnVsbCxcIlNxdWFyZVwiLHt9LG4sW10pfX0pLGV1PVwiU3F1YXJlZERpZmZlcmVuY2VcIjt2YXIgbnU9QW4oe3NxdWFyZWREaWZmZXJlbmNlXzpmdW5jdGlvbih0LGUpe3ZhciBuLHI9bW4odCxcImFcIixcInNxdWFyZWREaWZmZXJlbmNlXCIpLG89bW4oZSxcImJcIixcInNxdWFyZWREaWZmZXJlbmNlXCIpO249TnQocixvKSxyPW5bMF0sbz1uWzFdLFJvKHIuc2hhcGUsby5zaGFwZSk7dmFyIGE9e2E6cixiOm99LGk9W3Isb107cmV0dXJuIEx0LnJ1bktlcm5lbEZ1bmMoKGZ1bmN0aW9uKHQsZSl7dmFyIG49dC5zcXVhcmVkRGlmZmVyZW5jZShyLG8pO3JldHVybiBlKFtyLG9dKSxufSksYSwoZnVuY3Rpb24odCxlKXt2YXIgbj1lWzBdLHI9ZVsxXSxvPU9uKDIpO3JldHVybnthOmZ1bmN0aW9uKCl7cmV0dXJuIHQubXVsKG4uc3ViKHIpLm11bChvKSl9LGI6ZnVuY3Rpb24oKXtyZXR1cm4gdC5tdWwoci5zdWIobikubXVsKG8pKX19fSksZXUse30saSxbXSl9fSk7dmFyIHJ1PUFuKHthYnNfOmZ1bmN0aW9uKHQpe3ZhciBlPW1uKHQsXCJ4XCIsXCJhYnNcIik7cmV0dXJuXCJjb21wbGV4NjRcIj09PWUuZHR5cGU/THQucnVuS2VybmVsRnVuYygoZnVuY3Rpb24odCl7cmV0dXJuIHQuY29tcGxleEFicyhlKX0pLHskeDplfSk6THQucnVuS2VybmVsRnVuYygoZnVuY3Rpb24odCxuKXt2YXIgcj10LmFicyhlKTtyZXR1cm4gbihbZV0pLHJ9KSx7eDplfSwoZnVuY3Rpb24odCxlKXt2YXIgbj1lWzBdO3JldHVybnt4OmZ1bmN0aW9uKCl7cmV0dXJuIHQubXVsKG4udG9GbG9hdCgpLnN0ZXAoLTEpKX19fSksXCJBYnNcIil9fSksb3U9QW4oe2Fjb3NfOmZ1bmN0aW9uKHQpe3ZhciBlPW1uKHQsXCJ4XCIsXCJhY29zXCIpO3JldHVybiBMdC5ydW5LZXJuZWxGdW5jKChmdW5jdGlvbih0LG4pe3ZhciByPXQuYWNvcyhlKTtyZXR1cm4gbihbZV0pLHJ9KSx7JHg6ZX0sKGZ1bmN0aW9uKHQsZSl7dmFyIG49ZVswXTtyZXR1cm57JHg6ZnVuY3Rpb24oKXtyZXR1cm4gdC5kaXZTdHJpY3QoT24oMSkuc3ViKG4udG9GbG9hdCgpLnNxdWFyZSgpKS5zcXJ0KCkpLm5lZygpfX19KSl9fSksYXU9QW4oe2Fjb3NoXzpmdW5jdGlvbih0KXt2YXIgZT1tbih0LFwieFwiLFwiYWNvc2hcIik7cmV0dXJuIEx0LnJ1bktlcm5lbEZ1bmMoKGZ1bmN0aW9uKHQsbil7dmFyIHI9dC5hY29zaChlKTtyZXR1cm4gbihbZV0pLHJ9KSx7JHg6ZX0sKGZ1bmN0aW9uKHQsZSl7dmFyIG49ZVswXTtyZXR1cm57JHg6ZnVuY3Rpb24oKXtyZXR1cm4gdC5kaXZTdHJpY3Qobi50b0Zsb2F0KCkuc3F1YXJlKCkuc3ViKDEpLnNxcnQoKSl9fX0pKX19KSxpdT1Bbih7YXNpbl86ZnVuY3Rpb24odCl7dmFyIGU9bW4odCxcInhcIixcImFzaW5cIik7cmV0dXJuIEx0LnJ1bktlcm5lbEZ1bmMoKGZ1bmN0aW9uKHQsbil7dmFyIHI9dC5hc2luKGUpO3JldHVybiBuKFtlXSkscn0pLHskeDplfSwoZnVuY3Rpb24odCxlKXt2YXIgbj1lWzBdO3JldHVybnskeDpmdW5jdGlvbigpe3JldHVybiB0LmRpdlN0cmljdChPbigxKS5zdWIobi50b0Zsb2F0KCkuc3F1YXJlKCkpLnNxcnQoKSl9fX0pKX19KSxzdT1Bbih7YXNpbmhfOmZ1bmN0aW9uKHQpe3ZhciBlPW1uKHQsXCJ4XCIsXCJhc2luaFwiKTtyZXR1cm4gTHQucnVuS2VybmVsRnVuYygoZnVuY3Rpb24odCxuKXt2YXIgcj10LmFzaW5oKGUpO3JldHVybiBuKFtlXSkscn0pLHskeDplfSwoZnVuY3Rpb24odCxlKXt2YXIgbj1lWzBdO3JldHVybnskeDpmdW5jdGlvbigpe3JldHVybiB0LmRpdlN0cmljdChPbigxKS5hZGQobi50b0Zsb2F0KCkuc3F1YXJlKCkpLnNxcnQoKSl9fX0pKX19KSx1dT1Bbih7YXRhbl86ZnVuY3Rpb24odCl7dmFyIGU9bW4odCxcInhcIixcImF0YW5cIik7cmV0dXJuIEx0LnJ1bktlcm5lbEZ1bmMoKGZ1bmN0aW9uKHQsbil7dmFyIHI9dC5hdGFuKGUpO3JldHVybiBuKFtlXSkscn0pLHskeDplfSwoZnVuY3Rpb24odCxlKXt2YXIgbj1lWzBdO3JldHVybnskeDpmdW5jdGlvbigpe3JldHVybiB0LmRpdihuLnRvRmxvYXQoKS5zcXVhcmUoKS5hZGQoMSkpfX19KSl9fSksY3U9QW4oe2F0YW5oXzpmdW5jdGlvbih0KXt2YXIgZT1tbih0LFwieFwiLFwiYXRhbmhcIik7cmV0dXJuIEx0LnJ1bktlcm5lbEZ1bmMoKGZ1bmN0aW9uKHQsbil7dmFyIHI9dC5hdGFuaChlKTtyZXR1cm4gbihbZV0pLHJ9KSx7JHg6ZX0sKGZ1bmN0aW9uKHQsZSl7dmFyIG49ZVswXTtyZXR1cm57JHg6ZnVuY3Rpb24oKXtyZXR1cm4gdC5kaXYoT24oMSkuc3ViKG4udG9GbG9hdCgpLnNxdWFyZSgpKSl9fX0pKX19KSxsdT1Bbih7Y2VpbF86ZnVuY3Rpb24odCl7dmFyIGU9bW4odCxcInhcIixcImNlaWxcIik7cmV0dXJuIEx0LnJ1bktlcm5lbEZ1bmMoKGZ1bmN0aW9uKHQpe3JldHVybiB0LmNlaWwoZSl9KSx7JHg6ZX0sKGZ1bmN0aW9uKHQpe3JldHVybnskeDpmdW5jdGlvbigpe3JldHVybiBYbih0KX19fSkpfX0pLGh1PUFuKHtjbGlwQnlWYWx1ZV86ZnVuY3Rpb24odCxlLG4pe3ZhciByPW1uKHQsXCJ4XCIsXCJjbGlwQnlWYWx1ZVwiKTtDKGU8PW4sKGZ1bmN0aW9uKCl7cmV0dXJuXCJFcnJvciBpbiBjbGlwOiBtaW4gKFwiK2UrXCIpIG11c3QgYmUgbGVzcyB0aGFuIG9yIGVxdWFsIHRvIG1heCAoXCIrbitcIikuXCJ9KSk7dmFyIG89W3JdLGE9e21pbjplLG1heDpufTtyZXR1cm4gTHQucnVuS2VybmVsRnVuYygoZnVuY3Rpb24odCxvKXt2YXIgYT10LmNsaXAocixlLG4pO3JldHVybiBvKFtyXSksYX0pLHt4OnJ9LChmdW5jdGlvbih0LHIpe3ZhciBvPXJbMF07cmV0dXJue3g6ZnVuY3Rpb24oKXtyZXR1cm4gdC53aGVyZShvLmdyZWF0ZXJFcXVhbChlKS5sb2dpY2FsQW5kKG8ubGVzc0VxdWFsKG4pKSxYbih0KSl9fX0pLFwiQ2xpcEJ5VmFsdWVcIixhLG8pfX0pLGZ1PUFuKHtjb3NfOmZ1bmN0aW9uKHQpe3ZhciBlPW1uKHQsXCJ4XCIsXCJjb3NcIiksbj1bZV07cmV0dXJuIEx0LnJ1bktlcm5lbEZ1bmMoKGZ1bmN0aW9uKHQsbil7dmFyIHI9dC5jb3MoZSk7cmV0dXJuIG4oW2VdKSxyfSkse3g6ZX0sKGZ1bmN0aW9uKHQsZSl7dmFyIG49ZVswXTtyZXR1cm57eDpmdW5jdGlvbigpe3JldHVybiBuLnRvRmxvYXQoKS5zaW4oKS5uZWcoKS5tdWwodCl9fX0pLFwiQ29zXCIse30sbil9fSksZHU9QW4oe2Nvc2hfOmZ1bmN0aW9uKHQpe3ZhciBlPW1uKHQsXCJ4XCIsXCJjb3NoXCIpO3JldHVybiBMdC5ydW5LZXJuZWxGdW5jKChmdW5jdGlvbih0LG4pe3ZhciByPXQuY29zaChlKTtyZXR1cm4gbihbZV0pLHJ9KSx7JHg6ZX0sKGZ1bmN0aW9uKHQsZSl7dmFyIG49ZVswXTtyZXR1cm57JHg6ZnVuY3Rpb24oKXtyZXR1cm4gbi50b0Zsb2F0KCkuc2luaCgpLm11bFN0cmljdCh0KX19fSkpfX0pLHB1PUFuKHtlcmZfOmZ1bmN0aW9uKHQpe3ZhciBlPW1uKHQsXCJ4XCIsXCJlcmZcIik7cmV0dXJuIEMoXCJpbnQzMlwiPT09ZS5kdHlwZXx8XCJmbG9hdDMyXCI9PT1lLmR0eXBlLChmdW5jdGlvbigpe3JldHVyblwiSW5wdXQgZHR5cGUgbXVzdCBiZSBgaW50MzJgIG9yIGBmbG9hdDMyYC5cIn0pKSxcImludDMyXCI9PT1lLmR0eXBlJiYoZT1lLnRvRmxvYXQoKSksTHQucnVuS2VybmVsRnVuYygoZnVuY3Rpb24odCxuKXt2YXIgcj10LmVyZihlKTtyZXR1cm4gbihbZV0pLHJ9KSx7JHg6ZX0sKGZ1bmN0aW9uKHQsZSl7dmFyIG49ZVswXTtyZXR1cm57JHg6ZnVuY3Rpb24oKXtyZXR1cm4gdC5tdWwobi5zcXVhcmUoKS5uZWcoKS5leHAoKS5tdWwoMi9NYXRoLnNxcnQoTWF0aC5QSSkpKX19fSkpfX0pLHZ1PUFuKHtleHBfOmZ1bmN0aW9uKHQpe3ZhciBlPW1uKHQsXCJ4XCIsXCJleHBcIik7cmV0dXJuIEx0LnJ1bktlcm5lbEZ1bmMoKGZ1bmN0aW9uKHQsbil7dmFyIHI9dC5leHAoZSk7cmV0dXJuIG4oW3JdKSxyfSkse3g6ZX0sKGZ1bmN0aW9uKHQsZSl7cmV0dXJue3g6ZnVuY3Rpb24oKXtyZXR1cm4gdC5tdWxTdHJpY3QoZVswXSl9fX0pLFwiRXhwXCIse30sW10sWyEwXSl9fSksbXU9QW4oe2V4cG0xXzpmdW5jdGlvbih0KXt2YXIgZT1tbih0LFwieFwiLFwiZXhwbTFcIik7cmV0dXJuIEx0LnJ1bktlcm5lbEZ1bmMoKGZ1bmN0aW9uKHQsbil7dmFyIHI9dC5leHBtMShlKTtyZXR1cm4gbihbZV0pLHJ9KSx7JHg6ZX0sKGZ1bmN0aW9uKHQsZSl7dmFyIG49ZVswXTtyZXR1cm57JHg6ZnVuY3Rpb24oKXtyZXR1cm4gdC5tdWwobi5leHAoKSl9fX0pKX19KSxndT1Bbih7Zmxvb3JfOmZ1bmN0aW9uKHQpe3ZhciBlPW1uKHQsXCJ4XCIsXCJmbG9vclwiKTtyZXR1cm4gTHQucnVuS2VybmVsRnVuYygoZnVuY3Rpb24odCl7cmV0dXJuIHQuZmxvb3IoZSl9KSx7JHg6ZX0sKGZ1bmN0aW9uKHQpe3JldHVybnskeDpmdW5jdGlvbigpe3JldHVybiBYbih0KX19fSkpfX0pLHl1PUFuKHtsb2dfOmZ1bmN0aW9uKHQpe3ZhciBlPW1uKHQsXCJ4XCIsXCJsb2dcIiksbj1bZV07cmV0dXJuIEx0LnJ1bktlcm5lbEZ1bmMoKGZ1bmN0aW9uKHQsbil7dmFyIHI9dC5sb2coZSk7cmV0dXJuIG4oW2VdKSxyfSkse3g6ZX0sKGZ1bmN0aW9uKHQsZSl7dmFyIG49ZVswXTtyZXR1cm57eDpmdW5jdGlvbigpe3JldHVybiB0LmRpdihuLnRvRmxvYXQoKSl9fX0pLFwiTG9nXCIse30sbil9fSkseHU9QW4oe2xvZzFwXzpmdW5jdGlvbih0KXt2YXIgZT1tbih0LFwieFwiLFwibG9nMXBcIik7cmV0dXJuIEx0LnJ1bktlcm5lbEZ1bmMoKGZ1bmN0aW9uKHQsbil7dmFyIHI9dC5sb2cxcChlKTtyZXR1cm4gbihbZV0pLHJ9KSx7JHg6ZX0sKGZ1bmN0aW9uKHQsZSl7dmFyIG49ZVswXTtyZXR1cm57JHg6ZnVuY3Rpb24oKXtyZXR1cm4gdC5kaXYobi5hZGQoMSkpfX19KSl9fSksYnU9QW4oe2xvZ1NpZ21vaWRfOmZ1bmN0aW9uKHQpe3ZhciBlPW1uKHQsXCJ4XCIsXCJsb2dTaWdtb2lkXCIpO3JldHVybiBMdC5ydW5LZXJuZWxGdW5jKChmdW5jdGlvbih0LG4pe3ZhciByPXQuc29mdHBsdXMoZS5uZWcoKSkubmVnKCk7cmV0dXJuIG4oW2VdKSxyfSkseyR4OmV9LChmdW5jdGlvbih0LGUpe3ZhciBuPWVbMF07cmV0dXJueyR4OmZ1bmN0aW9uKCl7cmV0dXJuIHQubXVsKG4ubmVnKCkuc2lnbW9pZCgpKX19fSkpfX0pLHd1PUFuKHtuZWdfOmZ1bmN0aW9uKHQpe3ZhciBlPW1uKHQsXCJ4XCIsXCJuZWdcIiksbj1bZV07cmV0dXJuIEx0LnJ1bktlcm5lbEZ1bmMoKGZ1bmN0aW9uKHQpe3JldHVybiB0Lm5lZyhlKX0pLHt4OmV9LChmdW5jdGlvbih0KXtyZXR1cm57eDpmdW5jdGlvbigpe3JldHVybiB0Lm5lZygpfX19KSxcIk5lZ1wiLHt9LG4pfX0pLEN1PUFuKHtyZWNpcHJvY2FsXzpmdW5jdGlvbih0KXt2YXIgZT1tbih0LFwieFwiLFwicmVjaXByb2NhbFwiKTtyZXR1cm4gTHQucnVuS2VybmVsRnVuYygoZnVuY3Rpb24odCxuKXt2YXIgcj10LnJlY2lwcm9jYWwoZSk7cmV0dXJuIG4oW2VdKSxyfSkseyR4OmV9LChmdW5jdGlvbih0LGUpe3ZhciBuPWVbMF07cmV0dXJueyR4OmZ1bmN0aW9uKCl7cmV0dXJuIHQuZGl2KG4uc3F1YXJlKCkubmVnKCkpfX19KSl9fSksRXU9QW4oe3JvdW5kXzpmdW5jdGlvbih0KXt2YXIgZT1tbih0LFwieFwiLFwicm91bmRcIik7cmV0dXJuIEx0LnJ1bktlcm5lbEZ1bmMoKGZ1bmN0aW9uKHQpe3JldHVybiB0LnJvdW5kKGUpfSkseyR4OmV9LChmdW5jdGlvbih0KXtyZXR1cm57JHg6ZnVuY3Rpb24oKXtyZXR1cm4gWG4odCl9fX0pKX19KSxSdT1Bbih7cnNxcnRfOmZ1bmN0aW9uKHQpe3ZhciBlPW1uKHQsXCJ4XCIsXCJyc3FydFwiKSxuPVtlXTtyZXR1cm4gTHQucnVuS2VybmVsRnVuYygoZnVuY3Rpb24odCxuKXt2YXIgcj10LnJzcXJ0KGUpO3JldHVybiBuKFtlXSkscn0pLHt4OmV9LChmdW5jdGlvbih0LGUpe3ZhciBuPWVbMF07cmV0dXJue3g6ZnVuY3Rpb24oKXtyZXR1cm4gdC5kaXYobi5wb3coMS41KS5tdWwoMikpLm5lZygpfX19KSxcIlJzcXJ0XCIse30sbil9fSksSXU9QW4oe3NpZ21vaWRfOmZ1bmN0aW9uKHQpe3ZhciBlPW1uKHQsXCJ4XCIsXCJzaWdtb2lkXCIpO3JldHVybiBMdC5ydW5LZXJuZWxGdW5jKChmdW5jdGlvbih0LG4pe3ZhciByPXQuc2lnbW9pZChlKTtyZXR1cm4gbihbcl0pLHJ9KSx7eDplfSwoZnVuY3Rpb24odCxlKXt2YXIgbj1lWzBdO3JldHVybnt4OmZ1bmN0aW9uKCl7cmV0dXJuIHQubXVsKG4ubXVsKE9uKDEpLnN1YihuKSkpfX19KSxcIlNpZ21vaWRcIil9fSksa3U9QW4oe3NpZ25fOmZ1bmN0aW9uKHQpe3ZhciBlPW1uKHQsXCJ4XCIsXCJzaWduXCIpO3JldHVybiBMdC5ydW5LZXJuZWxGdW5jKChmdW5jdGlvbih0KXtyZXR1cm4gdC5zaWduKGUpfSkseyR4OmV9LChmdW5jdGlvbih0KXtyZXR1cm57JHg6ZnVuY3Rpb24oKXtyZXR1cm4gWG4odCl9fX0pKX19KSxTdT1Bbih7aXNOYU5fOmZ1bmN0aW9uKHQpe3ZhciBlPW1uKHQsXCJ4XCIsXCJpc05hTlwiKTtyZXR1cm4gTHQucnVuS2VybmVsRnVuYygoZnVuY3Rpb24odCl7cmV0dXJuIHQuaXNOYU4oZSl9KSx7JHg6ZX0sKGZ1bmN0aW9uKHQpe3JldHVybnskeDpmdW5jdGlvbigpe3JldHVybiBYbih0KX19fSkpfX0pLEF1PUFuKHtpc0luZl86ZnVuY3Rpb24odCl7dmFyIGU9bW4odCxcInhcIixcImlzSW5mXCIpO3JldHVybiBMdC5ydW5LZXJuZWxGdW5jKChmdW5jdGlvbih0KXtyZXR1cm4gdC5pc0luZihlKX0pLHskeDplfSwoZnVuY3Rpb24odCl7cmV0dXJueyR4OmZ1bmN0aW9uKCl7cmV0dXJuIFhuKHQpfX19KSl9fSksRHU9QW4oe2lzRmluaXRlXzpmdW5jdGlvbih0KXt2YXIgZT1tbih0LFwieFwiLFwiaXNGaW5pdGVcIik7cmV0dXJuIEx0LnJ1bktlcm5lbEZ1bmMoKGZ1bmN0aW9uKHQpe3JldHVybiB0LmlzRmluaXRlKGUpfSkseyR4OmV9LChmdW5jdGlvbih0KXtyZXR1cm57JHg6ZnVuY3Rpb24oKXtyZXR1cm4gWG4odCl9fX0pKX19KSxUdT1Bbih7c2luXzpmdW5jdGlvbih0KXt2YXIgZT1tbih0LFwieFwiLFwic2luXCIpLG49W2VdO3JldHVybiBMdC5ydW5LZXJuZWxGdW5jKChmdW5jdGlvbih0LG4pe3ZhciByPXQuc2luKGUpO3JldHVybiBuKFtlXSkscn0pLHt4OmV9LChmdW5jdGlvbih0LGUpe3ZhciBuPWVbMF07cmV0dXJue3g6ZnVuY3Rpb24oKXtyZXR1cm4gbi50b0Zsb2F0KCkuY29zKCkubXVsKHQpfX19KSxcIlNpblwiLHt9LG4pfX0pLE51PUFuKHtzaW5oXzpmdW5jdGlvbih0KXt2YXIgZT1tbih0LFwieFwiLFwic2luaFwiKTtyZXR1cm4gTHQucnVuS2VybmVsRnVuYygoZnVuY3Rpb24odCxuKXt2YXIgcj10LnNpbmgoZSk7cmV0dXJuIG4oW2VdKSxyfSkseyR4OmV9LChmdW5jdGlvbih0LGUpe3ZhciBuPWVbMF07cmV0dXJueyR4OmZ1bmN0aW9uKCl7cmV0dXJuIG4udG9GbG9hdCgpLmNvc2goKS5tdWxTdHJpY3QodCl9fX0pKX19KSxGdT1Bbih7c29mdHBsdXNfOmZ1bmN0aW9uKHQpe3ZhciBlPW1uKHQsXCJ4XCIsXCJzb2Z0cGx1c1wiKTtyZXR1cm4gTHQucnVuS2VybmVsRnVuYygoZnVuY3Rpb24odCxuKXt2YXIgcj10LnNvZnRwbHVzKGUpO3JldHVybiBuKFtlXSkscn0pLHskeDplfSwoZnVuY3Rpb24odCxlKXt2YXIgbj1lWzBdO3JldHVybnskeDpmdW5jdGlvbigpe3JldHVybiB0Lm11bChuLnNpZ21vaWQoKSl9fX0pKX19KSxfdT1Bbih7c3FydF86ZnVuY3Rpb24odCl7dmFyIGU9bW4odCxcInhcIixcInNxcnRcIik7cmV0dXJuIEx0LnJ1bktlcm5lbEZ1bmMoKGZ1bmN0aW9uKHQsbil7dmFyIHI9dC5zcXJ0KGUpO3JldHVybiBuKFtlXSkscn0pLHskeDplfSwoZnVuY3Rpb24odCxlKXt2YXIgbj1lWzBdO3JldHVybnskeDpmdW5jdGlvbigpe3JldHVybiB0LmRpdihuLnRvRmxvYXQoKS5zcXJ0KCkubXVsKDIpKX19fSkpfX0pLE91PUFuKHtzdGVwXzpmdW5jdGlvbih0LGUpe3ZvaWQgMD09PWUmJihlPTApO3ZhciBuPW1uKHQsXCJ4XCIsXCJzdGVwXCIpO3JldHVybiBMdC5ydW5LZXJuZWxGdW5jKChmdW5jdGlvbih0KXtyZXR1cm4gdC5zdGVwKG4sZSl9KSx7JHg6bn0sKGZ1bmN0aW9uKHQpe3JldHVybnskeDpmdW5jdGlvbigpe3JldHVybiBYbih0KX19fSkpfX0pLE11PUFuKHt0YW5fOmZ1bmN0aW9uKHQpe3ZhciBlPW1uKHQsXCJ4XCIsXCJ0YW5cIik7cmV0dXJuIEx0LnJ1bktlcm5lbEZ1bmMoKGZ1bmN0aW9uKHQsbil7dmFyIHI9dC50YW4oZSk7cmV0dXJuIG4oW2VdKSxyfSkseyR4OmV9LChmdW5jdGlvbih0LGUpe3ZhciBuPWVbMF07cmV0dXJueyR4OmZ1bmN0aW9uKCl7cmV0dXJuIHQuZGl2KG4uY29zKCkuc3F1YXJlKCkpfX19KSl9fSksQnU9QW4oe3RhbmhfOmZ1bmN0aW9uKHQpe3ZhciBlPW1uKHQsXCJ4XCIsXCJ0YW5oXCIpO3JldHVybiBMdC5ydW5LZXJuZWxGdW5jKChmdW5jdGlvbih0LG4pe3ZhciByPXQudGFuaChlKTtyZXR1cm4gbihbcl0pLHJ9KSx7eDplfSwoZnVuY3Rpb24odCxlKXt2YXIgbj1lWzBdO3JldHVybnt4OmZ1bmN0aW9uKCl7cmV0dXJuIE9uKDEpLnN1YihuLnNxdWFyZSgpKS5tdWxTdHJpY3QodCl9fX0pLFwiVGFuaFwiLHt9LG51bGwsWyEwXSl9fSk7ZnVuY3Rpb24gUHUodCxlLG4scixvLGEpe3ZhciBpLHMsdT1tbih0LFwieFwiLFwiYmF0Y2hOb3JtXCIpLGM9bW4oZSxcIm1lYW5cIixcImJhdGNoTm9ybVwiKSxsPW1uKG4sXCJ2YXJpYW5jZVwiLFwiYmF0Y2hOb3JtXCIpO3JldHVybiBudWxsIT1vJiYoaT1tbihvLFwic2NhbGVcIixcImJhdGNoTm9ybVwiKSksbnVsbCE9ciYmKHM9bW4ocixcIm9mZnNldFwiLFwiYmF0Y2hOb3JtXCIpKSxDKDI9PT11LnJhbmssKGZ1bmN0aW9uKCl7cmV0dXJuXCJFcnJvciBpbiBiYXRjaE5vcm0zRDogeCBtdXN0IGJlIHJhbmsgMyBidXQgZ290IHJhbmsgXCIrdS5yYW5rK1wiLlwifSkpLEMoMj09PWMucmFua3x8MT09PWMucmFuaywoZnVuY3Rpb24oKXtyZXR1cm5cIkVycm9yIGluIGJhdGNoTm9ybTJEOiBtZWFuIG11c3QgYmUgcmFuayAyIG9yIHJhbmsgMSBidXQgZ290IHJhbmsgXCIrYy5yYW5rK1wiLlwifSkpLEMoMj09PWwucmFua3x8MT09PWwucmFuaywoZnVuY3Rpb24oKXtyZXR1cm5cIkVycm9yIGluIGJhdGNoTm9ybTJEOiB2YXJpYW5jZSBtdXN0IGJlIHJhbmsgMiBvciByYW5rIDEgYnV0IGdvdCByYW5rIFwiK2wucmFuaytcIi5cIn0pKSxudWxsIT1pJiZDKDI9PT1pLnJhbmt8fDE9PT1pLnJhbmssKGZ1bmN0aW9uKCl7cmV0dXJuXCJFcnJvciBpbiBiYXRjaE5vcm0yRDogc2NhbGUgbXVzdCBiZSByYW5rIDIgb3IgcmFuayAxIGJ1dCBnb3QgcmFuayBcIitpLnJhbmsrXCIuXCJ9KSksbnVsbCE9cyYmQygyPT09cy5yYW5rfHwxPT09cy5yYW5rLChmdW5jdGlvbigpe3JldHVyblwiRXJyb3IgaW4gYmF0Y2hOb3JtMkQ6IG9mZnNldCBtdXN0IGJlIHJhbmsgMiBvciByYW5rIDEgYnV0IGdvdCByYW5rIFwiK3MucmFuaytcIi5cIn0pKSxVdSh1LGMsbCxzLGksYSl9ZnVuY3Rpb24gTHUodCxlLG4scixvLGEpe3ZhciBpLHMsdT1tbih0LFwieFwiLFwiYmF0Y2hOb3JtXCIpLGM9bW4oZSxcIm1lYW5cIixcImJhdGNoTm9ybVwiKSxsPW1uKG4sXCJ2YXJpYW5jZVwiLFwiYmF0Y2hOb3JtXCIpO3JldHVybiBudWxsIT1vJiYoaT1tbihvLFwic2NhbGVcIixcImJhdGNoTm9ybVwiKSksbnVsbCE9ciYmKHM9bW4ocixcIm9mZnNldFwiLFwiYmF0Y2hOb3JtXCIpKSxDKDM9PT11LnJhbmssKGZ1bmN0aW9uKCl7cmV0dXJuXCJFcnJvciBpbiBiYXRjaE5vcm0zRDogeCBtdXN0IGJlIHJhbmsgMyBidXQgZ290IHJhbmsgXCIrdS5yYW5rK1wiLlwifSkpLEMoMz09PWMucmFua3x8MT09PWMucmFuaywoZnVuY3Rpb24oKXtyZXR1cm5cIkVycm9yIGluIGJhdGNoTm9ybTNEOiBtZWFuIG11c3QgYmUgcmFuayAzIG9yIHJhbmsgMSBidXQgZ290IHJhbmsgXCIrYy5yYW5rK1wiLlwifSkpLEMoMz09PWwucmFua3x8MT09PWwucmFuaywoZnVuY3Rpb24oKXtyZXR1cm5cIkVycm9yIGluIGJhdGNoTm9ybTNEOiB2YXJpYW5jZSBtdXN0IGJlIHJhbmsgMyBvciByYW5rIDEgYnV0IGdvdCByYW5rIFwiK2wucmFuaytcIi5cIn0pKSxudWxsIT1pJiZDKDM9PT1pLnJhbmt8fDE9PT1pLnJhbmssKGZ1bmN0aW9uKCl7cmV0dXJuXCJFcnJvciBpbiBiYXRjaE5vcm0zRDogc2NhbGUgbXVzdCBiZSByYW5rIDMgb3IgcmFuayAxIGJ1dCBnb3QgcmFuayBcIitpLnJhbmsrXCIuXCJ9KSksbnVsbCE9cyYmQygzPT09cy5yYW5rfHwxPT09cy5yYW5rLChmdW5jdGlvbigpe3JldHVyblwiRXJyb3IgaW4gYmF0Y2hOb3JtM0Q6IG9mZnNldCBtdXN0IGJlIHJhbmsgMyBvciByYW5rIDEgYnV0IGdvdCByYW5rIFwiK3MucmFuaytcIi5cIn0pKSxVdSh1LGMsbCxzLGksYSl9ZnVuY3Rpb24gV3UodCxlLG4scixvLGEpe3ZhciBpLHMsdT1tbih0LFwieFwiLFwiYmF0Y2hOb3JtXCIpLGM9bW4oZSxcIm1lYW5cIixcImJhdGNoTm9ybVwiKSxsPW1uKG4sXCJ2YXJpYW5jZVwiLFwiYmF0Y2hOb3JtXCIpO3JldHVybiBudWxsIT1vJiYoaT1tbihvLFwic2NhbGVcIixcImJhdGNoTm9ybVwiKSksbnVsbCE9ciYmKHM9bW4ocixcIm9mZnNldFwiLFwiYmF0Y2hOb3JtXCIpKSxDKDQ9PT11LnJhbmssKGZ1bmN0aW9uKCl7cmV0dXJuXCJFcnJvciBpbiBiYXRjaE5vcm00RDogeCBtdXN0IGJlIHJhbmsgNCBidXQgZ290IHJhbmsgXCIrdS5yYW5rK1wiLlwifSkpLEMoND09PWMucmFua3x8MT09PWMucmFuaywoZnVuY3Rpb24oKXtyZXR1cm5cIkVycm9yIGluIGJhdGNoTm9ybTREOiBtZWFuIG11c3QgYmUgcmFuayA0IG9yIHJhbmsgMSBidXQgZ290IHJhbmsgXCIrYy5yYW5rK1wiLlwifSkpLEMoND09PWwucmFua3x8MT09PWwucmFuaywoZnVuY3Rpb24oKXtyZXR1cm5cIkVycm9yIGluIGJhdGNoTm9ybTREOiB2YXJpYW5jZSBtdXN0IGJlIHJhbmsgNCBvciByYW5rIDEgYnV0IGdvdCByYW5rIFwiK2wucmFuaytcIi5cIn0pKSxudWxsIT1pJiZDKDQ9PT1pLnJhbmt8fDE9PT1pLnJhbmssKGZ1bmN0aW9uKCl7cmV0dXJuXCJFcnJvciBpbiBiYXRjaE5vcm00RDogc2NhbGUgbXVzdCBiZSByYW5rIDQgb3IgcmFuayAxIGJ1dCBnb3QgcmFuayBcIitpLnJhbmsrXCIuXCJ9KSksbnVsbCE9cyYmQyg0PT09cy5yYW5rfHwxPT09cy5yYW5rLChmdW5jdGlvbigpe3JldHVyblwiRXJyb3IgaW4gYmF0Y2hOb3JtNEQ6IG9mZnNldCBtdXN0IGJlIHJhbmsgNCBvciByYW5rIDEgYnV0IGdvdCByYW5rIFwiK3MucmFuaytcIi5cIn0pKSxVdSh1LGMsbCxzLGksYSl9ZnVuY3Rpb24gVXUodCxlLG4scixvLGEpe251bGw9PWEmJihhPS4wMDEpO3ZhciBpLHMsdSxjPW1uKHQsXCJ4XCIsXCJiYXRjaE5vcm1cIiksbD1tbihlLFwibWVhblwiLFwiYmF0Y2hOb3JtXCIpLGg9bW4obixcInZhcmlhbmNlXCIsXCJiYXRjaE5vcm1cIik7bnVsbCE9byYmKGk9bW4obyxcInNjYWxlXCIsXCJiYXRjaE5vcm1cIikpLG51bGwhPXImJihzPW1uKHIsXCJvZmZzZXRcIixcImJhdGNoTm9ybVwiKSksQyhsLnJhbms9PT1oLnJhbmssKGZ1bmN0aW9uKCl7cmV0dXJuXCJCYXRjaCBub3JtYWxpemF0aW9uIGdyYWRpZW50IHJlcXVpcmVzIG1lYW4gYW5kIHZhcmlhbmNlIHRvIGhhdmUgZXF1YWwgcmFua3MuXCJ9KSksQyhudWxsPT1zfHxsLnJhbms9PT1zLnJhbmssKGZ1bmN0aW9uKCl7cmV0dXJuXCJCYXRjaCBub3JtYWxpemF0aW9uIGdyYWRpZW50IHJlcXVpcmVzIG1lYW4gYW5kIG9mZnNldCB0byBoYXZlIGVxdWFsIHJhbmtzLlwifSkpLEMobnVsbD09aXx8bC5yYW5rPT09aS5yYW5rLChmdW5jdGlvbigpe3JldHVyblwiQmF0Y2ggbm9ybWFsaXphdGlvbiBncmFkaWVudCByZXF1aXJlcyBtZWFuIGFuZCBzY2FsZSB0byBoYXZlIGVxdWFsIHJhbmtzLlwifSkpLHU9MD09PWMucmFua3x8MT09PWMucmFuaz9jLmFzNEQoMSwxLDEsYy5zaXplKToyPT09Yy5yYW5rP2MuYXM0RCgxLDEsYy5zaGFwZVswXSxjLnNoYXBlWzFdKTozPT09Yy5yYW5rP2MuYXM0RCgxLGMuc2hhcGVbMF0sYy5zaGFwZVsxXSxjLnNoYXBlWzJdKTpjO3ZhciBmPVtjLGwsaCxpXTtyZXR1cm4gTHQucnVuS2VybmVsRnVuYygoZnVuY3Rpb24odCxlKXt2YXIgbj10LmJhdGNoTm9ybWFsaXphdGlvbih1LFZ1KGwpLFZ1KGgpLGEsVnUoaSksVnUocykpO3JldHVybiBlKFtjLGwsaCxpXSksbn0pLHt4OmMsbWVhbjpsLHZhcmlhbmNlOmgsc2NhbGU6aSxvZmZzZXQ6c30sKGZ1bmN0aW9uKHQsZSl7dmFyIG49ZSxyPW5bMF0sbz1uWzFdLGk9blsyXSxzPW5bM10sYz1udWxsPT1zP09uKDEpOnMsbD1FbyhvLnNoYXBlLHUuc2hhcGUpLGg9W107aWYoMT09PW8ucmFuayl7Zm9yKHZhciBmPTA7Zjx1LnNoYXBlLmxlbmd0aC0xOysrZiloLnB1c2godS5zaGFwZVtmXSk7aC5wdXNoKDEpfXZhciBkPXIuc3ViKG8pLHA9dC5tdWwoYyksdj1SdShpLmFkZChPbihhKSkpLG09di5tdWwodikubXVsKHYpLm11bChPbigtLjUpKTtyZXR1cm57eDpmdW5jdGlvbigpe3JldHVybiAxPT09by5yYW5rP3QubXVsKExyKHYuYXM0RCgxLDEsMSxvLnNoYXBlWzBdKSxoKSkubXVsKGMpLnJlc2hhcGUoci5zaGFwZSk6dC5tdWwodikubXVsKGMpLnJlc2hhcGUoci5zaGFwZSl9LG1lYW46ZnVuY3Rpb24oKXt2YXIgdD12Lm11bChPbigtMSkpLm11bChwKTtyZXR1cm4gMT09PW8ucmFuayYmKHQ9dC5zdW0obCkpLHQucmVzaGFwZShvLnNoYXBlKX0sdmFyaWFuY2U6ZnVuY3Rpb24oKXt2YXIgdD1tLm11bChkKS5tdWwocCk7cmV0dXJuIDE9PT1vLnJhbmsmJih0PXQuc3VtKGwpKSx0LnJlc2hhcGUoby5zaGFwZSl9LHNjYWxlOmZ1bmN0aW9uKCl7dmFyIGU9ZC5tdWwodiksbj10Lm11bChlKTtyZXR1cm4gMT09PW8ucmFuayYmKG49bi5zdW0obCkpLG4ucmVzaGFwZShvLnNoYXBlKX0sb2Zmc2V0OmZ1bmN0aW9uKCl7dmFyIGU9dDtyZXR1cm4gMT09PW8ucmFuayYmKGU9ZS5zdW0obCkpLGUucmVzaGFwZShvLnNoYXBlKX19fSksXCJCYXRjaE5vcm1hbGl6YXRpb25cIix7dmFyaWFuY2VFcHNpbG9uOmF9LGYpLnJlc2hhcGUoYy5zaGFwZSl9ZnVuY3Rpb24gVnUodCl7cmV0dXJuIG51bGw9PXQ/bnVsbDowPT09dC5yYW5rP3QuYXMxRCgpOjE9PT10LnJhbms/dDoyPT09dC5yYW5rP3QuYXM0RCgxLDEsdC5zaGFwZVswXSx0LnNoYXBlWzFdKTozPT09dC5yYW5rP3QuYXM0RCgxLHQuc2hhcGVbMF0sdC5zaGFwZVsxXSx0LnNoYXBlWzJdKTp0fWZ1bmN0aW9uIHp1KCl7WGUoXCJ0Zi5iYXRjaE5vcm1hbGl6YXRpb24oKSBpcyBnb2luZyBhd2F5LiBVc2UgdGYuYmF0Y2hOb3JtKCkgaW5zdGVhZCwgYW5kIG5vdGUgdGhlIHBvc2l0aW9uYWwgYXJndW1lbnQgY2hhbmdlIG9mIHNjYWxlLCBvZmZzZXQsIGFuZCB2YXJpYW5jZUVwc2lsb25cIil9dmFyIEd1PUFuKHtiYXRjaE5vcm1hbGl6YXRpb24yZF86ZnVuY3Rpb24odCxlLG4scixvLGEpe3JldHVybiB2b2lkIDA9PT1yJiYocj0uMDAxKSx6dSgpLFB1KHQsZSxuLGEsbyxyKX19KSxIdT1Bbih7YmF0Y2hOb3JtYWxpemF0aW9uM2RfOmZ1bmN0aW9uKHQsZSxuLHIsbyxhKXtyZXR1cm4gdm9pZCAwPT09ciYmKHI9LjAwMSksenUoKSxMdSh0LGUsbixhLG8scil9fSkscXU9QW4oe2JhdGNoTm9ybWFsaXphdGlvbjRkXzpmdW5jdGlvbih0LGUsbixyLG8sYSl7cmV0dXJuIHZvaWQgMD09PXImJihyPS4wMDEpLHp1KCksV3UodCxlLG4sYSxvLHIpfX0pLEt1PUFuKHtiYXRjaE5vcm1hbGl6YXRpb25fOmZ1bmN0aW9uKHQsZSxuLHIsbyxhKXtyZXR1cm4gdm9pZCAwPT09ciYmKHI9LjAwMSksenUoKSxVdSh0LGUsbixhLG8scil9fSksanU9QW4oe2JhdGNoTm9ybV86VXV9KSxYdT1Bbih7YmF0Y2hOb3JtMmRfOlB1fSksWXU9QW4oe2JhdGNoTm9ybTNkXzpMdX0pLCR1PUFuKHtiYXRjaE5vcm00ZF86V3V9KTt2YXIgUXU9QW4oe2xvZ2ljYWxBbmRfOmZ1bmN0aW9uKHQsZSl7dmFyIG49bW4odCxcImFcIixcImxvZ2ljYWxBbmRcIixcImJvb2xcIikscj1tbihlLFwiYlwiLFwibG9naWNhbEFuZFwiLFwiYm9vbFwiKTtyZXR1cm4gUm8obi5zaGFwZSxyLnNoYXBlKSxMdC5ydW5LZXJuZWxGdW5jKChmdW5jdGlvbih0KXtyZXR1cm4gdC5sb2dpY2FsQW5kKG4scil9KSx7YTpuLGI6cn0sbnVsbCxcIkxvZ2ljYWxBbmRcIil9fSksSnU9QW4oe2xvZ2ljYWxOb3RfOmZ1bmN0aW9uKHQpe3ZhciBlPW1uKHQsXCJ4XCIsXCJsb2dpY2FsTm90XCIsXCJib29sXCIpO3JldHVybiBMdC5ydW5LZXJuZWxGdW5jKChmdW5jdGlvbih0KXtyZXR1cm4gdC5sb2dpY2FsTm90KGUpfSkseyR4OmV9KX19KSxadT1Bbih7bG9naWNhbE9yXzpmdW5jdGlvbih0LGUpe3ZhciBuPW1uKHQsXCJhXCIsXCJsb2dpY2FsT3JcIixcImJvb2xcIikscj1tbihlLFwiYlwiLFwibG9naWNhbE9yXCIsXCJib29sXCIpO3JldHVybiBSbyhuLnNoYXBlLHIuc2hhcGUpLEx0LnJ1bktlcm5lbEZ1bmMoKGZ1bmN0aW9uKHQpe3JldHVybiB0LmxvZ2ljYWxPcihuLHIpfSkseyRhOm4sJGI6cn0pfX0pLHRjPUFuKHtsb2dpY2FsWG9yXzpmdW5jdGlvbih0LGUpe3ZhciBuPW1uKHQsXCJhXCIsXCJsb2dpY2FsWG9yXCIsXCJib29sXCIpLHI9bW4oZSxcImJcIixcImxvZ2ljYWxYb3JcIixcImJvb2xcIik7cmV0dXJuIFJvKG4uc2hhcGUsci5zaGFwZSksWnUodCxlKS5sb2dpY2FsQW5kKFF1KHQsZSkubG9naWNhbE5vdCgpKX19KSxlYz1Bbih7d2hlcmVfOmZ1bmN0aW9uKHQsZSxuKXt2YXIgcj1tbihlLFwiYVwiLFwid2hlcmVcIiksbz1tbihuLFwiYlwiLFwid2hlcmVcIiksYT1tbih0LFwiY29uZGl0aW9uXCIsXCJ3aGVyZVwiLFwiYm9vbFwiKTtyZXR1cm4gRShyLnNoYXBlLG8uc2hhcGUsXCJFcnJvciBpbiB3aGVyZTogXCIpLDE9PT1hLnJhbms/QyhhLnNoYXBlWzBdPT09ci5zaGFwZVswXSwoZnVuY3Rpb24oKXtyZXR1cm5cIlRoZSBmaXJzdCBkaW1lbnNpb24gb2YgYGFgIG11c3QgbWF0Y2ggdGhlIHNpemUgb2YgYGNvbmRpdGlvbmAuXCJ9KSk6RShhLnNoYXBlLG8uc2hhcGUsXCJFcnJvciBpbiB3aGVyZTogXCIpLEx0LnJ1bktlcm5lbEZ1bmMoKGZ1bmN0aW9uKHQsZSl7dmFyIG49dC5zZWxlY3QoYSxyLG8pO3JldHVybiBlKFthXSksbn0pLHskY29uZGl0aW9uOmEsJGE6ciwkYjpvfSwoZnVuY3Rpb24odCxlKXt2YXIgbj1lWzBdO3JldHVybnskY29uZGl0aW9uOmZ1bmN0aW9uKCl7cmV0dXJuIFhuKG4pLnRvRmxvYXQoKX0sJGE6ZnVuY3Rpb24oKXtyZXR1cm4gdC5tdWwobi5jYXN0KHQuZHR5cGUpKX0sJGI6ZnVuY3Rpb24oKXtyZXR1cm4gdC5tdWwobi5sb2dpY2FsTm90KCkuY2FzdCh0LmR0eXBlKSl9fX0pKX19KSxuYz1mdW5jdGlvbih0KXtyZXR1cm4gbih0aGlzLHZvaWQgMCx2b2lkIDAsKGZ1bmN0aW9uKCl7dmFyIGUsbixvO3JldHVybiByKHRoaXMsKGZ1bmN0aW9uKHIpe3N3aXRjaChyLmxhYmVsKXtjYXNlIDA6cmV0dXJuWzQsKGU9bW4odCxcImNvbmRpdGlvblwiLFwid2hlcmVBc3luY1wiLFwiYm9vbFwiKSkuZGF0YSgpXTtjYXNlIDE6cmV0dXJuIG49ci5zZW50KCksbz1uYShlLnNoYXBlLG4pLHQhPT1lJiZlLmRpc3Bvc2UoKSxbMixvXX19KSl9KSl9O3ZhciByYz1Bbih7YWRkXzpmdW5jdGlvbih0LGUpe3ZhciBuLHI9bW4odCxcImFcIixcImFkZFwiKSxvPW1uKGUsXCJiXCIsXCJhZGRcIik7bj1OdChyLG8pLHI9blswXSxvPW5bMV07dmFyIGE9Um8oci5zaGFwZSxvLnNoYXBlKTtyZXR1cm4gTHQucnVuS2VybmVsRnVuYygoZnVuY3Rpb24odCl7cmV0dXJuIHQuYWRkKHIsbyl9KSx7YTpyLGI6b30sKGZ1bmN0aW9uKHQpe3JldHVybnthOmZ1bmN0aW9uKCl7dmFyIGU9dCxuPUVvKHIuc2hhcGUsYSk7cmV0dXJuIG4ubGVuZ3RoPjAmJihlPWUuc3VtKG4pKSxlLnJlc2hhcGUoci5zaGFwZSl9LGI6ZnVuY3Rpb24oKXt2YXIgZT10LG49RW8oby5zaGFwZSxhKTtyZXR1cm4gbi5sZW5ndGg+MCYmKGU9ZS5zdW0obikpLGUucmVzaGFwZShvLnNoYXBlKX19fSksXCJBZGRcIil9fSksb2M9QW4oe2FkZE5fOmZ1bmN0aW9uKHQpe0MoQXJyYXkuaXNBcnJheSh0KSwoZnVuY3Rpb24oKXtyZXR1cm5cIlRoZSBhcmd1bWVudCBwYXNzZWQgdG8gdGYuYWRkTigpIG11c3QgYmUgYSBsaXN0IG9mIHRlbnNvcnNcIn0pKSxDKHQubGVuZ3RoPj0xLChmdW5jdGlvbigpe3JldHVyblwiTXVzdCBwYXNzIGF0IGxlYXN0IG9uZSB0ZW5zb3IgdG8gdGYuYWRkTigpLCBidXQgZ290IFwiK3QubGVuZ3RofSkpO3ZhciBlPXQubWFwKChmdW5jdGlvbih0LGUpe3JldHVybiBtbih0LFwidGVuc29yc1wiK2UsXCJhZGROXCIpfSkpLG49ZVswXTtlLmZvckVhY2goKGZ1bmN0aW9uKHQpe2lmKHQuZHR5cGUhPT1uLmR0eXBlKXRocm93IG5ldyBFcnJvcihcIkFsbCB0ZW5zb3JzIHBhc3NlZCB0byB0Zi5hZGROKCkgbXVzdCBoYXZlIHRoZSBzYW1lIGR0eXBlXCIpfSkpLGUuZm9yRWFjaCgoZnVuY3Rpb24odCl7aWYoIVModC5zaGFwZSxuLnNoYXBlKSl0aHJvdyBuZXcgRXJyb3IoXCJBbGwgdGVuc29ycyBwYXNzZWQgdG8gdGYuYWRkTigpIG11c3QgaGF2ZSB0aGUgc2FtZSBzaGFwZVwiKX0pKTt2YXIgcj1lO3JldHVybiBMdC5ydW5LZXJuZWxGdW5jKChmdW5jdGlvbih0KXtyZXR1cm4gdC5hZGROKGUpfSksciwoZnVuY3Rpb24odCl7dmFyIG49e307cmV0dXJuIGUuZm9yRWFjaCgoZnVuY3Rpb24oZSxyKXtuW3JdPWZ1bmN0aW9uKCl7cmV0dXJuIHQuY2xvbmUoKX19KSksbn0pLFwiQWRkTlwiKX19KSxhYz1Bbih7YWRkU3RyaWN0XzpmdW5jdGlvbih0LGUpe3ZhciBuPW1uKHQsXCJhXCIsXCJhZGRTdHJpY3RcIikscj1tbihlLFwiYlwiLFwiYWRkU3RyaWN0XCIpO3JldHVybiBFKG4uc2hhcGUsci5zaGFwZSxcIkVycm9yIGluIGFkZFN0cmljdDogXCIpLG4uYWRkKHIpfX0pLGljPUFuKHthdGFuMl86ZnVuY3Rpb24odCxlKXt2YXIgbixyPW1uKHQsXCJhXCIsXCJhdGFuMlwiKSxvPW1uKGUsXCJiXCIsXCJhdGFuMlwiKTtuPU50KHIsbykscj1uWzBdLG89blsxXTt2YXIgYT1SbyhyLnNoYXBlLG8uc2hhcGUpO3JldHVybiBMdC5ydW5LZXJuZWxGdW5jKChmdW5jdGlvbih0LGUpe3ZhciBuPXQuYXRhbjIocixvKTtyZXR1cm4gZShbcixvXSksbn0pLHskYTpyLCRiOm99LChmdW5jdGlvbih0LGUpe3ZhciBuPWVbMF0scj1lWzFdO3JldHVybnskYTpmdW5jdGlvbigpe3ZhciBlPXJjKG4uc3F1YXJlKCksci5zcXVhcmUoKSksbz10Lm11bChyLmRpdihlKSksaT1FbyhuLnNoYXBlLGEpO3JldHVybiBpLmxlbmd0aD4wJiYobz1vLnN1bShpKSksby5yZXNoYXBlKG4uc2hhcGUpfSwkYjpmdW5jdGlvbigpe3ZhciBlPXJjKG4uc3F1YXJlKCksci5zcXVhcmUoKSksbz13dSh0Lm11bChuLmRpdihlKSkpLGk9RW8oci5zaGFwZSxhKTtyZXR1cm4gaS5sZW5ndGg+MCYmKG89by5zdW0oaSkpLG8ucmVzaGFwZShyLnNoYXBlKX19fSkpfX0pLHNjPUFuKHtkaXZfOmZ1bmN0aW9uKHQsZSl7dmFyIG4scj1tbih0LFwiYVwiLFwiZGl2XCIpLG89bW4oZSxcImJcIixcImRpdlwiKTtpZihuPU50KHIsbykscj1uWzBdLG89blsxXSxcImludDMyXCI9PT1yLmR0eXBlJiZcImludDMyXCI9PT1vLmR0eXBlKXJldHVybiBsYyhyLG8pO3ZhciBhPVJvKHIuc2hhcGUsby5zaGFwZSk7cmV0dXJuIEx0LnJ1bktlcm5lbEZ1bmMoKGZ1bmN0aW9uKHQsZSl7dmFyIG49dC5yZWFsRGl2aWRlKHIsbyk7cmV0dXJuIGUoW3Isb10pLG59KSx7YTpyLGI6b30sKGZ1bmN0aW9uKHQsZSl7dmFyIG49ZVswXSxyPWVbMV07cmV0dXJue2E6ZnVuY3Rpb24oKXt2YXIgZT10LmRpdihyLnRvRmxvYXQoKSksbz1FbyhuLnNoYXBlLGEpO3JldHVybiBvLmxlbmd0aD4wP2Uuc3VtKG8pLnJlc2hhcGUobi5zaGFwZSk6ZX0sYjpmdW5jdGlvbigpe3ZhciBlPXQubXVsKG4udG9GbG9hdCgpKSxvPUVvKHIuc2hhcGUsYSk7by5sZW5ndGg+MCYmKGU9ZS5zdW0obykucmVzaGFwZShyLnNoYXBlKSk7dmFyIGk9ci5zcXVhcmUoKTtyZXR1cm4gZS5kaXYoaS50b0Zsb2F0KCkpLm5lZygpfX19KSxcIkRpdlwiKX19KSx1Yz1Bbih7ZGl2Tm9OYW5fOmZ1bmN0aW9uKHQsZSl7dmFyIG4scj1tbih0LFwiYVwiLFwiZGl2XCIpLG89bW4oZSxcImJcIixcImRpdlwiKTtyPShuPU50KHIsbykpWzBdLG89blsxXTt2YXIgYT1zYyhyLG8pLGk9WG4oYSkscz1vLmVxdWFsKGkpO3JldHVybiBlYyhzLGksYSl9fSksY2M9QW4oe2RpdlN0cmljdF86ZnVuY3Rpb24odCxlKXt2YXIgbj1tbih0LFwiYVwiLFwiZGl2XCIpLHI9bW4oZSxcImJcIixcImRpdlwiKTtyZXR1cm4gRShuLnNoYXBlLHIuc2hhcGUsXCJFcnJvciBpbiBkaXZpZGVTdHJpY3Q6IFwiKSxuLmRpdihyKX19KSxsYz1Bbih7Zmxvb3JEaXZfOmZ1bmN0aW9uKHQsZSl7dmFyIG4scj1tbih0LFwiYVwiLFwiZmxvb3JEaXZcIiksbz1tbihlLFwiYlwiLFwiZmxvb3JEaXZcIik7bj1OdChyLG8pLHI9blswXSxvPW5bMV07dmFyIGE9Um8oci5zaGFwZSxvLnNoYXBlKTtyZXR1cm4gTHQucnVuS2VybmVsRnVuYygoZnVuY3Rpb24odCxlKXt2YXIgbj10LmZsb29yRGl2KHIsbyk7cmV0dXJuIGUoW3Isb10pLG59KSx7YTpyLGI6b30sKGZ1bmN0aW9uKHQsZSl7dmFyIG49ZVswXSxyPWVbMV07cmV0dXJue2E6ZnVuY3Rpb24oKXt2YXIgZT10LmRpdihyLnRvRmxvYXQoKSksbz1FbyhuLnNoYXBlLGEpO3JldHVybiBvLmxlbmd0aD4wP2Uuc3VtKG8pLnJlc2hhcGUobi5zaGFwZSk6ZX0sYjpmdW5jdGlvbigpe3ZhciBlPXQubXVsKG4udG9GbG9hdCgpKSxvPUVvKHIuc2hhcGUsYSk7by5sZW5ndGg+MCYmKGU9ZS5zdW0obykucmVzaGFwZShyLnNoYXBlKSk7dmFyIGk9ci5zcXVhcmUoKTtyZXR1cm4gZS5kaXYoaS50b0Zsb2F0KCkpLm5lZygpfX19KSxcIkZsb29yRGl2XCIpfX0pLGhjPUFuKHttYXhpbXVtXzpmdW5jdGlvbih0LGUpe3ZhciBuLHI9bW4odCxcImFcIixcIm1heGltdW1cIiksbz1tbihlLFwiYlwiLFwibWF4aW11bVwiKTtyZXR1cm4gbj1OdChyLG8pLHI9blswXSxvPW5bMV0sXCJib29sXCI9PT1yLmR0eXBlJiYocj1yLnRvSW50KCksbz1vLnRvSW50KCkpLFJvKHIuc2hhcGUsby5zaGFwZSksTHQucnVuS2VybmVsRnVuYygoZnVuY3Rpb24odCxlKXt2YXIgbj10Lm1heGltdW0ocixvKTtyZXR1cm4gZShbcixvXSksbn0pLHthOnIsYjpvfSwoZnVuY3Rpb24odCxlKXt2YXIgbj1lWzBdLHI9ZVsxXTtyZXR1cm57YTpmdW5jdGlvbigpe3JldHVybiB0Lm11bChuLmdyZWF0ZXJFcXVhbChyKS50b0Zsb2F0KCkpfSxiOmZ1bmN0aW9uKCl7cmV0dXJuIHQubXVsKG4ubGVzcyhyKS50b0Zsb2F0KCkpfX19KSxcIk1heGltdW1cIil9fSksZmM9QW4oe21heGltdW1TdHJpY3RfOmZ1bmN0aW9uKHQsZSl7dmFyIG49bW4odCxcImFcIixcIm1heGltdW1TdHJpY3RcIikscj1tbihlLFwiYlwiLFwibWF4aW11bVN0cmljdFwiKTtyZXR1cm4gRShuLnNoYXBlLHIuc2hhcGUsXCJFcnJvciBpbiBtYXhpbXVtU3RyaWN0OiBcIiksbi5tYXhpbXVtKHIpfX0pLGRjPUFuKHttaW5pbXVtXzpmdW5jdGlvbih0LGUpe3ZhciBuLHI9bW4odCxcImFcIixcIm1pbmltdW1cIiksbz1tbihlLFwiYlwiLFwibWluaW11bVwiKTtyZXR1cm4gbj1OdChyLG8pLHI9blswXSxvPW5bMV0sXCJib29sXCI9PT1yLmR0eXBlJiYocj1yLnRvSW50KCksbz1vLnRvSW50KCkpLFJvKHIuc2hhcGUsby5zaGFwZSksTHQucnVuS2VybmVsRnVuYygoZnVuY3Rpb24odCxlKXt2YXIgbj10Lm1pbmltdW0ocixvKTtyZXR1cm4gZShbcixvXSksbn0pLHthOnIsYjpvfSwoZnVuY3Rpb24odCxlKXt2YXIgbj1lWzBdLHI9ZVsxXTtyZXR1cm57YTpmdW5jdGlvbigpe3JldHVybiB0Lm11bChuLmxlc3NFcXVhbChyKS50b0Zsb2F0KCkpfSxiOmZ1bmN0aW9uKCl7cmV0dXJuIHQubXVsKG4uZ3JlYXRlcihyKS50b0Zsb2F0KCkpfX19KSxcIk1pbmltdW1cIil9fSkscGM9QW4oe21pbmltdW1TdHJpY3RfOmZ1bmN0aW9uKHQsZSl7dmFyIG49bW4odCxcImFcIixcIm1pbmltdW1TdHJpY3RcIikscj1tbihlLFwiYlwiLFwibWluaW11bVN0cmljdFwiKTtyZXR1cm4gRShuLnNoYXBlLHIuc2hhcGUsXCJFcnJvciBpbiBtaW5pbXVtU3RyaWN0OiBcIiksbi5taW5pbXVtKHIpfX0pLHZjPUFuKHttb2RfOmZ1bmN0aW9uKHQsZSl7dmFyIG4scj1tbih0LFwiYVwiLFwibW9kXCIpLG89bW4oZSxcImJcIixcIm1vZFwiKTtuPU50KHIsbykscj1uWzBdLG89blsxXTt2YXIgYT1SbyhyLnNoYXBlLG8uc2hhcGUpO3JldHVybiBMdC5ydW5LZXJuZWxGdW5jKChmdW5jdGlvbih0LGUpe3ZhciBuPXQubW9kKHIsbyk7cmV0dXJuIGUoW3Isb10pLG59KSx7JGE6ciwkYjpvfSwoZnVuY3Rpb24odCxlKXt2YXIgbj1lWzBdLHI9ZVsxXTtyZXR1cm57JGE6ZnVuY3Rpb24oKXt2YXIgZT1FbyhuLnNoYXBlLGEpO3JldHVybiBlLmxlbmd0aD4wP3Quc3VtKGUpLnJlc2hhcGUobi5zaGFwZSk6dH0sJGI6ZnVuY3Rpb24oKXt2YXIgZT10Lm11bChuLmRpdihyKS5mbG9vcigpLm5lZygpKSxvPUVvKHIuc2hhcGUsYSk7cmV0dXJuIG8ubGVuZ3RoPjA/ZS5zdW0obykucmVzaGFwZShyLnNoYXBlKTplfX19KSl9fSksbWM9QW4oe21vZFN0cmljdF86ZnVuY3Rpb24odCxlKXt2YXIgbj1tbih0LFwiYVwiLFwibW9kU3RyaWN0XCIpLHI9bW4oZSxcImJcIixcIm1vZFN0cmljdFwiKTtyZXR1cm4gRShuLnNoYXBlLHIuc2hhcGUsXCJFcnJvciBpbiBtb2RTdHJpY3Q6IFwiKSxuLm1vZChyKX19KSxnYz1Bbih7bXVsXzpmdW5jdGlvbih0LGUpe3ZhciBuLHI9bW4odCxcImFcIixcIm11bFwiKSxvPW1uKGUsXCJiXCIsXCJtdWxcIik7bj1OdChyLG8pLHI9blswXSxvPW5bMV07dmFyIGE9Um8oci5zaGFwZSxvLnNoYXBlKTtyZXR1cm4gTHQucnVuS2VybmVsRnVuYygoZnVuY3Rpb24odCxlKXt2YXIgbj10Lm11bHRpcGx5KHIsbyk7cmV0dXJuIGUoW3Isb10pLG59KSx7YTpyLGI6b30sKGZ1bmN0aW9uKHQsZSl7dmFyIG49ZVswXSxyPWVbMV07cmV0dXJue2E6ZnVuY3Rpb24oKXt2YXIgZT10Lm11bChyLnRvRmxvYXQoKSksbz1FbyhuLnNoYXBlLGEpO3JldHVybiBvLmxlbmd0aD4wP2Uuc3VtKG8pLnJlc2hhcGUobi5zaGFwZSk6ZX0sYjpmdW5jdGlvbigpe3ZhciBlPXQubXVsKG4udG9GbG9hdCgpKSxvPUVvKHIuc2hhcGUsYSk7cmV0dXJuIG8ubGVuZ3RoPjA/ZS5zdW0obykucmVzaGFwZShyLnNoYXBlKTplfX19KSxcIk11bFwiKX19KSx5Yz1Bbih7bXVsU3RyaWN0XzpmdW5jdGlvbih0LGUpe3ZhciBuPW1uKHQsXCJhXCIsXCJtdWxcIikscj1tbihlLFwiYlwiLFwibXVsXCIpO3JldHVybiBFKG4uc2hhcGUsci5zaGFwZSxcIkVycm9yIGluIG11bHRpcGx5U3RyaWN0OiBcIiksbi5tdWwocil9fSkseGM9QW4oe3Bvd186ZnVuY3Rpb24odCxlKXt2YXIgbixyPW1uKHQsXCJiYXNlXCIsXCJwb3dcIiksbz1tbihlLFwiZXhwXCIsXCJwb3dcIik7bj1OdChyLG8pLHI9blswXSxvPW5bMV07dmFyIGE9Um8oci5zaGFwZSxvLnNoYXBlKSxpPVtyLG9dO3JldHVybiBMdC5ydW5LZXJuZWxGdW5jKChmdW5jdGlvbih0LGUpe3ZhciBuPXQucG93KHIsbyk7cmV0dXJuIGUoW3IsbyxuXSksbn0pLHthOnIsYjpvfSwoZnVuY3Rpb24odCxlKXt2YXIgbj1lWzBdLHI9ZVsxXSxvPWVbMl07cmV0dXJue2E6ZnVuY3Rpb24oKXt2YXIgZT1yLnRvRmxvYXQoKSxvPXQubXVsKGUubXVsKG4ucG93KGUuc3ViKE9uKDEpKSkpKSxpPUVvKG4uc2hhcGUsYSk7cmV0dXJuIGkubGVuZ3RoPjAmJihvPW8uc3VtKGkpKSxvLnJlc2hhcGUobi5zaGFwZSl9LGI6ZnVuY3Rpb24oKXt2YXIgZT1uLmdyZWF0ZXIoMCksaT1uLmxvZygpLndoZXJlKGUsWG4obikpLHM9dC5tdWwoby5tdWwoaSkpLHU9RW8oci5zaGFwZSxhKTtyZXR1cm4gdS5sZW5ndGg+MCYmKHM9cy5zdW0odSkpLHMucmVzaGFwZShyLnNoYXBlKX19fSksXCJQb3dcIix7fSxpLFshMF0pfX0pLGJjPUFuKHtwb3dTdHJpY3RfOmZ1bmN0aW9uKHQsZSl7cmV0dXJuIEUodC5zaGFwZSxlLnNoYXBlLFwiRXJyb3IgaW4gcG93U3RyaWN0OiBcIiksdC5wb3coZSl9fSksd2M9QW4oe3NxdWFyZWREaWZmZXJlbmNlU3RyaWN0XzpmdW5jdGlvbih0LGUpe3ZhciBuPW1uKHQsXCJhXCIsXCJzcXVhcmVkRGlmZmVyZW5jZVN0cmljdFwiKSxyPW1uKGUsXCJiXCIsXCJzcXVhcmVkRGlmZmVyZW5jZVN0cmljdFwiKTtyZXR1cm4gRShuLnNoYXBlLHIuc2hhcGUsXCJFcnJvciBpbiBzcXVhcmVkRGlmZmVyZW5jZVN0cmljdDogXCIpLG4uc3F1YXJlZERpZmZlcmVuY2Uocil9fSksQ2M9QW4oe3N1Yl86ZnVuY3Rpb24odCxlKXt2YXIgbixyPW1uKHQsXCJhXCIsXCJzdWJcIiksbz1tbihlLFwiYlwiLFwic3ViXCIpO249TnQocixvKSxyPW5bMF0sbz1uWzFdO3ZhciBhPVJvKHIuc2hhcGUsby5zaGFwZSk7cmV0dXJuIEx0LnJ1bktlcm5lbEZ1bmMoKGZ1bmN0aW9uKHQpe3JldHVybiB0LnN1YnRyYWN0KHIsbyl9KSx7YTpyLGI6b30sKGZ1bmN0aW9uKHQpe3JldHVybnthOmZ1bmN0aW9uKCl7dmFyIGU9dCxuPUVvKHIuc2hhcGUsYSk7cmV0dXJuIG4ubGVuZ3RoPjAmJihlPWUuc3VtKG4pKSxlLnJlc2hhcGUoci5zaGFwZSl9LGI6ZnVuY3Rpb24oKXt2YXIgZT10LG49RW8oby5zaGFwZSxhKTtyZXR1cm4gbi5sZW5ndGg+MCYmKGU9ZS5zdW0obikpLGUubmVnKCkucmVzaGFwZShvLnNoYXBlKX19fSksXCJTdWJcIil9fSksRWM9QW4oe3N1YlN0cmljdF86ZnVuY3Rpb24odCxlKXt2YXIgbj1tbih0LFwiYVwiLFwic3ViU3RyaWN0XCIpLHI9bW4oZSxcImJcIixcInN1YlN0cmljdFwiKTtyZXR1cm4gRShuLnNoYXBlLHIuc2hhcGUsXCJFcnJvciBpbiBzdWJTdHJpY3Q6IFwiKSxuLnN1YihyKX19KTt2YXIgUmM9QW4oe2VxdWFsXzpmdW5jdGlvbih0LGUpe3ZhciBuLHI9bW4odCxcImFcIixcImVxdWFsXCIpLG89bW4oZSxcImJcIixcImVxdWFsXCIpO3JldHVybiBuPU50KHIsbykscj1uWzBdLG89blsxXSxSbyhyLnNoYXBlLG8uc2hhcGUpLEx0LnJ1bktlcm5lbEZ1bmMoKGZ1bmN0aW9uKHQpe3JldHVybiB0LmVxdWFsKHIsbyl9KSx7JGE6ciwkYjpvfSl9fSksSWM9QW4oe2VxdWFsU3RyaWN0XzpmdW5jdGlvbih0LGUpe3ZhciBuPW1uKHQsXCJhXCIsXCJlcXVhbFN0cmljdFwiKSxyPW1uKGUsXCJiXCIsXCJlcXVhbFN0cmljdFwiKTtyZXR1cm4gRShuLnNoYXBlLHIuc2hhcGUsXCJFcnJvciBpbiBlcXVhbFN0cmljdDogXCIpLG4uZXF1YWwocil9fSksa2M9QW4oe2dyZWF0ZXJfOmZ1bmN0aW9uKHQsZSl7dmFyIG4scj1tbih0LFwiYVwiLFwiZ3JlYXRlclwiKSxvPW1uKGUsXCJiXCIsXCJncmVhdGVyXCIpO3JldHVybiBuPU50KHIsbykscj1uWzBdLG89blsxXSxSbyhyLnNoYXBlLG8uc2hhcGUpLEx0LnJ1bktlcm5lbEZ1bmMoKGZ1bmN0aW9uKHQpe3JldHVybiB0LmdyZWF0ZXIocixvKX0pLHthOnIsYjpvfSxudWxsLFwiR3JlYXRlclwiKX19KSxTYz1Bbih7Z3JlYXRlckVxdWFsXzpmdW5jdGlvbih0LGUpe3ZhciBuLHI9bW4odCxcImFcIixcImdyZWF0ZXJFcXVhbFwiKSxvPW1uKGUsXCJiXCIsXCJncmVhdGVyRXF1YWxcIik7cmV0dXJuIG49TnQocixvKSxyPW5bMF0sbz1uWzFdLFJvKHIuc2hhcGUsby5zaGFwZSksTHQucnVuS2VybmVsRnVuYygoZnVuY3Rpb24odCxlKXt2YXIgbj10LmdyZWF0ZXJFcXVhbChyLG8pO3JldHVybiBlKFtyLG9dKSxufSkse2E6cixiOm99LChmdW5jdGlvbih0LGUpe3ZhciBuPWVbMF0scj1lWzFdO3JldHVybnthOmZ1bmN0aW9uKCl7cmV0dXJuIFhuKG4pfSxiOmZ1bmN0aW9uKCl7cmV0dXJuIFhuKHIpfX19KSxcIkdyZWF0ZXJFcXVhbFwiKX19KSxBYz1Bbih7Z3JlYXRlckVxdWFsU3RyaWN0XzpmdW5jdGlvbih0LGUpe3ZhciBuPW1uKHQsXCJhXCIsXCJncmVhdGVyRXF1YWxTdHJpY3RcIikscj1tbihlLFwiYlwiLFwiZ3JlYXRlckVxdWFsU3RyaWN0XCIpO3JldHVybiBFKG4uc2hhcGUsci5zaGFwZSxcIkVycm9yIGluIGdyZWF0ZXJFcXVhbFN0cmljdDogXCIpLG4uZ3JlYXRlckVxdWFsKHIpfX0pLERjPUFuKHtncmVhdGVyU3RyaWN0XzpmdW5jdGlvbih0LGUpe3ZhciBuPW1uKHQsXCJhXCIsXCJncmVhdGVyU3RyaWN0XCIpLHI9bW4oZSxcImJcIixcImdyZWF0ZXJTdHJpY3RcIik7cmV0dXJuIEUobi5zaGFwZSxyLnNoYXBlLFwiRXJyb3IgaW4gZ3JlYXRlclN0cmljdDogXCIpLG4uZ3JlYXRlcihyKX19KSxUYz1Bbih7bGVzc186ZnVuY3Rpb24odCxlKXt2YXIgbixyPW1uKHQsXCJhXCIsXCJsZXNzXCIpLG89bW4oZSxcImJcIixcImxlc3NcIik7cmV0dXJuIG49TnQocixvKSxyPW5bMF0sbz1uWzFdLFJvKHIuc2hhcGUsby5zaGFwZSksTHQucnVuS2VybmVsRnVuYygoZnVuY3Rpb24odCl7cmV0dXJuIHQubGVzcyhyLG8pfSkse2E6cixiOm99LG51bGwsXCJMZXNzXCIpfX0pLE5jPUFuKHtsZXNzRXF1YWxfOmZ1bmN0aW9uKHQsZSl7dmFyIG4scj1tbih0LFwiYVwiLFwibGVzc0VxdWFsXCIpLG89bW4oZSxcImJcIixcImxlc3NFcXVhbFwiKTtyZXR1cm4gbj1OdChyLG8pLHI9blswXSxvPW5bMV0sUm8oci5zaGFwZSxvLnNoYXBlKSxMdC5ydW5LZXJuZWxGdW5jKChmdW5jdGlvbih0LGUpe3ZhciBuPXQubGVzc0VxdWFsKHIsbyk7cmV0dXJuIGUoW3Isb10pLG59KSx7YTpyLGI6b30sbnVsbCxcIkxlc3NFcXVhbFwiKX19KSxGYz1Bbih7bGVzc0VxdWFsU3RyaWN0XzpmdW5jdGlvbih0LGUpe3ZhciBuPW1uKHQsXCJhXCIsXCJsZXNzRXF1YWxTdHJpY3RcIikscj1tbihlLFwiYlwiLFwibGVzc0VxdWFsU3RyaWN0XCIpO3JldHVybiBFKG4uc2hhcGUsci5zaGFwZSxcIkVycm9yIGluIGxlc3NFcXVhbFN0cmljdDogXCIpLG4ubGVzc0VxdWFsKHIpfX0pLF9jPUFuKHtsZXNzU3RyaWN0XzpmdW5jdGlvbih0LGUpe3ZhciBuPW1uKHQsXCJhXCIsXCJsZXNzU3RyaWN0XCIpLHI9bW4oZSxcImJcIixcImxlc3NTdHJpY3RcIik7cmV0dXJuIEUobi5zaGFwZSxyLnNoYXBlLFwiRXJyb3IgaW4gbGVzc1N0cmljdDogXCIpLG4ubGVzcyhyKX19KSxPYz1Bbih7bm90RXF1YWxfOmZ1bmN0aW9uKHQsZSl7dmFyIG4scj1tbih0LFwiYVwiLFwibm90RXF1YWxcIiksbz1tbihlLFwiYlwiLFwibm90RXF1YWxcIik7cmV0dXJuIG49TnQocixvKSxyPW5bMF0sbz1uWzFdLFJvKHIuc2hhcGUsby5zaGFwZSksTHQucnVuS2VybmVsRnVuYygoZnVuY3Rpb24odCl7cmV0dXJuIHQubm90RXF1YWwocixvKX0pLHthOnIsYjpvfSxudWxsLFwiTm90RXF1YWxcIil9fSksTWM9QW4oe25vdEVxdWFsU3RyaWN0XzpmdW5jdGlvbih0LGUpe3ZhciBuPW1uKHQsXCJhXCIsXCJub3RFcXVhbFN0cmljdFwiKSxyPW1uKGUsXCJiXCIsXCJub3RFcXVhbFN0cmljdFwiKTtyZXR1cm4gRShuLnNoYXBlLHIuc2hhcGUsXCJFcnJvciBpbiBub3RFcXVhbFN0cmljdDogXCIpLG4ubm90RXF1YWwocil9fSk7ZnVuY3Rpb24gQmModCxlKXtmb3IodmFyIG49W10scj10O3I8ZTsrK3Ipbi5wdXNoKHIpO3JldHVybiBufWZ1bmN0aW9uIFBjKHQpe2Zvcih2YXIgZT1bXSxuPTA7bjx0Lmxlbmd0aDsrK24pZm9yKHZhciByPTA7cjx0W25dLmxlbmd0aDsrK3IpZS5wdXNoKHRbbl1bcl0pO3JldHVybiBlfXZhciBMYz1Bbih7Z2F0aGVyXzpmdW5jdGlvbih0LGUsbil7dm9pZCAwPT09biYmKG49MCk7dmFyIHI9bW4odCxcInhcIixcImdhdGhlclwiKSxvPW1uKGUsXCJpbmRpY2VzXCIsXCJnYXRoZXJcIixcImludDMyXCIpO249TyhuLHIuc2hhcGUpWzBdO3ZhciBhPWZ1bmN0aW9uKHQsZSxuKXtmb3IodmFyIHI9dC5zaGFwZVtuXSxvPVtdLGE9MSxpPTEscz0wO3M8bjtzKyspby5wdXNoKHQuc2hhcGVbc10pLGEqPXQuc2hhcGVbc107Zm9yKHM9MDtzPGUucmFuaztzKyspby5wdXNoKGUuc2hhcGVbc10pO2ZvcihzPW4rMTtzPHQucmFuaztzKyspby5wdXNoKHQuc2hhcGVbc10pLGkqPXQuc2hhcGVbc107cmV0dXJue2JhdGNoU2l6ZTphLHNsaWNlU2l6ZTppLGRpbVNpemU6cixvdXRwdXRTaGFwZTpvfX0ocixvLG4pO3JldHVybiBMdC5ydW5LZXJuZWxGdW5jKChmdW5jdGlvbih0LGUpe3ZhciBhPXQuZ2F0aGVyKHIsby5mbGF0dGVuKCksbik7cmV0dXJuIGUoW29dKSxhfSkse3g6cixpbmRpY2VzOm99LChmdW5jdGlvbih0LGUpe3ZhciBvPWVbMF07cmV0dXJue3g6ZnVuY3Rpb24oKXt2YXIgZT1yLnNoYXBlLGE9by5zaXplLGk9ZS5zbGljZSgwLG4pLHM9aS5sZW5ndGgsdT1lLnNsaWNlKG4sZS5sZW5ndGgpLnNsaWNlKDEpLGM9dS5sZW5ndGgsbD1CYygwLHMpLGg9QmMocysxLHMrMStjKSxmPVBjKFtpLFthXSx1XSksZD10LnJlc2hhcGUoZikscD1vLnJlc2hhcGUoW2FdKSx2PVBjKFtbc10sbCxoXSksbT1kLnRyYW5zcG9zZSh2KSxnPVdjKG0scCxyLnNoYXBlW25dKSx5PVJuKHYpO3JldHVybiBnPWcudHJhbnNwb3NlKHkpfSxpbmRpY2VzOmZ1bmN0aW9uKCl7cmV0dXJuIG99fX0pLFwiR2F0aGVyXCIse2F4aXM6bn0pLnJlc2hhcGUoYS5vdXRwdXRTaGFwZSl9fSksV2M9QW4oe3Vuc29ydGVkU2VnbWVudFN1bV86ZnVuY3Rpb24odCxlLG4pe3ZhciByPW1uKHQsXCJ4XCIsXCJ1bnNvcnRlZFNlZ21lbnRTdW1cIiksbz1tbihlLFwic2VnbWVudElkc1wiLFwidW5zb3J0ZWRTZWdtZW50U3VtXCIsXCJpbnQzMlwiKTtyZXR1cm4gQyhBKG4pLChmdW5jdGlvbigpe3JldHVyblwibnVtU2VnbWVudHMgbXVzdCBiZSBvZiBkdHlwZSBpbnRcIn0pKSxMdC5ydW5LZXJuZWxGdW5jKChmdW5jdGlvbih0LGUpe3ZhciBhPXQudW5zb3J0ZWRTZWdtZW50U3VtKHIsbyxuKTtyZXR1cm4gZShbb10pLGF9KSx7JHg6cn0sKGZ1bmN0aW9uKHQsZSl7dmFyIG49ZVswXTtyZXR1cm57JHg6ZnVuY3Rpb24oKXtyZXR1cm4gZnVuY3Rpb24odCxlKXtmb3IodmFyIG49aGMoZSxYbihlKSkscj1MYyh0LG4pLG89U2MoZSxPbigwLFwiaW50MzJcIikpLGE9ci5yYW5rLW8ucmFuayxpPTA7aTxhOysraSlvPXdyKG8saSsxKTtvPVF1KG8sem4oci5zaGFwZSxcImJvb2xcIikpO3ZhciBzPVhuKHIpO3JldHVybiBlYyhvLHIscyl9KHQsbil9fX0pKX19KTt2YXIgVWM9ZnVuY3Rpb24odCxlLG8pe3JldHVybiBuKHRoaXMsdm9pZCAwLHZvaWQgMCwoZnVuY3Rpb24oKXt2YXIgbixhLGkscyx1LGMsbCxoLGYsZCxwLHYsbTtyZXR1cm4gcih0aGlzLChmdW5jdGlvbihyKXtzd2l0Y2goci5sYWJlbCl7Y2FzZSAwOmZvcihuPW1uKHQsXCJ0ZW5zb3JcIixcImJvb2xNYXNrXCIpLGE9bW4oZSxcIm1hc2tcIixcImJvb2xNYXNrXCIsXCJib29sXCIpLGk9bnVsbD09bz8wOm8scz1hLnJhbmssdT1uLnNoYXBlLEMocz4wLChmdW5jdGlvbigpe3JldHVyblwibWFzayBjYW5ub3QgYmUgc2NhbGFyXCJ9KSksRSh1LnNsaWNlKGksaStzKSxhLnNoYXBlLFwibWFzaydzIHNoYXBlIG11c3QgbWF0Y2ggdGhlIGZpcnN0IEsgZGltZW5zaW9ucyBvZiB0ZW5zb3IncyBzaGFwZSxcIiksYz0xLGw9aTtsPGkrcztsKyspYyo9dVtsXTtyZXR1cm4gaD11LnNsaWNlKDAsaSkuY29uY2F0KFtjXSx1LnNsaWNlKGkrcykpLGY9bi5yZXNoYXBlKGgpLGQ9YS5yZXNoYXBlKFstMV0pLFs0LG5jKGQpXTtjYXNlIDE6cmV0dXJuIHA9ci5zZW50KCksdj1wLnNxdWVlemUoWzFdKSxtPUxjKGYsdixpKSx0IT09biYmbi5kaXNwb3NlKCksZSE9PWEmJmEuZGlzcG9zZSgpLHYuZGlzcG9zZSgpLGYuZGlzcG9zZSgpLGQuZGlzcG9zZSgpLHAuZGlzcG9zZSgpLFsyLG1dfX0pKX0pKX07ZnVuY3Rpb24gVmModCxlLG4scixvLGEsaSl7dm9pZCAwPT09YSYmKGE9XCJOSFdDXCIpLEModC5sZW5ndGg9PT1lLnJhbmssKGZ1bmN0aW9uKCl7cmV0dXJuXCJMZW5ndGggb2YgaW5TaGFwZSAoXCIrdC5sZW5ndGgrXCIpIGFuZCByYW5rIG9mIGR5IChcIitlLnJhbmsrXCIpIG11c3QgbWF0Y2hcIn0pKTt2YXIgcz10LHU9ZSxjPSExOzM9PT1lLnJhbmsmJihjPSEwLHU9ZS5hczREKDEsZS5zaGFwZVswXSxlLnNoYXBlWzFdLGUuc2hhcGVbMl0pLHM9WzEsdFswXSx0WzFdLHRbMl1dKSxDKDQ9PT1zLmxlbmd0aCwoZnVuY3Rpb24oKXtyZXR1cm5cIkVycm9yIGluIGNvbnYyZERlcklucHV0OiBpblNoYXBlIG11c3QgYmUgbGVuZ3RoIDQsIGJ1dCBnb3QgbGVuZ3RoIFwiK3MubGVuZ3RoK1wiLlwifSkpLEMoND09PXUucmFuaywoZnVuY3Rpb24oKXtyZXR1cm5cIkVycm9yIGluIGNvbnYyZERlcklucHV0OiBkeSBtdXN0IGJlIHJhbmsgNCwgYnV0IGdvdCByYW5rIFwiK3UucmFua30pKSxDKDQ9PT1uLnJhbmssKGZ1bmN0aW9uKCl7cmV0dXJuXCJFcnJvciBpbiBjb252MmREZXJJbnB1dDogZmlsdGVyIG11c3QgYmUgcmFuayA0LCBidXQgZ290IHJhbmsgXCIrbi5yYW5rfSkpO3ZhciBsPVwiTkhXQ1wiPT09YT9zWzNdOnNbMV0saD1cIk5IV0NcIj09PWE/dS5zaGFwZVszXTp1LnNoYXBlWzFdO0MobD09PW4uc2hhcGVbMl0sKGZ1bmN0aW9uKCl7cmV0dXJuXCJFcnJvciBpbiBjb252MmREZXJJbnB1dDogZGVwdGggb2YgaW5wdXQgKFwiK2wrXCIpIG11c3QgbWF0Y2ggaW5wdXQgZGVwdGggZm9yIGZpbHRlciBcIituLnNoYXBlWzJdK1wiLlwifSkpLEMoaD09PW4uc2hhcGVbM10sKGZ1bmN0aW9uKCl7cmV0dXJuXCJFcnJvciBpbiBjb252MmREZXJJbnB1dDogZGVwdGggb2Ygb3V0cHV0IChcIitoK1wiKSBtdXN0IG1hdGNoIG91dHB1dCBkZXB0aCBmb3IgZmlsdGVyIFwiK24uc2hhcGVbM10rXCIuXCJ9KSksbnVsbCE9aSYmQyhBKG8pLChmdW5jdGlvbigpe3JldHVyblwiRXJyb3IgaW4gY29udjJkRGVySW5wdXQ6IHBhZCBtdXN0IGJlIGFuIGludGVnZXIgd2hlbiB1c2luZywgZGltUm91bmRpbmdNb2RlIFwiK2krXCIgYnV0IGdvdCBwYWQgXCIrbytcIi5cIn0pKTt2YXIgZj1CbyhhKSxkPVNvKHMsbi5zaGFwZSxyLDEsbyxpLCExLGYpLHA9THQucnVuS2VybmVsRnVuYygoZnVuY3Rpb24odCxlKXt2YXIgcj10LmNvbnYyZERlcklucHV0KHUsbixkKTtyZXR1cm4gZShbbix1XSkscn0pLHtkeTREOnUsZmlsdGVyOm59LChmdW5jdGlvbih0LGUpe3ZhciBuPWVbMF0scz1lWzFdO3JldHVybntkeTREOmZ1bmN0aW9uKCl7cmV0dXJuIHFjKHQsbixyLG8sYSwxLGkpfSxmaWx0ZXI6ZnVuY3Rpb24oKXtyZXR1cm4gamModCxzLG4uc2hhcGUscixvLGEsaSl9fX0pKTtyZXR1cm4gYz9wLmFzM0QocC5zaGFwZVsxXSxwLnNoYXBlWzJdLHAuc2hhcGVbM10pOnB9ZnVuY3Rpb24gemModCl7dmFyIGU9ZnVuY3Rpb24odCl7cmV0dXJuXCJudW1iZXJcIj09dHlwZW9mIHQ/W3QsdCx0XToyPT09dC5sZW5ndGg/W3RbMF0sdFsxXSwxXTp0fSh0KSxuPWVbMF0scj1lWzFdLG89ZVsyXTtyZXR1cm4gMT09PW4mJjE9PT1yJiYxPT09b31mdW5jdGlvbiBHYyh0LGUsbixyLG8pe0ModC5sZW5ndGg9PT1lLnJhbmssKGZ1bmN0aW9uKCl7cmV0dXJuXCJMZW5ndGggb2YgaW5TaGFwZSAoXCIrdC5sZW5ndGgrXCIpIGFuZCByYW5rIG9mIGR5IChcIitlLnJhbmsrXCIpIG11c3QgbWF0Y2hcIn0pKTt2YXIgYT10LGk9ZSxzPSExOzQ9PT1lLnJhbmsmJihzPSEwLGk9ZS5hczVEKDEsZS5zaGFwZVswXSxlLnNoYXBlWzFdLGUuc2hhcGVbMl0sZS5zaGFwZVszXSksYT1bMSx0WzBdLHRbMV0sdFsyXSx0WzNdXSk7dmFyIHU9YVs0XSxjPWkuc2hhcGVbNF07Qyg1PT09YS5sZW5ndGgsKGZ1bmN0aW9uKCl7cmV0dXJuXCJFcnJvciBpbiBjb252M2REZXJJbnB1dDogaW5TaGFwZSBtdXN0IGJlIGxlbmd0aCA1LCBidXQgZ290IGxlbmd0aCBcIithLmxlbmd0aCtcIi5cIn0pKSxDKDU9PT1pLnJhbmssKGZ1bmN0aW9uKCl7cmV0dXJuXCJFcnJvciBpbiBjb252M2REZXJJbnB1dDogZHkgbXVzdCBiZSByYW5rIDUsIGJ1dCBnb3QgcmFuayBcIitpLnJhbmt9KSksQyg1PT09bi5yYW5rLChmdW5jdGlvbigpe3JldHVyblwiRXJyb3IgaW4gY29udjNkRGVySW5wdXQ6IGZpbHRlciBtdXN0IGJlIHJhbmsgNSwgYnV0IGdvdCByYW5rIFwiK24ucmFua30pKSxDKHU9PT1uLnNoYXBlWzNdLChmdW5jdGlvbigpe3JldHVyblwiRXJyb3IgaW4gY29udjNkRGVySW5wdXQ6IGRlcHRoIG9mIGlucHV0IChcIit1K1wiKSBtdXN0IG1hdGNoIGlucHV0IGRlcHRoIGZvciBmaWx0ZXIgXCIrbi5zaGFwZVszXStcIi5cIn0pKSxDKGM9PT1uLnNoYXBlWzRdLChmdW5jdGlvbigpe3JldHVyblwiRXJyb3IgaW4gY29udjNkRGVySW5wdXQ6IGRlcHRoIG9mIG91dHB1dCAoXCIrYytcIikgbXVzdCBtYXRjaCBvdXRwdXQgZGVwdGggZm9yIGZpbHRlciBcIituLnNoYXBlWzRdK1wiLlwifSkpO3ZhciBsPUFvKGEsbi5zaGFwZSxyLDEsbyksaD1MdC5ydW5LZXJuZWxGdW5jKChmdW5jdGlvbih0KXtyZXR1cm4gdC5jb252M2REZXJJbnB1dChpLG4sbCl9KSx7ZHk1RDppfSk7cmV0dXJuIHM/aC5hczREKGguc2hhcGVbMV0saC5zaGFwZVsyXSxoLnNoYXBlWzNdLGguc2hhcGVbNF0pOmh9dmFyIEhjPUFuKHtjb252MWRfOmZ1bmN0aW9uKHQsZSxuLHIsbyxhLGkpe3ZvaWQgMD09PW8mJihvPVwiTldDXCIpLHZvaWQgMD09PWEmJihhPTEpO3ZhciBzPW1uKHQsXCJ4XCIsXCJjb252MWRcIiksdT1tbihlLFwiZmlsdGVyXCIsXCJjb252MWRcIiksYz1zLGw9ITE7Mj09PXMucmFuayYmKGw9ITAsYz1zLmFzM0QoMSxzLnNoYXBlWzBdLHMuc2hhcGVbMV0pKSxDKDM9PT1jLnJhbmssKGZ1bmN0aW9uKCl7cmV0dXJuXCJFcnJvciBpbiBjb252MWQ6IGlucHV0IG11c3QgYmUgcmFuayAzLCBidXQgZ290IHJhbmsgXCIrYy5yYW5rK1wiLlwifSkpLEMoMz09PXUucmFuaywoZnVuY3Rpb24oKXtyZXR1cm5cIkVycm9yIGluIGNvbnYxZDogZmlsdGVyIG11c3QgYmUgcmFuayAzLCBidXQgZ290IHJhbmsgXCIrdS5yYW5rK1wiLlwifSkpLG51bGwhPWkmJkMoQShyKSwoZnVuY3Rpb24oKXtyZXR1cm5cIkVycm9yIGluIGNvbnYxZDogcGFkIG11c3QgYmUgYW4gaW50ZWdlciB3aGVuIHVzaW5nLCBkaW1Sb3VuZGluZ01vZGUgXCIraStcIiBidXQgZ290IHBhZCBcIityK1wiLlwifSkpLEMoYy5zaGFwZVsyXT09PXUuc2hhcGVbMV0sKGZ1bmN0aW9uKCl7cmV0dXJuXCJFcnJvciBpbiBjb252MWQ6IGRlcHRoIG9mIGlucHV0IChcIitjLnNoYXBlWzJdK1wiKSBtdXN0IG1hdGNoIGlucHV0IGRlcHRoIGZvciBmaWx0ZXIgXCIrdS5zaGFwZVsxXStcIi5cIn0pKSxDKE1vKG4sYSksKGZ1bmN0aW9uKCl7cmV0dXJuXCJFcnJvciBpbiBjb252MUQ6IEVpdGhlciBzdHJpZGUgb3IgZGlsYXRpb24gbXVzdCBiZSAxLiBHb3Qgc3RyaWRlIFwiK24rXCIgYW5kIGRpbGF0aW9uICdcIithK1wiJ1wifSkpLEMoXCJOV0NcIj09PW8sKGZ1bmN0aW9uKCl7cmV0dXJuXCJFcnJvciBpbiBjb252MWQ6IGdvdCBkYXRhRm9ybWF0IG9mIFwiK28rXCIgYnV0IG9ubHkgTldDIGlzIGN1cnJlbnRseSBzdXBwb3J0ZWQuXCJ9KSk7dmFyIGg9dS5hczREKDEsdS5zaGFwZVswXSx1LnNoYXBlWzFdLHUuc2hhcGVbMl0pLGY9Yy5hczREKGMuc2hhcGVbMF0sMSxjLnNoYXBlWzFdLGMuc2hhcGVbMl0pLGQ9cWMoZixoLFsxLG5dLHIsXCJOSFdDXCIsWzEsYV0saSk7cmV0dXJuIGw/ZC5hczJEKGQuc2hhcGVbMl0sZC5zaGFwZVszXSk6ZC5hczNEKGQuc2hhcGVbMF0sZC5zaGFwZVsyXSxkLnNoYXBlWzNdKX19KSxxYz1Bbih7Y29udjJkXzpmdW5jdGlvbih0LGUsbixyLG8sYSxpKXt2b2lkIDA9PT1vJiYobz1cIk5IV0NcIiksdm9pZCAwPT09YSYmKGE9WzEsMV0pO3ZhciBzPW1uKHQsXCJ4XCIsXCJjb252MmRcIiksdT1tbihlLFwiZmlsdGVyXCIsXCJjb252MmRcIiksYz1zLGw9ITE7Mz09PXMucmFuayYmKGw9ITAsYz1zLmFzNEQoMSxzLnNoYXBlWzBdLHMuc2hhcGVbMV0scy5zaGFwZVsyXSkpLEMoND09PWMucmFuaywoZnVuY3Rpb24oKXtyZXR1cm5cIkVycm9yIGluIGNvbnYyZDogaW5wdXQgbXVzdCBiZSByYW5rIDQsIGJ1dCBnb3QgcmFuayBcIitjLnJhbmsrXCIuXCJ9KSksQyg0PT09dS5yYW5rLChmdW5jdGlvbigpe3JldHVyblwiRXJyb3IgaW4gY29udjJkOiBmaWx0ZXIgbXVzdCBiZSByYW5rIDQsIGJ1dCBnb3QgcmFuayBcIit1LnJhbmsrXCIuXCJ9KSksbnVsbCE9aSYmQyhBKHIpLChmdW5jdGlvbigpe3JldHVyblwiRXJyb3IgaW4gY29udjJkOiBwYWQgbXVzdCBiZSBhbiBpbnRlZ2VyIHdoZW4gdXNpbmcsIGRpbVJvdW5kaW5nTW9kZSBcIitpK1wiIGJ1dCBnb3QgcGFkIFwiK3IrXCIuXCJ9KSk7dmFyIGg9XCJOSFdDXCI9PT1vP2Muc2hhcGVbM106Yy5zaGFwZVsxXTtDKGg9PT11LnNoYXBlWzJdLChmdW5jdGlvbigpe3JldHVyblwiRXJyb3IgaW4gY29udjJkOiBkZXB0aCBvZiBpbnB1dCAoXCIraCtcIikgbXVzdCBtYXRjaCBpbnB1dCBkZXB0aCBmb3IgZmlsdGVyIFwiK3Uuc2hhcGVbMl0rXCIuXCJ9KSksQyhNbyhuLGEpLChmdW5jdGlvbigpe3JldHVyblwiRXJyb3IgaW4gY29udjJEOiBFaXRoZXIgc3RyaWRlcyBvciBkaWxhdGlvbnMgbXVzdCBiZSAxLiBHb3Qgc3RyaWRlcyBcIituK1wiIGFuZCBkaWxhdGlvbnMgJ1wiK2ErXCInXCJ9KSk7dmFyIGY9Qm8obyksZD1TbyhjLnNoYXBlLHUuc2hhcGUsbixhLHIsaSwhMSxmKSxwPVt1LGNdLHY9THQucnVuS2VybmVsRnVuYygoZnVuY3Rpb24odCxlKXt2YXIgbj10LmNvbnYyZChjLHUsZCk7cmV0dXJuIGUoW3UsY10pLG59KSx7eDpjLGZpbHRlcjp1fSwoZnVuY3Rpb24odCxlKXt2YXIgaT1lLHM9aVswXSx1PWlbMV07cmV0dXJuIEMoT28oYSksKGZ1bmN0aW9uKCl7cmV0dXJuXCJFcnJvciBpbiBncmFkaWVudCBvZiBjb252MkQ6IGRpbGF0aW9uIHJhdGVzIGdyZWF0ZXIgdGhhbiAxIGFyZSBub3QgeWV0IHN1cHBvcnRlZCBpbiBncmFkaWVudHMuIEdvdCBkaWxhdGlvbnMgJ1wiK2ErXCInXCJ9KSkse3g6ZnVuY3Rpb24oKXtyZXR1cm4gWGModS5zaGFwZSx0LHMsbixyLG8pfSxmaWx0ZXI6ZnVuY3Rpb24oKXtyZXR1cm4gamModSx0LHMuc2hhcGUsbixyLG8pfX19KSxcIkNvbnYyRFwiLGQscCk7cmV0dXJuIGw/di5hczNEKHYuc2hhcGVbMV0sdi5zaGFwZVsyXSx2LnNoYXBlWzNdKTp2fX0pLEtjPUFuKHtjb252M2RfOmZ1bmN0aW9uKHQsZSxuLHIsbyxhKXt2b2lkIDA9PT1vJiYobz1cIk5ESFdDXCIpLHZvaWQgMD09PWEmJihhPVsxLDEsMV0pO3ZhciBpPW1uKHQsXCJ4XCIsXCJjb252M2RcIikscz1tbihlLFwiZmlsdGVyXCIsXCJjb252M2RcIiksdT1pLGM9ITE7ND09PWkucmFuayYmKGM9ITAsdT1pLmFzNUQoMSxpLnNoYXBlWzBdLGkuc2hhcGVbMV0saS5zaGFwZVsyXSxpLnNoYXBlWzNdKSksQyg1PT09dS5yYW5rLChmdW5jdGlvbigpe3JldHVyblwiRXJyb3IgaW4gY29udjNkOiBpbnB1dCBtdXN0IGJlIHJhbmsgNSwgYnV0IGdvdCByYW5rIFwiK3UucmFuaytcIi5cIn0pKSxDKDU9PT1zLnJhbmssKGZ1bmN0aW9uKCl7cmV0dXJuXCJFcnJvciBpbiBjb252M2Q6IGZpbHRlciBtdXN0IGJlIHJhbmsgNSwgYnV0IGdvdCByYW5rIFwiK3MucmFuaytcIi5cIn0pKSxDKHUuc2hhcGVbNF09PT1zLnNoYXBlWzNdLChmdW5jdGlvbigpe3JldHVyblwiRXJyb3IgaW4gY29udjNkOiBkZXB0aCBvZiBpbnB1dCAoXCIrdS5zaGFwZVs0XStcIikgbXVzdCBtYXRjaCBpbnB1dCBkZXB0aCBmb3IgZmlsdGVyIFwiK3Muc2hhcGVbM10rXCIuXCJ9KSksQyhmdW5jdGlvbih0LGUpe3JldHVybiB6Yyh0KXx8emMoZSl9KG4sYSksKGZ1bmN0aW9uKCl7cmV0dXJuXCJFcnJvciBpbiBjb252M0Q6IEVpdGhlciBzdHJpZGVzIG9yIGRpbGF0aW9ucyBtdXN0IGJlIDEuIEdvdCBzdHJpZGVzIFwiK24rXCIgYW5kIGRpbGF0aW9ucyAnXCIrYStcIidcIn0pKSxDKFwiTkRIV0NcIj09PW8sKGZ1bmN0aW9uKCl7cmV0dXJuXCJFcnJvciBpbiBjb252M2Q6IGdvdCBkYXRhRm9ybWF0IG9mIFwiK28rXCIgYnV0IG9ubHkgTkRIV0MgaXMgY3VycmVudGx5IHN1cHBvcnRlZC5cIn0pKTt2YXIgbD1Bbyh1LnNoYXBlLHMuc2hhcGUsbixhLHIpLGg9THQucnVuS2VybmVsRnVuYygoZnVuY3Rpb24odCxlKXt2YXIgbj10LmNvbnYzZCh1LHMsbCk7cmV0dXJuIGUoW3Usc10pLG59KSx7eDp1LCRmaWx0ZXI6c30sKGZ1bmN0aW9uKHQsZSl7Qyh6YyhhKSwoZnVuY3Rpb24oKXtyZXR1cm5cIkVycm9yIGluIGdyYWRpZW50IG9mIGNvbnYzRDogZGlsYXRpb24gcmF0ZXMgZ3JlYXRlciB0aGFuIDEgYXJlIG5vdCB5ZXQgc3VwcG9ydGVkIGluIGdyYWRpZW50cy4gR290IGRpbGF0aW9ucyAnXCIrYStcIidcIn0pKTt2YXIgbz1lWzBdLGk9ZVsxXTtyZXR1cm57eDpmdW5jdGlvbigpe3JldHVybiBHYyhvLnNoYXBlLHQsaSxuLHIpfSwkZmlsdGVyOmZ1bmN0aW9uKCl7cmV0dXJuIGZ1bmN0aW9uKHQsZSxuLHIsbyl7dmFyIGE9dDs0PT09dC5yYW5rJiYoYT10LmFzNUQoMSx0LnNoYXBlWzBdLHQuc2hhcGVbMV0sdC5zaGFwZVsyXSx0LnNoYXBlWzNdKSk7dmFyIGk9ZTs0PT09aS5yYW5rJiYoaT1lLmFzNUQoMSxlLnNoYXBlWzBdLGUuc2hhcGVbMV0sZS5zaGFwZVsyXSxlLnNoYXBlWzNdKSk7Qyg1PT09YS5yYW5rLChmdW5jdGlvbigpe3JldHVyblwiRXJyb3IgaW4gY29udjNkRGVyRmlsdGVyOiBpbnB1dCBtdXN0IGJlIHJhbmsgNSwgYnV0IGdvdCBzaGFwZSBcIithLnNoYXBlK1wiLlwifSkpLEMoNT09PWkucmFuaywoZnVuY3Rpb24oKXtyZXR1cm5cIkVycm9yIGluIGNvbnYzZERlckZpbHRlcjogZHkgbXVzdCBiZSByYW5rIDUsIGJ1dCBnb3Qgc2hhcGUgXCIraS5zaGFwZStcIi5cIn0pKSxDKDU9PT1uLmxlbmd0aCwoZnVuY3Rpb24oKXtyZXR1cm5cIkVycm9yIGluIGNvbnYzZERlckZpbHRlcjogZmlsdGVyU2hhcGUgbXVzdCBiZSBsZW5ndGggNSwgYnV0IGdvdCBcIituK1wiLlwifSkpLEMoYS5zaGFwZVs0XT09PW5bM10sKGZ1bmN0aW9uKCl7cmV0dXJuXCJFcnJvciBpbiBjb252M2REZXJGaWx0ZXI6IGRlcHRoIG9mIGlucHV0IFwiK2Euc2hhcGVbNF0rXCIpIG11c3QgbWF0Y2ggaW5wdXQgZGVwdGggaW4gZmlsdGVyIChcIituWzNdK1wiLlwifSkpLEMoaS5zaGFwZVs0XT09PW5bNF0sKGZ1bmN0aW9uKCl7cmV0dXJuXCJFcnJvciBpbiBjb252M2REZXJGaWx0ZXI6IGRlcHRoIG9mIGR5IChcIitpLnNoYXBlWzRdK1wiKSBtdXN0IG1hdGNoIG91dHB1dCBkZXB0aCBmb3IgZmlsdGVyIChcIituWzRdK1wiKS5cIn0pKTt2YXIgcz1BbyhhLnNoYXBlLG4sciwxLG8pO3JldHVybiBMdC5ydW5LZXJuZWxGdW5jKChmdW5jdGlvbih0KXtyZXR1cm4gdC5jb252M2REZXJGaWx0ZXIoYSxpLHMpfSkse3g1RDphLGR5NUQ6aX0pfShvLHQsaS5zaGFwZSxuLHIpfX19KSk7cmV0dXJuIGM/aC5hczREKGguc2hhcGVbMV0saC5zaGFwZVsyXSxoLnNoYXBlWzNdLGguc2hhcGVbNF0pOmh9fSksamM9QW4oe2NvbnYyZERlckZpbHRlcl86ZnVuY3Rpb24odCxlLG4scixvLGEsaSl7dm9pZCAwPT09YSYmKGE9XCJOSFdDXCIpO3ZhciBzPXQ7Mz09PXQucmFuayYmKHM9dC5hczREKDEsdC5zaGFwZVswXSx0LnNoYXBlWzFdLHQuc2hhcGVbMl0pKTt2YXIgdT1lOzM9PT11LnJhbmsmJih1PWUuYXM0RCgxLGUuc2hhcGVbMF0sZS5zaGFwZVsxXSxlLnNoYXBlWzJdKSksQyg0PT09cy5yYW5rLChmdW5jdGlvbigpe3JldHVyblwiRXJyb3IgaW4gY29udjJkRGVyRmlsdGVyOiBpbnB1dCBtdXN0IGJlIHJhbmsgNCwgYnV0IGdvdCBzaGFwZSBcIitzLnNoYXBlK1wiLlwifSkpLEMoND09PXUucmFuaywoZnVuY3Rpb24oKXtyZXR1cm5cIkVycm9yIGluIGNvbnYyZERlckZpbHRlcjogZHkgbXVzdCBiZSByYW5rIDQsIGJ1dCBnb3Qgc2hhcGUgXCIrdS5zaGFwZStcIi5cIn0pKSxDKDQ9PT1uLmxlbmd0aCwoZnVuY3Rpb24oKXtyZXR1cm5cIkVycm9yIGluIGNvbnYyZERlckZpbHRlcjogZmlsdGVyU2hhcGUgbXVzdCBiZSBsZW5ndGggNCwgYnV0IGdvdCBcIituK1wiLlwifSkpO3ZhciBjPVwiTkhXQ1wiPT09YT9zLnNoYXBlWzNdOnMuc2hhcGVbMV0sbD1cIk5IV0NcIj09PWE/dS5zaGFwZVszXTp1LnNoYXBlWzFdO0MoYz09PW5bMl0sKGZ1bmN0aW9uKCl7cmV0dXJuXCJFcnJvciBpbiBjb252MmREZXJGaWx0ZXI6IGRlcHRoIG9mIGlucHV0IFwiK2MrXCIpIG11c3QgbWF0Y2ggaW5wdXQgZGVwdGggaW4gZmlsdGVyIChcIituWzJdK1wiLlwifSkpLEMobD09PW5bM10sKGZ1bmN0aW9uKCl7cmV0dXJuXCJFcnJvciBpbiBjb252MmREZXJGaWx0ZXI6IGRlcHRoIG9mIGR5IChcIitsK1wiKSBtdXN0IG1hdGNoIG91dHB1dCBkZXB0aCBmb3IgZmlsdGVyIChcIituWzNdK1wiKS5cIn0pKSxudWxsIT1pJiZDKEEobyksKGZ1bmN0aW9uKCl7cmV0dXJuXCJFcnJvciBpbiBjb252MmREZXJGaWx0ZXI6IHBhZCBtdXN0IGJlIGFuIGludGVnZXIgd2hlbiB1c2luZywgZGltUm91bmRpbmdNb2RlIFwiK2krXCIgYnV0IGdvdCBwYWQgXCIrbytcIi5cIn0pKTt2YXIgaD1CbyhhKSxmPVNvKHMuc2hhcGUsbixyLDEsbyxpLCExLGgpO3JldHVybiBMdC5ydW5LZXJuZWxGdW5jKChmdW5jdGlvbih0KXtyZXR1cm4gdC5jb252MmREZXJGaWx0ZXIocyx1LGYpfSkse3g0RDpzLGR5NEQ6dX0pfX0pLFhjPUFuKHtjb252MmREZXJJbnB1dF86VmN9KSxZYz1Bbih7ZGVwdGh3aXNlQ29udjJkXzpmdW5jdGlvbih0LGUsbixyLG8sYSxpKXt2b2lkIDA9PT1vJiYobz1cIk5IV0NcIiksdm9pZCAwPT09YSYmKGE9WzEsMV0pO3ZhciBzPW1uKHQsXCJ4XCIsXCJkZXB0aHdpc2VDb252MmRcIiksdT1tbihlLFwiZmlsdGVyXCIsXCJkZXB0aHdpc2VDb252MmRcIiksYz1zLGw9ITE7Mz09PXMucmFuayYmKGw9ITAsYz1zLmFzNEQoMSxzLnNoYXBlWzBdLHMuc2hhcGVbMV0scy5zaGFwZVsyXSkpLEMoND09PWMucmFuaywoZnVuY3Rpb24oKXtyZXR1cm5cIkVycm9yIGluIGRlcHRod2lzZUNvbnYyZDogaW5wdXQgbXVzdCBiZSByYW5rIDQsIGJ1dCBnb3QgcmFuayBcIitjLnJhbmsrXCIuXCJ9KSksQyg0PT09dS5yYW5rLChmdW5jdGlvbigpe3JldHVyblwiRXJyb3IgaW4gZGVwdGh3aXNlQ29udjJkOiBmaWx0ZXIgbXVzdCBiZSByYW5rIDQsIGJ1dCBnb3QgcmFuayBcIit1LnJhbmsrXCIuXCJ9KSksQyhjLnNoYXBlWzNdPT09dS5zaGFwZVsyXSwoZnVuY3Rpb24oKXtyZXR1cm5cIkVycm9yIGluIGRlcHRod2lzZUNvbnYyZDogbnVtYmVyIG9mIGlucHV0IGNoYW5uZWxzIChcIitjLnNoYXBlWzNdK1wiKSBtdXN0IG1hdGNoIHRoZSBpbkNoYW5uZWxzIGRpbWVuc2lvbiBpbiBmaWx0ZXIgXCIrdS5zaGFwZVsyXStcIi5cIn0pKSxudWxsPT1hJiYoYT1bMSwxXSksQyhNbyhuLGEpLChmdW5jdGlvbigpe3JldHVyblwiRXJyb3IgaW4gZGVwdGh3aXNlQ29udjJkOiBFaXRoZXIgc3RyaWRlcyBvciBkaWxhdGlvbnMgbXVzdCBiZSAxLiBHb3Qgc3RyaWRlcyBcIituK1wiIGFuZCBkaWxhdGlvbnMgJ1wiK2ErXCInXCJ9KSksbnVsbCE9aSYmQyhBKHIpLChmdW5jdGlvbigpe3JldHVyblwiRXJyb3IgaW4gZGVwdGh3aXNlQ29udjJkOiBwYWQgbXVzdCBiZSBhbiBpbnRlZ2VyIHdoZW4gdXNpbmcsIGRpbVJvdW5kaW5nTW9kZSBcIitpK1wiIGJ1dCBnb3QgcGFkIFwiK3IrXCIuXCJ9KSk7dmFyIGg9U28oYy5zaGFwZSx1LnNoYXBlLG4sYSxyLGksITApLGY9W2MsdV0sZD1MdC5ydW5LZXJuZWxGdW5jKChmdW5jdGlvbih0LGUpe3ZhciBuPXQuZGVwdGh3aXNlQ29udjJEKGMsdSxoKTtyZXR1cm4gZShbYyx1XSksbn0pLHt4OmMsZmlsdGVyOnV9LChmdW5jdGlvbih0LGUpe0MoT28oYSksKGZ1bmN0aW9uKCl7cmV0dXJuXCJFcnJvciBpbiBncmFkaWVudCBvZiBkZXB0aHdpc2VDb252MmQ6IGRpbGF0aW9uIHJhdGVzIGdyZWF0ZXIgdGhhbiAxIGFyZSBub3QgeWV0IHN1cHBvcnRlZC4gR290IGRpbGF0aW9ucyAnXCIrYStcIidcIn0pKTt2YXIgbj1lWzBdLHI9ZVsxXTtyZXR1cm57eDpmdW5jdGlvbigpe3JldHVybiAkYyhuLnNoYXBlLHQscixoKX0sZmlsdGVyOmZ1bmN0aW9uKCl7cmV0dXJuIFFjKG4sdCxyLnNoYXBlLGgpfX19KSxcIkRlcHRod2lzZUNvbnYyZE5hdGl2ZVwiLGgsZik7cmV0dXJuIGw/ZC5hczNEKGQuc2hhcGVbMV0sZC5zaGFwZVsyXSxkLnNoYXBlWzNdKTpkfX0pLCRjPUFuKHtkZXB0aHdpc2VDb252MmREZXJJbnB1dF86ZnVuY3Rpb24odCxlLG4scil7dmFyIG89ZSxhPSExOzM9PT1lLnJhbmsmJihhPSEwLG89ZS5hczREKDEsZS5zaGFwZVswXSxlLnNoYXBlWzFdLGUuc2hhcGVbMl0pKTt2YXIgaT1MdC5ydW5LZXJuZWxGdW5jKChmdW5jdGlvbih0KXtyZXR1cm4gdC5kZXB0aHdpc2VDb252MkREZXJJbnB1dChvLG4scil9KSx7ZHk0RDpvfSk7cmV0dXJuIGE/aS5hczNEKGkuc2hhcGVbMV0saS5zaGFwZVsyXSxpLnNoYXBlWzNdKTppfX0pLFFjPUFuKHtkZXB0aHdpc2VDb252MmREZXJGaWx0ZXJfOmZ1bmN0aW9uKHQsZSxuLHIpe3ZhciBvPXQ7Mz09PXQucmFuayYmKG89dC5hczREKDEsdC5zaGFwZVswXSx0LnNoYXBlWzFdLHQuc2hhcGVbMl0pKTt2YXIgYT1lO3JldHVybiAzPT09YS5yYW5rJiYoYT1lLmFzNEQoMSxlLnNoYXBlWzBdLGUuc2hhcGVbMV0sZS5zaGFwZVsyXSkpLEx0LnJ1bktlcm5lbEZ1bmMoKGZ1bmN0aW9uKHQpe3JldHVybiB0LmRlcHRod2lzZUNvbnYyRERlckZpbHRlcihvLGEscil9KSx7eDREOm8sZHk0RDphfSl9fSksSmM9QW4oe3NlcGFyYWJsZUNvbnYyZF86ZnVuY3Rpb24odCxlLG4scixvLGEsaSl7dm9pZCAwPT09YSYmKGE9WzEsMV0pLHZvaWQgMD09PWkmJihpPVwiTkhXQ1wiKTt2YXIgcz1tbih0LFwieFwiLFwic2VwYXJhYmxlQ29udjJkXCIpLHU9bW4oZSxcImRlcHRod2lzZUZpbHRlclwiLFwic2VwYXJhYmxlQ29udjJkXCIpLGM9bW4obixcInBvaW50d2lzZUZpbHRlclwiLFwic2VwYXJhYmxlQ29udjJkXCIpLGw9cyxoPSExO2lmKDM9PT1zLnJhbmsmJihoPSEwLGw9cy5hczREKDEscy5zaGFwZVswXSxzLnNoYXBlWzFdLHMuc2hhcGVbMl0pKSxcIk5DSFdcIj09PWkpdGhyb3cgbmV3IEVycm9yKFwic2VwYXJhYmxlQ29udjJkIGN1cnJlbnRseSBkb2VzIG5vdCBzdXBwb3J0IGRhdGFGb3JtYXQgTkNIVzsgb25seSBOSFdDIGlzIHN1cHBvcnRlZFwiKTtDKDQ9PT1sLnJhbmssKGZ1bmN0aW9uKCl7cmV0dXJuXCJFcnJvciBpbiBzZXBhcmFibGVDb252MmQ6IGlucHV0IG11c3QgYmUgcmFuayA0LCBidXQgZ290IHJhbmsgXCIrbC5yYW5rK1wiLlwifSkpLEMoND09PXUucmFuaywoZnVuY3Rpb24oKXtyZXR1cm5cIkVycm9yIGluIHNlcGFyYWJsZUNvbnYyZDogZGVwdGh3aXNlIGZpbHRlciBtdXN0IGJlIHJhbmsgNCwgYnV0IGdvdCByYW5rIFwiK3UucmFuaytcIi5cIn0pKSxDKDQ9PT1jLnJhbmssKGZ1bmN0aW9uKCl7cmV0dXJuXCJFcnJvciBpbiBzZXBhcmFibGVDb252MmQ6IHBvaW50d2lzZSBmaWx0ZXIgbXVzdCBiZSByYW5rIDQsIGJ1dCBnb3QgcmFuayBcIit1LnJhbmsrXCIuXCJ9KSksQygxPT09Yy5zaGFwZVswXSwoZnVuY3Rpb24oKXtyZXR1cm5cIkVycm9yIGluIHNlcGFyYWJsZUNvbnYyZDogdGhlIGZpcnN0IGRpbWVuc2lvbiBvZiBwb2ludHdpc2UgZmlsdGVyICBtdXN0IGJlIDEsIGJ1dCBnb3QgXCIrYy5zaGFwZVswXStcIi5cIn0pKSxDKDE9PT1jLnNoYXBlWzFdLChmdW5jdGlvbigpe3JldHVyblwiRXJyb3IgaW4gc2VwYXJhYmxlQ29udjJkOiB0aGUgc2Vjb25kIGRpbWVuc2lvbiBvZiBwb2ludHdpc2UgZmlsdGVyIG11c3QgYmUgMSwgYnV0IGdvdCBcIitjLnNoYXBlWzFdK1wiLlwifSkpO3ZhciBmPXUuc2hhcGVbMl0sZD11LnNoYXBlWzNdO0MoYy5zaGFwZVsyXT09PWYqZCwoZnVuY3Rpb24oKXtyZXR1cm5cIkVycm9yIGluIHNlcGFyYWJsZUNvbnYyZDogdGhlIHRoaXJkIGRpbWVuc2lvbiBvZiBwb2ludHdpc2UgZmlsdGVyIG11c3QgYmUgXCIrZipkK1wiLCBidXQgZ290IFwiK2Muc2hhcGVbMl0rXCIuXCJ9KSk7dmFyIHA9WWMobCx1LHIsbyxpLGEpLHY9cWMocCxjLDEsXCJ2YWxpZFwiLGkpO3JldHVybiBoP3YuYXMzRCh2LnNoYXBlWzFdLHYuc2hhcGVbMl0sdi5zaGFwZVszXSk6dn19KSxaYz1Bbih7Y29udjJkVHJhbnNwb3NlXzpmdW5jdGlvbih0LGUsbixyLG8sYSl7cmV0dXJuIFZjKG4sbW4odCxcInhcIixcImNvbnYyZFRyYW5zcG9zZVwiKSxtbihlLFwiZmlsdGVyXCIsXCJjb252MmRUcmFuc3Bvc2VcIikscixvLFwiTkhXQ1wiLGEpfX0pLHRsPUFuKHtjb252M2RUcmFuc3Bvc2VfOmZ1bmN0aW9uKHQsZSxuLHIsbyl7cmV0dXJuIEdjKG4sbW4odCxcInhcIixcImNvbnYzZFRyYW5zcG9zZVwiKSxtbihlLFwiZmlsdGVyXCIsXCJjb252M2RUcmFuc3Bvc2VcIikscixvKX19KTt2YXIgZWw9QW4oe21hdE11bF86ZnVuY3Rpb24odCxlLG4scil7dmFyIG87dm9pZCAwPT09biYmKG49ITEpLHZvaWQgMD09PXImJihyPSExKTt2YXIgYT1tbih0LFwiYVwiLFwibWF0TXVsXCIpLGk9bW4oZSxcImJcIixcIm1hdE11bFwiKTtvPU50KGEsaSksYT1vWzBdLGk9b1sxXTt2YXIgcz1uP2Euc2hhcGVbYS5yYW5rLTJdOmEuc2hhcGVbYS5yYW5rLTFdLHU9cj9pLnNoYXBlW2kucmFuay0xXTppLnNoYXBlW2kucmFuay0yXSxjPW4/YS5zaGFwZVthLnJhbmstMV06YS5zaGFwZVthLnJhbmstMl0sbD1yP2kuc2hhcGVbaS5yYW5rLTJdOmkuc2hhcGVbaS5yYW5rLTFdLGg9YS5zaGFwZS5zbGljZSgwLC0yKSxmPWkuc2hhcGUuc2xpY2UoMCwtMiksZD1rKGgpLHA9ayhmKTtDKGEucmFuaz49MiYmaS5yYW5rPj0yJiZhLnJhbms9PT1pLnJhbmssKGZ1bmN0aW9uKCl7cmV0dXJuXCJFcnJvciBpbiBtYXRNdWw6IGlucHV0cyBtdXN0IGhhdmUgdGhlIHNhbWUgcmFuayBvZiBhdCBsZWFzdCAyLCBnb3QgcmFua3MgXCIrYS5yYW5rK1wiIGFuZCBcIitpLnJhbmsrXCIuXCJ9KSksQyhTKGgsZiksKGZ1bmN0aW9uKCl7cmV0dXJuXCJFcnJvciBpbiBtYXRNdWw6IG91dGVyIGRpbWVuc2lvbnMgKFwiK2grXCIpIGFuZCAoXCIrZitcIikgb2YgVGVuc29ycyB3aXRoIHNoYXBlcyBcIithLnNoYXBlK1wiIGFuZCBcIitpLnNoYXBlK1wiIG11c3QgbWF0Y2guXCJ9KSksQyhzPT09dSwoZnVuY3Rpb24oKXtyZXR1cm5cIkVycm9yIGluIG1hdE11bDogaW5uZXIgc2hhcGVzIChcIitzK1wiKSBhbmQgKFwiK3UrXCIpIG9mIFRlbnNvcnMgd2l0aCBzaGFwZXMgXCIrYS5zaGFwZStcIiBhbmQgXCIraS5zaGFwZStcIiBhbmQgdHJhbnNwb3NlQT1cIituK1wiIGFuZCB0cmFuc3Bvc2VCPVwiK3IrXCIgbXVzdCBtYXRjaC5cIn0pKTt2YXIgdj1hLnNoYXBlLnNsaWNlKDAsLTIpLmNvbmNhdChbYyxsXSksbT1uP2EuYXMzRChkLHMsYyk6YS5hczNEKGQsYyxzKSxnPXI/aS5hczNEKHAsbCx1KTppLmFzM0QocCx1LGwpLHk9e3RyYW5zcG9zZUE6bix0cmFuc3Bvc2VCOnJ9O3JldHVybiBMdC5ydW5LZXJuZWxGdW5jKChmdW5jdGlvbih0LGUpe3ZhciBvPXQuYmF0Y2hNYXRNdWwobSxnLG4scik7cmV0dXJuIGUoW20sZ10pLG99KSx7YTptLGI6Z30sKGZ1bmN0aW9uKHQsZSl7dmFyIG89ZSxhPW9bMF0saT1vWzFdO3JldHVybiBufHxyPyFuJiZyP3thOmZ1bmN0aW9uKCl7cmV0dXJuIHQubWF0TXVsKGksITEsITEpfSxiOmZ1bmN0aW9uKCl7cmV0dXJuIHQubWF0TXVsKGEsITAsITEpfX06biYmIXI/e2E6ZnVuY3Rpb24oKXtyZXR1cm4gaS5tYXRNdWwodCwhMSwhMCl9LGI6ZnVuY3Rpb24oKXtyZXR1cm4gYS5tYXRNdWwodCwhMSwhMSl9fTp7YTpmdW5jdGlvbigpe3JldHVybiBpLm1hdE11bCh0LCEwLCEwKX0sYjpmdW5jdGlvbigpe3JldHVybiB0Lm1hdE11bChhLCEwLCEwKX19OnthOmZ1bmN0aW9uKCl7cmV0dXJuIHQubWF0TXVsKGksITEsITApfSxiOmZ1bmN0aW9uKCl7cmV0dXJuIGEubWF0TXVsKHQsITAsITEpfX19KSxcIkJhdGNoTWF0TXVsXCIseSkucmVzaGFwZSh2KX19KSxubD1Bbih7ZG90XzpmdW5jdGlvbih0LGUpe3ZhciBuPW1uKHQsXCJ0MVwiLFwiZG90XCIpLHI9bW4oZSxcInQyXCIsXCJkb3RcIik7QyghKDEhPT1uLnJhbmsmJjIhPT1uLnJhbmt8fDEhPT1yLnJhbmsmJjIhPT1yLnJhbmspLChmdW5jdGlvbigpe3JldHVyblwiRXJyb3IgaW4gZG90OiBpbnB1dHMgbXVzdCBhbGwgYmUgcmFuayAxIG9yIDIsIGJ1dCBnb3QgcmFua3MgXCIrbi5yYW5rK1wiIGFuZCBcIityLnJhbmsrXCIuXCJ9KSk7dmFyIG89MT09PW4ucmFuaz9uLnNpemU6bi5zaGFwZVsxXSxhPTE9PT1yLnJhbms/ci5zaXplOnIuc2hhcGVbMF07cmV0dXJuIEMobz09PWEsKGZ1bmN0aW9uKCl7cmV0dXJuXCJFcnJvciBpbiBkb3Q6IGlubmVyIGRpbWVuc2lvbnMgb2YgaW5wdXRzIG11c3QgbWF0Y2gsIGJ1dCBnb3QgXCIrbytcIiBhbmQgXCIrYStcIi5cIn0pKSwxPT09bi5yYW5rJiYxPT09ci5yYW5rP24uYXMyRCgxLC0xKS5tYXRNdWwoci5hczJEKC0xLDEpKS5hc1NjYWxhcigpOjE9PT1uLnJhbmsmJjI9PT1yLnJhbms/bi5hczJEKDEsLTEpLm1hdE11bChyLmFzMkQoci5zaGFwZVswXSxyLnNoYXBlWzFdKSkuYXMxRCgpOjI9PT1uLnJhbmsmJjE9PT1yLnJhbms/bi5tYXRNdWwoci5hczJEKC0xLDEpKS5hczFEKCk6bi5tYXRNdWwoci5hczJEKHIuc2hhcGVbMF0sci5zaGFwZVsxXSkpfX0pLHJsPUFuKHtvdXRlclByb2R1Y3RfOmZ1bmN0aW9uKHQsZSl7dmFyIG49bW4odCxcInYxXCIsXCJvdXRlclByb2R1Y3RcIikscj1tbihlLFwidjJcIixcIm91dGVyUHJvZHVjdFwiKTtyZXR1cm4gQygxPT09bi5yYW5rJiYxPT09ci5yYW5rLChmdW5jdGlvbigpe3JldHVyblwiRXJyb3IgaW4gb3V0ZXJQcm9kdWN0OiBpbnB1dHMgbXVzdCBiZSByYW5rIDEsIGJ1dCBnb3QgcmFua3MgXCIrbi5yYW5rK1wiIGFuZCBcIityLnJhbmsrXCIuXCJ9KSksbi5hczJEKC0xLDEpLm1hdE11bChyLmFzMkQoMSwtMSkpfX0pO3ZhciBvbD1Bbih7cmV2ZXJzZV86ZnVuY3Rpb24odCxlKXt2YXIgbj1tbih0LFwieFwiLFwicmV2ZXJzZVwiKTtpZigwPT09bi5yYW5rKXJldHVybiBuLmNsb25lKCk7dmFyIHI9TyhlLG4uc2hhcGUpO3JldHVybiBMdC5ydW5LZXJuZWxGdW5jKChmdW5jdGlvbih0KXtyZXR1cm4gdC5yZXZlcnNlKG4scil9KSx7JHg6bn0sKGZ1bmN0aW9uKHQpe3JldHVybnskeDpmdW5jdGlvbigpe3JldHVybiB0LnJldmVyc2Uocil9fX0pKS5yZXNoYXBlQXMobil9fSksYWw9QW4oe3JldmVyc2UxZF86ZnVuY3Rpb24odCl7dmFyIGU9bW4odCxcInhcIixcInJldmVyc2VcIik7cmV0dXJuIEMoMT09PWUucmFuaywoZnVuY3Rpb24oKXtyZXR1cm5cIkVycm9yIGluIHJldmVyc2UxRDogeCBtdXN0IGJlIHJhbmsgMSBidXQgZ290IHJhbmsgXCIrZS5yYW5rK1wiLlwifSkpLG9sKGUsMCl9fSksaWw9QW4oe3JldmVyc2UyZF86ZnVuY3Rpb24odCxlKXt2YXIgbj1tbih0LFwieFwiLFwicmV2ZXJzZVwiKTtyZXR1cm4gQygyPT09bi5yYW5rLChmdW5jdGlvbigpe3JldHVyblwiRXJyb3IgaW4gcmV2ZXJzZTJEOiB4IG11c3QgYmUgcmFuayAyIGJ1dCBnb3QgcmFuayBcIituLnJhbmsrXCIuXCJ9KSksb2wobixlKX19KSxzbD1Bbih7cmV2ZXJzZTNkXzpmdW5jdGlvbih0LGUpe3ZhciBuPW1uKHQsXCJ4XCIsXCJyZXZlcnNlXCIpO3JldHVybiBDKDM9PT1uLnJhbmssKGZ1bmN0aW9uKCl7cmV0dXJuXCJFcnJvciBpbiByZXZlcnNlM0Q6IHggbXVzdCBiZSByYW5rIDMgYnV0IGdvdCByYW5rIFwiK24ucmFuaytcIi5cIn0pKSxvbChuLGUpfX0pLHVsPUFuKHtyZXZlcnNlNGRfOmZ1bmN0aW9uKHQsZSl7dmFyIG49bW4odCxcInhcIixcInJldmVyc2VcIik7cmV0dXJuIEMoND09PW4ucmFuaywoZnVuY3Rpb24oKXtyZXR1cm5cIkVycm9yIGluIHJldmVyc2U0RDogeCBtdXN0IGJlIHJhbmsgNCBidXQgZ290IHJhbmsgXCIrbi5yYW5rK1wiLlwifSkpLG9sKG4sZSl9fSk7ZnVuY3Rpb24gY2wodCxlLG4scixvLGEpe3ZhciBpPW1uKHQsXCJ4XCIsXCJtYXhQb29sXCIpLHM9aSx1PSExOzM9PT1pLnJhbmsmJih1PSEwLHM9aS5hczREKDEsaS5zaGFwZVswXSxpLnNoYXBlWzFdLGkuc2hhcGVbMl0pKSxudWxsPT1yJiYocj1bMSwxXSksQyg0PT09cy5yYW5rLChmdW5jdGlvbigpe3JldHVyblwiRXJyb3IgaW4gbWF4UG9vbDogaW5wdXQgbXVzdCBiZSByYW5rIDQgYnV0IGdvdCByYW5rIFwiK3MucmFuaytcIi5cIn0pKSxDKE1vKG4sciksKGZ1bmN0aW9uKCl7cmV0dXJuXCJFcnJvciBpbiBtYXhQb29sOiBFaXRoZXIgc3RyaWRlcyBvciBkaWxhdGlvbnMgbXVzdCBiZSAxLiBHb3Qgc3RyaWRlcyBcIituK1wiIGFuZCBkaWxhdGlvbnMgJ1wiK3IrXCInXCJ9KSksbnVsbCE9YSYmQyhBKG8pLChmdW5jdGlvbigpe3JldHVyblwiRXJyb3IgaW4gbWF4UG9vbDogcGFkIG11c3QgYmUgYW4gaW50ZWdlciB3aGVuIHVzaW5nLCBkaW1Sb3VuZGluZ01vZGUgXCIrYStcIiBidXQgZ290IHBhZCBcIitvK1wiLlwifSkpO3ZhciBjPUlvKHMuc2hhcGUsZSxuLHIsbyxhKTtpZigxPT09Yy5maWx0ZXJXaWR0aCYmMT09PWMuZmlsdGVySGVpZ2h0JiZTKGMuaW5TaGFwZSxjLm91dFNoYXBlKSlyZXR1cm4gaS5jbG9uZSgpO3ZhciBsPVtzXSxoPUx0LnJ1bktlcm5lbEZ1bmMoKGZ1bmN0aW9uKHQsZSl7dmFyIG49dC5tYXhQb29sKHMsYyk7cmV0dXJuIGUoW3Msbl0pLG59KSx7eDpzfSwoZnVuY3Rpb24odCxhKXt2YXIgaT1hWzBdLHM9YVsxXTtyZXR1cm57eDpmdW5jdGlvbigpe3JldHVybiBmdW5jdGlvbih0LGUsbixyLG8sYSxpLHMpe3ZhciB1PW1uKHQsXCJkeVwiLFwibWF4UG9vbEJhY2twcm9wXCIpLGM9bW4oZSxcImlucHV0XCIsXCJtYXhQb29sQmFja3Byb3BcIiksbD1tbihuLFwib3V0cHV0XCIsXCJtYXhQb29sQmFja3Byb3BcIik7QyhjLnJhbms9PT11LnJhbmssKGZ1bmN0aW9uKCl7cmV0dXJuXCJSYW5rIG9mIGlucHV0IChcIitjLnJhbmsrXCIpIGRvZXMgbm90IG1hdGNoIHJhbmsgb2YgZHkgKFwiK3UucmFuaytcIilcIn0pKSxudWxsPT1hJiYoYT1bMSwxXSk7QyhNbyhvLGEpLChmdW5jdGlvbigpe3JldHVyblwiRXJyb3IgaW4gbWF4UG9vbEJhY2tQcm9wOiBFaXRoZXIgc3RyaWRlcyBvciBkaWxhdGlvbnMgbXVzdCBiZSAxLiBHb3Qgc3RyaWRlcyBcIitvK1wiIGFuZCBkaWxhdGlvbnMgJ1wiK2ErXCInXCJ9KSksQyg0PT09dS5yYW5rLChmdW5jdGlvbigpe3JldHVyblwiRXJyb3IgaW4gbWF4UG9vbEJhY2twcm9wOiBkeSBtdXN0IGJlIHJhbmsgNCBidXQgZ290IHJhbmsgXCIrdS5yYW5rK1wiLlwifSkpLEMoND09PWMucmFuaywoZnVuY3Rpb24oKXtyZXR1cm5cIkVycm9yIGluIG1heFBvb2xCYWNrcHJvcDogaW5wdXQgbXVzdCBiZSByYW5rIDQgYnV0IGdvdCByYW5rIFwiK2MucmFuaytcIi5cIn0pKSxudWxsIT1zJiZDKEEoaSksKGZ1bmN0aW9uKCl7cmV0dXJuXCJFcnJvciBpbiBtYXhQb29sQmFja3Byb3A6IHBhZCBtdXN0IGJlIGFuIGludGVnZXIgd2hlbiB1c2luZywgZGltUm91bmRpbmdNb2RlIFwiK3MrXCIgYnV0IGdvdCBwYWQgXCIraStcIi5cIn0pKTt2YXIgaD1JbyhjLnNoYXBlLHIsbyxhLGkscyk7cmV0dXJuIEx0LnJ1bktlcm5lbEZ1bmMoKGZ1bmN0aW9uKHQpe3JldHVybiB0Lm1heFBvb2xCYWNrcHJvcCh1LGMsbCxoKX0pLHskZHk6dSwkaW5wdXQ6Y30pfSh0LGkscyxlLG4scixvKX19fSksXCJNYXhQb29sXCIsYyxsKTtyZXR1cm4gdT9oLmFzM0QoaC5zaGFwZVsxXSxoLnNoYXBlWzJdLGguc2hhcGVbM10pOmh9ZnVuY3Rpb24gbGwodCxlLG4scixvLGEpe3ZhciBpPW1uKHQsXCJ4XCIsXCJhdmdQb29sXCIsXCJmbG9hdDMyXCIpO251bGw9PXImJihyPVsxLDFdKSxDKE1vKG4sciksKGZ1bmN0aW9uKCl7cmV0dXJuXCJFcnJvciBpbiBhdmdQb29sOiBFaXRoZXIgc3RyaWRlcyBvciBkaWxhdGlvbnMgbXVzdCBiZSAxLiBHb3Qgc3RyaWRlcyBcIituK1wiIGFuZCBkaWxhdGlvbnMgJ1wiK3IrXCInXCJ9KSk7dmFyIHM9aSx1PSExOzM9PT1pLnJhbmsmJih1PSEwLHM9aS5hczREKDEsaS5zaGFwZVswXSxpLnNoYXBlWzFdLGkuc2hhcGVbMl0pKSxDKDQ9PT1zLnJhbmssKGZ1bmN0aW9uKCl7cmV0dXJuXCJFcnJvciBpbiBhdmdQb29sOiB4IG11c3QgYmUgcmFuayA0IGJ1dCBnb3QgcmFuayBcIitzLnJhbmsrXCIuXCJ9KSksbnVsbCE9YSYmQyhBKG8pLChmdW5jdGlvbigpe3JldHVyblwiRXJyb3IgaW4gYXZnUG9vbDogcGFkIG11c3QgYmUgYW4gaW50ZWdlciB3aGVuIHVzaW5nLCBkaW1Sb3VuZGluZ01vZGUgXCIrYStcIiBidXQgZ290IHBhZCBcIitvK1wiLlwifSkpO3ZhciBjPUlvKHMuc2hhcGUsZSxuLHIsbyxhKTtpZigxPT09Yy5maWx0ZXJXaWR0aCYmMT09PWMuZmlsdGVySGVpZ2h0JiZTKGMuaW5TaGFwZSxjLm91dFNoYXBlKSlyZXR1cm4gaS5jbG9uZSgpO3ZhciBsPUx0LnJ1bktlcm5lbEZ1bmMoKGZ1bmN0aW9uKHQpe3JldHVybiB0LmF2Z1Bvb2wocyxjKX0pLHt4OnN9LChmdW5jdGlvbih0KXtyZXR1cm57eDpmdW5jdGlvbigpe3JldHVybiBmdW5jdGlvbih0LGUsbixyLG8sYSl7dmFyIGk9bW4odCxcImR5XCIsXCJhdmdQb29sQmFja3Byb3BcIikscz1tbihlLFwiaW5wdXRcIixcImF2Z1Bvb2xCYWNrcHJvcFwiKTtDKHMucmFuaz09PWkucmFuaywoZnVuY3Rpb24oKXtyZXR1cm5cIlJhbmsgb2YgaW5wdXQgKFwiK3MucmFuaytcIikgZG9lcyBub3QgbWF0Y2ggcmFuayBvZiBkeSAoXCIraS5yYW5rK1wiKVwifSkpLG51bGw9PW8mJihvPVsxLDFdKTtDKE1vKHIsbyksKGZ1bmN0aW9uKCl7cmV0dXJuXCJFcnJvciBpbiBhdmdQb29sQmFja3Byb3A6IEVpdGhlciBzdHJpZGVzIG9yIGRpbGF0aW9ucyBtdXN0IGJlIDEuIEdvdCBzdHJpZGVzIFwiK3IrXCIgYW5kIGRpbGF0aW9ucyAnXCIrbytcIidcIn0pKTt2YXIgdT1zLGM9aSxsPSExOzM9PT1zLnJhbmsmJihsPSEwLHU9cy5hczREKDEscy5zaGFwZVswXSxzLnNoYXBlWzFdLHMuc2hhcGVbMl0pLGM9aS5hczREKDEsaS5zaGFwZVswXSxpLnNoYXBlWzFdLGkuc2hhcGVbMl0pKTtDKDQ9PT1jLnJhbmssKGZ1bmN0aW9uKCl7cmV0dXJuXCJFcnJvciBpbiBhdmdQb29sQmFja3Byb3A6IGR5IG11c3QgYmUgcmFuayA0IGJ1dCBnb3QgcmFuayBcIitjLnJhbmsrXCIuXCJ9KSksQyg0PT09dS5yYW5rLChmdW5jdGlvbigpe3JldHVyblwiRXJyb3IgaW4gYXZnUG9vbEJhY2twcm9wOiBpbnB1dCBtdXN0IGJlIHJhbmsgNCBidXQgZ290IHJhbmsgXCIrdS5yYW5rK1wiLlwifSkpO3ZhciBoPUlvKHUuc2hhcGUsbixyLG8sYSksZj1MdC5ydW5LZXJuZWxGdW5jKChmdW5jdGlvbih0KXtyZXR1cm4gdC5hdmdQb29sQmFja3Byb3AoYyx1LGgpfSkse2R5NEQ6YyxpbnB1dDREOnV9KTtpZihsKXJldHVybiBmLmFzM0QoZi5zaGFwZVsxXSxmLnNoYXBlWzJdLGYuc2hhcGVbM10pO3JldHVybiBmfSh0LHMsZSxuLHIsbyl9fX0pLFwiQXZnUG9vbFwiLGMpO3JldHVybiBsPWwuY2FzdChpLmR0eXBlKSx1P2wuYXMzRChsLnNoYXBlWzFdLGwuc2hhcGVbMl0sbC5zaGFwZVszXSk6bH12YXIgaGw9QW4oe21heFBvb2xfOmZ1bmN0aW9uKHQsZSxuLHIsbyl7cmV0dXJuIGNsKHQsZSxuLDEscixvKX19KSxmbD1Bbih7YXZnUG9vbF86ZnVuY3Rpb24odCxlLG4scixvKXtyZXR1cm4gbGwodCxlLG4sMSxyLG8pfX0pLGRsPUFuKHtwb29sXzpmdW5jdGlvbih0LGUsbixyLG8sYSl7bnVsbD09byYmKG89WzEsMV0pLG51bGw9PWEmJihhPTEpLDA9PT1yJiYocj1cInZhbGlkXCIpO3ZhciBpPW1uKHQsXCJ4XCIsXCJtYXhQb29sXCIpLHM9aSx1PSExOzM9PT1pLnJhbmsmJih1PSEwLHM9aS5hczREKDEsaS5zaGFwZVswXSxpLnNoYXBlWzFdLGkuc2hhcGVbMl0pKSxDKE1vKGEsbyksKGZ1bmN0aW9uKCl7cmV0dXJuXCJFcnJvciBpbiBwb29sOiBFaXRoZXIgc3RyaWRlcyBvciBkaWxhdGlvbnMgbXVzdCBiZSAxLiBHb3Qgc3RyaWRlcyBcIithK1wiIGFuZCBkaWxhdGlvbnMgJ1wiK28rXCInXCJ9KSk7dmFyIGMsbD1JbyhzLnNoYXBlLGUsYSxvLHIpLGg9W2wuZGlsYXRpb25IZWlnaHQsbC5kaWxhdGlvbldpZHRoXTtjPVwic2FtZVwiPT09cj9mdW5jdGlvbih0LGUpe3ZhciBuPXQubWFwKChmdW5jdGlvbih0LG4pe3JldHVybiB0Kyh0LTEpKihlW25dLTEpfSkpLm1hcCgoZnVuY3Rpb24odCl7cmV0dXJuIHQtMX0pKSxyPW4ubWFwKChmdW5jdGlvbih0KXtyZXR1cm4gTWF0aC5mbG9vcih0LzIpfSkpLG89bi5tYXAoKGZ1bmN0aW9uKHQsZSl7cmV0dXJuIHQtcltlXX0pKTtyZXR1cm4gbi5tYXAoKGZ1bmN0aW9uKHQsZSl7cmV0dXJuW3JbZV0sb1tlXV19KSl9KFtsLmZpbHRlckhlaWdodCxsLmZpbHRlcldpZHRoXSxoKTpbWzAsMF0sWzAsMF1dO3ZhciBmPTE9PT1oWzBdJiYxPT09aFsxXSxkPWZ1bmN0aW9uKHQsZSxuKXt2YXIgcj1uLm1hcCgoZnVuY3Rpb24odCl7cmV0dXJuIHRbMF19KSksbz1uLm1hcCgoZnVuY3Rpb24odCl7cmV0dXJuIHRbMV19KSksYT10LmNvbmNhdChyLG8pLGk9ZS5tYXAoKGZ1bmN0aW9uKHQsZSl7cmV0dXJuKHQtYVtlXSV0KSV0fSkpLHM9by5tYXAoKGZ1bmN0aW9uKHQsZSl7cmV0dXJuIHQraVtlXX0pKSx1PWUubWFwKChmdW5jdGlvbih0LGUpe3JldHVybltyW2VdLHNbZV1dfSkpLGM9ZS5tYXAoKGZ1bmN0aW9uKHQsZSl7cmV0dXJuWzAsaVtlXV19KSk7cmV0dXJuW3UsY119KFtsLmluSGVpZ2h0LGwuaW5XaWR0aF0saCxjKSxwPWRbMF0sdj1kWzFdLG09Zj9yOlwidmFsaWRcIixnPWY/czpNcihzLGgscCkseT0oXCJhdmdcIj09PW4/ZnVuY3Rpb24oKXtyZXR1cm4gbGwoZyxlLGEsMSxtKX06ZnVuY3Rpb24oKXtyZXR1cm4gY2woZyxlLGEsMSxtKX0pKCkseD1mP3k6dnIoeSxoLHYpO3JldHVybiB1P3guYXMzRCh4LnNoYXBlWzFdLHguc2hhcGVbMl0seC5zaGFwZVszXSk6eH19KSxwbD1Bbih7bWF4UG9vbDNkXzpmdW5jdGlvbih0LGUsbixyLG8sYSxpKXt2b2lkIDA9PT1hJiYoYT1cIk5ESFdDXCIpO3ZhciBzPW1uKHQsXCJ4XCIsXCJtYXhQb29sM2RcIiksdT1zLGM9ITE7ND09PXMucmFuayYmKGM9ITAsdT1zLmFzNUQoMSxzLnNoYXBlWzBdLHMuc2hhcGVbMV0scy5zaGFwZVsyXSxzLnNoYXBlWzNdKSksbnVsbD09aSYmKGk9WzEsMSwxXSksQyg1PT09dS5yYW5rLChmdW5jdGlvbigpe3JldHVyblwiRXJyb3IgaW4gbWF4UG9vbDNkOiB4IG11c3QgYmUgcmFuayA1IGJ1dCBnb3QgcmFuayBcIit1LnJhbmsrXCIuXCJ9KSksQyhcIk5ESFdDXCI9PT1hLChmdW5jdGlvbigpe3JldHVyblwiRXJyb3IgaW4gbWF4UG9vbDNkOiBPbmx5IE5ESFdDIGlzIGN1cnJlbnRseSBzdXBwb3J0ZWQsIGJ1dCBnb3QgZGF0YUZvcm1hdCBvZiBcIithfSkpLEMoTW8obixpKSwoZnVuY3Rpb24oKXtyZXR1cm5cIkVycm9yIGluIG1heFBvb2wzZDogRWl0aGVyIHN0cmlkZXMgb3IgZGlsYXRpb25zIG11c3QgYmUgMS4gR290IHN0cmlkZXMgXCIrbitcIiBhbmQgZGlsYXRpb25zICdcIitpK1wiJ1wifSkpLG51bGwhPW8mJkMoQShyKSwoZnVuY3Rpb24oKXtyZXR1cm5cIkVycm9yIGluIG1heFBvb2wzZDogcGFkIG11c3QgYmUgYW4gaW50ZWdlciB3aGVuIHVzaW5nLCBkaW1Sb3VuZGluZ01vZGUgXCIrbytcIiBidXQgZ290IHBhZCBcIityK1wiLlwifSkpO3ZhciBsPWtvKHUuc2hhcGUsZSxuLGkscixvLGEpLGg9THQucnVuS2VybmVsRnVuYygoZnVuY3Rpb24odCxlKXt2YXIgbj10Lm1heFBvb2wzZCh1LGwpO3JldHVybiBlKFt1LG5dKSxufSkse3g6dX0sKGZ1bmN0aW9uKHQsYSl7dmFyIHM9YVswXSx1PWFbMV07cmV0dXJue3g6ZnVuY3Rpb24oKXtyZXR1cm4gZnVuY3Rpb24odCxlLG4scixvLGEsaSxzKXt2YXIgdT1tbih0LFwiZHlcIixcIm1heFBvb2wzZEJhY2twcm9wXCIpLGM9bW4oZSxcImlucHV0XCIsXCJtYXhQb29sM2RCYWNrcHJvcFwiKSxsPW1uKG4sXCJvdXRwdXRcIixcIm1heFBvb2wzZEJhY2twcm9wXCIpLGg9dSxmPWMsZD1sLHA9ITE7ND09PWMucmFuayYmKHA9ITAsaD11LmFzNUQoMSx1LnNoYXBlWzBdLHUuc2hhcGVbMV0sdS5zaGFwZVsyXSx1LnNoYXBlWzNdKSxmPWMuYXM1RCgxLGMuc2hhcGVbMF0sYy5zaGFwZVsxXSxjLnNoYXBlWzJdLGMuc2hhcGVbM10pLGQ9bC5hczVEKDEsbC5zaGFwZVswXSxsLnNoYXBlWzFdLGwuc2hhcGVbMl0sbC5zaGFwZVszXSkpO0MoNT09PWgucmFuaywoZnVuY3Rpb24oKXtyZXR1cm5cIkVycm9yIGluIG1heFBvb2wzZEJhY2twcm9wOiBkeSBtdXN0IGJlIHJhbmsgNSBidXQgZ290IHJhbmsgXCIraC5yYW5rK1wiLlwifSkpLEMoNT09PWYucmFuaywoZnVuY3Rpb24oKXtyZXR1cm5cIkVycm9yIGluIG1heFBvb2wzZEJhY2twcm9wOiBpbnB1dCBtdXN0IGJlIHJhbmsgNSBidXQgZ290IHJhbmsgXCIrZi5yYW5rK1wiLlwifSkpLEMoNT09PWQucmFuaywoZnVuY3Rpb24oKXtyZXR1cm5cIkVycm9yIGluIG1heFBvb2wzZEJhY2twcm9wOiBvdXRwdXQgbXVzdCBiZSByYW5rIDUgYnV0IGdvdCByYW5rIFwiK2QucmFuaytcIi5cIn0pKSxudWxsPT1hJiYoYT1bMSwxLDFdKTtDKE1vKG8sYSksKGZ1bmN0aW9uKCl7cmV0dXJuXCJFcnJvciBpbiBtYXhQb29sM2RCYWNrcHJvcDogRWl0aGVyIHN0cmlkZXMgb3IgZGlsYXRpb25zIG11c3QgYmUgMS4gR290IHN0cmlkZXMgXCIrbytcIiBhbmQgZGlsYXRpb25zICdcIithK1wiJ1wifSkpLG51bGwhPXMmJkMoQShpKSwoZnVuY3Rpb24oKXtyZXR1cm5cIkVycm9yIGluIG1heFBvb2wzZEJhY2twcm9wOiBwYWQgbXVzdCBiZSBhbiBpbnRlZ2VyIHdoZW4gdXNpbmcsIGRpbVJvdW5kaW5nTW9kZSBcIitzK1wiIGJ1dCBnb3QgcGFkIFwiK2krXCIuXCJ9KSk7dmFyIHY9a28oZi5zaGFwZSxyLG8sYSxpLHMpLG09THQucnVuS2VybmVsRnVuYygoZnVuY3Rpb24odCl7cmV0dXJuIHQubWF4UG9vbDNkQmFja3Byb3AoaCxmLGQsdil9KSx7ZHk1RDpoLGlucHV0NUQ6Zn0pO2lmKHApcmV0dXJuIG0uYXM0RChtLnNoYXBlWzFdLG0uc2hhcGVbMl0sbS5zaGFwZVszXSxtLnNoYXBlWzRdKTtyZXR1cm4gbX0odCxzLHUsZSxuLGkscixvKX19fSkpO3JldHVybiBjP2guYXM0RChoLnNoYXBlWzFdLGguc2hhcGVbMl0saC5zaGFwZVszXSxoLnNoYXBlWzRdKTpofX0pLHZsPUFuKHthdmdQb29sM2RfOmZ1bmN0aW9uKHQsZSxuLHIsbyxhLGkpe3ZvaWQgMD09PWEmJihhPVwiTkRIV0NcIik7dmFyIHM9bW4odCxcInhcIixcImF2Z1Bvb2wzZFwiLFwiZmxvYXQzMlwiKSx1PXMsYz0hMTs0PT09cy5yYW5rJiYoYz0hMCx1PXMuYXM1RCgxLHMuc2hhcGVbMF0scy5zaGFwZVsxXSxzLnNoYXBlWzJdLHMuc2hhcGVbM10pKSxudWxsPT1pJiYoaT1bMSwxLDFdKSxDKDU9PT11LnJhbmssKGZ1bmN0aW9uKCl7cmV0dXJuXCJFcnJvciBpbiBhdmdQb29sM2Q6IHggbXVzdCBiZSByYW5rIDUgYnV0IGdvdCByYW5rIFwiK3UucmFuaytcIi5cIn0pKSxDKFwiTkRIV0NcIj09PWEsKGZ1bmN0aW9uKCl7cmV0dXJuXCJFcnJvciBpbiBhdmdQb29sM2Q6IE9ubHkgTkRIV0MgaXMgY3VycmVudGx5IHN1cHBvcnRlZCwgYnV0IGdvdCBkYXRhRm9ybWF0IG9mIFwiK2F9KSksQyhNbyhuLGkpLChmdW5jdGlvbigpe3JldHVyblwiRXJyb3IgaW4gYXZnUG9vbDNkOiBFaXRoZXIgc3RyaWRlcyBvciBkaWxhdGlvbnMgbXVzdCBiZSAxLiBHb3Qgc3RyaWRlcyBcIituK1wiIGFuZCBkaWxhdGlvbnMgJ1wiK2krXCInXCJ9KSksbnVsbCE9byYmQyhBKHIpLChmdW5jdGlvbigpe3JldHVyblwiRXJyb3IgaW4gYXZnUG9vbDNkOiBwYWQgbXVzdCBiZSBhbiBpbnRlZ2VyIHdoZW4gdXNpbmcsIGRpbVJvdW5kaW5nTW9kZSBcIitvK1wiIGJ1dCBnb3QgcGFkIFwiK3IrXCIuXCJ9KSk7dmFyIGw9a28odS5zaGFwZSxlLG4saSxyLG8sYSksaD1MdC5ydW5LZXJuZWxGdW5jKChmdW5jdGlvbih0KXtyZXR1cm4gdC5hdmdQb29sM2QodSxsKX0pLHt4OnV9LChmdW5jdGlvbih0KXtyZXR1cm57eDpmdW5jdGlvbigpe3JldHVybiBmdW5jdGlvbih0LGUsbixyLG8sYSxpKXt2YXIgcz1tbih0LFwiZHlcIixcImF2Z1Bvb2wzZEJhY2twcm9wXCIpLHU9bW4oZSxcImlucHV0XCIsXCJhdmdQb29sM2RCYWNrcHJvcFwiKSxjPXMsbD11LGg9ITE7ND09PXUucmFuayYmKGg9ITAsYz1zLmFzNUQoMSxzLnNoYXBlWzBdLHMuc2hhcGVbMV0scy5zaGFwZVsyXSxzLnNoYXBlWzNdKSxsPXUuYXM1RCgxLHUuc2hhcGVbMF0sdS5zaGFwZVsxXSx1LnNoYXBlWzJdLHUuc2hhcGVbM10pKTtDKDU9PT1jLnJhbmssKGZ1bmN0aW9uKCl7cmV0dXJuXCJFcnJvciBpbiBhdmdQb29sM2RCYWNrcHJvcDogZHkgbXVzdCBiZSByYW5rIDUgYnV0IGdvdCByYW5rIFwiK2MucmFuaytcIi5cIn0pKSxDKDU9PT1sLnJhbmssKGZ1bmN0aW9uKCl7cmV0dXJuXCJFcnJvciBpbiBhdmdQb29sM2RCYWNrcHJvcDogaW5wdXQgbXVzdCBiZSByYW5rIDUgYnV0IGdvdCByYW5rIFwiK2wucmFuaytcIi5cIn0pKSxudWxsPT1vJiYobz1bMSwxLDFdKTtDKE1vKHIsbyksKGZ1bmN0aW9uKCl7cmV0dXJuXCJFcnJvciBpbiBhdmdQb29sM2RCYWNrcHJvcDogRWl0aGVyIHN0cmlkZXMgb3IgZGlsYXRpb25zIG11c3QgYmUgMS4gR290IHN0cmlkZXMgXCIrcitcIiBhbmQgZGlsYXRpb25zICdcIitvK1wiJ1wifSkpLG51bGwhPWkmJkMoQShhKSwoZnVuY3Rpb24oKXtyZXR1cm5cIkVycm9yIGluIG1heFBvb2wzZEJhY2twcm9wOiBwYWQgbXVzdCBiZSBhbiBpbnRlZ2VyIHdoZW4gdXNpbmcsIGRpbVJvdW5kaW5nTW9kZSBcIitpK1wiIGJ1dCBnb3QgcGFkIFwiK2ErXCIuXCJ9KSk7dmFyIGY9a28obC5zaGFwZSxuLHIsbyxhLGkpLGQ9THQucnVuS2VybmVsRnVuYygoZnVuY3Rpb24odCl7cmV0dXJuIHQuYXZnUG9vbDNkQmFja3Byb3AoYyxsLGYpfSkse2R5NUQ6YyxpbnB1dDVEOmx9KTtpZihoKXJldHVybiBkLmFzNEQoZC5zaGFwZVsxXSxkLnNoYXBlWzJdLGQuc2hhcGVbM10sZC5zaGFwZVs0XSk7cmV0dXJuIGR9KHQsdSxlLG4saSxyLG8pfX19KSk7cmV0dXJuIGg9aC5jYXN0KHUuZHR5cGUpLGM/aC5hczREKGguc2hhcGVbMV0saC5zaGFwZVsyXSxoLnNoYXBlWzNdLGguc2hhcGVbNF0pOmh9fSk7dmFyIG1sPUFuKHtzbGljZV86ZnVuY3Rpb24odCxlLG4pe3ZhciByLG8sYT1tbih0LFwieFwiLFwic2xpY2VcIik7aWYoMD09PWEucmFuayl0aHJvdyBuZXcgRXJyb3IoXCJTbGljaW5nIHNjYWxhciBpcyBub3QgcG9zc2libGVcIik7KHI9XCJudW1iZXJcIj09dHlwZW9mIGU/W2VdLmNvbmNhdChuZXcgQXJyYXkoYS5yYW5rLTEpLmZpbGwoMCkpOmUubGVuZ3RoPGEucmFuaz9lLmNvbmNhdChuZXcgQXJyYXkoYS5yYW5rLWUubGVuZ3RoKS5maWxsKDApKTplLnNsaWNlKCkpLmZvckVhY2goKGZ1bmN0aW9uKHQpe0MoLTEhPT10LChmdW5jdGlvbigpe3JldHVyblwic2xpY2UoKSBkb2VzIG5vdCBzdXBwb3J0IG5lZ2F0aXZlIGJlZ2luIGluZGV4aW5nLlwifSkpfSkpLG89KG89bnVsbD09bj9uZXcgQXJyYXkoYS5yYW5rKS5maWxsKC0xKTpcIm51bWJlclwiPT10eXBlb2Ygbj9bbl0uY29uY2F0KG5ldyBBcnJheShhLnJhbmstMSkuZmlsbCgtMSkpOm4ubGVuZ3RoPGEucmFuaz9uLmNvbmNhdChuZXcgQXJyYXkoYS5yYW5rLW4ubGVuZ3RoKS5maWxsKC0xKSk6bikubWFwKChmdW5jdGlvbih0LGUpe3JldHVybiB0Pj0wP3Q6KEMoLTE9PT10LChmdW5jdGlvbigpe3JldHVyblwiTmVnYXRpdmUgc2l6ZSB2YWx1ZXMgc2hvdWxkIGJlIGV4YWN0bHkgLTEgYnV0IGdvdCBcIit0K1wiIGZvciB0aGUgc2xpY2UoKSBzaXplIGF0IGluZGV4IFwiK2UrXCIuXCJ9KSksYS5zaGFwZVtlXS1yW2VdKX0pKSxlbyhhLHIsbyk7dmFyIGk9YS5zaGFwZSxzPXtiZWdpbjpyLHNpemU6b307cmV0dXJuIEx0LnJ1bktlcm5lbEZ1bmMoKGZ1bmN0aW9uKHQpe3JldHVybiB0LnNsaWNlKGEscixvKX0pLHt4OmF9LChmdW5jdGlvbih0KXtmb3IodmFyIGU9W10sbj0wO248dC5yYW5rO24rKyllLnB1c2goW3Jbbl0saVtuXS1yW25dLW9bbl1dKTtyZXR1cm57eDpmdW5jdGlvbigpe3JldHVybiB0LnBhZChlKX19fSksXCJTbGljZVwiLHMpfX0pLGdsPUFuKHtzbGljZTFkXzpmdW5jdGlvbih0LGUsbil7dmFyIHI9bW4odCxcInhcIixcInNsaWNlMWRcIik7cmV0dXJuIEMoMT09PXIucmFuaywoZnVuY3Rpb24oKXtyZXR1cm5cInNsaWNlMWQgZXhwZWN0cyBhIHJhbmstMSB0ZW5zb3IsIGJ1dCBnb3QgYSByYW5rLVwiK3IucmFuaytcIiB0ZW5zb3JcIn0pKSxtbChyLFtlXSxbbl0pfX0pLHlsPUFuKHtzbGljZTJkXzpmdW5jdGlvbih0LGUsbil7dmFyIHI9bW4odCxcInhcIixcInNsaWNlMmRcIik7cmV0dXJuIEMoMj09PXIucmFuaywoZnVuY3Rpb24oKXtyZXR1cm5cInNsaWNlMmQgZXhwZWN0cyBhIHJhbmstMiB0ZW5zb3IsIGJ1dCBnb3QgYSByYW5rLVwiK3IucmFuaytcIiB0ZW5zb3JcIn0pKSxtbChyLGUsbil9fSkseGw9QW4oe3NsaWNlM2RfOmZ1bmN0aW9uKHQsZSxuKXt2YXIgcj1tbih0LFwieFwiLFwic2xpY2UzZFwiKTtyZXR1cm4gQygzPT09ci5yYW5rLChmdW5jdGlvbigpe3JldHVyblwic2xpY2UzZCBleHBlY3RzIGEgcmFuay0zIHRlbnNvciwgYnV0IGdvdCBhIHJhbmstXCIrci5yYW5rK1wiIHRlbnNvclwifSkpLG1sKHIsZSxuKX19KSxibD1Bbih7c2xpY2U0ZF86ZnVuY3Rpb24odCxlLG4pe3ZhciByPW1uKHQsXCJ4XCIsXCJzbGljZTRkXCIpO3JldHVybiBDKDQ9PT1yLnJhbmssKGZ1bmN0aW9uKCl7cmV0dXJuXCJzbGljZTRkIGV4cGVjdHMgYSByYW5rLTQgdGVuc29yLCBidXQgZ290IGEgcmFuay1cIityLnJhbmsrXCIgdGVuc29yXCJ9KSksbWwocixlLG4pfX0pO2Z1bmN0aW9uIHdsKHQsZSxuLHIsbyl7cmV0dXJuIGUucmFuazxuLnJhbmsmJihlPWUucmVzaGFwZSh3bihlLnNoYXBlLHIpKSksdC5yYW5rPG4ucmFuayYmKHQ9dC5yZXNoYXBlKHduKHQuc2hhcGUscikpKSx7eDpmdW5jdGlvbigpe3ZhciByPXQubXVsKG4uZXF1YWwoZSkuY2FzdCh0LmR0eXBlKSk7cmV0dXJuIG51bGw9PW8/cjpyLnRyYW5zcG9zZShvKX19fXZhciBDbD1Bbih7YWxsXzpmdW5jdGlvbih0LGUsbil7dm9pZCAwPT09ZSYmKGU9bnVsbCksdm9pZCAwPT09biYmKG49ITEpO3ZhciByPW1uKHQsXCJ4XCIsXCJhbGxcIixcImJvb2xcIiksbz1PKGUsci5zaGFwZSksYT1vLGk9RW4oYSxyLnJhbmspO251bGwhPWkmJihyPXIudHJhbnNwb3NlKGkpLGE9SW4oYS5sZW5ndGgsci5yYW5rKSk7dmFyIHM9THQucnVuS2VybmVsRnVuYygoZnVuY3Rpb24odCl7cmV0dXJuIHQuYWxsKHIsYSl9KSx7JHg6cn0pO2lmKG4pe3ZhciB1PXduKHMuc2hhcGUsbyk7cmV0dXJuIHMucmVzaGFwZSh1KX1yZXR1cm4gc319KSxFbD1Bbih7YW55XzpmdW5jdGlvbih0LGUsbil7dm9pZCAwPT09ZSYmKGU9bnVsbCksdm9pZCAwPT09biYmKG49ITEpO3ZhciByPW1uKHQsXCJ4XCIsXCJhbnlcIixcImJvb2xcIiksbz1PKGUsci5zaGFwZSksYT1vLGk9RW4oYSxyLnJhbmspO251bGwhPWkmJihyPXIudHJhbnNwb3NlKGkpLGE9SW4oYS5sZW5ndGgsci5yYW5rKSk7dmFyIHM9THQucnVuS2VybmVsRnVuYygoZnVuY3Rpb24odCl7cmV0dXJuIHQuYW55KHIsYSl9KSx7JHg6cn0pO2lmKG4pe3ZhciB1PXduKHMuc2hhcGUsbyk7cmV0dXJuIHMucmVzaGFwZSh1KX1yZXR1cm4gc319KSxSbD1Bbih7YXJnTWF4XzpmdW5jdGlvbih0LGUpe3ZvaWQgMD09PWUmJihlPTApO3ZhciBuPW1uKHQsXCJ4XCIsXCJhcmdNYXhcIik7bnVsbD09ZSYmKGU9MCk7dmFyIHI9TyhlLG4uc2hhcGUpLG89RW4ocixuLnJhbmspO251bGwhPW8mJihuPW4udHJhbnNwb3NlKG8pLHI9SW4oci5sZW5ndGgsbi5yYW5rKSk7dmFyIGE9e2F4aXM6clswXX0saT1bbl07cmV0dXJuIEx0LnJ1bktlcm5lbEZ1bmMoKGZ1bmN0aW9uKHQsZSl7dmFyIG89dC5hcmdNYXgobixyWzBdKTtyZXR1cm4gZShbbl0pLG99KSx7eDpufSwoZnVuY3Rpb24odCxlKXt2YXIgbj1lWzBdO3JldHVybnt4OmZ1bmN0aW9uKCl7cmV0dXJuIFhuKG4pfX19KSxcIkFyZ01heFwiLGEsaSl9fSksSWw9QW4oe2FyZ01pbl86ZnVuY3Rpb24odCxlKXt2b2lkIDA9PT1lJiYoZT0wKTt2YXIgbj1tbih0LFwieFwiLFwiYXJnTWluXCIpO251bGw9PWUmJihlPTApO3ZhciByPU8oZSxuLnNoYXBlKSxvPUVuKHIsbi5yYW5rKTtyZXR1cm4gbnVsbCE9byYmKG49bi50cmFuc3Bvc2Uobykscj1JbihyLmxlbmd0aCxuLnJhbmspKSxMdC5ydW5LZXJuZWxGdW5jKChmdW5jdGlvbih0LGUpe3ZhciBvPXQuYXJnTWluKG4sclswXSk7cmV0dXJuIGUoW25dKSxvfSkseyR4Om59LChmdW5jdGlvbih0LGUpe3ZhciBuPWVbMF07cmV0dXJueyR4OmZ1bmN0aW9uKCl7cmV0dXJuIFhuKG4pfX19KSl9fSksa2w9QW4oe2xvZ1N1bUV4cF86ZnVuY3Rpb24odCxlLG4pe3ZvaWQgMD09PWUmJihlPW51bGwpLHZvaWQgMD09PW4mJihuPSExKTt2YXIgcj1tbih0LFwieFwiLFwibG9nU3VtRXhwXCIpLG89TyhlLHIuc2hhcGUpLGE9ci5tYXgobywhMCksaT1yLnN1YihhKS5leHAoKS5zdW0obykubG9nKCkscz1hLnJlc2hhcGUoaS5zaGFwZSkuYWRkKGkpO2lmKG4pe3ZhciB1PXduKHMuc2hhcGUsbyk7cmV0dXJuIHMucmVzaGFwZSh1KX1yZXR1cm4gc319KSxTbD1Bbih7bWF4XzpmdW5jdGlvbih0LGUsbil7dm9pZCAwPT09ZSYmKGU9bnVsbCksdm9pZCAwPT09biYmKG49ITEpO3ZhciByPW1uKHQsXCJ4XCIsXCJtYXhcIiksbz1yLGE9TyhlLHIuc2hhcGUpLGk9YSxzPUVuKGksci5yYW5rKTtudWxsIT1zJiYocj1yLnRyYW5zcG9zZShzKSxpPUluKGkubGVuZ3RoLHIucmFuaykpO3ZhciB1PVtyXSxjPUx0LnJ1bktlcm5lbEZ1bmMoKGZ1bmN0aW9uKHQsZSl7dmFyIG49dC5tYXgocixpKTtyZXR1cm4gZShbbyxuXSksbn0pLHt4OnJ9LChmdW5jdGlvbih0LGUpe3JldHVybiB3bCh0LGVbMV0sZVswXSxhLHMpfSksXCJNYXhcIix7YXhlczppfSx1LFshMF0pO2lmKG4pe3ZhciBsPXduKGMuc2hhcGUsYSk7Yz1jLnJlc2hhcGUobCl9cmV0dXJuIGN9fSksQWw9QW4oe21lYW5fOmZ1bmN0aW9uKHQsZSxuKXt2b2lkIDA9PT1lJiYoZT1udWxsKSx2b2lkIDA9PT1uJiYobj0hMSk7dmFyIHI9bW4odCxcInhcIixcIm1lYW5cIiksbz1PKGUsci5zaGFwZSksYT1rKGJuKHIuc2hhcGUsbylbMV0pO3JldHVybiB2bygoZnVuY3Rpb24odCl7dmFyIHI9T24oYSk7cmV0dXJue3ZhbHVlOihyLmR0eXBlPT09dC5kdHlwZT90OnQuY2FzdChyLmR0eXBlKSkuZGl2KHIpLnN1bShlLG4pLGdyYWRGdW5jOmZ1bmN0aW9uKGUpe3ZhciBuPXQuc2hhcGUuc2xpY2UoKTtyZXR1cm4gby5mb3JFYWNoKChmdW5jdGlvbih0KXtuW3RdPTF9KSksZS5yZXNoYXBlKG4pLm11bCh6bih0LnNoYXBlLFwiZmxvYXQzMlwiKSkuZGl2KGEpfX19KSkocil9fSksRGw9QW4oe21pbl86ZnVuY3Rpb24odCxlLG4pe3ZvaWQgMD09PWUmJihlPW51bGwpLHZvaWQgMD09PW4mJihuPSExKTt2YXIgcj1tbih0LFwieFwiLFwibWluXCIpLG89cixhPU8oZSxyLnNoYXBlKSxpPWEscz1FbihpLHIucmFuayk7bnVsbCE9cyYmKHI9ci50cmFuc3Bvc2UocyksaT1JbihpLmxlbmd0aCxyLnJhbmspKTt2YXIgdT1bcl0sYz1MdC5ydW5LZXJuZWxGdW5jKChmdW5jdGlvbih0LGUpe3ZhciBuPXQubWluKHIsaSk7cmV0dXJuIGUoW28sbl0pLG59KSx7eDpyfSwoZnVuY3Rpb24odCxlKXtyZXR1cm4gd2wodCxlWzFdLGVbMF0sYSxzKX0pLFwiTWluXCIse2F4ZXM6aX0sdSxbITBdKTtpZihuKXt2YXIgbD13bihjLnNoYXBlLGEpO2M9Yy5yZXNoYXBlKGwpfXJldHVybiBjfX0pLFRsPUFuKHttb21lbnRzXzpmdW5jdGlvbih0LGUsbil7dm9pZCAwPT09ZSYmKGU9bnVsbCksdm9pZCAwPT09biYmKG49ITEpO3ZhciByPU8oZSwodD1tbih0LFwieFwiLFwibW9tZW50c1wiKSkuc2hhcGUpLG89dC5tZWFuKHIsbiksYT1vLnNoYXBlO258fChhPXduKG8uc2hhcGUscikpO3ZhciBpPXQudG9GbG9hdCgpLnN1YihvLnJlc2hhcGUoYSkpLnNxdWFyZSgpO3JldHVybnttZWFuOm8sdmFyaWFuY2U6aS5tZWFuKHIsbil9fX0pLE5sPUFuKHtzdW1fOmZ1bmN0aW9uKHQsZSxuKXt2b2lkIDA9PT1lJiYoZT1udWxsKSx2b2lkIDA9PT1uJiYobj0hMSk7dmFyIHI9bW4odCxcInhcIixcInN1bVwiKTtcImJvb2xcIj09PXIuZHR5cGUmJihyPXIudG9JbnQoKSk7dmFyIG89TyhlLHIuc2hhcGUpO3JldHVybiB2bygoZnVuY3Rpb24odCl7dmFyIGU9RW4obyx0LnJhbmspLHI9byxhPXQ7bnVsbCE9ZSYmKGE9dC50cmFuc3Bvc2UoZSkscj1JbihyLmxlbmd0aCx0LnJhbmspKTt2YXIgaT1mdW5jdGlvbihlKXt2YXIgbj10LnNoYXBlLnNsaWNlKCk7cmV0dXJuIG8uZm9yRWFjaCgoZnVuY3Rpb24odCl7blt0XT0xfSkpLGUucmVzaGFwZShuKS5tdWwoem4odC5zaGFwZSxcImZsb2F0MzJcIikpfSxzPXtheGVzOnJ9LHU9THQucnVuS2VybmVsRnVuYygoZnVuY3Rpb24odCl7cmV0dXJuIHQuc3VtKGEscil9KSx7eDphfSwoZnVuY3Rpb24odCl7cmV0dXJue3g6ZnVuY3Rpb24oKXtyZXR1cm4gaSh0KX19fSksXCJTdW1cIixzKTtpZihuKXt2YXIgYz13bih1LnNoYXBlLG8pO3U9dS5yZXNoYXBlKGMpfXJldHVybnt2YWx1ZTp1LGdyYWRGdW5jOml9fSkpKHIpfX0pLEZsPUFuKHtwcm9kXzpmdW5jdGlvbih0LGUsbil7dm9pZCAwPT09ZSYmKGU9bnVsbCksdm9pZCAwPT09biYmKG49ITEpO3ZhciByPW1uKHQsXCJ4XCIsXCJwcm9kXCIpO1wiYm9vbFwiPT09ci5kdHlwZSYmKHI9ci50b0ludCgpKTt2YXIgbz1PKGUsci5zaGFwZSksYT1FbihvLHIucmFuayksaT1vLHM9cjtudWxsIT1hJiYocz1yLnRyYW5zcG9zZShhKSxpPUluKGkubGVuZ3RoLHIucmFuaykpO3ZhciB1PUx0LnJ1bktlcm5lbEZ1bmMoKGZ1bmN0aW9uKHQpe3JldHVybiB0LnByb2QocyxpKX0pLHtwZXJtdXRlZFg6c30pO2lmKG4pe3ZhciBjPXduKHUuc2hhcGUsbyk7dT11LnJlc2hhcGUoYyl9cmV0dXJuIHV9fSk7dmFyIF9sPUFuKHtlbHVfOmZ1bmN0aW9uKHQpe3ZhciBlPW1uKHQsXCJ4XCIsXCJlbHVcIik7cmV0dXJuIEx0LnJ1bktlcm5lbEZ1bmMoKGZ1bmN0aW9uKHQsbil7dmFyIHI9dC5lbHUoZSk7cmV0dXJuIG4oW3JdKSxyfSkseyR4OmV9LChmdW5jdGlvbih0LGUpe3ZhciBuPWVbMF07cmV0dXJueyR4OmZ1bmN0aW9uKCl7cmV0dXJuIEx0LnJ1bktlcm5lbEZ1bmMoKGZ1bmN0aW9uKGUpe3JldHVybiBlLmVsdURlcih0LG4pfSkse2R5OnQseTpufSl9fX0pKX19KSxPbD1Bbih7bGVha3lSZWx1XzpmdW5jdGlvbih0LGUpe3ZvaWQgMD09PWUmJihlPS4yKTt2YXIgbj1tbih0LFwieFwiLFwibGVha3lSZWx1XCIpO3JldHVybiBoYyhPbihlKS5tdWwobiksbil9fSksTWw9QW4oe3ByZWx1XzpmdW5jdGlvbih0LGUpe3ZhciBuPW1uKHQsXCJ4XCIsXCJwcmVsdVwiKSxyPW1uKGUsXCJhbHBoYVwiLFwicHJlbHVcIik7cmV0dXJuIEx0LnJ1bktlcm5lbEZ1bmMoKGZ1bmN0aW9uKHQsZSl7dmFyIG89dC5wcmVsdShuLHIpO3JldHVybiBlKFtuLHJdKSxvfSkse3g6bixhbHBoYTpyfSwoZnVuY3Rpb24odCxlKXt2YXIgbj1lWzBdLHI9ZVsxXSxvPW4uZ3JlYXRlcigwKTtyZXR1cm57eDpmdW5jdGlvbigpe3JldHVybiBlYyhvLHQsdC5tdWwocikpfSxhbHBoYTpmdW5jdGlvbigpe3ZhciBlPWVjKG8sWG4odCksdC5tdWwobikpLGE9RW8oci5zaGFwZSx0LnNoYXBlKTtyZXR1cm4gYS5sZW5ndGg+MCYmKGU9ZS5zdW0oYSkpLGUucmVzaGFwZShyLnNoYXBlKX19fSksXCJQcmVsdVwiKX19KSxCbD1Bbih7cmVsdV86ZnVuY3Rpb24odCl7dmFyIGU9bW4odCxcInhcIixcInJlbHVcIik7cmV0dXJuXCJib29sXCI9PT1lLmR0eXBlP2UudG9JbnQoKTpMdC5ydW5LZXJuZWxGdW5jKChmdW5jdGlvbih0LG4pe3ZhciByPXQucmVsdShlKTtyZXR1cm4gbihbZV0pLHJ9KSx7eDplfSwoZnVuY3Rpb24odCxlKXt2YXIgbj1lWzBdO3JldHVybnt4OmZ1bmN0aW9uKCl7cmV0dXJuIHQubXVsU3RyaWN0KG4uc3RlcCgpLnRvRmxvYXQoKSl9fX0pLFwiUmVsdVwiKX19KSxQbD1Bbih7cmVsdTZfOmZ1bmN0aW9uKHQpe3ZhciBlPW1uKHQsXCJ4XCIsXCJyZWx1NlwiKTtyZXR1cm5cImJvb2xcIj09PWUuZHR5cGU/ZS50b0ludCgpOkx0LnJ1bktlcm5lbEZ1bmMoKGZ1bmN0aW9uKHQsbil7dmFyIHI9dC5yZWx1NihlKTtyZXR1cm4gbihbZV0pLHJ9KSx7eDplfSwoZnVuY3Rpb24odCxlKXt2YXIgbj1lWzBdLHI9bi5sZXNzRXF1YWwoNikubXVsKG4uc3RlcCgpKTtyZXR1cm57eDpmdW5jdGlvbigpe3JldHVybiB0Lm11bFN0cmljdChyLnRvRmxvYXQoKSl9fX0pLFwiUmVsdTZcIil9fSksTGw9QW4oe3NlbHVfOmZ1bmN0aW9uKHQpe3ZhciBlPW1uKHQsXCJ4XCIsXCJzZWx1XCIpO3JldHVybiBMdC5ydW5LZXJuZWxGdW5jKChmdW5jdGlvbih0LG4pe3ZhciByPXQuc2VsdShlKTtyZXR1cm4gbihbZV0pLHJ9KSx7JHg6ZX0sKGZ1bmN0aW9uKHQsZSl7dmFyIG49ZVswXTtyZXR1cm57JHg6ZnVuY3Rpb24oKXt2YXIgZT1uLmdyZWF0ZXIoT24oMCkpLHI9T24oYnMpLG89T24od3MpLGE9dC5tdWwobyksaT10Lm11bChyKS5tdWwobi50b0Zsb2F0KCkuZXhwKCkpO3JldHVybiBlYyhlLGEsaSl9fX0pKX19KTt2YXIgV2w9QW4oe3RyYW5zcG9zZV86ZnVuY3Rpb24odCxlKXt2YXIgbj1tbih0LFwieFwiLFwidHJhbnNwb3NlXCIpO2lmKG51bGw9PWUmJihlPW4uc2hhcGUubWFwKChmdW5jdGlvbih0LGUpe3JldHVybiBlfSkpLnJldmVyc2UoKSksQyhuLnJhbms9PT1lLmxlbmd0aCwoZnVuY3Rpb24oKXtyZXR1cm5cIkVycm9yIGluIHRyYW5zcG9zZTogcmFuayBvZiBpbnB1dCBcIituLnJhbmsrXCIgbXVzdCBtYXRjaCBsZW5ndGggb2YgcGVybSBcIitlK1wiLlwifSkpLGUuZm9yRWFjaCgoZnVuY3Rpb24odCl7Qyh0Pj0wJiZ0PG4ucmFuaywoZnVuY3Rpb24oKXtyZXR1cm5cIkFsbCBlbnRyaWVzIGluICdwZXJtJyBtdXN0IGJlIGJldHdlZW4gMCBhbmQgXCIrKG4ucmFuay0xKStcIiBidXQgZ290IFwiK2V9KSl9KSksbi5yYW5rPD0xKXJldHVybiBuLmNsb25lKCk7dmFyIHI9e3Blcm06ZX07cmV0dXJuIEx0LnJ1bktlcm5lbEZ1bmMoKGZ1bmN0aW9uKHQpe3JldHVybiB0LnRyYW5zcG9zZShuLGUpfSkse3g6bn0sKGZ1bmN0aW9uKHQpe3ZhciBuPVJuKGUpO3JldHVybnt4OmZ1bmN0aW9uKCl7cmV0dXJuIHQudHJhbnNwb3NlKG4pfX19KSxcIlRyYW5zcG9zZVwiLHIpfX0pO3ZhciBVbD1Bbih7bG9jYWxSZXNwb25zZU5vcm1hbGl6YXRpb25fOmZ1bmN0aW9uKHQsZSxuLHIsbyl7dm9pZCAwPT09ZSYmKGU9NSksdm9pZCAwPT09biYmKG49MSksdm9pZCAwPT09ciYmKHI9MSksdm9pZCAwPT09byYmKG89LjUpO3ZhciBhPW1uKHQsXCJ4XCIsXCJsb2NhbFJlc3BvbnNlTm9ybWFsaXphdGlvblwiKTtDKDQ9PT1hLnJhbmt8fDM9PT1hLnJhbmssKGZ1bmN0aW9uKCl7cmV0dXJuXCJFcnJvciBpbiBsb2NhbFJlc3BvbnNlTm9ybWFsaXphdGlvbjogeCBtdXN0IGJlIHJhbmsgMyBvciA0IGJ1dCBnb3RcXG4gICAgICAgICAgICAgICByYW5rIFwiK2EucmFuaytcIi5cIn0pKSxDKEEoZSksKGZ1bmN0aW9uKCl7cmV0dXJuXCJFcnJvciBpbiBsb2NhbFJlc3BvbnNlTm9ybWFsaXphdGlvbjogZGVwdGhSYWRpdXMgbXVzdCBiZSBhbiBpbnRlZ2VyIGJ1dCBnb3QgZGVwdGhSYWRpdXMgXCIrZStcIi5cIn0pKTt2YXIgaT1hLHM9ITE7Mz09PWEucmFuayYmKHM9ITAsaT1hLmFzNEQoMSxhLnNoYXBlWzBdLGEuc2hhcGVbMV0sYS5zaGFwZVsyXSkpO3ZhciB1PUx0LnJ1bktlcm5lbEZ1bmMoKGZ1bmN0aW9uKHQsYSl7dmFyIHM9dC5sb2NhbFJlc3BvbnNlTm9ybWFsaXphdGlvbjREKGksZSxuLHIsbyk7cmV0dXJuIGEoW2ksc10pLHN9KSx7eDREOml9LChmdW5jdGlvbih0LGEpe3ZhciBpPWFbMF0scz1hWzFdO3JldHVybnt4NEQ6ZnVuY3Rpb24oKXtyZXR1cm4gTHQucnVuS2VybmVsRnVuYygoZnVuY3Rpb24oYSl7cmV0dXJuIGEuTFJOR3JhZCh0LGkscyxlLG4scixvKX0pLHt9KX19fSkpO3JldHVybiBzP3UuYXMzRCh1LnNoYXBlWzFdLHUuc2hhcGVbMl0sdS5zaGFwZVszXSk6dX19KTt2YXIgVmw9QW4oe25vcm1fOmZ1bmN0aW9uKHQsZSxuLHIpe3ZvaWQgMD09PWUmJihlPVwiZXVjbGlkZWFuXCIpLHZvaWQgMD09PW4mJihuPW51bGwpLHZvaWQgMD09PXImJihyPSExKTt2YXIgbz1mdW5jdGlvbiB0KGUsbixyKXt2b2lkIDA9PT1yJiYocj1udWxsKTtpZigwPT09ZS5yYW5rKXJldHVybiBlLmFicygpO2lmKDEhPT1lLnJhbmsmJm51bGw9PT1yKXJldHVybiB0KGUucmVzaGFwZShbLTFdKSxuLHIpO2lmKDE9PT1lLnJhbmt8fFwibnVtYmVyXCI9PXR5cGVvZiByfHxBcnJheS5pc0FycmF5KHIpJiYxPT09ci5sZW5ndGgpe2lmKDE9PT1uKXJldHVybiBlLmFicygpLnN1bShyKTtpZihuPT09MS8wKXJldHVybiBlLmFicygpLm1heChyKTtpZihuPT09LTEvMClyZXR1cm4gZS5hYnMoKS5taW4ocik7aWYoXCJldWNsaWRlYW5cIj09PW58fDI9PT1uKXJldHVybiBlLmFicygpLnBvdyhPbigyLFwiaW50MzJcIikpLnN1bShyKS5zcXJ0KCk7dGhyb3cgbmV3IEVycm9yKFwiRXJyb3IgaW4gbm9ybTogaW52YWxpZCBvcmQgdmFsdWU6IFwiK24pfWlmKEFycmF5LmlzQXJyYXkocikmJjI9PT1yLmxlbmd0aCl7aWYoMT09PW4pcmV0dXJuIGUuYWJzKCkuc3VtKHJbMF0pLm1heChyWzFdLTEpO2lmKG49PT0xLzApcmV0dXJuIGUuYWJzKCkuc3VtKHJbMV0pLm1heChyWzBdKTtpZihuPT09LTEvMClyZXR1cm4gZS5hYnMoKS5zdW0oclsxXSkubWluKHJbMF0pO2lmKFwiZnJvXCI9PT1ufHxcImV1Y2xpZGVhblwiPT09bilyZXR1cm4gZS5zcXVhcmUoKS5zdW0ocikuc3FydCgpO3Rocm93IG5ldyBFcnJvcihcIkVycm9yIGluIG5vcm06IGludmFsaWQgb3JkIHZhbHVlOiBcIituKX10aHJvdyBuZXcgRXJyb3IoXCJFcnJvciBpbiBub3JtOiBpbnZhbGlkIGF4aXM6IFwiK3IpfSh0PW1uKHQsXCJ4XCIsXCJub3JtXCIpLGUsbiksYT1vLnNoYXBlO2lmKHIpe3ZhciBpPU8obix0LnNoYXBlKTthPXduKG8uc2hhcGUsaSl9cmV0dXJuIG8ucmVzaGFwZShhKX19KTt2YXIgemw9QW4oe2Jhc2ljTFNUTUNlbGxfOmZ1bmN0aW9uKHQsZSxuLHIsbyxhKXt2YXIgaT1tbih0LFwiZm9yZ2V0Qmlhc1wiLFwiYmFzaWNMU1RNQ2VsbFwiKSxzPW1uKGUsXCJsc3RtS2VybmVsXCIsXCJiYXNpY0xTVE1DZWxsXCIpLHU9bW4obixcImxzdG1CaWFzXCIsXCJiYXNpY0xTVE1DZWxsXCIpLGM9bW4ocixcImRhdGFcIixcImJhc2ljTFNUTUNlbGxcIiksbD1tbihvLFwiY1wiLFwiYmFzaWNMU1RNQ2VsbFwiKSxoPW1uKGEsXCJoXCIsXCJiYXNpY0xTVE1DZWxsXCIpLGY9Yy5jb25jYXQoaCwxKS5tYXRNdWwocykuYWRkKHUpLGQ9Zi5zaGFwZVswXSxwPWYuc2hhcGVbMV0vNCx2PVtkLHBdLG09Zi5zbGljZShbMCwwXSx2KSxnPWYuc2xpY2UoWzAscF0sdikseT1mLnNsaWNlKFswLDIqcF0sdikseD1mLnNsaWNlKFswLDMqcF0sdiksYj1tLnNpZ21vaWQoKS5tdWxTdHJpY3QoZy50YW5oKCkpLmFkZFN0cmljdChsLm11bFN0cmljdChpLmFkZCh5KS5zaWdtb2lkKCkpKSx3PWIudGFuaCgpLm11bFN0cmljdCh4LnNpZ21vaWQoKSk7cmV0dXJuW2Isd119fSksR2w9QW4oe211bHRpUk5OQ2VsbF86ZnVuY3Rpb24odCxlLG4scil7Zm9yKHZhciBvPW1uKGUsXCJkYXRhXCIsXCJtdWx0aVJOTkNlbGxcIiksYT1nbihuLFwiY1wiLFwibXVsdGlSTk5DZWxsXCIpLGk9Z24ocixcImhcIixcIm11bHRpUk5OQ2VsbFwiKSxzPW8sdT1bXSxjPTA7Yzx0Lmxlbmd0aDtjKyspe3ZhciBsPXRbY10ocyxhW2NdLGlbY10pO3UucHVzaChsWzBdKSx1LnB1c2gobFsxXSkscz1sWzFdfXZhciBoPVtdLGY9W107Zm9yKGM9MDtjPHUubGVuZ3RoO2MrPTIpaC5wdXNoKHVbY10pLGYucHVzaCh1W2MrMV0pO3JldHVybltoLGZdfX0pO3ZhciBIbD1Bbih7bW92aW5nQXZlcmFnZV86ZnVuY3Rpb24odCxlLG4scixvKXt2b2lkIDA9PT1vJiYobz0hMCk7dmFyIGE9bW4odCxcInZcIixcIm1vdmluZ0F2ZXJhZ2VcIiksaT1tbihlLFwieFwiLFwibW92aW5nQXZlcmFnZVwiKSxzPW1uKG4sXCJkZWNheVwiLFwibW92aW5nQXZlcmFnZVwiKTtGdChhLGkpLEMoUyhhLnNoYXBlLGkuc2hhcGUpLChmdW5jdGlvbigpe3JldHVyblwiU2hhcGUgbWlzbWF0Y2ggaW4gdiBhbmQgeFwifSkpO3ZhciB1PU9uKDEpLGM9dS5zdWIocyksbD1pLnN1YihhKS5tdWwoYyk7aWYobyl7QyhudWxsIT1yLChmdW5jdGlvbigpe3JldHVyblwiV2hlbiB1c2luZyB6ZXJvRGViaWFzOiB0cnVlLCBzdGVwIGlzIHJlcXVpcmVkLlwifSkpO3ZhciBoPW1uKHIsXCJzdGVwXCIsXCJtb3ZpbmdBdmVyYWdlXCIpO2w9bC5kaXYodS5zdWIoeGMocyxoKSkpfXJldHVybiBhLmFkZChsKX19KTt2YXIgcWw9QW4oe3N0cmlkZWRTbGljZV86ZnVuY3Rpb24odCxlLG4scixvLGEsaSxzLHUpe2lmKHZvaWQgMD09PW8mJihvPTApLHZvaWQgMD09PWEmJihhPTApLHZvaWQgMD09PWkmJihpPTApLHZvaWQgMD09PXMmJihzPTApLHZvaWQgMD09PXUmJih1PTApLG51bGw9PXImJihyPW5ldyBBcnJheShlLmxlbmd0aCkpLDAhPT1pKXRocm93IG5ldyBFcnJvcihcImVsbGlwc2lzIG1hc2sgaXMgbm90IHlldCBzdXBwb3J0ZWRcIik7dmFyIGM9bW4odCxcInhcIixcInN0cmlkZWRTbGljZVwiKSxsPW5vKHMpLGg9Yy5zaGFwZS5zbGljZSgpO2wuZm9yRWFjaCgoZnVuY3Rpb24odCl7ZVt0XT0wLG5bdF09MSxoLnNwbGljZSh0LDAsMSl9KSksYz1jLnJlc2hhcGUoaCk7Zm9yKHZhciBmPTA7ZjxjLnJhbms7ZisrKWVbZl09b28obyxlLHIsYy5zaGFwZSxmKSxuW2ZdPWFvKGEsbixyLGMuc2hhcGUsZikscltmXT1yW2ZdfHwxO3ZhciBkPW5vKHUpO2QuZm9yRWFjaCgoZnVuY3Rpb24odCl7blt0XT1lW3RdKzEsclt0XT0xfSkpO3ZhciBwPXJvKGUsbixyKSx2PXAuZmlsdGVyKChmdW5jdGlvbih0LGUpe3JldHVybi0xPT09ZC5pbmRleE9mKGUpfSkpO3JldHVybiByLmV2ZXJ5KChmdW5jdGlvbih0KXtyZXR1cm4gMT09PXR9KSk/bWwoYyxlLHApLnJlc2hhcGUodik6THQucnVuS2VybmVsRnVuYygoZnVuY3Rpb24odCl7cmV0dXJuIHQuc3RyaWRlZFNsaWNlKGMsZSxuLHIpfSkseyR4OmN9KS5yZXNoYXBlKHYpfX0pO3ZhciBLbD1Bbih7dG9wa186ZnVuY3Rpb24odCxlLG4pe3ZvaWQgMD09PWUmJihlPTEpLHZvaWQgMD09PW4mJihuPSEwKTt2YXIgcj1tbih0LFwieFwiLFwidG9wa1wiKTtpZigwPT09ci5yYW5rKXRocm93IG5ldyBFcnJvcihcInRvcGsoKSBleHBlY3RzIHRoZSBpbnB1dCB0byBiZSBvZiByYW5rIDEgb3IgaGlnaGVyXCIpO3ZhciBvPXIuc2hhcGVbci5zaGFwZS5sZW5ndGgtMV07aWYoZT5vKXRocm93IG5ldyBFcnJvcihcIidrJyBwYXNzZWQgdG8gdG9waygpIG11c3QgYmUgPD0gdGhlIGxhc3QgZGltZW5zaW9uIChcIitvK1wiKSBidXQgZ290IFwiK2UpO3ZhciBhPUx0LnJ1bktlcm5lbEZ1bmMoKGZ1bmN0aW9uKHQpe3JldHVybiB0LnRvcGsocixlLG4pfSkseyR4OnJ9KTtyZXR1cm57dmFsdWVzOmFbMF0saW5kaWNlczphWzFdfX19KTt2YXIgamw9QW4oe3NjYXR0ZXJORF86ZnVuY3Rpb24odCxlLG4pe3ZhciByPW1uKHQsXCJpbmRpY2VzXCIsXCJzY2F0dGVyTkRcIixcImludDMyXCIpLG89bW4oZSxcInVwZGF0ZXNcIixcInNjYXR0ZXJORFwiKTtyZXR1cm4gSnIobyxyLG4pLEx0LnJ1bktlcm5lbEZ1bmMoKGZ1bmN0aW9uKHQpe3JldHVybiB0LnNjYXR0ZXJORChyLG8sbil9KSx7aW5kaWNlczpyLHVwZGF0ZXM6b30sbnVsbCxcIlNjYXR0ZXJOZFwiLHtzaGFwZTpufSl9fSk7dmFyIFhsPUFuKHtmZnRfOmZ1bmN0aW9uKHQpe0MoXCJjb21wbGV4NjRcIj09PXQuZHR5cGUsKGZ1bmN0aW9uKCl7cmV0dXJuXCJUaGUgZHR5cGUgZm9yIHRmLnNwZWN0cmFsLmZmdCgpIG11c3QgYmUgY29tcGxleDY0IGJ1dCBnb3QgXCIrdC5kdHlwZStcIi5cIn0pKTt2YXIgZT10LnNoYXBlW3Quc2hhcGUubGVuZ3RoLTFdLG49dC5zaXplL2Uscj10LmFzMkQobixlKTtyZXR1cm4gTHQucnVuS2VybmVsRnVuYygoZnVuY3Rpb24odCl7cmV0dXJuIHQuZmZ0KHIpfSkse2lucHV0OnR9KS5yZXNoYXBlKHQuc2hhcGUpfX0pLFlsPUFuKHtpZmZ0XzpmdW5jdGlvbih0KXtDKFwiY29tcGxleDY0XCI9PT10LmR0eXBlLChmdW5jdGlvbigpe3JldHVyblwiVGhlIGR0eXBlIGZvciB0Zi5zcGVjdHJhbC5pZmZ0KCkgbXVzdCBiZSBjb21wbGV4NjQgYnV0IGdvdCBcIit0LmR0eXBlK1wiLlwifSkpO3ZhciBlPXQuc2hhcGVbdC5zaGFwZS5sZW5ndGgtMV0sbj10LnNpemUvZSxyPXQuYXMyRChuLGUpO3JldHVybiBMdC5ydW5LZXJuZWxGdW5jKChmdW5jdGlvbih0KXtyZXR1cm4gdC5pZmZ0KHIpfSkse2lucHV0OnR9KS5yZXNoYXBlKHQuc2hhcGUpfX0pLCRsPUFuKHtyZmZ0XzpmdW5jdGlvbih0LGUpe0MoXCJmbG9hdDMyXCI9PT10LmR0eXBlLChmdW5jdGlvbigpe3JldHVyblwiVGhlIGR0eXBlIGZvciByZmZ0KCkgbXVzdCBiZSByZWFsIHZhbHVlIGJ1dCBnb3QgXCIrdC5kdHlwZX0pKTt2YXIgbixyPXQuc2hhcGVbdC5zaGFwZS5sZW5ndGgtMV0sbz10LnNpemUvcjtpZihudWxsIT1lJiZlPHIpe3ZhciBhPXQuc2hhcGUubWFwKChmdW5jdGlvbih0KXtyZXR1cm4gMH0pKSxpPXQuc2hhcGUubWFwKChmdW5jdGlvbih0KXtyZXR1cm4gdH0pKTtpW3Quc2hhcGUubGVuZ3RoLTFdPWUsbj10LnNsaWNlKGEsaSkscj1lfWVsc2UgaWYobnVsbCE9ZSYmZT5yKXt2YXIgcz10LnNoYXBlLm1hcCgoZnVuY3Rpb24odCl7cmV0dXJuIHR9KSk7c1t0LnNoYXBlLmxlbmd0aC0xXT1lLXIsbj10LmNvbmNhdChHbihzKSx0LnNoYXBlLmxlbmd0aC0xKSxyPWV9ZWxzZSBuPXQ7dmFyIHU9bi56ZXJvc0xpa2UoKSxjPURuKG4sdSkuYXMyRChvLHIpLGw9WGwoYyksaD1NYXRoLmZsb29yKHIvMikrMSxmPVRuKGwpLGQ9Tm4obCkscD1mLnNwbGl0KFtoLHItaF0sZi5zaGFwZS5sZW5ndGgtMSksdj1kLnNwbGl0KFtoLHItaF0sZC5zaGFwZS5sZW5ndGgtMSksbT1uLnNoYXBlLnNsaWNlKCk7cmV0dXJuIG1bbi5zaGFwZS5sZW5ndGgtMV09aCxEbihwWzBdLHZbMF0pLnJlc2hhcGUobSl9fSksUWw9QW4oe2lyZmZ0XzpmdW5jdGlvbih0KXt2YXIgZT10LnNoYXBlW3Quc2hhcGUubGVuZ3RoLTFdLG49dC5zaXplL2U7aWYoZTw9Mil7dmFyIHI9dC5hczJEKG4sZSksbz1ZbChyKTtyZXR1cm4gVG4obyl9dmFyIGE9W24sMiooZS0xKV0saT1Ubih0KS5hczJEKG4sZSkscz1Obih0KS5hczJEKG4sZSksdT1pLnNsaWNlKFswLDFdLFtuLGUtMl0pLnJldmVyc2UoMSksYz1zLnNsaWNlKFswLDFdLFtuLGUtMl0pLnJldmVyc2UoMSkubXVsKE9uKC0xKSksbD1pLmNvbmNhdCh1LDEpLGg9cy5jb25jYXQoYywxKTtyZXR1cm4gcj1EbihsLGgpLmFzMkQoYVswXSxhWzFdKSxvPVlsKHIpLFRuKG8pfX0pLEpsPU9iamVjdC5mcmVlemUoe2ZmdDpYbCxpZmZ0OllsLHJmZnQ6JGwsaXJmZnQ6UWx9KTt2YXIgWmw9QW4oe3NwYXJzZVRvRGVuc2VfOmZ1bmN0aW9uKHQsZSxuLHIpe3ZvaWQgMD09PXImJihyPTApO3ZhciBvPW1uKHQsXCJzcGFyc2VJbmRpY2VzXCIsXCJzcGFyc2VUb0RlbnNlXCIsXCJpbnQzMlwiKSxhPW1uKGUsXCJzcGFyc2VWYWx1ZXNcIixcInNwYXJzZVRvRGVuc2VcIiksaT1tbihyLFwiZGVmYXVsdFZhbHVlXCIsXCJzcGFyc2VUb0RlbnNlXCIsYS5kdHlwZSk7cmV0dXJuIGZ1bmN0aW9uKHQsZSxuLHIpe2lmKFwiaW50MzJcIiE9PXQuZHR5cGUpdGhyb3cgbmV3IEVycm9yKFwidGYuc3BhcnNlVG9EZW5zZSgpIGV4cGVjdHMgdGhlIGluZGljZXMgdG8gYmUgaW50MzIgdHlwZSwgYnV0IHRoZSBkdHlwZSB3YXMgXCIrdC5kdHlwZStcIi5cIik7aWYodC5yYW5rPjIpdGhyb3cgbmV3IEVycm9yKFwic3BhcnNlSW5kaWNlcyBzaG91bGQgYmUgYSBzY2FsYXIsIHZlY3Rvciwgb3IgbWF0cml4LCBidXQgZ290IHNoYXBlIFwiK3Quc2hhcGUrXCIuXCIpO3ZhciBvPXQucmFuaz4wP3Quc2hhcGVbMF06MSxhPXQucmFuaz4xP3Quc2hhcGVbMV06MTtpZihuLmxlbmd0aCE9PWEpdGhyb3cgbmV3IEVycm9yKFwib3V0cHV0U2hhcGUgaGFzIGluY29ycmVjdCBudW1iZXIgb2YgZWxlbWVudHM6LCBcIituLmxlbmd0aCtcIiwgc2hvdWxkIGJlOiBcIithK1wiLlwiKTt2YXIgaT1lLnNpemU7aWYoMCE9PWUucmFuayYmKDEhPT1lLnJhbmt8fGkhPT1vKSl0aHJvdyBuZXcgRXJyb3IoXCJzcGFyc2VWYWx1ZXMgaGFzIGluY29ycmVjdCBzaGFwZSBcIitlLnNoYXBlK1wiLCBzaG91bGQgYmUgW10gb3IgW1wiK28rXCJdXCIpO2lmKGUuZHR5cGUhPT1yLmR0eXBlKXRocm93IG5ldyBFcnJvcihcInNwYXJzZVZhbHVlcy5kdHlwZSBtdXN0IG1hdGNoIGRlZmF1bHRWYWx1ZXMuZHR5cGVcIil9KG8sYSxuLGkpLEx0LnJ1bktlcm5lbEZ1bmMoKGZ1bmN0aW9uKHQpe3JldHVybiB0LnNwYXJzZVRvRGVuc2UobyxhLG4saSl9KSx7JHNwYXJzZUluZGljZXM6bywkc3BhcnNlVmFsdWVzOmEsJGRlZmF1bHRWYWx1ZTppfSl9fSk7dmFyIHRoPUFuKHtnYXRoZXJORF86ZnVuY3Rpb24odCxlKXt2YXIgbj1tbihlLFwiaW5kaWNlc1wiLFwiZ2F0aGVyTkRcIixcImludDMyXCIpLHI9bW4odCxcInhcIixcImdhdGhlck5EXCIpO3JldHVybiBMdC5ydW5LZXJuZWxGdW5jKChmdW5jdGlvbih0KXtyZXR1cm4gdC5nYXRoZXJORChyLG4pfSkse3g6cixpbmRpY2VzOm59LG51bGwsXCJHYXRoZXJOZFwiKX19KTt2YXIgZWg9QW4oe2RpYWdfOmZ1bmN0aW9uKHQpe3ZhciBlPW1uKHQsXCJ4XCIsXCJkaWFnXCIpLmZsYXR0ZW4oKSxuPXQuc2hhcGUuY29uY2F0KHQuc2hhcGUpO3JldHVybiBMdC5ydW5LZXJuZWxGdW5jKChmdW5jdGlvbih0KXtyZXR1cm4gdC5kaWFnKGUpfSkseyR4OmV9KS5yZXNoYXBlKG4pfX0pO3ZhciBuaD1Bbih7ZHJvcG91dF86ZnVuY3Rpb24odCxlLG4scil7dmFyIG89bW4odCxcInhcIixcImRyb3BvdXRcIik7aWYoQyhcImZsb2F0MzJcIj09PW8uZHR5cGUsKGZ1bmN0aW9uKCl7cmV0dXJuXCJ4IGhhcyB0byBiZSBhIGZsb2F0aW5nIHBvaW50IHRlbnNvciBzaW5jZSBpdCdzIGdvaW5nIHRvIGJlIHNjYWxlZCwgYnV0IGdvdCBhIFwiK28uZHR5cGUrXCIgdGVuc29yIGluc3RlYWQuXCJ9KSksQyhlPj0wJiZlPDEsKGZ1bmN0aW9uKCl7cmV0dXJuXCJyYXRlIG11c3QgYmUgYSBmbG9hdCBpbiB0aGUgcmFuZ2UgWzAsIDEpLCBidXQgZ290IFwiK2UrXCIuXCJ9KSksMD09PWUpcmV0dXJuIHQgaW5zdGFuY2VvZiB3dD9vLmNsb25lKCk6bzt2YXIgYT1mdW5jdGlvbih0LGUpe2lmKG51bGw9PWUpcmV0dXJuIHQuc2hhcGUuc2xpY2UoKTtpZihTKHQuc2hhcGUsZSkpcmV0dXJuIGU7aWYodC5zaGFwZS5sZW5ndGg9PT1lLmxlbmd0aCl7Zm9yKHZhciBuPVtdLHI9MDtyPHQuc2hhcGUubGVuZ3RoO3IrKyludWxsPT1lW3JdJiZudWxsIT10LnNoYXBlW3JdP24ucHVzaCh0LnNoYXBlW3JdKTpuLnB1c2goZVtyXSk7cmV0dXJuIG59cmV0dXJuIGV9KG8sbiksaT0xLWUscz1fcihhLDAsMSxcImZsb2F0MzJcIixyKS5hZGQoaSkuZmxvb3IoKS5kaXYoaSk7cmV0dXJuIG8ubXVsKHMpfX0pO2Z1bmN0aW9uIHJoKHQsZSxuKXtmb3IodmFyIHI9MS10JTIsbz1uZXcgRmxvYXQzMkFycmF5KHQpLGE9MDthPHQ7KythKXt2YXIgaT0yKk1hdGguUEkqYS8odCtyLTEpO29bYV09ZS1uKk1hdGguY29zKGkpfXJldHVybiBNbihvLFwiZmxvYXQzMlwiKX12YXIgb2g9QW4oe2hhbm5XaW5kb3dfOmZ1bmN0aW9uKHQpe3JldHVybiByaCh0LC41LC41KX19KSxhaD1Bbih7aGFtbWluZ1dpbmRvd186ZnVuY3Rpb24odCl7cmV0dXJuIHJoKHQsLjU0LC40Nil9fSksaWg9QW4oe2ZyYW1lXzpmdW5jdGlvbih0LGUsbixyLG8pe3ZvaWQgMD09PXImJihyPSExKSx2b2lkIDA9PT1vJiYobz0wKTtmb3IodmFyIGE9MCxpPVtdO2ErZTw9dC5zaXplOylpLnB1c2gobWwodCxhLGUpKSxhKz1uO2lmKHIpZm9yKDthPHQuc2l6ZTspe3ZhciBzPWErZS10LnNpemUsdT1ZbihbbWwodCxhLGUtcyksSG4oW3NdLG8pXSk7aS5wdXNoKHUpLGErPW59cmV0dXJuIDA9PT1pLmxlbmd0aD9CbihbXSxbMCxlXSk6WW4oaSkuYXMyRChpLmxlbmd0aCxlKX19KSxzaD1Bbih7c3RmdF86ZnVuY3Rpb24odCxlLG4scixvKXt2YXIgYTt2b2lkIDA9PT1vJiYobz1vaCksbnVsbD09ciYmKGE9ZSxyPU1hdGguZmxvb3IoTWF0aC5wb3coMixNYXRoLmNlaWwoTWF0aC5sb2coYSkvTWF0aC5sb2coMikpKSkpO2Zvcih2YXIgaT1paCh0LGUsbikscz1nYyhpLG8oZSkpLHU9W10sYz0wO2M8aS5zaGFwZVswXTtjKyspdS5wdXNoKCRsKHMuc2xpY2UoW2MsMF0sWzEsZV0pLHIpKTtyZXR1cm4gWW4odSl9fSksdWg9T2JqZWN0LmZyZWV6ZSh7aGFubldpbmRvdzpvaCxoYW1taW5nV2luZG93OmFoLGZyYW1lOmloLHN0ZnQ6c2h9KTt2YXIgY2gsbGg9ZnVuY3Rpb24odCxlLG8pe3JldHVybiB2b2lkIDA9PT1vJiYobz0xKSxuKHRoaXMsdm9pZCAwLHZvaWQgMCwoZnVuY3Rpb24oKXt2YXIgbixhLGkscyx1LGMsbCxoLGYsZCxwLHYsbSxnO3JldHVybiByKHRoaXMsKGZ1bmN0aW9uKHIpe3N3aXRjaChyLmxhYmVsKXtjYXNlIDA6cmV0dXJuIG49bW4odCxcInByZWRpY3Rpb25zXCIsXCJpblRvcEtcIiksYT1tbihlLFwidGFyZ2V0c1wiLFwiaW5Ub3BLXCIpLEMobi5yYW5rPjEsKGZ1bmN0aW9uKCl7cmV0dXJuXCJpblRvcEsoKSBleHBlY3RzIHRoZSBwcmVkaWN0aW9ucyB0byBiZSBvZiByYW5rIDIgb3IgaGlnaGVyLCBidXQgZ290IFwiK24ucmFua30pKSxDKG4ucmFuay0xPT09YS5yYW5rLChmdW5jdGlvbigpe3JldHVyblwicHJlZGljdGlvbnMgcmFuayBzaG91bGQgYmUgMSBsYXJnZXIgdGhhbiB0YXJnZXRzIHJhbmssIGJ1dCBnb3QgcHJlZGljdGlvbnMgcmFuayBcIituLnJhbmsrXCIgYW5kIHRhcmdldHMgcmFuayBcIithLnJhbmt9KSksRShuLnNoYXBlLnNsaWNlKDAsbi5zaGFwZS5sZW5ndGgtMSksYS5zaGFwZSxcInByZWRpY3Rpb25zJ3Mgc2hhcGUgc2hvdWxkIGJlIGFsaWduIHdpdGggdGhlIHRhcmdldHMnIHNoYXBlLCBleGNlcHQgdGhlIGxhc3QgZGltZW5zaW9uLlwiKSxpPW4uc2hhcGVbbi5zaGFwZS5sZW5ndGgtMV0sQyhvPjAmJm88PWksKGZ1bmN0aW9uKCl7cmV0dXJuXCInaycgcGFzc2VkIHRvIGluVG9wSygpIG11c3QgYmUgPiAwICYmIDw9IHRoZSBwcmVkaWN0aW9ucyBsYXN0IGRpbWVuc2lvbiAoXCIraStcIiksIGJ1dCBnb3QgXCIrb30pKSxbNCxuLmRhdGEoKV07Y2FzZSAxOnJldHVybiBzPXIuc2VudCgpLFs0LGEuZGF0YSgpXTtjYXNlIDI6Zm9yKHU9ci5zZW50KCksYz1bcy5sZW5ndGgvaSxpXSxoPWNbMV0sZj1CKFwiYm9vbFwiLGw9Y1swXSksZD0wO2Q8bDtkKyspe2ZvcihwPWQqaCx2PXMuc3ViYXJyYXkocCxwK2gpLG09W10sZz0wO2c8di5sZW5ndGg7ZysrKW0ucHVzaCh7dmFsdWU6dltnXSxpbmRleDpnfSk7Zm9yKG0uc29ydCgoZnVuY3Rpb24odCxlKXtyZXR1cm4gZS52YWx1ZS10LnZhbHVlfSkpLGZbZF09MCxnPTA7ZzxvO2crKylpZihtW2ddLmluZGV4PT09dVtkXSl7ZltkXT0xO2JyZWFrfX1yZXR1cm4gdCE9PW4mJm4uZGlzcG9zZSgpLGUhPT1hJiZhLmRpc3Bvc2UoKSxbMixGbihmLGEuc2hhcGUsXCJib29sXCIpXX19KSl9KSl9OyFmdW5jdGlvbih0KXt0W3QuTk9ORT0wXT1cIk5PTkVcIix0W3QuTUVBTj0xXT1cIk1FQU5cIix0W3QuU1VNPTJdPVwiU1VNXCIsdFt0LlNVTV9CWV9OT05aRVJPX1dFSUdIVFM9M109XCJTVU1fQllfTk9OWkVST19XRUlHSFRTXCJ9KGNofHwoY2g9e30pKTt2YXIgaGg9QW4oe2Fic29sdXRlRGlmZmVyZW5jZV86ZnVuY3Rpb24odCxlLG4scil7dm9pZCAwPT09ciYmKHI9Y2guU1VNX0JZX05PTlpFUk9fV0VJR0hUUyk7dmFyIG89bW4odCxcImxhYmVsc1wiLFwiYWJzb2x1dGVEaWZmZXJlbmNlXCIpLGE9bW4oZSxcInByZWRpY3Rpb25zXCIsXCJhYnNvbHV0ZURpZmZlcmVuY2VcIiksaT1udWxsO251bGwhPW4mJihpPW1uKG4sXCJ3ZWlnaHRzXCIsXCJhYnNvbHV0ZURpZmZlcmVuY2VcIikpLEUoby5zaGFwZSxhLnNoYXBlLFwiRXJyb3IgaW4gYWJzb2x1dGVEaWZmZXJlbmNlOiBcIik7dmFyIHM9by5zdWIoYSkuYWJzKCk7cmV0dXJuIGZoKHMsaSxyKX19KSxmaD1Bbih7Y29tcHV0ZVdlaWdodGVkTG9zc186ZnVuY3Rpb24odCxlLG4pe3ZvaWQgMD09PW4mJihuPWNoLlNVTV9CWV9OT05aRVJPX1dFSUdIVFMpO3ZhciByPW1uKHQsXCJsb3NzZXNcIixcImNvbXB1dGVXZWlnaHRlZExvc3NcIiksbz1udWxsO251bGwhPWUmJihvPW1uKGUsXCJ3ZWlnaHRzXCIsXCJjb21wdXRlV2VpZ2h0ZWRMb3NzXCIpKTt2YXIgYT1udWxsPT1vP3I6ci5tdWwobyk7aWYobj09PWNoLk5PTkUpcmV0dXJuIGE7aWYobj09PWNoLlNVTSlyZXR1cm4gYS5zdW0oKTtpZihuPT09Y2guTUVBTil7aWYobnVsbD09bylyZXR1cm4gYS5tZWFuKCk7dmFyIGk9ci5zaXplL28uc2l6ZSxzPWEuc3VtKCkuZGl2KG8uc3VtKCkpO3JldHVybiBpPjE/cy5kaXYoT24oaSkpOnN9aWYobj09PWNoLlNVTV9CWV9OT05aRVJPX1dFSUdIVFMpe2lmKG51bGw9PW8pcmV0dXJuIGEuc3VtKCkuZGl2KE9uKHIuc2l6ZSkpO3ZhciB1PW8ubXVsKHpuKHIuc2hhcGUpKS5ub3RFcXVhbChPbigwKSkuc3VtKCkudG9GbG9hdCgpO3JldHVybiBhLnN1bSgpLmRpdih1KX10aHJvdyBFcnJvcihcIlVua25vd24gcmVkdWN0aW9uOiBcIituKX19KSxkaD1Bbih7Y29zaW5lRGlzdGFuY2VfOmZ1bmN0aW9uKHQsZSxuLHIsbyl7dm9pZCAwPT09byYmKG89Y2guU1VNX0JZX05PTlpFUk9fV0VJR0hUUyk7dmFyIGE9bW4odCxcImxhYmVsc1wiLFwiY29zaW5lRGlzdGFuY2VcIiksaT1tbihlLFwicHJlZGljdGlvbnNcIixcImNvc2luZURpc3RhbmNlXCIpLHM9bnVsbDtudWxsIT1yJiYocz1tbihyLFwid2VpZ2h0c1wiLFwiY29zaW5lRGlzdGFuY2VcIikpLEUoYS5zaGFwZSxpLnNoYXBlLFwiRXJyb3IgaW4gY29zaW5lRGlzdGFuY2U6IFwiKTt2YXIgdT1PbigxKS5zdWIoYS5tdWwoaSkuc3VtKG4sITApKTtyZXR1cm4gZmgodSxzLG8pfX0pLHBoPUFuKHtoaW5nZUxvc3NfOmZ1bmN0aW9uKHQsZSxuLHIpe3ZvaWQgMD09PXImJihyPWNoLlNVTV9CWV9OT05aRVJPX1dFSUdIVFMpO3ZhciBvPW1uKHQsXCJsYWJlbHNcIixcImhpbmdlTG9zc1wiKSxhPW1uKGUsXCJwcmVkaWN0aW9uc1wiLFwiaGluZ2VMb3NzXCIpLGk9bnVsbDtudWxsIT1uJiYoaT1tbihuLFwid2VpZ2h0c1wiLFwiaGluZ2VMb3NzXCIpKSxFKG8uc2hhcGUsYS5zaGFwZSxcIkVycm9yIGluIGhpbmdlTG9zczogXCIpO3ZhciBzPU9uKDEpO289T24oMikubXVsKG8pLnN1YihzKTt2YXIgdT1zLnN1YihvLm11bChhKSkucmVsdSgpO3JldHVybiBmaCh1LGkscil9fSksdmg9QW4oe2h1YmVyTG9zc186ZnVuY3Rpb24odCxlLG4scixvKXt2b2lkIDA9PT1yJiYocj0xKSx2b2lkIDA9PT1vJiYobz1jaC5TVU1fQllfTk9OWkVST19XRUlHSFRTKTt2YXIgYT1tbih0LFwibGFiZWxzXCIsXCJodWJlckxvc3NcIiksaT1tbihlLFwicHJlZGljdGlvbnNcIixcImh1YmVyTG9zc1wiKSxzPW51bGw7bnVsbCE9biYmKHM9bW4obixcIndlaWdodHNcIixcImh1YmVyTG9zc1wiKSksRShhLnNoYXBlLGkuc2hhcGUsXCJFcnJvciBpbiBodWJlckxvc3M6IFwiKTt2YXIgdT1PbihyKSxjPWkuc3ViKGEpLmFicygpLGw9ZGMoYyx1KSxoPWMuc3ViKGwpLGY9T24oLjUpLm11bChsLnNxdWFyZSgpKS5hZGQodS5tdWwoaCkpO3JldHVybiBmaChmLHMsbyl9fSksbWg9QW4oe2xvZ0xvc3NfOmZ1bmN0aW9uKHQsZSxuLHIsbyl7dm9pZCAwPT09ciYmKHI9MWUtNyksdm9pZCAwPT09byYmKG89Y2guU1VNX0JZX05PTlpFUk9fV0VJR0hUUyk7dmFyIGE9bW4odCxcImxhYmVsc1wiLFwibG9nTG9zc1wiKSxpPW1uKGUsXCJwcmVkaWN0aW9uc1wiLFwibG9nTG9zc1wiKSxzPW51bGw7bnVsbCE9biYmKHM9bW4obixcIndlaWdodHNcIixcImxvZ0xvc3NcIikpLEUoYS5zaGFwZSxpLnNoYXBlLFwiRXJyb3IgaW4gbG9nTG9zczogXCIpO3ZhciB1PU9uKDEpLGM9T24ociksbD1hLm11bChpLmFkZChjKS5sb2coKSkubmVnKCkuc3ViKHUuc3ViKGEpLm11bCh1LnN1YihpKS5hZGQoYykubG9nKCkpKTtyZXR1cm4gZmgobCxzLG8pfX0pLGdoPUFuKHttZWFuU3F1YXJlZEVycm9yXzpmdW5jdGlvbih0LGUsbixyKXt2b2lkIDA9PT1yJiYocj1jaC5TVU1fQllfTk9OWkVST19XRUlHSFRTKTt2YXIgbz1tbih0LFwibGFiZWxzXCIsXCJtZWFuU3F1YXJlZEVycm9yXCIpLGE9bW4oZSxcInByZWRpY3Rpb25zXCIsXCJtZWFuU3F1YXJlZEVycm9yXCIpLGk9bnVsbDtudWxsIT1uJiYoaT1tbihuLFwid2VpZ2h0c1wiLFwibWVhblNxdWFyZWRFcnJvclwiKSksRShvLnNoYXBlLGEuc2hhcGUsXCJFcnJvciBpbiBtZWFuU3F1YXJlZEVycm9yOiBcIik7dmFyIHM9by5zcXVhcmVkRGlmZmVyZW5jZShhKTtyZXR1cm4gZmgocyxpLHIpfX0pLHloPUFuKHtzaWdtb2lkQ3Jvc3NFbnRyb3B5XzpmdW5jdGlvbih0LGUsbixyLG8pe3ZvaWQgMD09PXImJihyPTApLHZvaWQgMD09PW8mJihvPWNoLlNVTV9CWV9OT05aRVJPX1dFSUdIVFMpO3ZhciBhPW1uKHQsXCJtdWx0aUNsYXNzTGFiZWxzXCIsXCJzaWdtb2lkQ3Jvc3NFbnRyb3B5XCIpLGk9bW4oZSxcImxvZ2l0c1wiLFwic2lnbW9pZENyb3NzRW50cm9weVwiKSxzPW51bGw7aWYobnVsbCE9biYmKHM9bW4obixcIndlaWdodHNcIixcInNpZ21vaWRDcm9zc0VudHJvcHlcIikpLEUoYS5zaGFwZSxpLnNoYXBlLFwiRXJyb3IgaW4gc2lnbW9pZENyb3NzRW50cm9weTogXCIpLHI+MCl7dmFyIHU9T24ociksYz1PbigxKSxsPU9uKC41KTthPWEubXVsKGMuc3ViKHUpKS5hZGQobC5tdWwodSkpfXZhciBoPWZ1bmN0aW9uKHQsZSl7dmFyIG49bW4odCxcImxhYmVsc1wiLFwic2lnbW9pZENyb3NzRW50cm9weVdpdGhMb2dpdHNcIikscj1tbihlLFwibG9naXRzXCIsXCJzaWdtb2lkQ3Jvc3NFbnRyb3B5V2l0aExvZ2l0c1wiKTtFKG4uc2hhcGUsci5zaGFwZSxcIkVycm9yIGluIHNpZ21vaWRDcm9zc0VudHJvcHlXaXRoTG9naXRzOiBcIik7dmFyIG89ci5yZWx1KCksYT1yLm11bChuKSxpPXIuYWJzKCkubmVnKCkuZXhwKCkubG9nMXAoKTtyZXR1cm4gby5zdWIoYSkuYWRkKGkpfShhLGkpO3JldHVybiBmaChoLHMsbyl9fSkseGg9QW4oe3NvZnRtYXhDcm9zc0VudHJvcHlfOmZ1bmN0aW9uKHQsZSxuLHIsbyl7dm9pZCAwPT09ciYmKHI9MCksdm9pZCAwPT09byYmKG89Y2guU1VNX0JZX05PTlpFUk9fV0VJR0hUUyk7dmFyIGE9bW4odCxcIm9uZWhvdExhYmVsc1wiLFwic29mdG1heENyb3NzRW50cm9weVwiKSxpPW1uKGUsXCJsb2dpdHNcIixcInNvZnRtYXhDcm9zc0VudHJvcHlcIikscz1udWxsO2lmKG51bGwhPW4mJihzPW1uKG4sXCJ3ZWlnaHRzXCIsXCJzb2Z0bWF4Q3Jvc3NFbnRyb3B5XCIpKSxFKGEuc2hhcGUsaS5zaGFwZSxcIkVycm9yIGluIHNvZnRtYXhDcm9zc0VudHJvcHk6IFwiKSxyPjApe3ZhciB1PU9uKHIpLGM9T24oMSksbD1PbihhLnNoYXBlWzFdKTthPWEubXVsKGMuc3ViKHUpKS5hZGQodS5kaXYobCkpfXZhciBoPWZ1bmN0aW9uKHQsZSxuKXtpZih2b2lkIDA9PT1uJiYobj0tMSksLTE9PT1uJiYobj1lLnJhbmstMSksbiE9PWUucmFuay0xKXRocm93IEVycm9yKFwiU29mdG1heCBjcm9zcyBlbnRyb3B5IGFsb25nIGEgbm9uLWxhc3QgZGltZW5zaW9uIGlzIG5vdCB5ZXQgc3VwcG9ydGVkLiBMYWJlbHMgLyBsb2dpdHMgd2FzIHJhbmsgXCIrZS5yYW5rK1wiIGFuZCBkaW0gd2FzIFwiK24pO3JldHVybiB2bygoZnVuY3Rpb24odCxlLHIpe3ZhciBvPWUubG9nU3VtRXhwKFtuXSwhMCksYT1lLnRvRmxvYXQoKS5zdWIobyk7cihbdCxhXSk7cmV0dXJue3ZhbHVlOmEubXVsKHQpLm5lZygpLnN1bShbbl0pLGdyYWRGdW5jOmZ1bmN0aW9uKHQsZSl7dmFyIHI9ZVswXSxvPWVbMV0sYT13bih0LnNoYXBlLFtuXSk7cmV0dXJuW3QucmVzaGFwZShhKS5tdWwoci50b0Zsb2F0KCkuc3ViKG8uZXhwKCkpKSx0LnJlc2hhcGUoYSkubXVsKG8uZXhwKCkuc3ViKHIudG9GbG9hdCgpKSldfX19KSkodCxlKX0oYSxpKTtyZXR1cm4gZmgoaCxzLG8pfX0pLGJoPU9iamVjdC5mcmVlemUoe2dldCBSZWR1Y3Rpb24oKXtyZXR1cm4gY2h9LGFic29sdXRlRGlmZmVyZW5jZTpoaCxjb21wdXRlV2VpZ2h0ZWRMb3NzOmZoLGNvc2luZURpc3RhbmNlOmRoLGhpbmdlTG9zczpwaCxodWJlckxvc3M6dmgsbG9nTG9zczptaCxtZWFuU3F1YXJlZEVycm9yOmdoLHNpZ21vaWRDcm9zc0VudHJvcHk6eWgsc29mdG1heENyb3NzRW50cm9weTp4aH0pO2Z1bmN0aW9uIHdoKHQsZSl7cmV0dXJuIHZvaWQgMD09PWUmJihlPSExKSxMdC50aWR5KChmdW5jdGlvbigpe2lmKDIhPT10LnNoYXBlLmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJxcjJkKCkgcmVxdWlyZXMgYSAyRCBUZW5zb3IsIGJ1dCBnb3QgYSBcIit0LnNoYXBlLmxlbmd0aCtcIkQgVGVuc29yLlwiKTtmb3IodmFyIG49dC5zaGFwZVswXSxyPXQuc2hhcGVbMV0sbz1DcihuKSxhPXQuY2xvbmUoKSxpPUJuKFtbMV1dLFsxLDFdKSxzPWkuY2xvbmUoKSx1PW4+PXI/cjpuLGM9ZnVuY3Rpb24odCl7dmFyIGUsdT1hLGM9cyxsPW87ZT1MdC50aWR5KChmdW5jdGlvbigpe3ZhciBlPWEuc2xpY2UoW3QsdF0sW24tdCwxXSksdT1lLm5vcm0oKSxjPWEuc2xpY2UoW3QsdF0sWzEsMV0pLGw9Qm4oW1stMV1dKS53aGVyZShjLmdyZWF0ZXIoMCksQm4oW1sxXV0pKSxoPWMuc3ViKGwubXVsKHUpKSxmPWUuZGl2KGgpO3M9MT09PWYuc2hhcGVbMF0/aS5jbG9uZSgpOmkuY29uY2F0KGYuc2xpY2UoWzEsMF0sW2Yuc2hhcGVbMF0tMSxmLnNoYXBlWzFdXSksMCk7dmFyIGQ9bC5tYXRNdWwoaCkuZGl2KHUpLm5lZygpLHA9YS5zbGljZShbdCwwXSxbbi10LHJdKSx2PWQubXVsKHMpO2lmKDA9PT10KWE9cC5zdWIodi5tYXRNdWwocy50cmFuc3Bvc2UoKS5tYXRNdWwocCkpKTtlbHNle3ZhciBtPXAuc3ViKHYubWF0TXVsKHMudHJhbnNwb3NlKCkubWF0TXVsKHApKSk7YT1hLnNsaWNlKFswLDBdLFt0LHJdKS5jb25jYXQobSwwKX12YXIgZz1vLnNsaWNlKFswLHRdLFtuLG8uc2hhcGVbMV0tdF0pO2lmKDA9PT10KW89Zy5zdWIoZy5tYXRNdWwocykubWF0TXVsKHYudHJhbnNwb3NlKCkpKTtlbHNle3ZhciB5PWcuc3ViKGcubWF0TXVsKHMpLm1hdE11bCh2LnRyYW5zcG9zZSgpKSk7bz1vLnNsaWNlKFswLDBdLFtuLHRdKS5jb25jYXQoeSwxKX1yZXR1cm5bcyxhLG9dfSkpLHM9ZVswXSxhPWVbMV0sbz1lWzJdLHRuKFt1LGMsbF0pfSxsPTA7bDx1OysrbCljKGwpO3JldHVybiFlJiZuPnImJihvPW8uc2xpY2UoWzAsMF0sW24scl0pLGE9YS5zbGljZShbMCwwXSxbcixyXSkpLFtvLGFdfSkpfXZhciBDaD1Bbih7YmFuZFBhcnRfOmZ1bmN0aW9uKHQsZSxuKXtpZihlJTEhPTApdGhyb3cgbmV3IEVycm9yKFwiYmFuZFBhcnQoKTogbnVtTG93ZXIgbXVzdCBiZSBhbiBpbnRlZ2VyLCBnb3QgXCIrZStcIi5cIik7aWYobiUxIT0wKXRocm93IG5ldyBFcnJvcihcImJhbmRQYXJ0KCk6IG51bVVwcGVyIG11c3QgYmUgYW4gaW50ZWdlciwgZ290IFwiK24rXCIuXCIpO3ZhciByPW1uKHQsXCJhXCIsXCJiYW5kUGFydFwiKTtpZihyLnJhbms8Mil0aHJvdyBuZXcgRXJyb3IoXCJiYW5kUGFydCgpOiBSYW5rIG11c3QgYmUgYXQgbGVhc3QgMiwgZ290IFwiK3IucmFuaytcIi5cIik7dmFyIG89ci5zaGFwZSxhPXIuc2hhcGUuc2xpY2UoLTIpLGk9YVswXSxzPWFbMV07aWYoIShlPD1pKSl0aHJvdyBuZXcgRXJyb3IoXCJiYW5kUGFydCgpOiBudW1Mb3dlciAoXCIrZStcIikgbXVzdCBub3QgYmUgZ3JlYXRlciB0aGFuIHRoZSBudW1iZXIgb2Ygcm93cyAoXCIraStcIikuXCIpO2lmKCEobjw9cykpdGhyb3cgbmV3IEVycm9yKFwiYmFuZFBhcnQoKTogbnVtVXBwZXIgKFwiK24rXCIpIG11c3Qgbm90IGJlIGdyZWF0ZXIgdGhhbiB0aGUgbnVtYmVyIG9mIGNvbHVtbnMgKFwiK3MrXCIpLlwiKTtlPDAmJihlPWkpLG48MCYmKG49cyk7dmFyIHU9S24oMCxpLDEsXCJpbnQzMlwiKS5yZXNoYXBlKFstMSwxXSksYz1LbigwLHMsMSxcImludDMyXCIpLGw9Q2ModSxjKSxoPVF1KGwubGVzc0VxdWFsKE9uKCtlLFwiaW50MzJcIikpLGwuZ3JlYXRlckVxdWFsKE9uKC1uLFwiaW50MzJcIikpKSxmPUduKFtpLHNdLHIuZHR5cGUpO3JldHVybiBQcihVcihyLnJlc2hhcGUoWy0xLGksc10pKS5tYXAoKGZ1bmN0aW9uKHQpe3JldHVybiBlYyhoLHQsZil9KSkpLnJlc2hhcGUobyl9fSksRWg9QW4oe2dyYW1TY2htaWR0XzpmdW5jdGlvbih0KXt2YXIgZTtpZihBcnJheS5pc0FycmF5KHQpKXtlPSExLEMobnVsbCE9dCYmdC5sZW5ndGg+MCwoZnVuY3Rpb24oKXtyZXR1cm5cIkdyYW0tU2NobWlkdCBwcm9jZXNzOiBpbnB1dCBtdXN0IG5vdCBiZSBudWxsLCB1bmRlZmluZWQsIG9yIGVtcHR5XCJ9KSk7Zm9yKHZhciBuPXRbMF0uc2hhcGVbMF0scj1mdW5jdGlvbihlKXtDKHRbZV0uc2hhcGVbMF09PT1uLChmdW5jdGlvbigpe3JldHVyblwiR3JhbS1TY2htaWR0OiBOb24tdW5pcXVlIGxlbmd0aHMgZm91bmQgaW4gdGhlIGlucHV0IHZlY3RvcnM6IChcIit0W2VdLnNoYXBlWzBdK1wiIHZzLiBcIituK1wiKVwifSkpfSxvPTE7bzx0Lmxlbmd0aDsrK28pcihvKX1lbHNlIGU9ITAsdD10cih0LHQuc2hhcGVbMF0sMCkubWFwKChmdW5jdGlvbih0KXtyZXR1cm4gQnIodCxbMF0pfSkpO0ModC5sZW5ndGg8PXRbMF0uc2hhcGVbMF0sKGZ1bmN0aW9uKCl7cmV0dXJuXCJHcmFtLVNjaG1pZHQ6IE51bWJlciBvZiB2ZWN0b3JzIChcIit0Lmxlbmd0aCtcIikgZXhjZWVkcyBudW1iZXIgb2YgZGltZW5zaW9ucyAoXCIrdFswXS5zaGFwZVswXStcIikuXCJ9KSk7dmFyIGE9W10saT10LHM9ZnVuY3Rpb24odCl7YS5wdXNoKEx0LnRpZHkoKGZ1bmN0aW9uKCl7dmFyIGU9aVt0XTtpZih0PjApZm9yKHZhciBuPTA7bjx0Oysrbil7dmFyIHI9TmwoYVtuXS5tdWxTdHJpY3QoZSkpLm11bChhW25dKTtlPWUuc3ViKHIpfXJldHVybiBlLmRpdihWbChlLFwiZXVjbGlkZWFuXCIpKX0pKSl9O2ZvcihvPTA7bzx0Lmxlbmd0aDsrK28pcyhvKTtyZXR1cm4gZT9QcihhLDApOmF9fSksUmg9QW4oe3FyXzpmdW5jdGlvbih0LGUpe2lmKHZvaWQgMD09PWUmJihlPSExKSx0LnJhbms8Mil0aHJvdyBuZXcgRXJyb3IoXCJxcigpIHJlcXVpcmVzIGlucHV0IHRlbnNvciB0byBoYXZlIGEgcmFuayA+PSAyLCBidXQgZ290IHJhbmsgXCIrdC5yYW5rKTtpZigyPT09dC5yYW5rKXJldHVybiB3aCh0LGUpO3ZhciBuPXQuc2hhcGUuc2xpY2UoMCx0LnNoYXBlLmxlbmd0aC0yKS5yZWR1Y2UoKGZ1bmN0aW9uKHQsZSl7cmV0dXJuIHQqZX0pKSxyPVVyKHQucmVzaGFwZShbbix0LnNoYXBlW3Quc2hhcGUubGVuZ3RoLTJdLHQuc2hhcGVbdC5zaGFwZS5sZW5ndGgtMV1dKSwwKSxvPVtdLGE9W107cmV0dXJuIHIuZm9yRWFjaCgoZnVuY3Rpb24odCl7dmFyIG49d2godCxlKSxyPW5bMF0saT1uWzFdO28ucHVzaChyKSxhLnB1c2goaSl9KSksW1ByKG8sMCkucmVzaGFwZSh0LnNoYXBlKSxQcihhLDApLnJlc2hhcGUodC5zaGFwZSldfX0pLEloPU9iamVjdC5mcmVlemUoe2JhbmRQYXJ0OkNoLGdyYW1TY2htaWR0OkVoLHFyOlJofSk7ZnVuY3Rpb24ga2godCxlLG4scixvLGEpe251bGw9PXImJihyPS41KSxudWxsPT1vJiYobz1OdW1iZXIuTkVHQVRJVkVfSU5GSU5JVFkpLG51bGw9PWEmJihhPTApO3ZhciBpPXQuc2hhcGVbMF07cmV0dXJuIG49TWF0aC5taW4obixpKSxDKDA8PXImJnI8PTEsKGZ1bmN0aW9uKCl7cmV0dXJuXCJpb3VUaHJlc2hvbGQgbXVzdCBiZSBpbiBbMCwgMV0sIGJ1dCB3YXMgJ1wiK3IrXCInXCJ9KSksQygyPT09dC5yYW5rLChmdW5jdGlvbigpe3JldHVyblwiYm94ZXMgbXVzdCBiZSBhIDJEIHRlbnNvciwgYnV0IHdhcyBvZiByYW5rICdcIit0LnJhbmsrXCInXCJ9KSksQyg0PT09dC5zaGFwZVsxXSwoZnVuY3Rpb24oKXtyZXR1cm5cImJveGVzIG11c3QgaGF2ZSA0IGNvbHVtbnMsIGJ1dCAybmQgZGltZW5zaW9uIHdhcyBcIit0LnNoYXBlWzFdfSkpLEMoMT09PWUucmFuaywoZnVuY3Rpb24oKXtyZXR1cm5cInNjb3JlcyBtdXN0IGJlIGEgMUQgdGVuc29yXCJ9KSksQyhlLnNoYXBlWzBdPT09aSwoZnVuY3Rpb24oKXtyZXR1cm5cInNjb3JlcyBoYXMgaW5jb21wYXRpYmxlIHNoYXBlIHdpdGggYm94ZXMuIEV4cGVjdGVkIFwiK2krXCIsIGJ1dCB3YXMgXCIrZS5zaGFwZVswXX0pKSxDKDA8PWEmJmE8PTEsKGZ1bmN0aW9uKCl7cmV0dXJuXCJzb2Z0Tm1zU2lnbWEgbXVzdCBiZSBpbiBbMCwgMV0sIGJ1dCB3YXMgJ1wiK2ErXCInXCJ9KSkse21heE91dHB1dFNpemU6bixpb3VUaHJlc2hvbGQ6cixzY29yZVRocmVzaG9sZDpvLHNvZnRObXNTaWdtYTphfX12YXIgU2g9QW4oe3Jlc2l6ZUJpbGluZWFyXzpmdW5jdGlvbih0LGUsbil7dm9pZCAwPT09biYmKG49ITEpO3ZhciByPW1uKHQsXCJpbWFnZXNcIixcInJlc2l6ZUJpbGluZWFyXCIpO0MoMz09PXIucmFua3x8ND09PXIucmFuaywoZnVuY3Rpb24oKXtyZXR1cm5cIkVycm9yIGluIHJlc2l6ZUJpbGluZWFyOiB4IG11c3QgYmUgcmFuayAzIG9yIDQsIGJ1dCBnb3QgcmFuayBcIityLnJhbmsrXCIuXCJ9KSksQygyPT09ZS5sZW5ndGgsKGZ1bmN0aW9uKCl7cmV0dXJuXCJFcnJvciBpbiByZXNpemVCaWxpbmVhcjogbmV3IHNoYXBlIG11c3QgMkQsIGJ1dCBnb3Qgc2hhcGUgXCIrZStcIi5cIn0pKTt2YXIgbz1yLGE9ITE7Mz09PXIucmFuayYmKGE9ITAsbz1yLmFzNEQoMSxyLnNoYXBlWzBdLHIuc2hhcGVbMV0sci5zaGFwZVsyXSkpO3ZhciBpPWVbMF0scz1lWzFdLHU9THQucnVuS2VybmVsRnVuYygoZnVuY3Rpb24odCxlKXtyZXR1cm4gZShbb10pLHQucmVzaXplQmlsaW5lYXIobyxpLHMsbil9KSx7eDpvfSwoZnVuY3Rpb24odCxlKXtyZXR1cm57eDpmdW5jdGlvbigpe3JldHVybiBMdC5ydW5LZXJuZWxGdW5jKChmdW5jdGlvbihyKXtyZXR1cm4gci5yZXNpemVCaWxpbmVhckJhY2twcm9wKHQsZVswXSxuKX0pLHt9KX19fSksXCJSZXNpemVCaWxpbmVhclwiLHthbGlnbkNvcm5lcnM6bixuZXdIZWlnaHQ6aSxuZXdXaWR0aDpzfSk7cmV0dXJuIGE/dS5hczNEKHUuc2hhcGVbMV0sdS5zaGFwZVsyXSx1LnNoYXBlWzNdKTp1fX0pLEFoPUFuKHtyZXNpemVOZWFyZXN0TmVpZ2hib3JfOmZ1bmN0aW9uKHQsZSxuKXt2b2lkIDA9PT1uJiYobj0hMSk7dmFyIHI9bW4odCxcImltYWdlc1wiLFwicmVzaXplTmVhcmVzdE5laWdoYm9yXCIpO0MoMz09PXIucmFua3x8ND09PXIucmFuaywoZnVuY3Rpb24oKXtyZXR1cm5cIkVycm9yIGluIHJlc2l6ZU5lYXJlc3ROZWlnaGJvcjogeCBtdXN0IGJlIHJhbmsgMyBvciA0LCBidXQgZ290IHJhbmsgXCIrci5yYW5rK1wiLlwifSkpLEMoMj09PWUubGVuZ3RoLChmdW5jdGlvbigpe3JldHVyblwiRXJyb3IgaW4gcmVzaXplTmVhcmVzdE5laWdoYm9yOiBuZXcgc2hhcGUgbXVzdCAyRCwgYnV0IGdvdCBzaGFwZSBcIitlK1wiLlwifSkpLEMoXCJmbG9hdDMyXCI9PT1yLmR0eXBlfHxcImludDMyXCI9PT1yLmR0eXBlLChmdW5jdGlvbigpe3JldHVyblwiYGltYWdlc2AgbXVzdCBoYXZlIGBpbnQzMmAgb3IgYGZsb2F0MzJgIGFzIGR0eXBlXCJ9KSk7dmFyIG89cixhPSExOzM9PT1yLnJhbmsmJihhPSEwLG89ci5hczREKDEsci5zaGFwZVswXSxyLnNoYXBlWzFdLHIuc2hhcGVbMl0pKTt2YXIgaT1lWzBdLHM9ZVsxXSx1PUx0LnJ1bktlcm5lbEZ1bmMoKGZ1bmN0aW9uKHQsZSl7cmV0dXJuIGUoW29dKSx0LnJlc2l6ZU5lYXJlc3ROZWlnaGJvcihvLGkscyxuKX0pLHtiYXRjaEltYWdlczpvfSwoZnVuY3Rpb24odCxlKXtyZXR1cm57YmF0Y2hJbWFnZXM6ZnVuY3Rpb24oKXtyZXR1cm4gTHQucnVuS2VybmVsRnVuYygoZnVuY3Rpb24ocil7cmV0dXJuIHIucmVzaXplTmVhcmVzdE5laWdoYm9yQmFja3Byb3AodCxlWzBdLG4pfSkse30pfX19KSk7cmV0dXJuIGE/dS5hczNEKHUuc2hhcGVbMV0sdS5zaGFwZVsyXSx1LnNoYXBlWzNdKTp1fX0pLERoPUFuKHtub25NYXhTdXBwcmVzc2lvbl86ZnVuY3Rpb24odCxlLG4scixvKXt2b2lkIDA9PT1yJiYocj0uNSksdm9pZCAwPT09byYmKG89TnVtYmVyLk5FR0FUSVZFX0lORklOSVRZKTt2YXIgYT1tbih0LFwiYm94ZXNcIixcIm5vbk1heFN1cHByZXNzaW9uXCIpLGk9bW4oZSxcInNjb3Jlc1wiLFwibm9uTWF4U3VwcHJlc3Npb25cIikscz1raChhLGksbixyLG8pO249cy5tYXhPdXRwdXRTaXplLHI9cy5pb3VUaHJlc2hvbGQsbz1zLnNjb3JlVGhyZXNob2xkO3ZhciB1PXttYXhPdXRwdXRTaXplOm4saW91VGhyZXNob2xkOnIsc2NvcmVUaHJlc2hvbGQ6b307cmV0dXJuIEx0LnJ1bktlcm5lbEZ1bmMoKGZ1bmN0aW9uKHQpe3JldHVybiB0Lm5vbk1heFN1cHByZXNzaW9uKGEsaSxuLHIsbyl9KSx7Ym94ZXM6YSxzY29yZXM6aX0sbnVsbCxcIk5vbk1heFN1cHByZXNzaW9uVjNcIix1KX19KSxUaD1mdW5jdGlvbih0LGUsbyxhLGkpe3JldHVybiB2b2lkIDA9PT1hJiYoYT0uNSksdm9pZCAwPT09aSYmKGk9TnVtYmVyLk5FR0FUSVZFX0lORklOSVRZKSxuKHRoaXMsdm9pZCAwLHZvaWQgMCwoZnVuY3Rpb24oKXt2YXIgbixzLHUsYyxsLGgsZjtyZXR1cm4gcih0aGlzLChmdW5jdGlvbihyKXtzd2l0Y2goci5sYWJlbCl7Y2FzZSAwOnJldHVybiBuPW1uKHQsXCJib3hlc1wiLFwibm9uTWF4U3VwcHJlc3Npb25Bc3luY1wiKSxzPW1uKGUsXCJzY29yZXNcIixcIm5vbk1heFN1cHByZXNzaW9uQXN5bmNcIiksdT1raChuLHMsbyxhLGkpLG89dS5tYXhPdXRwdXRTaXplLGE9dS5pb3VUaHJlc2hvbGQsaT11LnNjb3JlVGhyZXNob2xkLFs0LFByb21pc2UuYWxsKFtuLmRhdGEoKSxzLmRhdGEoKV0pXTtjYXNlIDE6cmV0dXJuIGM9ci5zZW50KCksbD1jWzBdLGg9Y1sxXSxmPWpvKGwsaCxvLGEsaSksbiE9PXQmJm4uZGlzcG9zZSgpLHMhPT1lJiZzLmRpc3Bvc2UoKSxbMixmXX19KSl9KSl9LE5oPUFuKHtub25NYXhTdXBwcmVzc2lvbldpdGhTY29yZV86ZnVuY3Rpb24odCxlLG4scixvLGEpe3ZvaWQgMD09PXImJihyPS41KSx2b2lkIDA9PT1vJiYobz1OdW1iZXIuTkVHQVRJVkVfSU5GSU5JVFkpLHZvaWQgMD09PWEmJihhPTApO3ZhciBpPW1uKHQsXCJib3hlc1wiLFwibm9uTWF4U3VwcHJlc3Npb25cIikscz1tbihlLFwic2NvcmVzXCIsXCJub25NYXhTdXBwcmVzc2lvblwiKSx1PWtoKGkscyxuLHIsbyxhKSxjPXttYXhPdXRwdXRTaXplOm49dS5tYXhPdXRwdXRTaXplLGlvdVRocmVzaG9sZDpyPXUuaW91VGhyZXNob2xkLHNjb3JlVGhyZXNob2xkOm89dS5zY29yZVRocmVzaG9sZCxzb2Z0Tm1zU2lnbWE6YT11LnNvZnRObXNTaWdtYX0sbD1MdC5ydW5LZXJuZWwoXCJOb25NYXhTdXBwcmVzc2lvblY1XCIse2JveGVzOmksc2NvcmVzOnN9LGMpO3JldHVybntzZWxlY3RlZEluZGljZXM6bFswXSxzZWxlY3RlZFNjb3JlczpsWzFdfX19KSxGaD1mdW5jdGlvbih0LGUsbyxhLGkscyl7cmV0dXJuIHZvaWQgMD09PWEmJihhPS41KSx2b2lkIDA9PT1pJiYoaT1OdW1iZXIuTkVHQVRJVkVfSU5GSU5JVFkpLHZvaWQgMD09PXMmJihzPTApLG4odGhpcyx2b2lkIDAsdm9pZCAwLChmdW5jdGlvbigpe3ZhciBuLHUsYyxsLGgsZixkO3JldHVybiByKHRoaXMsKGZ1bmN0aW9uKHIpe3N3aXRjaChyLmxhYmVsKXtjYXNlIDA6cmV0dXJuIG49bW4odCxcImJveGVzXCIsXCJub25NYXhTdXBwcmVzc2lvbkFzeW5jXCIpLHU9bW4oZSxcInNjb3Jlc1wiLFwibm9uTWF4U3VwcHJlc3Npb25Bc3luY1wiKSxjPWtoKG4sdSxvLGEsaSxzKSxvPWMubWF4T3V0cHV0U2l6ZSxhPWMuaW91VGhyZXNob2xkLGk9Yy5zY29yZVRocmVzaG9sZCxzPWMuc29mdE5tc1NpZ21hLFs0LFByb21pc2UuYWxsKFtuLmRhdGEoKSx1LmRhdGEoKV0pXTtjYXNlIDE6cmV0dXJuIGw9ci5zZW50KCksaD1sWzBdLGY9bFsxXSxkPVhvKGgsZixvLGEsaSxzKSxuIT09dCYmbi5kaXNwb3NlKCksdSE9PWUmJnUuZGlzcG9zZSgpLFsyLGRdfX0pKX0pKX0sX2g9QW4oe2Nyb3BBbmRSZXNpemVfOmZ1bmN0aW9uKHQsZSxuLHIsbyxhKXt2YXIgaT1tbih0LFwiaW1hZ2VcIixcImNyb3BBbmRSZXNpemVcIikscz1tbihlLFwiYm94ZXNcIixcImNyb3BBbmRSZXNpemVcIixcImZsb2F0MzJcIiksdT1tbihuLFwiYm94SW5kXCIsXCJjcm9wQW5kUmVzaXplXCIsXCJpbnQzMlwiKTtvPW98fFwiYmlsaW5lYXJcIixhPWF8fDA7dmFyIGM9cy5zaGFwZVswXTtyZXR1cm4gQyg0PT09aS5yYW5rLChmdW5jdGlvbigpe3JldHVyblwiRXJyb3IgaW4gY3JvcEFuZFJlc2l6ZTogaW1hZ2UgbXVzdCBiZSByYW5rIDQsYnV0IGdvdCByYW5rIFwiK2kucmFuaytcIi5cIn0pKSxDKDI9PT1zLnJhbmsmJjQ9PT1zLnNoYXBlWzFdLChmdW5jdGlvbigpe3JldHVyblwiRXJyb3IgaW4gY3JvcEFuZFJlc2l6ZTogYm94ZXMgbXVzdCBiZSBoYXZlIHNpemUgW1wiK2MrXCIsNF0gYnV0IGhhZCBzaGFwZSBcIitzLnNoYXBlK1wiLlwifSkpLEMoMT09PXUucmFuayYmdS5zaGFwZVswXT09PWMsKGZ1bmN0aW9uKCl7cmV0dXJuXCJFcnJvciBpbiBjcm9wQW5kUmVzaXplOiBib3hJbmQgbXVzdCBiZSBoYXZlIHNpemUgW1wiK2MrXCJdIGJ1dCBoYWQgc2hhcGUgXCIrcy5zaGFwZStcIi5cIn0pKSxDKDI9PT1yLmxlbmd0aCwoZnVuY3Rpb24oKXtyZXR1cm5cIkVycm9yIGluIGNyb3BBbmRSZXNpemU6IGNyb3BTaXplIG11c3QgYmUgb2YgbGVuZ3RoIDIsIGJ1dCBnb3QgbGVuZ3RoIFwiK3IubGVuZ3RoK1wiLlwifSkpLEMoclswXT49MSYmclsxXT49MSwoZnVuY3Rpb24oKXtyZXR1cm5cImNyb3BTaXplIG11c3QgYmUgYXRsZWFzdCBbMSwxXSwgYnV0IHdhcyBcIityfSkpLEMoXCJiaWxpbmVhclwiPT09b3x8XCJuZWFyZXN0XCI9PT1vLChmdW5jdGlvbigpe3JldHVyblwibWV0aG9kIG11c3QgYmUgYmlsaW5lYXIgb3IgbmVhcmVzdCwgYnV0IHdhcyBcIitvfSkpLEx0LnJ1bktlcm5lbEZ1bmMoKGZ1bmN0aW9uKHQsZSl7cmV0dXJuIHQuY3JvcEFuZFJlc2l6ZShpLHMsdSxyLG8sYSl9KSx7aW1hZ2VzOmksYm94ZXM6cyxib3hJbmQ6dX0sbnVsbCxcIkNyb3BBbmRSZXNpemVcIix7bWV0aG9kOm8sZXh0cmFwb2xhdGlvblZhbHVlOmEsY3JvcFNpemU6cn0pfX0pLE9oPU9iamVjdC5mcmVlemUoe3Jlc2l6ZUJpbGluZWFyOlNoLHJlc2l6ZU5lYXJlc3ROZWlnaGJvcjpBaCxub25NYXhTdXBwcmVzc2lvbjpEaCxub25NYXhTdXBwcmVzc2lvbkFzeW5jOlRoLG5vbk1heFN1cHByZXNzaW9uV2l0aFNjb3JlOk5oLG5vbk1heFN1cHByZXNzaW9uV2l0aFNjb3JlQXN5bmM6RmgsY3JvcEFuZFJlc2l6ZTpfaH0pLE1oPWZ1bmN0aW9uKHQsZSl7cmV0dXJuISh0PjApfHxcImxpbmVhclwiPT09ZX0sQmg9ZnVuY3Rpb24odCxlLG4pe2lmKG51bGw9PW58fFwibGluZWFyXCI9PT1uKXJldHVybiB0O2lmKFwicmVsdVwiPT09bilyZXR1cm4gdC5tdWwoZS5zdGVwKCkpO3Rocm93IG5ldyBFcnJvcihcIkdyYWRpZW50IGZvciBhY3RpdmF0aW9uIFwiK24rXCIgaGFzIG5vdCBiZWVuIGltcGxlbWVudGVkIHlldC5cIil9LFBoPWZ1bmN0aW9uKHQsZSl7dmFyIG49ZSxyPUVvKHQuc2hhcGUsZS5zaGFwZSk7cmV0dXJuIHIubGVuZ3RoPjAmJihuPW4uc3VtKHIpKSxuLnJlc2hhcGUodC5zaGFwZSl9LExoPWZ1bmN0aW9uKHQsZSxuKXtpZihcImxpbmVhclwiPT09ZSlyZXR1cm4gdDtpZihcInJlbHVcIj09PWUpcmV0dXJuIEJsKHQpO2lmKFwiZWx1XCI9PT1lKXJldHVybiBfbCh0KTtpZihcInJlbHU2XCI9PT1lKXJldHVybiBQbCh0KTtpZihcInByZWx1XCI9PT1lKXJldHVybiBNbCh0LG4pO3Rocm93IG5ldyBFcnJvcihcIlVua25vd24gZnVzZWQgYWN0aXZhdGlvbiBcIitlK1wiLlwiKX07dmFyIFdoPUFuKHtmdXNlZE1hdE11bF86ZnVuY3Rpb24odCl7dmFyIGUsbj10LmEscj10LmIsbz10LnRyYW5zcG9zZUEsYT12b2lkIDAhPT1vJiZvLGk9dC50cmFuc3Bvc2VCLHM9dm9pZCAwIT09aSYmaSx1PXQuYmlhcyxjPXQuYWN0aXZhdGlvbixsPXZvaWQgMD09PWM/XCJsaW5lYXJcIjpjLGg9dC5wcmVsdUFjdGl2YXRpb25XZWlnaHRzO2lmKCExPT09TWgoTHQuc3RhdGUuZ3JhZGllbnREZXB0aCxsKSl7dmFyIGY9ZWwobixyLGEscyk7cmV0dXJuIG51bGwhPXUmJihmPXJjKGYsdSkpLExoKGYsbCxoKX12YXIgZD1tbihuLFwiYVwiLFwiZnVzZWQgbWF0TXVsXCIpLHA9bW4ocixcImJcIixcImZ1c2VkIG1hdE11bFwiKTtlPU50KGQscCksZD1lWzBdLHA9ZVsxXTt2YXIgdj1hP2Quc2hhcGVbZC5yYW5rLTJdOmQuc2hhcGVbZC5yYW5rLTFdLG09cz9wLnNoYXBlW3AucmFuay0xXTpwLnNoYXBlW3AucmFuay0yXSxnPWE/ZC5zaGFwZVtkLnJhbmstMV06ZC5zaGFwZVtkLnJhbmstMl0seT1zP3Auc2hhcGVbcC5yYW5rLTJdOnAuc2hhcGVbcC5yYW5rLTFdLHg9ZC5zaGFwZS5zbGljZSgwLC0yKSxiPXAuc2hhcGUuc2xpY2UoMCwtMiksdz1rKHgpLEU9ayhiKTtDKGQucmFuaz49MiYmcC5yYW5rPj0yJiZkLnJhbms9PT1wLnJhbmssKGZ1bmN0aW9uKCl7cmV0dXJuXCJFcnJvciBpbiBmdXNlZCBtYXRNdWw6IGlucHV0cyBtdXN0IGhhdmUgdGhlIHNhbWUgcmFuayBvZiBhdCBsZWFzdCAyLCBnb3QgcmFua3MgXCIrZC5yYW5rK1wiIGFuZCBcIitwLnJhbmsrXCIuXCJ9KSksQyhTKHgsYiksKGZ1bmN0aW9uKCl7cmV0dXJuXCJFcnJvciBpbiBmdXNlZCBtYXRNdWw6IG91dGVyIGRpbWVuc2lvbnMgKFwiK3grXCIpIGFuZCAoXCIrYitcIikgb2YgVGVuc29ycyB3aXRoIHNoYXBlcyBcIitkLnNoYXBlK1wiIGFuZCBcIitwLnNoYXBlK1wiIG11c3QgbWF0Y2guXCJ9KSksQyh2PT09bSwoZnVuY3Rpb24oKXtyZXR1cm5cIkVycm9yIGluIGZ1c2VkIG1hdE11bDogaW5uZXIgc2hhcGVzIChcIit2K1wiKSBhbmQgKFwiK20rXCIpIG9mIFRlbnNvcnMgd2l0aCBzaGFwZXMgXCIrZC5zaGFwZStcIiBhbmQgXCIrcC5zaGFwZStcIiBhbmQgdHJhbnNwb3NlQT1cIithK1wiIGFuZCB0cmFuc3Bvc2VCPVwiK3MrXCIgbXVzdCBtYXRjaC5cIn0pKTt2YXIgUixJLEE9ZC5zaGFwZS5zbGljZSgwLC0yKS5jb25jYXQoW2cseV0pLEQ9YT9kLmFzM0Qodyx2LGcpOmQuYXMzRCh3LGcsdiksVD1zP3AuYXMzRChFLHksbSk6cC5hczNEKEUsbSx5KTtudWxsIT11JiZSbyhBLChSPU50KFI9bW4odSxcImJpYXNcIixcImZ1c2VkIG1hdE11bFwiKSxkKVswXSkuc2hhcGUpLG51bGwhPWgmJihJPW1uKGgsXCJwcmVsdSB3ZWlnaHRzXCIsXCJmdXNlZCBtYXRNdWxcIikpO3ZhciBOPXthOkQsYjpUfTtudWxsIT11JiYoTi5iaWFzPVIpLG51bGwhPWgmJihOLnByZWx1QWN0aXZhdGlvbldlaWdodHM9SSk7dmFyIEY9W0QsVF07cmV0dXJuIEx0LnJ1bktlcm5lbEZ1bmMoKGZ1bmN0aW9uKHQsZSl7dmFyIG49dC5mdXNlZEJhdGNoTWF0TXVsKHthOkQsYjpULHRyYW5zcG9zZUE6YSx0cmFuc3Bvc2VCOnMsYmlhczpSLGFjdGl2YXRpb246bCxwcmVsdUFjdGl2YXRpb25XZWlnaHRzOkl9KTtyZXR1cm4gZShbRCxULG5dKSxufSksTiwoZnVuY3Rpb24odCxlKXt2YXIgbj1lWzBdLHI9ZVsxXSxvPWVbMl0saT1CaCh0LG8sbCksYz17fTtyZXR1cm4gbnVsbCE9dSYmKGM9e2JpYXM6ZnVuY3Rpb24oKXtyZXR1cm4gUGgoUixpKX19KSxhfHxzPyFhJiZzP09iamVjdC5hc3NpZ24oe2E6ZnVuY3Rpb24oKXtyZXR1cm4gaS5tYXRNdWwociwhMSwhMSl9LGI6ZnVuY3Rpb24oKXtyZXR1cm4gaS5tYXRNdWwobiwhMCwhMSl9fSxjKTphJiYhcz9PYmplY3QuYXNzaWduKHthOmZ1bmN0aW9uKCl7cmV0dXJuIHIubWF0TXVsKGksITEsITApfSxiOmZ1bmN0aW9uKCl7cmV0dXJuIG4ubWF0TXVsKGksITEsITEpfX0sYyk6T2JqZWN0LmFzc2lnbih7YTpmdW5jdGlvbigpe3JldHVybiByLm1hdE11bChpLCEwLCEwKX0sYjpmdW5jdGlvbigpe3JldHVybiBpLm1hdE11bChuLCEwLCEwKX19LGMpOk9iamVjdC5hc3NpZ24oe2E6ZnVuY3Rpb24oKXtyZXR1cm4gaS5tYXRNdWwociwhMSwhMCl9LGI6ZnVuY3Rpb24oKXtyZXR1cm4gbi5tYXRNdWwoaSwhMCwhMSl9fSxjKX0pLFwiX0Z1c2VkTWF0TXVsXCIse3RyYW5zcG9zZUE6YSx0cmFuc3Bvc2VCOnMsYWN0aXZhdGlvbjpsfSxGLFshMF0pLnJlc2hhcGUoQSl9fSksVWg9QW4oe2Z1c2VkQ29udjJkXzpmdW5jdGlvbih0KXt2YXIgZT10Lngsbj10LmZpbHRlcixyPXQuc3RyaWRlcyxvPXQucGFkLGE9dC5kYXRhRm9ybWF0LGk9dm9pZCAwPT09YT9cIk5IV0NcIjphLHM9dC5kaWxhdGlvbnMsdT12b2lkIDA9PT1zP1sxLDFdOnMsYz10LmRpbVJvdW5kaW5nTW9kZSxsPXQuYmlhcyxoPXQuYWN0aXZhdGlvbixmPXZvaWQgMD09PWg/XCJsaW5lYXJcIjpoLGQ9dC5wcmVsdUFjdGl2YXRpb25XZWlnaHRzO2lmKGY9Znx8XCJsaW5lYXJcIiwhMT09PU1oKEx0LnN0YXRlLmdyYWRpZW50RGVwdGgsZikpe3ZhciBwPXFjKGUsbixyLG8saSx1LGMpO3JldHVybiBudWxsIT1sJiYocD1yYyhwLGwpKSxMaChwLGYsZCl9dmFyIHY9bW4oZSxcInhcIixcImNvbnYyZFwiKSxtPW1uKG4sXCJmaWx0ZXJcIixcImNvbnYyZFwiKSxnPXYseT0hMTszPT09di5yYW5rJiYoeT0hMCxnPXYuYXM0RCgxLHYuc2hhcGVbMF0sdi5zaGFwZVsxXSx2LnNoYXBlWzJdKSksQyg0PT09Zy5yYW5rLChmdW5jdGlvbigpe3JldHVyblwiRXJyb3IgaW4gZnVzZWQgY29udjJkOiBpbnB1dCBtdXN0IGJlIHJhbmsgNCwgYnV0IGdvdCByYW5rIFwiK2cucmFuaytcIi5cIn0pKSxDKDQ9PT1tLnJhbmssKGZ1bmN0aW9uKCl7cmV0dXJuXCJFcnJvciBpbiBmdXNlZCBjb252MmQ6IGZpbHRlciBtdXN0IGJlIHJhbmsgNCwgYnV0IGdvdCByYW5rIFwiK20ucmFuaytcIi5cIn0pKSxudWxsIT1jJiZDKEEobyksKGZ1bmN0aW9uKCl7cmV0dXJuXCJFcnJvciBpbiBmdXNlZCBjb252MmQ6IHBhZCBtdXN0IGJlIGFuIGludGVnZXIgd2hlbiB1c2luZywgZGltUm91bmRpbmdNb2RlIFwiK2MrXCIgYnV0IGdvdCBwYWQgXCIrbytcIi5cIn0pKSxDKGcuc2hhcGVbM109PT1tLnNoYXBlWzJdLChmdW5jdGlvbigpe3JldHVyblwiRXJyb3IgaW4gY29udjJkOiBkZXB0aCBvZiBpbnB1dCAoXCIrZy5zaGFwZVszXStcIikgbXVzdCBtYXRjaCBpbnB1dCBkZXB0aCBmb3IgZmlsdGVyIFwiK20uc2hhcGVbMl0rXCIuXCJ9KSksQyhNbyhyLHUpLChmdW5jdGlvbigpe3JldHVyblwiRXJyb3IgaW4gY29udjJEOiBFaXRoZXIgc3RyaWRlcyBvciBkaWxhdGlvbnMgbXVzdCBiZSAxLiBHb3Qgc3RyaWRlcyBcIityK1wiIGFuZCBkaWxhdGlvbnMgJ1wiK3UrXCInXCJ9KSksQyhcIk5IV0NcIj09PWksKGZ1bmN0aW9uKCl7cmV0dXJuXCJFcnJvciBpbiBjb252MmQ6IGdvdCBkYXRhRm9ybWF0IG9mIFwiK2krXCIgYnV0IG9ubHkgTkhXQyBpcyBjdXJyZW50bHkgc3VwcG9ydGVkLlwifSkpO3ZhciB4LGIsdz1TbyhnLnNoYXBlLG0uc2hhcGUscix1LG8sYyk7bnVsbCE9bCYmKHg9TnQoeD1tbihsLFwiYmlhc1wiLFwiZnVzZWQgY29udjJkXCIpLHYpWzBdLFJvKHcub3V0U2hhcGUseC5zaGFwZSkpLG51bGwhPWQmJihiPW1uKGQsXCJwcmVsdSB3ZWlnaHRzXCIsXCJmdXNlZCBjb252MmRcIikpO3ZhciBFPXt4OmcsZmlsdGVyOm19O251bGwhPWwmJihFLmJpYXM9eCksbnVsbCE9ZCYmKEUucHJlbHVBY3RpdmF0aW9uV2VpZ2h0cz1iKTt2YXIgUj1bbSxnXSxJPUx0LnJ1bktlcm5lbEZ1bmMoKGZ1bmN0aW9uKHQsZSl7dmFyIG49dC5mdXNlZENvbnYyZCh7aW5wdXQ6ZyxmaWx0ZXI6bSxjb252SW5mbzp3LGJpYXM6eCxhY3RpdmF0aW9uOmYscHJlbHVBY3RpdmF0aW9uV2VpZ2h0czpifSk7cmV0dXJuIGUoW20sZyxuXSksbn0pLEUsKGZ1bmN0aW9uKHQsZSl7dmFyIG49ZSxhPW5bMF0saT1uWzFdLHM9blsyXSxjPUJoKHQscyxmKTtDKE9vKHUpLChmdW5jdGlvbigpe3JldHVyblwiRXJyb3IgaW4gZ3JhZGllbnQgb2YgZnVzZWQgY29udjJEOiBkaWxhdGlvbiByYXRlcyBncmVhdGVyIHRoYW4gMSBhcmUgbm90IHlldCBzdXBwb3J0ZWQgaW4gZ3JhZGllbnRzLiBHb3QgZGlsYXRpb25zICdcIit1K1wiJ1wifSkpO3ZhciBoPXt9O3JldHVybiBudWxsIT1sJiYoaD17YmlhczpmdW5jdGlvbigpe3JldHVybiBQaCh4LGMpfX0pLE9iamVjdC5hc3NpZ24oe3g6ZnVuY3Rpb24oKXtyZXR1cm4gWGMoaS5zaGFwZSxjLGEscixvKX0sZmlsdGVyOmZ1bmN0aW9uKCl7cmV0dXJuIGpjKGksYyxhLnNoYXBlLHIsbyl9fSxoKX0pLFwiRnVzZWRDb252MkRcIix7Y29udkluZm86dyxhY3RpdmF0aW9uOmZ9LFIsWyEwXSk7cmV0dXJuIHk/SS5hczNEKEkuc2hhcGVbMV0sSS5zaGFwZVsyXSxJLnNoYXBlWzNdKTpJfX0pLFZoPUFuKHtmdXNlZERlcHRod2lzZUNvbnYyZF86ZnVuY3Rpb24odCl7dmFyIGU9dC54LG49dC5maWx0ZXIscj10LnN0cmlkZXMsbz10LnBhZCxhPXQuZGF0YUZvcm1hdCxpPXZvaWQgMD09PWE/XCJOSFdDXCI6YSxzPXQuZGlsYXRpb25zLHU9dm9pZCAwPT09cz9bMSwxXTpzLGM9dC5kaW1Sb3VuZGluZ01vZGUsbD10LmJpYXMsaD10LmFjdGl2YXRpb24sZj12b2lkIDA9PT1oP1wibGluZWFyXCI6aCxkPXQucHJlbHVBY3RpdmF0aW9uV2VpZ2h0cztpZighMT09PU1oKEx0LnN0YXRlLmdyYWRpZW50RGVwdGgsZikpe3ZhciBwPVljKGUsbixyLG8saSx1LGMpO3JldHVybiBudWxsIT1sJiYocD1yYyhwLGwpKSxMaChwLGYsZCl9dmFyIHY9bW4oZSxcInhcIixcImRlcHRod2lzZUNvbnYyZFwiKSxtPW1uKG4sXCJmaWx0ZXJcIixcImRlcHRod2lzZUNvbnYyZFwiKSxnPXYseT0hMTszPT09di5yYW5rJiYoeT0hMCxnPXYuYXM0RCgxLHYuc2hhcGVbMF0sdi5zaGFwZVsxXSx2LnNoYXBlWzJdKSksQyg0PT09Zy5yYW5rLChmdW5jdGlvbigpe3JldHVyblwiRXJyb3IgaW4gZnVzZWQgZGVwdGh3aXNlQ29udjJkOiBpbnB1dCBtdXN0IGJlIHJhbmsgNCwgYnV0IGdvdCByYW5rIFwiK2cucmFuaytcIi5cIn0pKSxDKDQ9PT1tLnJhbmssKGZ1bmN0aW9uKCl7cmV0dXJuXCJFcnJvciBpbiBmdXNlZCBkZXB0aHdpc2VDb252MmQ6IGZpbHRlciBtdXN0IGJlIHJhbmsgNCwgYnV0IGdvdCByYW5rIFwiK20ucmFuaytcIi5cIn0pKSxDKGcuc2hhcGVbM109PT1tLnNoYXBlWzJdLChmdW5jdGlvbigpe3JldHVyblwiRXJyb3IgaW4gZnVzZWQgZGVwdGh3aXNlQ29udjJkOiBudW1iZXIgb2YgaW5wdXQgY2hhbm5lbHMgKFwiK2cuc2hhcGVbM10rXCIpIG11c3QgbWF0Y2ggdGhlIGluQ2hhbm5lbHMgZGltZW5zaW9uIGluIGZpbHRlciBcIittLnNoYXBlWzJdK1wiLlwifSkpLG51bGw9PXUmJih1PVsxLDFdKSxDKE1vKHIsdSksKGZ1bmN0aW9uKCl7cmV0dXJuXCJFcnJvciBpbiBmdXNlZCBkZXB0aHdpc2VDb252MmQ6IEVpdGhlciBzdHJpZGVzIG9yIGRpbGF0aW9ucyBtdXN0IGJlIDEuIEdvdCBzdHJpZGVzIFwiK3IrXCIgYW5kIGRpbGF0aW9ucyAnXCIrdStcIidcIn0pKSxudWxsIT1jJiZDKEEobyksKGZ1bmN0aW9uKCl7cmV0dXJuXCJFcnJvciBpbiBmdXNlZCBkZXB0aHdpc2VDb252MmQ6IHBhZCBtdXN0IGJlIGFuIGludGVnZXIgd2hlbiB1c2luZyBkaW1Sb3VuZGluZ01vZGUgXCIrYytcIiBidXQgZ290IHBhZCBcIitvK1wiLlwifSkpO3ZhciB4LGIsdz1TbyhnLnNoYXBlLG0uc2hhcGUscix1LG8sYywhMCk7bnVsbCE9bCYmKHg9TnQoeD1tbihsLFwiYmlhc1wiLFwiZnVzZWQgY29udjJkXCIpLHYpWzBdLFJvKHcub3V0U2hhcGUseC5zaGFwZSkpLG51bGwhPWQmJihiPW1uKGQsXCJwcmVsdSB3ZWlnaHRzXCIsXCJmdXNlZCBkZXB0aHdpc2VDb252MmRcIikpO3ZhciBFPXt4OmcsZmlsdGVyOm19O251bGwhPWwmJihFLmJpYXM9eCksbnVsbCE9ZCYmKEUucHJlbHVBY3RpdmF0aW9uV2VpZ2h0cz1iKTt2YXIgUj1bbSxnXSxJPUx0LnJ1bktlcm5lbEZ1bmMoKGZ1bmN0aW9uKHQsZSl7dmFyIG49dC5mdXNlZERlcHRod2lzZUNvbnYyRCh7aW5wdXQ6ZyxmaWx0ZXI6bSxjb252SW5mbzp3LGJpYXM6eCxhY3RpdmF0aW9uOmYscHJlbHVBY3RpdmF0aW9uV2VpZ2h0czpifSk7cmV0dXJuIGUoW20sZyxuXSksbn0pLEUsKGZ1bmN0aW9uKHQsZSl7QyhPbyh1KSwoZnVuY3Rpb24oKXtyZXR1cm5cIkVycm9yIGluIGdyYWRpZW50IG9mIGZ1c2VkIGRlcHRod2lzZUNvbnYyZDogZGlsYXRpb24gcmF0ZXMgZ3JlYXRlciB0aGFuIDEgYXJlIG5vdCB5ZXQgc3VwcG9ydGVkLiBHb3QgZGlsYXRpb25zICdcIit1K1wiJ1wifSkpO3ZhciBuPWVbMF0scj1lWzFdLG89ZVsyXSxhPUJoKHQsbyxmKSxpPXt9O3JldHVybiBudWxsIT1sJiYoaT17YmlhczpmdW5jdGlvbigpe3JldHVybiBQaCh4LGEpfX0pLE9iamVjdC5hc3NpZ24oe3g6ZnVuY3Rpb24oKXtyZXR1cm4gJGMoci5zaGFwZSxhLG4sdyl9LGZpbHRlcjpmdW5jdGlvbigpe3JldHVybiBRYyhyLGEsbi5zaGFwZSx3KX19LGkpfSksXCJGdXNlZERlcHRod2lzZUNvbnYyRFwiLHtjb252SW5mbzp3LGFjdGl2YXRpb246Zn0sUixbITBdKTtyZXR1cm4geT9JLmFzM0QoSS5zaGFwZVsxXSxJLnNoYXBlWzJdLEkuc2hhcGVbM10pOkl9fSksemg9T2JqZWN0LmZyZWV6ZSh7bWF0TXVsOldoLGNvbnYyZDpVaCxkZXB0aHdpc2VDb252MmQ6Vmh9KSxHaD1PYmplY3QuZnJlZXplKHtpbWFnZTpPaCxsaW5hbGc6SWgsbG9zc2VzOmJoLHNwZWN0cmFsOkpsLGZ1c2VkOnpoLHNpZ25hbDp1aCxzcXVhcmU6dHUsc3F1YXJlZERpZmZlcmVuY2U6bnUsY29udjFkOkhjLGNvbnYyZDpxYyxjb252M2Q6S2MsZGVwdGh3aXNlQ29udjJkOlljLHNlcGFyYWJsZUNvbnYyZDpKYyxjb252MmRUcmFuc3Bvc2U6WmMsY29udjNkVHJhbnNwb3NlOnRsLG9wOkFuLGJhdGNoTm9ybWFsaXphdGlvbjJkOkd1LGJhdGNoTm9ybWFsaXphdGlvbjNkOkh1LGJhdGNoTm9ybWFsaXphdGlvbjRkOnF1LGJhdGNoTm9ybWFsaXphdGlvbjpLdSxiYXRjaE5vcm06anUsYmF0Y2hOb3JtMmQ6WHUsYmF0Y2hOb3JtM2Q6WXUsYmF0Y2hOb3JtNGQ6JHUsYm9vbGVhbk1hc2tBc3luYzpVYyxjb21wbGV4OkRuLHJlYWw6VG4saW1hZzpObixjb25jYXQ6WW4sY29uY2F0MWQ6JG4sY29uY2F0MmQ6UW4sY29uY2F0M2Q6Sm4sY29uY2F0NGQ6Wm4sc3BsaXQ6dHIsbWF0TXVsOmVsLGRvdDpubCxvdXRlclByb2R1Y3Q6cmwscmV2ZXJzZTpvbCxyZXZlcnNlMWQ6YWwscmV2ZXJzZTJkOmlsLHJldmVyc2UzZDpzbCxyZXZlcnNlNGQ6dWwsbWF4UG9vbDpobCxhdmdQb29sOmZsLHBvb2w6ZGwsbWF4UG9vbDNkOnBsLGF2Z1Bvb2wzZDp2bCxzbGljZTptbCxzbGljZTFkOmdsLHNsaWNlMmQ6eWwsc2xpY2UzZDp4bCxzbGljZTRkOmJsLGFiczpydSxhY29zOm91LGFjb3NoOmF1LGFzaW46aXUsYXNpbmg6c3UsYXRhbjp1dSxhdGFuaDpjdSxjZWlsOmx1LGNsaXBCeVZhbHVlOmh1LGNvczpmdSxjb3NoOmR1LGVyZjpwdSxleHA6dnUsZXhwbTE6bXUsZmxvb3I6Z3UsbG9nOnl1LGxvZzFwOnh1LGxvZ1NpZ21vaWQ6YnUsbmVnOnd1LHJlY2lwcm9jYWw6Q3Uscm91bmQ6RXUscnNxcnQ6UnUsc2lnbW9pZDpJdSxzaWduOmt1LGlzTmFOOlN1LGlzSW5mOkF1LGlzRmluaXRlOkR1LHNpbjpUdSxzaW5oOk51LHNvZnRwbHVzOkZ1LHNxcnQ6X3Usc3RlcDpPdSx0YW46TXUsdGFuaDpCdSxhbGw6Q2wsYW55OkVsLGFyZ01heDpSbCxhcmdNaW46SWwsbG9nU3VtRXhwOmtsLG1heDpTbCxtZWFuOkFsLG1pbjpEbCxtb21lbnRzOlRsLHN1bTpObCxwcm9kOkZsLGVxdWFsOlJjLGVxdWFsU3RyaWN0OkljLGdyZWF0ZXI6a2MsZ3JlYXRlckVxdWFsOlNjLGdyZWF0ZXJFcXVhbFN0cmljdDpBYyxncmVhdGVyU3RyaWN0OkRjLGxlc3M6VGMsbGVzc0VxdWFsOk5jLGxlc3NFcXVhbFN0cmljdDpGYyxsZXNzU3RyaWN0Ol9jLG5vdEVxdWFsOk9jLG5vdEVxdWFsU3RyaWN0Ok1jLGFkZDpyYyxhZGROOm9jLGFkZFN0cmljdDphYyxhdGFuMjppYyxkaXY6c2MsZGl2Tm9OYW46dWMsZGl2U3RyaWN0OmNjLGZsb29yRGl2OmxjLG1heGltdW06aGMsbWF4aW11bVN0cmljdDpmYyxtaW5pbXVtOmRjLG1pbmltdW1TdHJpY3Q6cGMsbW9kOnZjLG1vZFN0cmljdDptYyxtdWw6Z2MsbXVsU3RyaWN0OnljLHBvdzp4Yyxwb3dTdHJpY3Q6YmMsc3F1YXJlZERpZmZlcmVuY2VTdHJpY3Q6d2Msc3ViOkNjLHN1YlN0cmljdDpFYyxlbHU6X2wsbGVha3lSZWx1Ok9sLHByZWx1Ok1sLHJlbHU6QmwscmVsdTY6UGwsc2VsdTpMbCxsb2dpY2FsQW5kOlF1LGxvZ2ljYWxOb3Q6SnUsbG9naWNhbE9yOlp1LGxvZ2ljYWxYb3I6dGMsd2hlcmU6ZWMsd2hlcmVBc3luYzpuYyxidWZmZXI6ZHIscHJpbnQ6cHIsYmF0Y2hUb1NwYWNlTkQ6dnIsYnJvYWRjYXN0VG86bXIsY2FzdDpncixjbG9uZTp5cixjdW1zdW06eHIsZGVwdGhUb1NwYWNlOmJyLGV4cGFuZERpbXM6d3IsZXllOkNyLG11bHRpbm9taWFsOkVyLG9uZUhvdDpScixwYWQ6SXIscGFkMWQ6a3IscGFkMmQ6U3IscGFkM2Q6QXIscGFkNGQ6RHIscmFuZDpUcixyYW5kb21Ob3JtYWw6TnIscmFuZG9tR2FtbWE6RnIscmFuZG9tVW5pZm9ybTpfcixyZXNoYXBlOk9yLHNwYWNlVG9CYXRjaE5EOk1yLHNxdWVlemU6QnIsc3RhY2s6UHIsdGlsZTpMcix0cnVuY2F0ZWROb3JtYWw6V3IsdW5zdGFjazpVcixzZXRkaWZmMWRBc3luYzpWcixmaWxsOkhuLGxpbnNwYWNlOnFuLG9uZXM6em4scmFuZ2U6S24sc2NhbGFyOk9uLHRlbnNvcjpGbix0ZW5zb3IxZDpNbix0ZW5zb3IyZDpCbix0ZW5zb3IzZDpQbix0ZW5zb3I0ZDpMbix0ZW5zb3I1ZDpXbix0ZW5zb3I2ZDpVbix2YXJpYWJsZTpWbix6ZXJvczpHbixvbmVzTGlrZTpqbix6ZXJvc0xpa2U6WG4sdHJhbnNwb3NlOldsLHNvZnRtYXg6Z28sbG9nU29mdG1heDp5byxsb2NhbFJlc3BvbnNlTm9ybWFsaXphdGlvbjpVbCxub3JtOlZsLGdhdGhlcjpMYyx1bnNvcnRlZFNlZ21lbnRTdW06V2MsYmFzaWNMU1RNQ2VsbDp6bCxtdWx0aVJOTkNlbGw6R2wsbW92aW5nQXZlcmFnZTpIbCxzdHJpZGVkU2xpY2U6cWwsdG9wazpLbCxzY2F0dGVyTkQ6amwsZmZ0OlhsLGlmZnQ6WWwscmZmdDokbCxpcmZmdDpRbCxzcGFyc2VUb0RlbnNlOlpsLGdhdGhlck5EOnRoLGRpYWc6ZWgsZHJvcG91dDpuaCxoYW5uV2luZG93Om9oLGhhbW1pbmdXaW5kb3c6YWgsZnJhbWU6aWgsc3RmdDpzaCxpblRvcEtBc3luYzpsaH0pO2Z1bmN0aW9uIEhoKHQsZSl7QXJyYXkuaXNBcnJheSh0KXx8KHQ9W3RdKSx0LmZvckVhY2goKGZ1bmN0aW9uKHQpe251bGwhPXQmJkMoXCJjb21wbGV4NjRcIiE9PXQuZHR5cGUsKGZ1bmN0aW9uKCl7cmV0dXJuIGUrXCIgZG9lcyBub3Qgc3VwcG9ydCBjb21wbGV4NjQgdGVuc29ycy5cIn0pKX0pKX1mdW5jdGlvbiBxaCh0LGUsbixyKXtpZihcImxpbmVhclwiPT09bilyZXR1cm4gdC5saW5lYXIoZSk7aWYoXCJyZWx1XCI9PT1uKXJldHVybiB0LnJlbHUoZSk7aWYoXCJlbHVcIj09PW4pcmV0dXJuIHQuZWx1KGUpO2lmKFwicmVsdTZcIj09PW4pcmV0dXJuIHQucmVsdTYoZSk7aWYoXCJwcmVsdVwiPT09bilyZXR1cm4gdC5wcmVsdShlLHIpO3Rocm93IG5ldyBFcnJvcihcIkFjdGl2YXRpb24gXCIrbitcIiBoYXMgbm90IGJlZW4gaW1wbGVtZW50ZWQgZm9yIHRoZSBDUFUgYmFja2VuZC5cIil9dmFyIEtoPWZ1bmN0aW9uKHQpe2Z1bmN0aW9uIG8oKXt2YXIgZT10LmNhbGwodGhpcyl8fHRoaXM7cmV0dXJuIGUuYmxvY2tTaXplPTQ4LGUuZmlyc3RVc2U9ITAsZS5kYXRhPW5ldyB4byhlLEx0KSxlfXJldHVybiBlKG8sdCksby5wcm90b3R5cGUud3JpdGU9ZnVuY3Rpb24odCxlLG4pe3RoaXMuZmlyc3RVc2UmJih0aGlzLmZpcnN0VXNlPSExLGkoKS5nZXQoXCJJU19OT0RFXCIpJiZkbihcIlxcbj09PT09PT09PT09PT09PT09PT09PT09PT09PT1cXG5IaSB0aGVyZSDwn5GLLiBMb29rcyBsaWtlIHlvdSBhcmUgcnVubmluZyBUZW5zb3JGbG93LmpzIGluIE5vZGUuanMuIFRvIHNwZWVkIHRoaW5ncyB1cCBkcmFtYXRpY2FsbHksIGluc3RhbGwgb3VyIG5vZGUgYmFja2VuZCwgd2hpY2ggYmluZHMgdG8gVGVuc29yRmxvdyBDKyssIGJ5IHJ1bm5pbmcgbnBtIGkgQHRlbnNvcmZsb3cvdGZqcy1ub2RlLCBvciBucG0gaSBAdGVuc29yZmxvdy90ZmpzLW5vZGUtZ3B1IGlmIHlvdSBoYXZlIENVREEuIFRoZW4gY2FsbCByZXF1aXJlKCdAdGVuc29yZmxvdy90ZmpzLW5vZGUnKTsgKC1ncHUgc3VmZml4IGZvciBDVURBKSBhdCB0aGUgc3RhcnQgb2YgeW91ciBwcm9ncmFtLiBWaXNpdCBodHRwczovL2dpdGh1Yi5jb20vdGVuc29yZmxvdy90ZmpzLW5vZGUgZm9yIG1vcmUgZGV0YWlscy5cXG49PT09PT09PT09PT09PT09PT09PT09PT09PT09XCIpKTt2YXIgcj17fTtyZXR1cm4gdGhpcy5kYXRhLnNldChyLHt2YWx1ZXM6dCxkdHlwZTpufSkscn0sby5wcm90b3R5cGUubW92ZT1mdW5jdGlvbih0LGUsbixyKXt0aGlzLmRhdGEuc2V0KHQse3ZhbHVlczplLGR0eXBlOnJ9KX0sby5wcm90b3R5cGUubnVtRGF0YUlkcz1mdW5jdGlvbigpe3JldHVybiB0aGlzLmRhdGEubnVtRGF0YUlkcygpfSxvLnByb3RvdHlwZS5yZWFkPWZ1bmN0aW9uKHQpe3JldHVybiBuKHRoaXMsdm9pZCAwLHZvaWQgMCwoZnVuY3Rpb24oKXtyZXR1cm4gcih0aGlzLChmdW5jdGlvbihlKXtyZXR1cm5bMix0aGlzLnJlYWRTeW5jKHQpXX0pKX0pKX0sby5wcm90b3R5cGUucmVhZFN5bmM9ZnVuY3Rpb24odCl7dmFyIGU9dGhpcy5kYXRhLmdldCh0KSxuPWUuZHR5cGUscj1lLmNvbXBsZXhUZW5zb3JzO3JldHVyblwiY29tcGxleDY0XCI9PT1uP1ZvKHRoaXMucmVhZFN5bmMoci5yZWFsLmRhdGFJZCksdGhpcy5yZWFkU3luYyhyLmltYWcuZGF0YUlkKSk6dGhpcy5kYXRhLmdldCh0KS52YWx1ZXN9LG8ucHJvdG90eXBlLmJ1ZmZlclN5bmM9ZnVuY3Rpb24odCl7dmFyIGU9dGhpcy5yZWFkU3luYyh0LmRhdGFJZCksbj1lO2lmKFwic3RyaW5nXCI9PT10LmR0eXBlKXRyeXtuPWUubWFwKChmdW5jdGlvbih0KXtyZXR1cm4gb3QodCl9KSl9Y2F0Y2godCl7dGhyb3cgbmV3IEVycm9yKFwiRmFpbGVkIHRvIGRlY29kZSBlbmNvZGVkIHN0cmluZyBieXRlcyBpbnRvIHV0Zi04XCIpfXJldHVybiBkcih0LnNoYXBlLHQuZHR5cGUsbil9LG8ucHJvdG90eXBlLm1ha2VPdXRwdXQ9ZnVuY3Rpb24odCxlLG4pe3ZhciByPXRoaXMud3JpdGUodCxlLG4pO3JldHVybiBMdC5tYWtlVGVuc29yRnJvbURhdGFJZChyLGUsbix0aGlzKX0sby5wcm90b3R5cGUuZGlzcG9zZURhdGE9ZnVuY3Rpb24odCl7aWYodGhpcy5kYXRhLmhhcyh0KSl7dmFyIGU9dGhpcy5kYXRhLmdldCh0KS5jb21wbGV4VGVuc29ycztudWxsIT1lJiYoZS5yZWFsLmRpc3Bvc2UoKSxlLmltYWcuZGlzcG9zZSgpKSx0aGlzLmRhdGEuZGVsZXRlKHQpfX0sby5wcm90b3R5cGUudGltZT1mdW5jdGlvbih0KXtyZXR1cm4gbih0aGlzLHZvaWQgMCx2b2lkIDAsKGZ1bmN0aW9uKCl7dmFyIGU7cmV0dXJuIHIodGhpcywoZnVuY3Rpb24obil7cmV0dXJuIGU9ZXQoKSx0KCksWzIse2tlcm5lbE1zOmV0KCktZX1dfSkpfSkpfSxvLnByb3RvdHlwZS5tZW1vcnk9ZnVuY3Rpb24oKXtyZXR1cm57dW5yZWxpYWJsZTohMCxyZWFzb25zOltcIlRoZSByZXBvcnRlZCBtZW1vcnkgaXMgYW4gdXBwZXIgYm91bmQuIER1ZSB0byBhdXRvbWF0aWMgZ2FyYmFnZSBjb2xsZWN0aW9uLCB0aGUgdHJ1ZSBhbGxvY2F0ZWQgbWVtb3J5IG1heSBiZSBsZXNzLlwiXX19LG8ucHJvdG90eXBlLmNvbXBsZXg9ZnVuY3Rpb24odCxlKXt2YXIgbj10aGlzLm1ha2VPdXRwdXQobnVsbCx0LnNoYXBlLFwiY29tcGxleDY0XCIpO3JldHVybiB0aGlzLmRhdGEuZ2V0KG4uZGF0YUlkKS5jb21wbGV4VGVuc29ycz17cmVhbDpMdC5rZWVwKHQuY2xvbmUoKSksaW1hZzpMdC5rZWVwKGUuY2xvbmUoKSl9LG59LG8ucHJvdG90eXBlLnJlYWw9ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMuZGF0YS5nZXQodC5kYXRhSWQpLmNvbXBsZXhUZW5zb3JzLnJlYWwuY2xvbmUoKX0sby5wcm90b3R5cGUuaW1hZz1mdW5jdGlvbih0KXtyZXR1cm4gdGhpcy5kYXRhLmdldCh0LmRhdGFJZCkuY29tcGxleFRlbnNvcnMuaW1hZy5jbG9uZSgpfSxvLnByb3RvdHlwZS5zbGljZT1mdW5jdGlvbih0LGUsbil7aWYoSGgodCxcInNsaWNlXCIpLGlvKHQuc2hhcGUsZSxuKSl7dmFyIHI9c28oZSx0LnN0cmlkZXMpLG89ayhuKTtyZXR1cm4gRm4odGhpcy5yZWFkU3luYyh0LmRhdGFJZCkuc3ViYXJyYXkocixyK28pLG4sdC5kdHlwZSl9Zm9yKHZhciBhPWRyKG4sdC5kdHlwZSksaT10aGlzLmJ1ZmZlclN5bmModCkscz0wO3M8YS5zaXplOysrcyl7dmFyIHU9YS5pbmRleFRvTG9jKHMpLm1hcCgoZnVuY3Rpb24odCxuKXtyZXR1cm4gdCtlW25dfSkpO2EudmFsdWVzW3NdPWkuZ2V0LmFwcGx5KGksdSl9cmV0dXJuIGEudG9UZW5zb3IoKX0sby5wcm90b3R5cGUuc3RyaWRlZFNsaWNlPWZ1bmN0aW9uKHQsZSxuLHIpe0hoKHQsXCJzdHJpZGVkU2xpY2VcIik7dmFyIG89cm8oZSxuLHIpO2lmKG8uc29tZSgoZnVuY3Rpb24odCl7cmV0dXJuIDA9PT10fSkpKXJldHVybiBGbihbXSxvKTtmb3IodmFyIGE9ZHIobyx0LmR0eXBlKSxpPXRoaXMuYnVmZmVyU3luYyh0KSxzPTA7czxhLnNpemU7cysrKXtmb3IodmFyIHU9YS5pbmRleFRvTG9jKHMpLGM9bmV3IEFycmF5KHUubGVuZ3RoKSxsPTA7bDxjLmxlbmd0aDtsKyspY1tsXT11W2xdKnJbbF0rZVtsXTthLnNldC5hcHBseShhLFtpLmdldC5hcHBseShpLGMpXS5jb25jYXQodSkpfXJldHVybiBhLnRvVGVuc29yKCl9LG8ucHJvdG90eXBlLmRpYWc9ZnVuY3Rpb24odCl7Zm9yKHZhciBlPXRoaXMucmVhZFN5bmModC5kYXRhSWQpLG49ZHIoW3Quc2l6ZSx0LnNpemVdLHQuZHR5cGUpLHI9bi52YWx1ZXMsbz0wO288ZS5sZW5ndGg7bysrKXJbbyp0LnNpemUrb109ZVtvXTtyZXR1cm4gbi50b1RlbnNvcigpfSxvLnByb3RvdHlwZS51bnN0YWNrPWZ1bmN0aW9uKHQsZSl7Zm9yKHZhciBuPXQuc2hhcGVbZV0scj1uZXcgQXJyYXkodC5yYW5rLTEpLG89MCxhPTA7YTx0LnJhbms7YSsrKWEhPT1lJiYocltvKytdPXQuc2hhcGVbYV0pO3ZhciBpPW5ldyBBcnJheSh0LnJhbmspLmZpbGwoMCkscz10LnNoYXBlLnNsaWNlKCk7c1tlXT0xO3ZhciB1PW5ldyBBcnJheShuKTtmb3IoYT0wO2E8dS5sZW5ndGg7YSsrKWlbZV09YSx1W2FdPXRoaXMuc2xpY2UodCxpLHMpLnJlc2hhcGUocik7cmV0dXJuIHV9LG8ucHJvdG90eXBlLnJldmVyc2U9ZnVuY3Rpb24odCxlKXtIaCh0LFwicmV2ZXJzZVwiKTtmb3IodmFyIG49ZHIodC5zaGFwZSx0LmR0eXBlKSxyPXRoaXMuYnVmZmVyU3luYyh0KSxvPWZ1bmN0aW9uKG8pe3ZhciBhPW4uaW5kZXhUb0xvYyhvKSxpPWEuc2xpY2UoKTtlLmZvckVhY2goKGZ1bmN0aW9uKGUpe3JldHVybiBpW2VdPXQuc2hhcGVbZV0tMS1pW2VdfSkpLG4uc2V0LmFwcGx5KG4sW3IuZ2V0LmFwcGx5KHIsaSldLmNvbmNhdChhKSl9LGE9MDthPG4uc2l6ZTthKyspbyhhKTtyZXR1cm4gbi50b1RlbnNvcigpfSxvLnByb3RvdHlwZS5jb25jYXQ9ZnVuY3Rpb24odCxlKXt2YXIgbj10aGlzO2lmKFwiY29tcGxleDY0XCI9PT10WzBdLmR0eXBlKXt2YXIgcj10Lm1hcCgoZnVuY3Rpb24odCl7cmV0dXJuIFRuKHQpfSkpLG89dC5tYXAoKGZ1bmN0aW9uKHQpe3JldHVybiBObih0KX0pKTtyZXR1cm4gRG4odGhpcy5jb25jYXQocixlKSx0aGlzLmNvbmNhdChvLGUpKX12YXIgYT10Lm1hcCgoZnVuY3Rpb24odCl7dmFyIG49ayh0LnNoYXBlLnNsaWNlKGUpKTtyZXR1cm4gdC5hczJEKC0xLG4pfSkpLGk9U24oYS5tYXAoKGZ1bmN0aW9uKHQpe3JldHVybiB0LnNoYXBlfSkpLDEpLHM9ZHIoaSx0WzBdLmR0eXBlKS52YWx1ZXM7aWYoMT09PWFbMF0uc2hhcGVbMF0pe3ZhciB1PTA7YS5mb3JFYWNoKChmdW5jdGlvbih0KXtzLnNldChuLnJlYWRTeW5jKHQuZGF0YUlkKSx1KSx1Kz10LnNpemV9KSl9ZWxzZXt2YXIgYz0wO2EuZm9yRWFjaCgoZnVuY3Rpb24odCl7Zm9yKHZhciBlPW4ucmVhZFN5bmModC5kYXRhSWQpLHI9MCxvPTA7bzx0LnNoYXBlWzBdOysrbylmb3IodmFyIGE9byppWzFdK2MsdT0wO3U8dC5zaGFwZVsxXTsrK3Upc1thK3VdPWVbcisrXTtjKz10LnNoYXBlWzFdfSkpfXZhciBsPVNuKHQubWFwKChmdW5jdGlvbih0KXtyZXR1cm4gdC5zaGFwZX0pKSxlKTtyZXR1cm4gRm4ocyxsLHRbMF0uZHR5cGUpfSxvLnByb3RvdHlwZS5uZWc9ZnVuY3Rpb24odCl7cmV0dXJuIEhoKHQsXCJuZWdcIiksdGhpcy5tdWx0aXBseShPbigtMSksdCl9LG8ucHJvdG90eXBlLmFkZD1mdW5jdGlvbih0LGUpe3JldHVyblwiY29tcGxleDY0XCI9PT10LmR0eXBlfHxcImNvbXBsZXg2NFwiPT09ZS5kdHlwZT90aGlzLmJyb2FkY2FzdGVkQmluYXJ5Q29tcGxleE9wKHQuY2FzdChcImNvbXBsZXg2NFwiKSxlLmNhc3QoXCJjb21wbGV4NjRcIiksKGZ1bmN0aW9uKHQsZSxuLHIpe3JldHVybntyZWFsOnQrbixpbWFnOmUrcn19KSk6dGhpcy5icm9hZGNhc3RlZEJpbmFyeU9wKHQsZSxEdCh0LmR0eXBlLGUuZHR5cGUpLChmdW5jdGlvbih0LGUpe3JldHVybiB0K2V9KSl9LG8ucHJvdG90eXBlLmFkZE49ZnVuY3Rpb24odCl7dmFyIGU9dGhpcztIaCh0LFwiYWRkTlwiKTtmb3IodmFyIG49dC5tYXAoKGZ1bmN0aW9uKHQpe3JldHVybiBlLnJlYWRTeW5jKHQuZGF0YUlkKX0pKSxyPWRyKHRbMF0uc2hhcGUsdFswXS5kdHlwZSksbz1yLnZhbHVlcyxhPTA7YTx0Lmxlbmd0aDthKyspZm9yKHZhciBpPW5bYV0scz0wO3M8by5sZW5ndGg7cysrKW9bc10rPWlbc107cmV0dXJuIHIudG9UZW5zb3IoKX0sby5wcm90b3R5cGUuc29mdG1heD1mdW5jdGlvbih0LGUpe3ZhciBuPU8oW2VdLHQuc2hhcGUpLHI9dGhpcy5tYXgodCxuKSxvPXduKHIuc2hhcGUsbiksYT10aGlzLnN1YnRyYWN0KHQsci5yZXNoYXBlKG8pKSxpPXRoaXMuZXhwKGEpLHM9dGhpcy5zdW0oaSxuKS5yZXNoYXBlKG8pO3JldHVybiB0aGlzLnJlYWxEaXZpZGUoaSxzKX0sby5wcm90b3R5cGUuc3VidHJhY3Q9ZnVuY3Rpb24odCxlKXtyZXR1cm5cImNvbXBsZXg2NFwiPT09dC5kdHlwZXx8XCJjb21wbGV4NjRcIj09PWUuZHR5cGU/dGhpcy5icm9hZGNhc3RlZEJpbmFyeUNvbXBsZXhPcCh0LmNhc3QoXCJjb21wbGV4NjRcIiksZS5jYXN0KFwiY29tcGxleDY0XCIpLChmdW5jdGlvbih0LGUsbixyKXtyZXR1cm57cmVhbDp0LW4saW1hZzplLXJ9fSkpOnRoaXMuYnJvYWRjYXN0ZWRCaW5hcnlPcCh0LGUsRHQodC5kdHlwZSxlLmR0eXBlKSwoZnVuY3Rpb24odCxlKXtyZXR1cm4gdC1lfSkpfSxvLnByb3RvdHlwZS5wb3c9ZnVuY3Rpb24odCxlKXtyZXR1cm4gSGgoW3QsZV0sXCJwb3dcIiksdGhpcy5icm9hZGNhc3RlZEJpbmFyeU9wKHQsZSx0LmR0eXBlLChmdW5jdGlvbih0LGUpe3JldHVybiBNYXRoLnBvdyh0LGUpfSkpfSxvLnByb3RvdHlwZS5iYXRjaE1hdE11bD1mdW5jdGlvbih0LGUsbixyKXtIaChbdCxlXSxcIm1hdE11bFwiKTtmb3IodmFyIG89bj90LnNoYXBlWzFdOnQuc2hhcGVbMl0sYT1uP3Quc2hhcGVbMl06dC5zaGFwZVsxXSxpPXI/ZS5zaGFwZVsxXTplLnNoYXBlWzJdLHM9dC5zaGFwZVswXSx1PXRoaXMucmVhZFN5bmModC5kYXRhSWQpLGM9dGhpcy5yZWFkU3luYyhlLmRhdGFJZCksbD1uP1t0LnN0cmlkZXNbMF0sMSx0LnN0cmlkZXNbMV1dOlt0LnN0cmlkZXNbMF0sdC5zdHJpZGVzWzFdLDFdLGg9bFswXSxmPWxbMV0sZD1sWzJdLHA9cj9bMSxlLnN0cmlkZXNbMV0sZS5zdHJpZGVzWzBdXTpbZS5zdHJpZGVzWzFdLDEsZS5zdHJpZGVzWzBdXSx2PXBbMF0sbT1wWzFdLGc9cFsyXSx5PWEqaSx4PWRyKFtzLGEsaV0sdC5kdHlwZSksYj14LnZhbHVlcyx3PXRoaXMuYmxvY2tTaXplLEM9MDtDPHM7QysrKWZvcih2YXIgRT0wO0U8YTtFKz13KWZvcih2YXIgUj0wO1I8aTtSKz13KWZvcih2YXIgST0wO0k8bztJKz13KWZvcih2YXIgaz1NYXRoLm1pbihFK3csYSksUz1NYXRoLm1pbihSK3csaSksQT1NYXRoLm1pbihJK3csbyksRD1FO0Q8aztEKyspZm9yKHZhciBUPVI7VDxTO1QrKyl7Zm9yKHZhciBOPTAsRj1JO0Y8QTtGKyspTis9dVtDKmgrRCpmK0YqZF0qY1tGKnYrVCptK0MqZ107YltDKnkrKEQqaStUKV0rPU59cmV0dXJuIHgudG9UZW5zb3IoKX0sby5wcm90b3R5cGUuZnVzZWRCYXRjaE1hdE11bD1mdW5jdGlvbih0KXt2YXIgZT10LmEsbj10LmIscj10LnRyYW5zcG9zZUEsbz10LnRyYW5zcG9zZUIsYT10LmJpYXMsaT10LmFjdGl2YXRpb24scz10LnByZWx1QWN0aXZhdGlvbldlaWdodHMsdT10aGlzLmJhdGNoTWF0TXVsKGUsbixyLG8pO3JldHVybiBhJiYodT10aGlzLmFkZCh1LGEpKSxpJiYodT1xaCh0aGlzLHUsaSxzKSksdX0sby5wcm90b3R5cGUubXVsdGlwbHk9ZnVuY3Rpb24odCxlKXtyZXR1cm5cImNvbXBsZXg2NFwiPT09dC5kdHlwZXx8XCJjb21wbGV4NjRcIj09PWUuZHR5cGU/dGhpcy5icm9hZGNhc3RlZEJpbmFyeUNvbXBsZXhPcCh0LmNhc3QoXCJjb21wbGV4NjRcIiksZS5jYXN0KFwiY29tcGxleDY0XCIpLChmdW5jdGlvbih0LGUsbixyKXtyZXR1cm57cmVhbDp0Km4tZSpyLGltYWc6dCpyK2Uqbn19KSk6dGhpcy5icm9hZGNhc3RlZEJpbmFyeU9wKHQsZSxEdCh0LmR0eXBlLGUuZHR5cGUpLChmdW5jdGlvbih0LGUpe3JldHVybiB0KmV9KSl9LG8ucHJvdG90eXBlLnJlYWxEaXZpZGU9ZnVuY3Rpb24odCxlKXtIaChbdCxlXSxcInJlYWxEaXZpZGVcIik7cmV0dXJuIHRoaXMuYnJvYWRjYXN0ZWRCaW5hcnlPcCh0LGUsXCJmbG9hdDMyXCIsKGZ1bmN0aW9uKHQsZSl7cmV0dXJuIHQvZX0pKX0sby5wcm90b3R5cGUuZmxvb3JEaXY9ZnVuY3Rpb24odCxlKXtIaChbdCxlXSxcImZsb29yRGl2XCIpO3JldHVybiB0aGlzLmJyb2FkY2FzdGVkQmluYXJ5T3AodCxlLFwiaW50MzJcIiwoZnVuY3Rpb24odCxlKXtyZXR1cm4gTWF0aC5mbG9vcih0L2UpfSkpfSxvLnByb3RvdHlwZS5zdW09ZnVuY3Rpb24odCxlKXtIaCh0LFwic3VtXCIpLENuKFwic3VtXCIsZSx0LnJhbmspO2Zvcih2YXIgbj1ibih0LnNoYXBlLGUpLHI9blswXSxvPW5bMV0sYT1HbihyLER0KHQuZHR5cGUsXCJpbnQzMlwiKSksaT1rKG8pLHM9dGhpcy5yZWFkU3luYyhhLmRhdGFJZCksdT10aGlzLnJlYWRTeW5jKHQuZGF0YUlkKSxjPTA7YzxzLmxlbmd0aDsrK2Mpe2Zvcih2YXIgbD1jKmksaD0wLGY9MDtmPGk7KytmKWgrPXVbbCtmXTtzW2NdPWh9cmV0dXJuIGF9LG8ucHJvdG90eXBlLnByb2Q9ZnVuY3Rpb24odCxlKXtIaCh0LFwic3VtXCIpO2Zvcih2YXIgbj1ibih0LnNoYXBlLGUpLHI9blswXSxvPW5bMV0sYT1HbihyLER0KHQuZHR5cGUsXCJpbnQzMlwiKSksaT1rKG8pLHM9dGhpcy5yZWFkU3luYyhhLmRhdGFJZCksdT10aGlzLnJlYWRTeW5jKHQuZGF0YUlkKSxjPTA7YzxzLmxlbmd0aDsrK2Mpe2Zvcih2YXIgbD1jKmksaD0xLGY9MDtmPGk7KytmKWgqPXVbbCtmXTtzW2NdPWh9cmV0dXJuIGF9LG8ucHJvdG90eXBlLnVuc29ydGVkU2VnbWVudFN1bT1mdW5jdGlvbih0LGUsbil7SGgodCxcInVuc29ydGVkU2VnbWVudFN1bVwiKTtmb3IodmFyIHI9W10sbz10LnJhbmstZS5yYW5rLGE9MDthPG87KythKWU9ZS5leHBhbmREaW1zKGErMSk7Zm9yKGE9MDthPG47KythKXt2YXIgaT1PbihhLFwiaW50MzJcIikscz1SYyhpLGUpLmFzVHlwZShcImZsb2F0MzJcIikubXVsKHQpLnN1bSgwKTtyLnB1c2gocyl9cmV0dXJuIFByKHIpfSxvLnByb3RvdHlwZS5hcmdNaW49ZnVuY3Rpb24odCxlKXtIaCh0LFwiYXJnTWluXCIpO3ZhciBuPVtlXTtDbihcImFyZ01pblwiLG4sdC5yYW5rKTtmb3IodmFyIHI9Ym4odC5zaGFwZSxuKSxvPXJbMF0sYT1yWzFdLGk9R24obyxcImludDMyXCIpLHM9ayhhKSx1PXRoaXMucmVhZFN5bmMoaS5kYXRhSWQpLGM9dGhpcy5yZWFkU3luYyh0LmRhdGFJZCksbD0wO2w8dS5sZW5ndGg7KytsKXtmb3IodmFyIGg9bCpzLGY9Y1toXSxkPTAscD0wO3A8czsrK3Ape3ZhciB2PWNbaCtwXTt2PGYmJihmPXYsZD1wKX11W2xdPWR9cmV0dXJuIGl9LG8ucHJvdG90eXBlLmFyZ01heD1mdW5jdGlvbih0LGUpe0hoKHQsXCJhcmdNYXhcIik7dmFyIG49W2VdO0NuKFwiYXJnTWF4XCIsbix0LnJhbmspO2Zvcih2YXIgcj1ibih0LnNoYXBlLG4pLG89clswXSxhPXJbMV0saT1HbihvLFwiaW50MzJcIikscz1rKGEpLHU9dGhpcy5yZWFkU3luYyhpLmRhdGFJZCksYz10aGlzLnJlYWRTeW5jKHQuZGF0YUlkKSxsPTA7bDx1Lmxlbmd0aDsrK2wpe2Zvcih2YXIgaD1sKnMsZj1jW2hdLGQ9MCxwPTA7cDxzOysrcCl7dmFyIHY9Y1toK3BdO3Y+ZiYmKGY9dixkPXApfXVbbF09ZH1yZXR1cm4gaX0sby5wcm90b3R5cGUuY3Vtc3VtPWZ1bmN0aW9uKHQsZSxuLHIpe2lmKEhoKHQsXCJjdW1zdW1cIiksZSE9PXQucmFuay0xKXRocm93IG5ldyBFcnJvcihcImJhY2tlbmQuY3Vtc3VtIGluIENQVSBleHBlY3RzIGFuIGlubmVyLW1vc3QgYXhpcz1cIisodC5yYW5rLTEpK1wiIGJ1dCBnb3QgYXhpcz1cIitlKTtmb3IodmFyIG89RHQodC5kdHlwZSxcImludDMyXCIpLGE9R24odC5zaGFwZSxvKSxpPXRoaXMucmVhZFN5bmMoYS5kYXRhSWQpLHM9dGhpcy5yZWFkU3luYyh0LmRhdGFJZCksdT10LnNoYXBlW3QucmFuay0xXSxjPXI/ZnVuY3Rpb24odCxlKXtyZXR1cm4gdCt1LWUtMX06ZnVuY3Rpb24odCxlKXtyZXR1cm4gdCtlfSxsPTA7bDxzLmxlbmd0aDtsKz11KWZvcih2YXIgaD0wO2g8dTtoKyspe3ZhciBmPWMobCxoKTtpZigwPT09aClpW2ZdPW4/MDpzW2ZdO2Vsc2V7dmFyIGQ9YyhsLGgtMSk7aVtmXT1uP3NbZF0raVtkXTpzW2ZdK2lbZF19fXJldHVybiBhfSxvLnByb3RvdHlwZS5lcXVhbD1mdW5jdGlvbih0LGUpe3JldHVybiBIaChbdCxlXSxcImVxdWFsXCIpLHRoaXMuYnJvYWRjYXN0ZWRCaW5hcnlPcCh0LGUsXCJib29sXCIsKGZ1bmN0aW9uKHQsZSl7cmV0dXJuIHQ9PT1lPzE6MH0pKX0sby5wcm90b3R5cGUubm90RXF1YWw9ZnVuY3Rpb24odCxlKXtyZXR1cm4gSGgoW3QsZV0sXCJub3RFcXVhbFwiKSx0aGlzLmJyb2FkY2FzdGVkQmluYXJ5T3AodCxlLFwiYm9vbFwiLChmdW5jdGlvbih0LGUpe3JldHVybiB0IT09ZT8xOjB9KSl9LG8ucHJvdG90eXBlLmxlc3M9ZnVuY3Rpb24odCxlKXtyZXR1cm4gSGgoW3QsZV0sXCJsZXNzXCIpLHRoaXMuYnJvYWRjYXN0ZWRCaW5hcnlPcCh0LGUsXCJib29sXCIsKGZ1bmN0aW9uKHQsZSl7cmV0dXJuIHQ8ZT8xOjB9KSl9LG8ucHJvdG90eXBlLmxlc3NFcXVhbD1mdW5jdGlvbih0LGUpe3JldHVybiBIaChbdCxlXSxcImxlc3NFcXVhbFwiKSx0aGlzLmJyb2FkY2FzdGVkQmluYXJ5T3AodCxlLFwiYm9vbFwiLChmdW5jdGlvbih0LGUpe3JldHVybiB0PD1lPzE6MH0pKX0sby5wcm90b3R5cGUuZ3JlYXRlcj1mdW5jdGlvbih0LGUpe3JldHVybiBIaChbdCxlXSxcImdyZWF0ZXJcIiksdGhpcy5icm9hZGNhc3RlZEJpbmFyeU9wKHQsZSxcImJvb2xcIiwoZnVuY3Rpb24odCxlKXtyZXR1cm4gdD5lPzE6MH0pKX0sby5wcm90b3R5cGUuZ3JlYXRlckVxdWFsPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIEhoKFt0LGVdLFwiZ3JlYXRlckVxdWFsXCIpLHRoaXMuYnJvYWRjYXN0ZWRCaW5hcnlPcCh0LGUsXCJib29sXCIsKGZ1bmN0aW9uKHQsZSl7cmV0dXJuIHQ+PWU/MTowfSkpfSxvLnByb3RvdHlwZS5sb2dpY2FsTm90PWZ1bmN0aW9uKHQpe0hoKHQsXCJsb2dpY2FsTm90XCIpO2Zvcih2YXIgZT10aGlzLnJlYWRTeW5jKHQuZGF0YUlkKSxuPW5ldyBVaW50OEFycmF5KGUubGVuZ3RoKSxyPTA7cjxlLmxlbmd0aDsrK3IpbltyXT1lW3JdPzA6MTtyZXR1cm4gdGhpcy5tYWtlT3V0cHV0KG4sdC5zaGFwZSxcImJvb2xcIil9LG8ucHJvdG90eXBlLmxvZ2ljYWxBbmQ9ZnVuY3Rpb24odCxlKXtyZXR1cm4gSGgoW3QsZV0sXCJsb2dpY2FsQW5kXCIpLHRoaXMuYnJvYWRjYXN0ZWRCaW5hcnlPcCh0LGUsXCJib29sXCIsKGZ1bmN0aW9uKHQsZSl7cmV0dXJuIHQmJmV9KSl9LG8ucHJvdG90eXBlLmxvZ2ljYWxPcj1mdW5jdGlvbih0LGUpe3JldHVybiBIaChbdCxlXSxcImxvZ2ljYWxPclwiKSx0aGlzLmJyb2FkY2FzdGVkQmluYXJ5T3AodCxlLFwiYm9vbFwiLChmdW5jdGlvbih0LGUpe3JldHVybiB0fHxlfSkpfSxvLnByb3RvdHlwZS5zZWxlY3Q9ZnVuY3Rpb24odCxlLG4pe0hoKFt0LGUsbl0sXCJzZWxlY3RcIik7Zm9yKHZhciByPXRoaXMucmVhZFN5bmModC5kYXRhSWQpLG89dGhpcy5yZWFkU3luYyhlLmRhdGFJZCksYT10aGlzLnJlYWRTeW5jKG4uZGF0YUlkKSxpPUduKGUuc2hhcGUsRHQoZS5kdHlwZSxuLmR0eXBlKSkscz10aGlzLnJlYWRTeW5jKGkuZGF0YUlkKSx1PTAsYz0wPT09dC5yYW5rfHx0LnJhbms+MXx8MT09PWUucmFuaz8xOmsoZS5zaGFwZS5zbGljZSgxKSksbD0wO2w8ci5sZW5ndGg7bCsrKWZvcih2YXIgaD0wO2g8YztoKyspMT09PXJbbF0/c1t1KytdPW9bbF06c1t1KytdPWFbbF07cmV0dXJuIGl9LG8ucHJvdG90eXBlLndoZXJlPWZ1bmN0aW9uKHQpe0hoKFt0XSxcIndoZXJlXCIpO3ZhciBlPXRoaXMucmVhZFN5bmModC5kYXRhSWQpO3JldHVybiBuYSh0LnNoYXBlLGUpfSxvLnByb3RvdHlwZS50b3BrPWZ1bmN0aW9uKHQsZSxuKXtyZXR1cm4gSGgodCxcInRvcGtcIiksZWEodGhpcy5yZWFkU3luYyh0LmRhdGFJZCksdC5zaGFwZSx0LmR0eXBlLGUpfSxvLnByb3RvdHlwZS5taW49ZnVuY3Rpb24odCxlKXtIaCh0LFwibWluXCIpLENuKFwibWluXCIsZSx0LnJhbmspO2Zvcih2YXIgbj1ibih0LnNoYXBlLGUpLHI9blswXSxvPW5bMV0sYT1HbihyLHQuZHR5cGUpLGk9ayhvKSxzPXRoaXMucmVhZFN5bmMoYS5kYXRhSWQpLHU9dGhpcy5yZWFkU3luYyh0LmRhdGFJZCksYz0wO2M8cy5sZW5ndGg7KytjKXtmb3IodmFyIGw9YyppLGg9dVtsXSxmPTA7ZjxpOysrZil7dmFyIGQ9dVtsK2ZdO2Q8aCYmKGg9ZCl9c1tjXT1ofXJldHVybiBhfSxvLnByb3RvdHlwZS5taW5pbXVtPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIEhoKFt0LGVdLFwibWluaW11bVwiKSx0aGlzLmJyb2FkY2FzdGVkQmluYXJ5T3AodCxlLHQuZHR5cGUsKGZ1bmN0aW9uKHQsZSl7cmV0dXJuIE1hdGgubWluKHQsZSl9KSl9LG8ucHJvdG90eXBlLm1vZD1mdW5jdGlvbih0LGUpe3JldHVybiBIaChbdCxlXSxcIm1vZFwiKSx0aGlzLmJyb2FkY2FzdGVkQmluYXJ5T3AodCxlLHQuZHR5cGUsKGZ1bmN0aW9uKHQsZSl7dmFyIG49dCVlO3JldHVybiB0PDAmJmU8MHx8dD49MCYmZT49MD9uOihuK2UpJWV9KSl9LG8ucHJvdG90eXBlLm1heD1mdW5jdGlvbih0LGUpe0hoKHQsXCJtYXhcIiksQ24oXCJtYXhcIixlLHQucmFuayk7Zm9yKHZhciBuPWJuKHQuc2hhcGUsZSkscj1uWzBdLG89blsxXSxhPUduKHIsdC5kdHlwZSksaT1rKG8pLHM9dGhpcy5yZWFkU3luYyhhLmRhdGFJZCksdT10aGlzLnJlYWRTeW5jKHQuZGF0YUlkKSxjPTA7YzxzLmxlbmd0aDsrK2Mpe2Zvcih2YXIgbD1jKmksaD11W2xdLGY9MDtmPGk7KytmKXt2YXIgZD11W2wrZl07ZD5oJiYoaD1kKX1zW2NdPWh9cmV0dXJuIGF9LG8ucHJvdG90eXBlLm1heGltdW09ZnVuY3Rpb24odCxlKXtyZXR1cm4gSGgoW3QsZV0sXCJtYXhpbXVtXCIpLHRoaXMuYnJvYWRjYXN0ZWRCaW5hcnlPcCh0LGUsdC5kdHlwZSwoZnVuY3Rpb24odCxlKXtyZXR1cm4gTWF0aC5tYXgodCxlKX0pKX0sby5wcm90b3R5cGUuYWxsPWZ1bmN0aW9uKHQsZSl7SGgodCxcImFsbFwiKSxDbihcImFsbFwiLGUsdC5yYW5rKTtmb3IodmFyIG49Ym4odC5zaGFwZSxlKSxyPW5bMF0sbz1uWzFdLGE9R24ocix0LmR0eXBlKSxpPWsobykscz10aGlzLnJlYWRTeW5jKGEuZGF0YUlkKSx1PXRoaXMucmVhZFN5bmModC5kYXRhSWQpLGM9MDtjPHMubGVuZ3RoOysrYyl7Zm9yKHZhciBsPWMqaSxoPXVbbF0sZj0wO2Y8aTsrK2Ype3ZhciBkPXVbbCtmXTtoPWgmJmR9c1tjXT1ofXJldHVybiBhfSxvLnByb3RvdHlwZS5hbnk9ZnVuY3Rpb24odCxlKXtIaCh0LFwiYW55XCIpLENuKFwiYW55XCIsZSx0LnJhbmspO2Zvcih2YXIgbj1ibih0LnNoYXBlLGUpLHI9blswXSxvPW5bMV0sYT1HbihyLHQuZHR5cGUpLGk9ayhvKSxzPXRoaXMucmVhZFN5bmMoYS5kYXRhSWQpLHU9dGhpcy5yZWFkU3luYyh0LmRhdGFJZCksYz0wO2M8cy5sZW5ndGg7KytjKXtmb3IodmFyIGw9YyppLGg9dVtsXSxmPTA7ZjxpOysrZil7dmFyIGQ9dVtsK2ZdO2g9aHx8ZH1zW2NdPWh9cmV0dXJuIGF9LG8ucHJvdG90eXBlLnNxdWFyZWREaWZmZXJlbmNlPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIEhoKFt0LGVdLFwic3F1YXJlZERpZmZlcmVuY2VcIiksdGhpcy5icm9hZGNhc3RlZEJpbmFyeU9wKHQsZSx0LmR0eXBlLChmdW5jdGlvbih0LGUpe3ZhciBuPXQtZTtyZXR1cm4gbipufSkpfSxvLnByb3RvdHlwZS5jZWlsPWZ1bmN0aW9uKHQpe0hoKHQsXCJjZWlsXCIpO2Zvcih2YXIgZT10aGlzLnJlYWRTeW5jKHQuZGF0YUlkKSxuPW5ldyBGbG9hdDMyQXJyYXkoZS5sZW5ndGgpLHI9MDtyPGUubGVuZ3RoOysrciluW3JdPU1hdGguY2VpbChlW3JdKTtyZXR1cm4gdGhpcy5tYWtlT3V0cHV0KG4sdC5zaGFwZSxcImZsb2F0MzJcIil9LG8ucHJvdG90eXBlLmZsb29yPWZ1bmN0aW9uKHQpe0hoKHQsXCJmbG9vclwiKTtmb3IodmFyIGU9dGhpcy5yZWFkU3luYyh0LmRhdGFJZCksbj1uZXcgRmxvYXQzMkFycmF5KGUubGVuZ3RoKSxyPTA7cjxlLmxlbmd0aDsrK3IpbltyXT1NYXRoLmZsb29yKGVbcl0pO3JldHVybiB0aGlzLm1ha2VPdXRwdXQobix0LnNoYXBlLFwiZmxvYXQzMlwiKX0sby5wcm90b3R5cGUuc2lnbj1mdW5jdGlvbih0KXtIaCh0LFwieFwiKTtmb3IodmFyIGU9dGhpcy5yZWFkU3luYyh0LmRhdGFJZCksbj1uZXcgRmxvYXQzMkFycmF5KGUubGVuZ3RoKSxyPTA7cjxlLmxlbmd0aDsrK3IpZVtyXTwwP25bcl09LTE6ZVtyXT4wP25bcl09MTpuW3JdPTA7cmV0dXJuIHRoaXMubWFrZU91dHB1dChuLHQuc2hhcGUsXCJmbG9hdDMyXCIpfSxvLnByb3RvdHlwZS5pc05hTj1mdW5jdGlvbih0KXtIaCh0LFwieFwiKTtmb3IodmFyIGU9dGhpcy5yZWFkU3luYyh0LmRhdGFJZCksbj1uZXcgVWludDhBcnJheShlLmxlbmd0aCkscj0wO3I8ZS5sZW5ndGg7KytyKU51bWJlci5pc05hTihlW3JdKSYmKG5bcl09MSk7cmV0dXJuIHRoaXMubWFrZU91dHB1dChuLHQuc2hhcGUsXCJib29sXCIpfSxvLnByb3RvdHlwZS5pc0luZj1mdW5jdGlvbih0KXtIaCh0LFwieFwiKTtmb3IodmFyIGU9dGhpcy5yZWFkU3luYyh0LmRhdGFJZCksbj1uZXcgVWludDhBcnJheShlLmxlbmd0aCkscj0wO3I8ZS5sZW5ndGg7KytyKU1hdGguYWJzKGVbcl0pPT09MS8wJiYobltyXT0xKTtyZXR1cm4gdGhpcy5tYWtlT3V0cHV0KG4sdC5zaGFwZSxcImJvb2xcIil9LG8ucHJvdG90eXBlLmlzRmluaXRlPWZ1bmN0aW9uKHQpe0hoKHQsXCJ4XCIpO2Zvcih2YXIgZT10aGlzLnJlYWRTeW5jKHQuZGF0YUlkKSxuPW5ldyBVaW50OEFycmF5KGUubGVuZ3RoKSxyPTA7cjxlLmxlbmd0aDsrK3IpTnVtYmVyLmlzRmluaXRlKGVbcl0pJiYobltyXT0xKTtyZXR1cm4gdGhpcy5tYWtlT3V0cHV0KG4sdC5zaGFwZSxcImJvb2xcIil9LG8ucHJvdG90eXBlLnJvdW5kPWZ1bmN0aW9uKHQpe0hoKHQsXCJyb3VuZFwiKTtmb3IodmFyIGU9dGhpcy5yZWFkU3luYyh0LmRhdGFJZCksbj1uZXcgRmxvYXQzMkFycmF5KGUubGVuZ3RoKSxyPTA7cjxlLmxlbmd0aDsrK3Ipe3ZhciBvPU1hdGguZmxvb3IoZVtyXSk7ZVtyXS1vPC41P25bcl09TWF0aC5mbG9vcihlW3JdKTplW3JdLW8+LjU/bltyXT1NYXRoLmNlaWwoZVtyXSk6bltyXT1vJTI9PTA/bzpvKzF9cmV0dXJuIHRoaXMubWFrZU91dHB1dChuLHQuc2hhcGUsXCJmbG9hdDMyXCIpfSxvLnByb3RvdHlwZS5leHA9ZnVuY3Rpb24odCl7SGgodCxcImV4cFwiKTtmb3IodmFyIGU9dGhpcy5yZWFkU3luYyh0LmRhdGFJZCksbj1uZXcgRmxvYXQzMkFycmF5KGUubGVuZ3RoKSxyPTA7cjxlLmxlbmd0aDsrK3IpbltyXT1NYXRoLmV4cChlW3JdKTtyZXR1cm4gdGhpcy5tYWtlT3V0cHV0KG4sdC5zaGFwZSxcImZsb2F0MzJcIil9LG8ucHJvdG90eXBlLmV4cG0xPWZ1bmN0aW9uKHQpe0hoKHQsXCJleHBtMVwiKTtmb3IodmFyIGU9dGhpcy5yZWFkU3luYyh0LmRhdGFJZCksbj1uZXcgRmxvYXQzMkFycmF5KGUubGVuZ3RoKSxyPTA7cjxlLmxlbmd0aDsrK3IpbltyXT1NYXRoLmV4cG0xKGVbcl0pO3JldHVybiB0aGlzLm1ha2VPdXRwdXQobix0LnNoYXBlLFwiZmxvYXQzMlwiKX0sby5wcm90b3R5cGUubG9nPWZ1bmN0aW9uKHQpe0hoKHQsXCJsb2dcIik7Zm9yKHZhciBlPXRoaXMucmVhZFN5bmModC5kYXRhSWQpLG49bmV3IEZsb2F0MzJBcnJheShlLmxlbmd0aCkscj0wO3I8ZS5sZW5ndGg7KytyKXt2YXIgbz1lW3JdO25bcl09TWF0aC5sb2cobyl9cmV0dXJuIHRoaXMubWFrZU91dHB1dChuLHQuc2hhcGUsXCJmbG9hdDMyXCIpfSxvLnByb3RvdHlwZS5sb2cxcD1mdW5jdGlvbih0KXtIaCh0LFwibG9nMXBcIik7Zm9yKHZhciBlPXRoaXMucmVhZFN5bmModC5kYXRhSWQpLG49bmV3IEZsb2F0MzJBcnJheShlLmxlbmd0aCkscj0wO3I8ZS5sZW5ndGg7KytyKXt2YXIgbz1lW3JdO25bcl09TWF0aC5sb2cxcChvKX1yZXR1cm4gdGhpcy5tYWtlT3V0cHV0KG4sdC5zaGFwZSxcImZsb2F0MzJcIil9LG8ucHJvdG90eXBlLnNxcnQ9ZnVuY3Rpb24odCl7SGgodCxcInNxcnRcIik7Zm9yKHZhciBlPXRoaXMucmVhZFN5bmModC5kYXRhSWQpLG49bmV3IEZsb2F0MzJBcnJheShlLmxlbmd0aCkscj0wO3I8ZS5sZW5ndGg7KytyKXt2YXIgbz1lW3JdO25bcl09TWF0aC5zcXJ0KG8pfXJldHVybiB0aGlzLm1ha2VPdXRwdXQobix0LnNoYXBlLFwiZmxvYXQzMlwiKX0sby5wcm90b3R5cGUucnNxcnQ9ZnVuY3Rpb24odCl7SGgodCxcInJzcXJ0XCIpO2Zvcih2YXIgZT10aGlzLnJlYWRTeW5jKHQuZGF0YUlkKSxuPW5ldyBGbG9hdDMyQXJyYXkoZS5sZW5ndGgpLHI9MDtyPGUubGVuZ3RoOysrcil7dmFyIG89ZVtyXTtuW3JdPTEvTWF0aC5zcXJ0KG8pfXJldHVybiB0aGlzLm1ha2VPdXRwdXQobix0LnNoYXBlLFwiZmxvYXQzMlwiKX0sby5wcm90b3R5cGUucmVjaXByb2NhbD1mdW5jdGlvbih0KXtIaCh0LFwicmVjaXByb2NhbFwiKTtmb3IodmFyIGU9dGhpcy5yZWFkU3luYyh0LmRhdGFJZCksbj1uZXcgRmxvYXQzMkFycmF5KGUubGVuZ3RoKSxyPTA7cjxlLmxlbmd0aDsrK3IpbltyXT0xL2Vbcl07cmV0dXJuIHRoaXMubWFrZU91dHB1dChuLHQuc2hhcGUsXCJmbG9hdDMyXCIpfSxvLnByb3RvdHlwZS5saW5lYXI9ZnVuY3Rpb24odCl7cmV0dXJuIHR9LG8ucHJvdG90eXBlLnJlbHU9ZnVuY3Rpb24odCl7SGgodCxcInJlbHVcIik7Zm9yKHZhciBlPUduKHQuc2hhcGUsdC5kdHlwZSksbj10aGlzLnJlYWRTeW5jKGUuZGF0YUlkKSxyPXRoaXMucmVhZFN5bmModC5kYXRhSWQpLG89MDtvPHIubGVuZ3RoOysrbyluW29dPU1hdGgubWF4KDAscltvXSk7cmV0dXJuIGV9LG8ucHJvdG90eXBlLnJlbHU2PWZ1bmN0aW9uKHQpe0hoKHQsXCJyZWx1XCIpO2Zvcih2YXIgZT1Hbih0LnNoYXBlLHQuZHR5cGUpLG49dGhpcy5yZWFkU3luYyhlLmRhdGFJZCkscj10aGlzLnJlYWRTeW5jKHQuZGF0YUlkKSxvPTA7bzxyLmxlbmd0aDsrK28pbltvXT1NYXRoLm1pbihNYXRoLm1heCgwLHJbb10pLDYpO3JldHVybiBlfSxvLnByb3RvdHlwZS5wcmVsdT1mdW5jdGlvbih0LGUpe3JldHVybiBIaChbdCxlXSxcInByZWx1XCIpLHRoaXMuYnJvYWRjYXN0ZWRCaW5hcnlPcCh0LGUsdC5kdHlwZSwoZnVuY3Rpb24odCxlKXtyZXR1cm4gdDwwP2UqdDp0fSkpfSxvLnByb3RvdHlwZS5lbHU9ZnVuY3Rpb24odCl7SGgodCxcImVsdVwiKTtmb3IodmFyIGU9bmV3IEZsb2F0MzJBcnJheSh0LnNpemUpLG49dGhpcy5yZWFkU3luYyh0LmRhdGFJZCkscj0wO3I8bi5sZW5ndGg7KytyKXt2YXIgbz1uW3JdO2Vbcl09bz49MD9vOk1hdGguZXhwKG8pLTF9cmV0dXJuIHRoaXMubWFrZU91dHB1dChlLHQuc2hhcGUsXCJmbG9hdDMyXCIpfSxvLnByb3RvdHlwZS5lbHVEZXI9ZnVuY3Rpb24odCxlKXtIaChbdCxlXSxcImVsdURlclwiKTtmb3IodmFyIG49bmV3IEZsb2F0MzJBcnJheShlLnNpemUpLHI9dGhpcy5yZWFkU3luYyhlLmRhdGFJZCksbz10aGlzLnJlYWRTeW5jKHQuZGF0YUlkKSxhPTA7YTxyLmxlbmd0aDsrK2Epe3ZhciBpPXJbYV07blthXT1pPj0xP29bYV06b1thXSooaSsxKX1yZXR1cm4gdGhpcy5tYWtlT3V0cHV0KG4sZS5zaGFwZSxcImZsb2F0MzJcIil9LG8ucHJvdG90eXBlLnNlbHU9ZnVuY3Rpb24odCl7SGgodCxcInNlbHVcIik7Zm9yKHZhciBlPWJzLG49d3Mscj1uZXcgRmxvYXQzMkFycmF5KHQuc2l6ZSksbz10aGlzLnJlYWRTeW5jKHQuZGF0YUlkKSxhPTA7YTxvLmxlbmd0aDsrK2Epe3ZhciBpPW9bYV07clthXT1pPj0wP24qaTplKihNYXRoLmV4cChpKS0xKX1yZXR1cm4gdGhpcy5tYWtlT3V0cHV0KHIsdC5zaGFwZSxcImZsb2F0MzJcIil9LG8ucHJvdG90eXBlLmNsaXA9ZnVuY3Rpb24odCxlLG4pe0hoKHQsXCJjbGlwXCIpO2Zvcih2YXIgcj1uZXcgRmxvYXQzMkFycmF5KHQuc2l6ZSksbz10aGlzLnJlYWRTeW5jKHQuZGF0YUlkKSxhPTA7YTxvLmxlbmd0aDsrK2Epe3ZhciBpPW9bYV07clthXT1pPm4/bjppPGU/ZTppfXJldHVybiB0aGlzLm1ha2VPdXRwdXQocix0LnNoYXBlLFwiZmxvYXQzMlwiKX0sby5wcm90b3R5cGUuYWJzPWZ1bmN0aW9uKHQpe2Zvcih2YXIgZT1uZXcgRmxvYXQzMkFycmF5KHQuc2l6ZSksbj10aGlzLnJlYWRTeW5jKHQuZGF0YUlkKSxyPTA7cjxuLmxlbmd0aDsrK3IpZVtyXT1NYXRoLmFicyhuW3JdKTtyZXR1cm4gdGhpcy5tYWtlT3V0cHV0KGUsdC5zaGFwZSxcImZsb2F0MzJcIil9LG8ucHJvdG90eXBlLmNvbXBsZXhBYnM9ZnVuY3Rpb24odCl7Zm9yKHZhciBlPW5ldyBGbG9hdDMyQXJyYXkodC5zaXplKSxuPXRoaXMucmVhZFN5bmModC5kYXRhSWQpLHI9MDtyPHQuc2l6ZTsrK3Ipe3ZhciBvPW5bMipyXSxhPW5bMipyKzFdO2Vbcl09TWF0aC5oeXBvdChvLGEpfXJldHVybiB0aGlzLm1ha2VPdXRwdXQoZSx0LnNoYXBlLFwiZmxvYXQzMlwiKX0sby5wcm90b3R5cGUuaW50PWZ1bmN0aW9uKHQpe0hoKHQsXCJpbnRcIik7Zm9yKHZhciBlPW5ldyBJbnQzMkFycmF5KHQuc2l6ZSksbj10aGlzLnJlYWRTeW5jKHQuZGF0YUlkKSxyPTA7cjxuLmxlbmd0aDsrK3IpZVtyXT1uW3JdO3JldHVybiB0aGlzLm1ha2VPdXRwdXQoZSx0LnNoYXBlLFwiaW50MzJcIil9LG8ucHJvdG90eXBlLnNpZ21vaWQ9ZnVuY3Rpb24odCl7SGgodCxcInNpZ21vaWRcIik7Zm9yKHZhciBlPW5ldyBGbG9hdDMyQXJyYXkodC5zaXplKSxuPXRoaXMucmVhZFN5bmModC5kYXRhSWQpLHI9MDtyPG4ubGVuZ3RoOysrcillW3JdPTEvKDErTWF0aC5leHAoLW5bcl0pKTtyZXR1cm4gdGhpcy5tYWtlT3V0cHV0KGUsdC5zaGFwZSxcImZsb2F0MzJcIil9LG8ucHJvdG90eXBlLnNvZnRwbHVzPWZ1bmN0aW9uKHQpe0hoKHQsXCJzb2Z0cGx1c1wiKTtmb3IodmFyIGU9TWF0aC5sb2coMS4xOTIwOTI4OTU1MDc4MTI1ZS03KSsyLG49bmV3IEZsb2F0MzJBcnJheSh0LnNpemUpLHI9dGhpcy5yZWFkU3luYyh0LmRhdGFJZCksbz0wO288ci5sZW5ndGg7KytvKXt2YXIgYT1yW29dPi1lLGk9cltvXTxlLHM9TWF0aC5leHAocltvXSksdT12b2lkIDA7dT1pP3M6YT9yW29dOk1hdGgubG9nKDErcyksbltvXT11fXJldHVybiB0aGlzLm1ha2VPdXRwdXQobix0LnNoYXBlLFwiZmxvYXQzMlwiKX0sby5wcm90b3R5cGUuc2luPWZ1bmN0aW9uKHQpe0hoKHQsXCJzaW5cIik7Zm9yKHZhciBlPW5ldyBGbG9hdDMyQXJyYXkodC5zaXplKSxuPXRoaXMucmVhZFN5bmModC5kYXRhSWQpLHI9MDtyPG4ubGVuZ3RoOysrcillW3JdPU1hdGguc2luKG5bcl0pO3JldHVybiB0aGlzLm1ha2VPdXRwdXQoZSx0LnNoYXBlLFwiZmxvYXQzMlwiKX0sby5wcm90b3R5cGUuY29zPWZ1bmN0aW9uKHQpe0hoKHQsXCJjb3NcIik7Zm9yKHZhciBlPW5ldyBGbG9hdDMyQXJyYXkodC5zaXplKSxuPXRoaXMucmVhZFN5bmModC5kYXRhSWQpLHI9MDtyPG4ubGVuZ3RoOysrcillW3JdPU1hdGguY29zKG5bcl0pO3JldHVybiB0aGlzLm1ha2VPdXRwdXQoZSx0LnNoYXBlLFwiZmxvYXQzMlwiKX0sby5wcm90b3R5cGUudGFuPWZ1bmN0aW9uKHQpe0hoKHQsXCJ0YW5cIik7Zm9yKHZhciBlPW5ldyBGbG9hdDMyQXJyYXkodC5zaXplKSxuPXRoaXMucmVhZFN5bmModC5kYXRhSWQpLHI9MDtyPG4ubGVuZ3RoOysrcillW3JdPU1hdGgudGFuKG5bcl0pO3JldHVybiB0aGlzLm1ha2VPdXRwdXQoZSx0LnNoYXBlLFwiZmxvYXQzMlwiKX0sby5wcm90b3R5cGUuYXNpbj1mdW5jdGlvbih0KXtIaCh0LFwiYXNpblwiKTtmb3IodmFyIGU9bmV3IEZsb2F0MzJBcnJheSh0LnNpemUpLG49dGhpcy5yZWFkU3luYyh0LmRhdGFJZCkscj0wO3I8bi5sZW5ndGg7KytyKWVbcl09TWF0aC5hc2luKG5bcl0pO3JldHVybiB0aGlzLm1ha2VPdXRwdXQoZSx0LnNoYXBlLFwiZmxvYXQzMlwiKX0sby5wcm90b3R5cGUuYWNvcz1mdW5jdGlvbih0KXtIaCh0LFwiYWNvc1wiKTtmb3IodmFyIGU9bmV3IEZsb2F0MzJBcnJheSh0LnNpemUpLG49dGhpcy5yZWFkU3luYyh0LmRhdGFJZCkscj0wO3I8bi5sZW5ndGg7KytyKWVbcl09TWF0aC5hY29zKG5bcl0pO3JldHVybiB0aGlzLm1ha2VPdXRwdXQoZSx0LnNoYXBlLFwiZmxvYXQzMlwiKX0sby5wcm90b3R5cGUuYXRhbj1mdW5jdGlvbih0KXtIaCh0LFwiYXRhblwiKTtmb3IodmFyIGU9bmV3IEZsb2F0MzJBcnJheSh0LnNpemUpLG49dGhpcy5yZWFkU3luYyh0LmRhdGFJZCkscj0wO3I8bi5sZW5ndGg7KytyKWVbcl09TWF0aC5hdGFuKG5bcl0pO3JldHVybiB0aGlzLm1ha2VPdXRwdXQoZSx0LnNoYXBlLFwiZmxvYXQzMlwiKX0sby5wcm90b3R5cGUuYXRhbjI9ZnVuY3Rpb24odCxlKXtyZXR1cm4gSGgoW3QsZV0sXCJhdGFuMlwiKSx0aGlzLmJyb2FkY2FzdGVkQmluYXJ5T3AodCxlLHQuZHR5cGUsKGZ1bmN0aW9uKHQsZSl7cmV0dXJuIE1hdGguYXRhbjIodCxlKX0pKX0sby5wcm90b3R5cGUuc2luaD1mdW5jdGlvbih0KXtIaCh0LFwic2luaFwiKTtmb3IodmFyIGU9bmV3IEZsb2F0MzJBcnJheSh0LnNpemUpLG49dGhpcy5yZWFkU3luYyh0LmRhdGFJZCkscj0wO3I8bi5sZW5ndGg7KytyKWVbcl09TWF0aC5zaW5oKG5bcl0pO3JldHVybiB0aGlzLm1ha2VPdXRwdXQoZSx0LnNoYXBlLFwiZmxvYXQzMlwiKX0sby5wcm90b3R5cGUuY29zaD1mdW5jdGlvbih0KXtIaCh0LFwiY29zaFwiKTtmb3IodmFyIGU9bmV3IEZsb2F0MzJBcnJheSh0LnNpemUpLG49dGhpcy5yZWFkU3luYyh0LmRhdGFJZCkscj0wO3I8bi5sZW5ndGg7KytyKWVbcl09TWF0aC5jb3NoKG5bcl0pO3JldHVybiB0aGlzLm1ha2VPdXRwdXQoZSx0LnNoYXBlLFwiZmxvYXQzMlwiKX0sby5wcm90b3R5cGUudGFuaD1mdW5jdGlvbih0KXtIaCh0LFwidGFuaFwiKTtmb3IodmFyIGU9bmV3IEZsb2F0MzJBcnJheSh0LnNpemUpLG49dGhpcy5yZWFkU3luYyh0LmRhdGFJZCkscj0wO3I8bi5sZW5ndGg7KytyKWVbcl09RChuW3JdKTtyZXR1cm4gdGhpcy5tYWtlT3V0cHV0KGUsdC5zaGFwZSxcImZsb2F0MzJcIil9LG8ucHJvdG90eXBlLmFzaW5oPWZ1bmN0aW9uKHQpe0hoKHQsXCJhc2luaFwiKTtmb3IodmFyIGU9bmV3IEZsb2F0MzJBcnJheSh0LnNpemUpLG49dGhpcy5yZWFkU3luYyh0LmRhdGFJZCkscj0wO3I8bi5sZW5ndGg7KytyKWVbcl09TWF0aC5hc2luaChuW3JdKTtyZXR1cm4gdGhpcy5tYWtlT3V0cHV0KGUsdC5zaGFwZSxcImZsb2F0MzJcIil9LG8ucHJvdG90eXBlLmFjb3NoPWZ1bmN0aW9uKHQpe0hoKHQsXCJhY29zaFwiKTtmb3IodmFyIGU9bmV3IEZsb2F0MzJBcnJheSh0LnNpemUpLG49dGhpcy5yZWFkU3luYyh0LmRhdGFJZCkscj0wO3I8bi5sZW5ndGg7KytyKWVbcl09TWF0aC5hY29zaChuW3JdKTtyZXR1cm4gdGhpcy5tYWtlT3V0cHV0KGUsdC5zaGFwZSxcImZsb2F0MzJcIil9LG8ucHJvdG90eXBlLmF0YW5oPWZ1bmN0aW9uKHQpe0hoKHQsXCJhdGFuaFwiKTtmb3IodmFyIGU9bmV3IEZsb2F0MzJBcnJheSh0LnNpemUpLG49dGhpcy5yZWFkU3luYyh0LmRhdGFJZCkscj0wO3I8bi5sZW5ndGg7KytyKWVbcl09TWF0aC5hdGFuaChuW3JdKTtyZXR1cm4gdGhpcy5tYWtlT3V0cHV0KGUsdC5zaGFwZSxcImZsb2F0MzJcIil9LG8ucHJvdG90eXBlLmVyZj1mdW5jdGlvbih0KXtIaCh0LFwiZXJmXCIpO2Zvcih2YXIgZT1uZXcgRmxvYXQzMkFycmF5KHQuc2l6ZSksbj10aGlzLnJlYWRTeW5jKHQuZGF0YUlkKSxyPTA7cjxuLmxlbmd0aDsrK3Ipe3ZhciBvPU1hdGguc2lnbihuW3JdKSxhPU1hdGguYWJzKG5bcl0pLGk9MS8oMSsuMzI3NTkxMSphKTtlW3JdPW8qKDEtKCgoKDEuMDYxNDA1NDI5KmktMS40NTMxNTIwMjcpKmkrMS40MjE0MTM3NDEpKmktLjI4NDQ5NjczNikqaSsuMjU0ODI5NTkyKSppKk1hdGguZXhwKC1hKmEpKX1yZXR1cm4gdGhpcy5tYWtlT3V0cHV0KGUsdC5zaGFwZSxcImZsb2F0MzJcIil9LG8ucHJvdG90eXBlLnN0ZXA9ZnVuY3Rpb24odCxlKXt2b2lkIDA9PT1lJiYoZT0wKSxIaCh0LFwic3RlcFwiKTtmb3IodmFyIG49bmV3IEZsb2F0MzJBcnJheSh0LnNpemUpLHI9dGhpcy5yZWFkU3luYyh0LmRhdGFJZCksbz0wO288ci5sZW5ndGg7KytvKXt2YXIgYT1yW29dO2lzTmFOKGEpP25bb109TmFOOm5bb109YT4wPzE6ZX1yZXR1cm4gdGhpcy5tYWtlT3V0cHV0KG4sdC5zaGFwZSxcImZsb2F0MzJcIil9LG8ucHJvdG90eXBlLmZ1c2VkQ29udjJkPWZ1bmN0aW9uKHQpe3ZhciBlPXQuaW5wdXQsbj10LmZpbHRlcixyPXQuY29udkluZm8sbz10LmJpYXMsYT10LmFjdGl2YXRpb24saT10LnByZWx1QWN0aXZhdGlvbldlaWdodHMscz10aGlzLmNvbnYyZChlLG4scik7cmV0dXJuIG8mJihzPXRoaXMuYWRkKHMsbykpLGEmJihzPXFoKHRoaXMscyxhLGkpKSxzfSxvLnByb3RvdHlwZS5jb252MmQ9ZnVuY3Rpb24odCxlLG4pe0hoKFt0LGVdLFwiY29udjJkXCIpO2Zvcih2YXIgcj1uLmZpbHRlckhlaWdodCxvPW4uZmlsdGVyV2lkdGgsYT1uLmRpbGF0aW9uSGVpZ2h0LGk9bi5kaWxhdGlvbldpZHRoLHM9bi5wYWRJbmZvLmxlZnQsdT1uLnBhZEluZm8udG9wLGM9XCJjaGFubmVsc0xhc3RcIj09PW4uZGF0YUZvcm1hdCxsPWRyKG4ub3V0U2hhcGUsdC5kdHlwZSksaD10LnN0cmlkZXNbMF0sZj1jP3Quc3RyaWRlc1sxXTp0LnN0cmlkZXNbMl0sZD1jP3Quc3RyaWRlc1syXToxLHA9Yz8xOnQuc3RyaWRlc1sxXSx2PWwuc3RyaWRlc1swXSxtPWM/bC5zdHJpZGVzWzFdOmwuc3RyaWRlc1syXSxnPWM/bC5zdHJpZGVzWzJdOjEseT1jPzE6bC5zdHJpZGVzWzFdLHg9dGhpcy5yZWFkU3luYyh0LmRhdGFJZCksYj10aGlzLnJlYWRTeW5jKGUuZGF0YUlkKSx3PWwudmFsdWVzLEM9MDtDPG4uYmF0Y2hTaXplOysrQylmb3IodmFyIEU9QypoLFI9Qyp2LEk9MDtJPG4ub3V0SGVpZ2h0OysrSSlmb3IodmFyIGs9UitJKm0sUz1JKm4uc3RyaWRlSGVpZ2h0LXUsQT0wO0E8cjtBKyspe3ZhciBEPVMrQSphO2lmKCEoRDwwfHxEPj1uLmluSGVpZ2h0KSlmb3IodmFyIFQ9QSplLnN0cmlkZXNbMF0sTj1FK0QqZixGPTA7RjxuLm91dFdpZHRoOysrRilmb3IodmFyIF89aytGKmcsTz1GKm4uc3RyaWRlV2lkdGgtcyxNPTA7TTxvO00rKyl7dmFyIEI9TytNKmk7aWYoIShCPDB8fEI+PW4uaW5XaWR0aCkpZm9yKHZhciBQPU4rQipkLEw9VCtNKmUuc3RyaWRlc1sxXSxXPTA7VzxuLmluQ2hhbm5lbHM7KytXKXtmb3IodmFyIFU9eFtQK1cqcF0sVj0wO1Y8bi5vdXRDaGFubmVsczsrK1Ypd1tfK1YqeV0rPVUqYltMK1ZdO0wrPW4ub3V0Q2hhbm5lbHN9fX1yZXR1cm4gbC50b1RlbnNvcigpfSxvLnByb3RvdHlwZS5jb252M2Q9ZnVuY3Rpb24odCxlLG4pe2Zvcih2YXIgcj1uLmZpbHRlckRlcHRoLG89bi5maWx0ZXJIZWlnaHQsYT1uLmZpbHRlcldpZHRoLGk9bi5kaWxhdGlvbkRlcHRoLHM9bi5kaWxhdGlvbkhlaWdodCx1PW4uZGlsYXRpb25XaWR0aCxjPW4ucGFkSW5mby5mcm9udCxsPW4ucGFkSW5mby5sZWZ0LGg9bi5wYWRJbmZvLnRvcCxmPWRyKG4ub3V0U2hhcGUsdC5kdHlwZSksZD10aGlzLnJlYWRTeW5jKHQuZGF0YUlkKSxwPXRoaXMucmVhZFN5bmMoZS5kYXRhSWQpLHY9Zi52YWx1ZXMsbT0wO208bi5iYXRjaFNpemU7KyttKWZvcih2YXIgZz1tKnQuc3RyaWRlc1swXSx5PW0qZi5zdHJpZGVzWzBdLHg9MDt4PG4ub3V0RGVwdGg7Kyt4KWZvcih2YXIgYj15K3gqZi5zdHJpZGVzWzFdLHc9eCpuLnN0cmlkZURlcHRoLWMsQz0wO0M8cjtDKyspe3ZhciBFPXcrQyppO2lmKCEoRTwwfHxFPj1uLmluRGVwdGgpKWZvcih2YXIgUj1DKmUuc3RyaWRlc1swXSxJPWcrRSp0LnN0cmlkZXNbMV0saz0wO2s8bi5vdXRIZWlnaHQ7KytrKWZvcih2YXIgUz1iK2sqZi5zdHJpZGVzWzJdLEE9aypuLnN0cmlkZUhlaWdodC1oLEQ9MDtEPG87RCsrKXt2YXIgVD1BK0QqcztpZighKFQ8MHx8VD49bi5pbkhlaWdodCkpZm9yKHZhciBOPVIrRCplLnN0cmlkZXNbMV0sRj1JK1QqdC5zdHJpZGVzWzJdLF89MDtfPG4ub3V0V2lkdGg7KytfKWZvcih2YXIgTz1TK18qbi5vdXRDaGFubmVscyxNPV8qbi5zdHJpZGVXaWR0aC1sLEI9MDtCPGE7QisrKXt2YXIgUD1NK0IqdTtpZighKFA8MHx8UD49bi5pbldpZHRoKSlmb3IodmFyIEw9TitCKmUuc3RyaWRlc1syXSxXPUYrUCpuLmluQ2hhbm5lbHMsVT1MLFY9MDtWPG4uaW5DaGFubmVsczsrK1Ype2Zvcih2YXIgej1kW1crVl0sRz0wO0c8bi5vdXRDaGFubmVsczsrK0cpdltPK0ddKz16KnBbVStHXTtVKz1uLm91dENoYW5uZWxzfX19fXJldHVybiBmLnRvVGVuc29yKCl9LG8ucHJvdG90eXBlLmNvbnYyZERlcklucHV0PWZ1bmN0aW9uKHQsZSxuKXtIaChbdCxlXSxcImNvbnYyZERlcklucHV0XCIpO2Zvcih2YXIgcj1kcihuLmluU2hhcGUsXCJmbG9hdDMyXCIpLG89ci52YWx1ZXMsYT10aGlzLnJlYWRTeW5jKHQuZGF0YUlkKSxpPXRoaXMucmVhZFN5bmMoZS5kYXRhSWQpLHM9ZS5zdHJpZGVzLHU9c1swXSxjPXNbMV0sbD1zWzJdLGg9bi5iYXRjaFNpemUsZj1uLmZpbHRlckhlaWdodCxkPW4uZmlsdGVyV2lkdGgscD1uLmluQ2hhbm5lbHMsdj1uLmluSGVpZ2h0LG09bi5pbldpZHRoLGc9bi5vdXRDaGFubmVscyx5PW4ub3V0SGVpZ2h0LHg9bi5vdXRXaWR0aCxiPW4uc3RyaWRlSGVpZ2h0LHc9bi5zdHJpZGVXaWR0aCxDPW4uZGF0YUZvcm1hdCxFPWYtMS1uLnBhZEluZm8udG9wLFI9ZC0xLW4ucGFkSW5mby5sZWZ0LEk9XCJjaGFubmVsc0xhc3RcIj09PUMsaz1yLnN0cmlkZXNbMF0sUz1JP3Iuc3RyaWRlc1sxXTpyLnN0cmlkZXNbMl0sQT1JP3Iuc3RyaWRlc1syXToxLEQ9ST8xOnIuc3RyaWRlc1sxXSxUPXQuc3RyaWRlc1swXSxOPUk/dC5zdHJpZGVzWzFdOnQuc3RyaWRlc1syXSxGPUk/dC5zdHJpZGVzWzJdOjEsXz1JPzE6dC5zdHJpZGVzWzFdLE89MDtPPGg7KytPKWZvcih2YXIgTT0wO008cDsrK00pZm9yKHZhciBCPTA7Qjx2OysrQilmb3IodmFyIFA9Qi1FLEw9TWF0aC5tYXgoMCxNYXRoLmNlaWwoUC9iKSksVz1NYXRoLm1pbih5LChmK1ApL2IpLFU9MDtVPG07KytVKXtmb3IodmFyIFY9VS1SLHo9TWF0aC5tYXgoMCxNYXRoLmNlaWwoVi93KSksRz1NYXRoLm1pbih4LChkK1YpL3cpLEg9MCxxPUw7cTxXOysrcSlmb3IodmFyIEs9cSpiLVAsaj16O2o8RzsrK2opZm9yKHZhciBYPVQqTytOKnErRipqLFk9dSooZi0xLUspK2MqKGQtMS0oaip3LVYpKStsKk0sJD0wOyQ8ZzsrKyQpe0grPWFbWCtfKiRdKmlbWSskXX1vW2sqTytTKkIrQSpVK0QqTV09SH1yZXR1cm4gci50b1RlbnNvcigpfSxvLnByb3RvdHlwZS5jb252M2REZXJJbnB1dD1mdW5jdGlvbih0LGUsbil7Zm9yKHZhciByPWRyKG4uaW5TaGFwZSxcImZsb2F0MzJcIiksbz1yLnZhbHVlcyxhPXIuc3RyaWRlcyxpPWFbMF0scz1hWzFdLHU9YVsyXSxjPWFbM10sbD10aGlzLnJlYWRTeW5jKHQuZGF0YUlkKSxoPXQuc3RyaWRlcyxmPWhbMF0sZD1oWzFdLHA9aFsyXSx2PWhbM10sbT10aGlzLnJlYWRTeW5jKGUuZGF0YUlkKSxnPWUuc3RyaWRlcyx5PWdbMF0seD1nWzFdLGI9Z1syXSx3PWdbM10sQz1uLmJhdGNoU2l6ZSxFPW4uZmlsdGVyRGVwdGgsUj1uLmZpbHRlckhlaWdodCxJPW4uZmlsdGVyV2lkdGgsaz1uLmluQ2hhbm5lbHMsUz1uLmluRGVwdGgsQT1uLmluSGVpZ2h0LEQ9bi5pbldpZHRoLFQ9bi5vdXRDaGFubmVscyxOPW4ub3V0RGVwdGgsRj1uLm91dEhlaWdodCxfPW4ub3V0V2lkdGgsTz1uLnN0cmlkZURlcHRoLE09bi5zdHJpZGVIZWlnaHQsQj1uLnN0cmlkZVdpZHRoLFA9RS0xLW4ucGFkSW5mby5mcm9udCxMPVItMS1uLnBhZEluZm8udG9wLFc9SS0xLW4ucGFkSW5mby5sZWZ0LFU9MDtVPEM7KytVKWZvcih2YXIgVj0wO1Y8azsrK1YpZm9yKHZhciB6PTA7ejxTOysreilmb3IodmFyIEc9ei1QLEg9TWF0aC5tYXgoMCxNYXRoLmNlaWwoRy9PKSkscT1NYXRoLm1pbihOLChFK0cpL08pLEs9MDtLPEE7KytLKWZvcih2YXIgaj1LLUwsWD1NYXRoLm1heCgwLE1hdGguY2VpbChqL00pKSxZPU1hdGgubWluKEYsKFIraikvTSksJD0wOyQ8RDsrKyQpe2Zvcih2YXIgUT0kLVcsSj1NYXRoLm1heCgwLE1hdGguY2VpbChRL0IpKSxaPU1hdGgubWluKF8sKEkrUSkvQiksdHQ9MCxldD1IO2V0PHE7KytldClmb3IodmFyIG50PWV0Kk8tRyxydD1YO3J0PFk7KytydClmb3IodmFyIG90PXJ0Kk0taixhdD1KO2F0PFo7KythdClmb3IodmFyIGl0PWYqVStkKmV0K3AqcnQrdiphdCxzdD15KihFLTEtbnQpK3gqKFItMS1vdCkrYiooSS0xLShhdCpCLVEpKSt3KlYsdXQ9MDt1dDxUOysrdXQpe3R0Kz1sW2l0K3V0XSptW3N0K3V0XX1vW2kqVStzKnordSpLK2MqJCtWXT10dH1yZXR1cm4gci50b1RlbnNvcigpfSxvLnByb3RvdHlwZS5jb252MmREZXJGaWx0ZXI9ZnVuY3Rpb24odCxlLG4pe0hoKFt0LGVdLFwiY29udjJkRGVyRmlsdGVyXCIpO2Zvcih2YXIgcj1uLnN0cmlkZUhlaWdodCxvPW4uc3RyaWRlV2lkdGgsYT1uLmZpbHRlckhlaWdodCxpPW4uZmlsdGVyV2lkdGgscz1cImNoYW5uZWxzTGFzdFwiPT09bi5kYXRhRm9ybWF0LHU9ZHIobi5maWx0ZXJTaGFwZSxcImZsb2F0MzJcIiksYz1uLnBhZEluZm8ubGVmdCxsPW4ucGFkSW5mby50b3AsaD10aGlzLmJ1ZmZlclN5bmModCksZj10aGlzLmJ1ZmZlclN5bmMoZSksZD0wO2Q8YTsrK2QpZm9yKHZhciBwPU1hdGgubWF4KDAsTWF0aC5jZWlsKChsLWQpL3IpKSx2PU1hdGgubWluKG4ub3V0SGVpZ2h0LChuLmluSGVpZ2h0K2wtZCkvciksbT0wO208aTsrK20pZm9yKHZhciBnPU1hdGgubWF4KDAsTWF0aC5jZWlsKChjLW0pL28pKSx5PU1hdGgubWluKG4ub3V0V2lkdGgsKG4uaW5XaWR0aCtjLW0pL28pLHg9MDt4PG4uaW5DaGFubmVsczsrK3gpZm9yKHZhciBiPTA7YjxuLm91dENoYW5uZWxzOysrYil7Zm9yKHZhciB3PTAsQz0wO0M8bi5iYXRjaFNpemU7KytDKWZvcih2YXIgRT1wO0U8djsrK0UpZm9yKHZhciBSPWQrRSpyLWwsST1nO0k8eTsrK0kpe3ZhciBrPW0rSSpvLWM7dys9cz9oLmdldChDLFIsayx4KSpmLmdldChDLEUsSSxiKTpoLmdldChDLHgsUixrKSpmLmdldChDLGIsRSxJKX11LnNldCh3LGQsbSx4LGIpfXJldHVybiB1LnRvVGVuc29yKCl9LG8ucHJvdG90eXBlLmNvbnYzZERlckZpbHRlcj1mdW5jdGlvbih0LGUsbil7Zm9yKHZhciByPW4uc3RyaWRlRGVwdGgsbz1uLnN0cmlkZUhlaWdodCxhPW4uc3RyaWRlV2lkdGgsaT1uLmZpbHRlckRlcHRoLHM9bi5maWx0ZXJIZWlnaHQsdT1uLmZpbHRlcldpZHRoLGM9ZHIobi5maWx0ZXJTaGFwZSxcImZsb2F0MzJcIiksbD1jLnZhbHVlcyxoPWMuc3RyaWRlcyxmPWhbMF0sZD1oWzFdLHA9aFsyXSx2PWhbM10sbT10aGlzLnJlYWRTeW5jKGUuZGF0YUlkKSxnPWUuc3RyaWRlcyx5PWdbMF0seD1nWzFdLGI9Z1syXSx3PWdbM10sQz10aGlzLnJlYWRTeW5jKHQuZGF0YUlkKSxFPXQuc3RyaWRlcyxSPUVbMF0sST1FWzFdLGs9RVsyXSxTPUVbM10sQT1uLnBhZEluZm8uZnJvbnQsRD1uLnBhZEluZm8ubGVmdCxUPW4ucGFkSW5mby50b3AsTj0wO048aTsrK04pZm9yKHZhciBGPU1hdGgubWF4KDAsTWF0aC5jZWlsKChBLU4pL3IpKSxfPU1hdGgubWluKG4ub3V0RGVwdGgsKG4uaW5EZXB0aCtBLU4pL3IpLE89TipmLE09MDtNPHM7KytNKWZvcih2YXIgQj1NYXRoLm1heCgwLE1hdGguY2VpbCgoVC1NKS9vKSksUD1NYXRoLm1pbihuLm91dEhlaWdodCwobi5pbkhlaWdodCtULU0pL28pLEw9TSpkK08sVz0wO1c8dTsrK1cpZm9yKHZhciBVPU1hdGgubWF4KDAsTWF0aC5jZWlsKChELVcpL2EpKSxWPU1hdGgubWluKG4ub3V0V2lkdGgsKG4uaW5XaWR0aCtELVcpL2EpLHo9VypwK0wsRz0wO0c8bi5pbkNoYW5uZWxzOysrRylmb3IodmFyIEg9Ryp2K3oscT0wO3E8bi5vdXRDaGFubmVsczsrK3Epe2Zvcih2YXIgSz0wLGo9MDtqPG4uYmF0Y2hTaXplOysrailmb3IodmFyIFg9aipSLFk9aip5LCQ9RjskPF87KyskKWZvcih2YXIgUT0oTiskKnItQSkqSStYLEo9JCp4K1ksWj1CO1o8UDsrK1opZm9yKHZhciB0dD0oTStaKm8tVCkqaytRLGV0PVoqYitKLG50PVU7bnQ8VjsrK250KXt2YXIgcnQ9bnQqdytldDtLKz1DWyhXK250KmEtRCkqUyt0dCtHXSptW3J0K3FdfWxbSCtxXT1LfXJldHVybiBjLnRvVGVuc29yKCl9LG8ucHJvdG90eXBlLmZ1c2VkRGVwdGh3aXNlQ29udjJEPWZ1bmN0aW9uKHQpe3ZhciBlPXQuaW5wdXQsbj10LmZpbHRlcixyPXQuY29udkluZm8sbz10LmJpYXMsYT10LmFjdGl2YXRpb24saT10LnByZWx1QWN0aXZhdGlvbldlaWdodHMscz10aGlzLmRlcHRod2lzZUNvbnYyRChlLG4scik7cmV0dXJuIG8mJihzPXRoaXMuYWRkKHMsbykpLGEmJihzPXFoKHRoaXMscyxhLGkpKSxzfSxvLnByb3RvdHlwZS5kZXB0aHdpc2VDb252MkQ9ZnVuY3Rpb24odCxlLG4pe0hoKFt0LGVdLFwiZGVwdGh3aXNlQ29udjJEXCIpO2Zvcih2YXIgcj1uLmZpbHRlckhlaWdodCxvPW4uZmlsdGVyV2lkdGgsYT1uLmRpbGF0aW9uSGVpZ2h0LGk9bi5kaWxhdGlvbldpZHRoLHM9bi5wYWRJbmZvLmxlZnQsdT1uLnBhZEluZm8udG9wLGM9bi5vdXRDaGFubmVscy9uLmluQ2hhbm5lbHMsbD1kcihuLm91dFNoYXBlLHQuZHR5cGUpLGg9dGhpcy5yZWFkU3luYyh0LmRhdGFJZCksZj10aGlzLnJlYWRTeW5jKGUuZGF0YUlkKSxkPWwudmFsdWVzLHA9MDtwPG4uYmF0Y2hTaXplOysrcClmb3IodmFyIHY9cCp0LnN0cmlkZXNbMF0sbT1wKmwuc3RyaWRlc1swXSxnPTA7ZzxuLm91dEhlaWdodDsrK2cpZm9yKHZhciB5PW0rZypsLnN0cmlkZXNbMV0seD1nKm4uc3RyaWRlSGVpZ2h0LXMsYj0wO2I8cjsrK2Ipe3ZhciB3PXgrYiphO2lmKCEodzwwfHx3Pj1uLmluSGVpZ2h0KSlmb3IodmFyIEM9YiplLnN0cmlkZXNbMF0sRT12K3cqdC5zdHJpZGVzWzFdLFI9MDtSPG4ub3V0V2lkdGg7KytSKWZvcih2YXIgST15K1IqbC5zdHJpZGVzWzJdLGs9UipuLnN0cmlkZVdpZHRoLXUsUz0wO1M8bzsrK1Mpe3ZhciBBPWsrUyppO2lmKCEoQTwwfHxBPj1uLmluV2lkdGgpKWZvcih2YXIgRD1DK1MqZS5zdHJpZGVzWzFdLFQ9RStBKm4uaW5DaGFubmVscyxOPUksRj1ELF89MDtfPG4uaW5DaGFubmVsczsrK18pe2Zvcih2YXIgTz1oW1QrX10sTT0wO008YzsrK00pZFtOK01dKz1PKmZbRitNXTtOKz1jLEYrPWN9fX1yZXR1cm4gbC50b1RlbnNvcigpfSxvLnByb3RvdHlwZS5kZXB0aHdpc2VDb252MkREZXJJbnB1dD1mdW5jdGlvbih0LGUsbil7SGgoW3QsZV0sXCJkZXB0aHdpc2VDb252MkREZXJJbnB1dFwiKTtmb3IodmFyIHI9ZHIobi5pblNoYXBlLFwiZmxvYXQzMlwiKSxvPXIudmFsdWVzLGE9ci5zdHJpZGVzLGk9YVswXSxzPWFbMV0sdT1hWzJdLGM9dGhpcy5yZWFkU3luYyh0LmRhdGFJZCksbD10LnN0cmlkZXMsaD1sWzBdLGY9bFsxXSxkPWxbMl0scD10aGlzLnJlYWRTeW5jKGUuZGF0YUlkKSx2PWUuc3RyaWRlcyxtPXZbMF0sZz12WzFdLHk9dlsyXSx4PW4uYmF0Y2hTaXplLGI9bi5maWx0ZXJIZWlnaHQsdz1uLmZpbHRlcldpZHRoLEM9bi5pbkNoYW5uZWxzLEU9bi5pbkhlaWdodCxSPW4uaW5XaWR0aCxJPW4ub3V0Q2hhbm5lbHMsaz1uLm91dEhlaWdodCxTPW4ub3V0V2lkdGgsQT1uLnN0cmlkZUhlaWdodCxEPW4uc3RyaWRlV2lkdGgsVD1iLTEtbi5wYWRJbmZvLnRvcCxOPXctMS1uLnBhZEluZm8ubGVmdCxGPUkvQyxfPTA7Xzx4OysrXylmb3IodmFyIE89MDtPPEM7KytPKWZvcih2YXIgTT0wO008RTsrK00pZm9yKHZhciBCPU0tVCxQPU1hdGgubWF4KDAsTWF0aC5jZWlsKEIvQSkpLEw9TWF0aC5taW4oaywoYitCKS9BKSxXPTA7VzxSOysrVyl7Zm9yKHZhciBVPVctTixWPU1hdGgubWF4KDAsTWF0aC5jZWlsKFUvRCkpLHo9TWF0aC5taW4oUywodytVKS9EKSxHPTAsSD1QO0g8TDsrK0gpZm9yKHZhciBxPUgqQS1CLEs9VjtLPHo7KytLKWZvcih2YXIgaj1oKl8rZipIK2QqSyxYPW0qKGItMS1xKStnKih3LTEtKEsqRC1VKSkreSpPLFk9MDtZPEY7KytZKXtHKz1jW2orKE8qRitZKV0qcFtYK1ldfW9baSpfK3MqTSt1KlcrT109R31yZXR1cm4gci50b1RlbnNvcigpfSxvLnByb3RvdHlwZS5kZXB0aHdpc2VDb252MkREZXJGaWx0ZXI9ZnVuY3Rpb24odCxlLG4pe0hoKFt0LGVdLFwiZGVwdGh3aXNlQ29udjJERGVyRmlsdGVyXCIpO2Zvcih2YXIgcj1uLnN0cmlkZUhlaWdodCxvPW4uc3RyaWRlV2lkdGgsYT1uLmZpbHRlckhlaWdodCxpPW4uZmlsdGVyV2lkdGgscz1kcihuLmZpbHRlclNoYXBlLFwiZmxvYXQzMlwiKSx1PW4ucGFkSW5mby5sZWZ0LGM9bi5wYWRJbmZvLnRvcCxsPW4ub3V0Q2hhbm5lbHMvbi5pbkNoYW5uZWxzLGg9dGhpcy5idWZmZXJTeW5jKHQpLGY9dGhpcy5idWZmZXJTeW5jKGUpLGQ9MDtkPGE7KytkKWZvcih2YXIgcD1NYXRoLm1heCgwLE1hdGguY2VpbCgoYy1kKS9yKSksdj1NYXRoLm1pbihuLm91dEhlaWdodCwobi5pbkhlaWdodCtjLWQpL3IpLG09MDttPGk7KyttKWZvcih2YXIgZz1NYXRoLm1heCgwLE1hdGguY2VpbCgodS1tKS9vKSkseT1NYXRoLm1pbihuLm91dFdpZHRoLChuLmluV2lkdGgrdS1tKS9vKSx4PTA7eDxuLm91dENoYW5uZWxzOysreCl7Zm9yKHZhciBiPU1hdGgudHJ1bmMoeC9sKSx3PXglbCxDPTAsRT0wO0U8bi5iYXRjaFNpemU7KytFKWZvcih2YXIgUj1wO1I8djsrK1IpZm9yKHZhciBJPWQrUipyLWMsaz1nO2s8eTsrK2spe3ZhciBTPW0raypvLXU7Qys9aC5nZXQoRSxJLFMsYikqZi5nZXQoRSxSLGsseCl9cy5zZXQoQyxkLG0sYix3KX1yZXR1cm4gcy50b1RlbnNvcigpfSxvLnByb3RvdHlwZS50aWxlPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIEhoKHQsXCJ0aWxlXCIpLHRhKHRoaXMuYnVmZmVyU3luYyh0KSxlKX0sby5wcm90b3R5cGUucGFkPWZ1bmN0aW9uKHQsZSxuKXtIaCh0LFwicGFkXCIpO3ZhciByPWUubWFwKChmdW5jdGlvbihlLG4pe3JldHVybiBlWzBdK3Quc2hhcGVbbl0rZVsxXX0pKSxvPWUubWFwKChmdW5jdGlvbih0KXtyZXR1cm4gdFswXX0pKSxhPXRoaXMuYnVmZmVyU3luYyh0KSxpPWRyKHIsdC5kdHlwZSk7MCE9PW4mJmkudmFsdWVzLmZpbGwobik7Zm9yKHZhciBzPTA7czx0LnNpemU7cysrKXt2YXIgdT1hLmluZGV4VG9Mb2MocyksYz11Lm1hcCgoZnVuY3Rpb24odCxlKXtyZXR1cm4gdCtvW2VdfSkpO2kuc2V0LmFwcGx5KGksW2EuZ2V0LmFwcGx5KGEsdSldLmNvbmNhdChjKSl9cmV0dXJuIGkudG9UZW5zb3IoKX0sby5wcm90b3R5cGUudHJhbnNwb3NlPWZ1bmN0aW9uKHQsZSl7SGgodCxcInRyYW5zcG9zZVwiKTtmb3IodmFyIG49bmV3IEFycmF5KHQucmFuaykscj0wO3I8bi5sZW5ndGg7cisrKW5bcl09dC5zaGFwZVtlW3JdXTt2YXIgbz10aGlzLnJlYWRTeW5jKHQuZGF0YUlkKSxhPWRyKG4sdC5kdHlwZSksaT10aGlzLmJ1ZmZlclN5bmModCk7Zm9yKHI9MDtyPHQuc2l6ZTsrK3Ipe2Zvcih2YXIgcz1pLmluZGV4VG9Mb2MociksdT1uZXcgQXJyYXkocy5sZW5ndGgpLGM9MDtjPHUubGVuZ3RoO2MrKyl1W2NdPXNbZVtjXV07dmFyIGw9YS5sb2NUb0luZGV4KHUpO2EudmFsdWVzW2xdPW9bcl19cmV0dXJuIGEudG9UZW5zb3IoKX0sby5wcm90b3R5cGUuZ2F0aGVyPWZ1bmN0aW9uKHQsZSxuKXtIaChbdCxlXSxcImdhdGhlclwiKTt2YXIgcj10LnNoYXBlLnNsaWNlKCksbz10aGlzLnJlYWRTeW5jKGUuZGF0YUlkKTtyW25dPW8ubGVuZ3RoO2Zvcih2YXIgYT1kcihyLHQuZHR5cGUpLGk9dGhpcy5idWZmZXJTeW5jKHQpLHM9MDtzPGEuc2l6ZTsrK3Mpe3ZhciB1PWEuaW5kZXhUb0xvYyhzKSxjPXUuc2xpY2UoKTtjW25dPW9bdVtuXV07dmFyIGw9aS5sb2NUb0luZGV4KGMpO2EudmFsdWVzW3NdPWkudmFsdWVzW2xdfXJldHVybiBhLnRvVGVuc29yKCl9LG8ucHJvdG90eXBlLmJhdGNoVG9TcGFjZU5EPWZ1bmN0aW9uKHQsZSxuKXtIaChbdF0sXCJiYXRjaFRvU3BhY2VORFwiKTt2YXIgcj1lLnJlZHVjZSgoZnVuY3Rpb24odCxlKXtyZXR1cm4gdCplfSkpLG89enIodC5zaGFwZSxlLHIpLGE9R3Ioby5sZW5ndGgsZS5sZW5ndGgpLGk9SHIodC5zaGFwZSxlLHIpLHM9cXIobixlLmxlbmd0aCksdT1LcihpLG4sZS5sZW5ndGgpO3JldHVybiB0LnJlc2hhcGUobykudHJhbnNwb3NlKGEpLnJlc2hhcGUoaSkuc2xpY2Uocyx1KX0sby5wcm90b3R5cGUuc3BhY2VUb0JhdGNoTkQ9ZnVuY3Rpb24odCxlLG4pe0hoKFt0XSxcInNwYWNlVG9CYXRjaE5EXCIpO3ZhciByPWUucmVkdWNlKChmdW5jdGlvbih0LGUpe3JldHVybiB0KmV9KSksbz1bWzAsMF1dO28ucHVzaC5hcHBseShvLG4pO2Zvcih2YXIgYT0xK2UubGVuZ3RoO2E8dC5zaGFwZS5sZW5ndGg7KythKW8ucHVzaChbMCwwXSk7dmFyIGk9dC5wYWQobykscz16cihpLnNoYXBlLGUsciwhMSksdT1HcihzLmxlbmd0aCxlLmxlbmd0aCwhMSksYz1IcihpLnNoYXBlLGUsciwhMSk7cmV0dXJuIGkucmVzaGFwZShzKS50cmFuc3Bvc2UodSkucmVzaGFwZShjKX0sby5wcm90b3R5cGUucG9vbD1mdW5jdGlvbih0LGUsbil7SGgodCxcInBvb2xcIik7Zm9yKHZhciByPWUuc3RyaWRlSGVpZ2h0LG89ZS5zdHJpZGVXaWR0aCxhPWUuZGlsYXRpb25IZWlnaHQsaT1lLmRpbGF0aW9uV2lkdGgscz1lLmVmZmVjdGl2ZUZpbHRlckhlaWdodCx1PWUuZWZmZWN0aXZlRmlsdGVyV2lkdGgsYz1lLnBhZEluZm8udG9wLGw9ZS5wYWRJbmZvLmxlZnQsaD1cIm1heFwiPT09bj9OdW1iZXIuTkVHQVRJVkVfSU5GSU5JVFk6TnVtYmVyLlBPU0lUSVZFX0lORklOSVRZLGY9dGhpcy5yZWFkU3luYyh0LmRhdGFJZCksZD1kcihlLm91dFNoYXBlLHQuZHR5cGUpLHA9ZC52YWx1ZXMsdj1lLm91dFNoYXBlWzFdKmUub3V0U2hhcGVbMl0qZS5vdXRTaGFwZVszXSxtPWUub3V0U2hhcGVbMl0qZS5vdXRTaGFwZVszXSxnPWUub3V0U2hhcGVbM10seT0wO3k8ZS5iYXRjaFNpemU7Kyt5KWZvcih2YXIgeD15KnYsYj15KnQuc3RyaWRlc1swXSx3PTA7dzxlLmluQ2hhbm5lbHM7Kyt3KWZvcih2YXIgQz0wO0M8ZS5vdXRIZWlnaHQ7KytDKWZvcih2YXIgRT1DKnItYyxSPU1hdGgubWF4KDAsRSksST1NYXRoLm1pbihlLmluSGVpZ2h0LHMrRSksaz14K0MqbSxTPTA7UzxlLm91dFdpZHRoOysrUyl7Zm9yKHZhciBBPVMqby1sLEQ9TWF0aC5tYXgoMCxBKSxUPU1hdGgubWluKGUuaW5XaWR0aCx1K0EpLE49aCxGPTAsXz0wLE89UjtPPEk7Tys9YSl7Zm9yKHZhciBNPWIrTyp0LnN0cmlkZXNbMV0sQj1EO0I8VDtCKz1pKXt2YXIgUD1mW00rQip0LnN0cmlkZXNbMl0rd107XCJtYXhcIj09PW4mJlA+Tj9OPVA6XCJhdmdcIj09PW4mJihGKz1QLF8rKyl9aWYoaXNOYU4oTikpYnJlYWt9cFtrK1MqZyt3XT1cImF2Z1wiPT09bj9GL186Tn1yZXR1cm4gZC50b1RlbnNvcigpfSxvLnByb3RvdHlwZS5tYXhQb29sPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIHRoaXMucG9vbCh0LGUsXCJtYXhcIil9LG8ucHJvdG90eXBlLm1heFBvb2xQb3NpdGlvbnM9ZnVuY3Rpb24odCxlKXtmb3IodmFyIG49ZHIoZS5vdXRTaGFwZSxcImludDMyXCIpLHI9ZS5zdHJpZGVIZWlnaHQsbz1lLnN0cmlkZVdpZHRoLGE9ZS5kaWxhdGlvbkhlaWdodCxpPWUuZGlsYXRpb25XaWR0aCxzPWUuZWZmZWN0aXZlRmlsdGVySGVpZ2h0LHU9ZS5lZmZlY3RpdmVGaWx0ZXJXaWR0aCxjPWUucGFkSW5mby50b3AsbD1lLnBhZEluZm8ubGVmdCxoPXRoaXMuYnVmZmVyU3luYyh0KSxmPTA7ZjxlLmJhdGNoU2l6ZTsrK2YpZm9yKHZhciBkPTA7ZDxlLmluQ2hhbm5lbHM7KytkKWZvcih2YXIgcD0wO3A8ZS5vdXRIZWlnaHQ7KytwKXtmb3IodmFyIHY9cCpyLWMsbT12O208MDspbSs9YTtmb3IodmFyIGc9TWF0aC5taW4oZS5pbkhlaWdodCxzK3YpLHk9MDt5PGUub3V0V2lkdGg7Kyt5KXtmb3IodmFyIHg9eSpvLWwsYj14O2I8MDspYis9aTtmb3IodmFyIHc9TWF0aC5taW4oZS5pbldpZHRoLHUreCksQz1OdW1iZXIuTkVHQVRJVkVfSU5GSU5JVFksRT0tMSxSPW07UjxnO1IrPWEpZm9yKHZhciBJPVItdixrPWI7azx3O2srPWkpe3ZhciBTPWsteCxBPWguZ2V0KGYsUixrLGQpO0E+QyYmKEM9QSxFPUkqdStTKX1uLnNldChFLGYscCx5LGQpfX1yZXR1cm4gbi50b1RlbnNvcigpfSxvLnByb3RvdHlwZS5tYXhQb29sQmFja3Byb3A9ZnVuY3Rpb24odCxlLG4scil7SGgoW2Usbl0sXCJtYXhQb29sQmFja3Byb3BcIik7Zm9yKHZhciBvPXRoaXMubWF4UG9vbFBvc2l0aW9ucyhlLHIpLGE9ci5zdHJpZGVIZWlnaHQsaT1yLnN0cmlkZVdpZHRoLHM9ci5kaWxhdGlvbkhlaWdodCx1PXIuZGlsYXRpb25XaWR0aCxjPXIuZWZmZWN0aXZlRmlsdGVySGVpZ2h0LGw9ci5lZmZlY3RpdmVGaWx0ZXJXaWR0aCxoPWwtMS1yLnBhZEluZm8ubGVmdCxmPWMtMS1yLnBhZEluZm8udG9wLGQ9ZHIoZS5zaGFwZSxcImZsb2F0MzJcIikscD10aGlzLmJ1ZmZlclN5bmMobyksdj10aGlzLmJ1ZmZlclN5bmModCksbT0wO208ci5iYXRjaFNpemU7KyttKWZvcih2YXIgZz0wO2c8ci5pbkNoYW5uZWxzOysrZylmb3IodmFyIHk9MDt5PHIuaW5IZWlnaHQ7Kyt5KWZvcih2YXIgeD0wO3g8ci5pbldpZHRoOysreCl7Zm9yKHZhciBiPXktZix3PXgtaCxDPTAsRT0wO0U8YztFKz1zKXt2YXIgUj0oYitFKS9hO2lmKCEoUjwwfHxSPj1yLm91dEhlaWdodHx8TWF0aC5mbG9vcihSKSE9PVIpKWZvcih2YXIgST0wO0k8bDtJKz11KXt2YXIgaz0odytJKS9pO2lmKCEoazwwfHxrPj1yLm91dFdpZHRofHxNYXRoLmZsb29yKGspIT09aykpe3ZhciBTPWMqbC0xLXAuZ2V0KG0sUixrLGcpPT09RSpsK0k/MTowO2lmKDAhPT1TKUMrPXYuZ2V0KG0sUixrLGcpKlN9fX1kLnNldChDLG0seSx4LGcpfXJldHVybiBkLnRvVGVuc29yKCl9LG8ucHJvdG90eXBlLmF2Z1Bvb2xCYWNrcHJvcD1mdW5jdGlvbih0LGUsbil7SGgoW3QsZV0sXCJhdmdQb29sQmFja3Byb3BcIik7Zm9yKHZhciByPW4uc3RyaWRlSGVpZ2h0LG89bi5zdHJpZGVXaWR0aCxhPW4uZmlsdGVySGVpZ2h0LGk9bi5maWx0ZXJXaWR0aCxzPW4uZGlsYXRpb25IZWlnaHQsdT1uLmRpbGF0aW9uV2lkdGgsYz1uLmVmZmVjdGl2ZUZpbHRlckhlaWdodCxsPW4uZWZmZWN0aXZlRmlsdGVyV2lkdGgsaD1sLTEtbi5wYWRJbmZvLmxlZnQsZj1jLTEtbi5wYWRJbmZvLnRvcCxkPWRyKGUuc2hhcGUsXCJmbG9hdDMyXCIpLHA9MS8oYSppKSx2PXRoaXMuYnVmZmVyU3luYyh0KSxtPTA7bTxuLmJhdGNoU2l6ZTsrK20pZm9yKHZhciBnPTA7ZzxuLmluQ2hhbm5lbHM7KytnKWZvcih2YXIgeT0wO3k8bi5pbkhlaWdodDsrK3kpZm9yKHZhciB4PTA7eDxuLmluV2lkdGg7Kyt4KXtmb3IodmFyIGI9eS1mLHc9eC1oLEM9MCxFPTA7RTxjO0UrPXMpe3ZhciBSPShiK0UpL3I7aWYoIShSPDB8fFI+PW4ub3V0SGVpZ2h0fHxNYXRoLmZsb29yKFIpIT09UikpZm9yKHZhciBJPTA7STxsO0krPXUpe3ZhciBrPSh3K0kpL287aWYoIShrPDB8fGs+PW4ub3V0V2lkdGh8fE1hdGguZmxvb3IoaykhPT1rKSlDKz12LmdldChtLFIsayxnKX19ZC5zZXQoQypwLG0seSx4LGcpfXJldHVybiBkLnRvVGVuc29yKCl9LG8ucHJvdG90eXBlLnBvb2wzZD1mdW5jdGlvbih0LGUsbil7SGgodCxcInBvb2wzZFwiKTtmb3IodmFyIHI9ZS5zdHJpZGVEZXB0aCxvPWUuc3RyaWRlSGVpZ2h0LGE9ZS5zdHJpZGVXaWR0aCxpPWUuZGlsYXRpb25EZXB0aCxzPWUuZGlsYXRpb25IZWlnaHQsdT1lLmRpbGF0aW9uV2lkdGgsYz1lLmVmZmVjdGl2ZUZpbHRlckRlcHRoLGw9ZS5lZmZlY3RpdmVGaWx0ZXJIZWlnaHQsaD1lLmVmZmVjdGl2ZUZpbHRlcldpZHRoLGY9ZS5wYWRJbmZvLmZyb250LGQ9ZS5wYWRJbmZvLnRvcCxwPWUucGFkSW5mby5sZWZ0LHY9XCJtYXhcIj09PW4/TnVtYmVyLk5FR0FUSVZFX0lORklOSVRZOk51bWJlci5QT1NJVElWRV9JTkZJTklUWSxtPXRoaXMucmVhZFN5bmModC5kYXRhSWQpLGc9ZHIoZS5vdXRTaGFwZSx0LmR0eXBlKSx5PWcudmFsdWVzLHg9ZS5vdXRTaGFwZVsxXSplLm91dFNoYXBlWzJdKmUub3V0U2hhcGVbM10qZS5vdXRTaGFwZVs0XSxiPWUub3V0U2hhcGVbMl0qZS5vdXRTaGFwZVszXSplLm91dFNoYXBlWzRdLHc9ZS5vdXRTaGFwZVszXSplLm91dFNoYXBlWzRdLEM9ZS5vdXRTaGFwZVs0XSxFPTA7RTxlLmJhdGNoU2l6ZTsrK0UpZm9yKHZhciBSPUUqeCxJPUUqdC5zdHJpZGVzWzBdLGs9MDtrPGUuaW5DaGFubmVsczsrK2spZm9yKHZhciBTPTA7UzxlLm91dERlcHRoOysrUyl7Zm9yKHZhciBBPVMqci1mLEQ9QTtEPDA7KUQrPWk7Zm9yKHZhciBUPU1hdGgubWluKGUuaW5EZXB0aCxjK0EpLE49UitTKmIsRj0wO0Y8ZS5vdXRIZWlnaHQ7KytGKXtmb3IodmFyIF89RipvLWQsTz1fO088MDspTys9cztmb3IodmFyIE09TWF0aC5taW4oZS5pbkhlaWdodCxsK18pLEI9TitGKncsUD0wO1A8ZS5vdXRXaWR0aDsrK1Ape2Zvcih2YXIgTD1QKmEtcCxXPUw7VzwwOylXKz11O2Zvcih2YXIgVT1NYXRoLm1pbihlLmluV2lkdGgsaCtMKSxWPUIrUCpDLHo9dixHPTAsSD0wLHE9RDtxPFQ7cSs9aSl7Zm9yKHZhciBLPUkrcSp0LnN0cmlkZXNbMV0saj1PO2o8TTtqKz1zKXtmb3IodmFyIFg9SytqKnQuc3RyaWRlc1syXSxZPVc7WTxVO1krPXUpe3ZhciAkPW1bWCtZKnQuc3RyaWRlc1szXStrXTtpZihcIm1heFwiPT09biYmJD56P3o9JDpcImF2Z1wiPT09biYmKEcrPSQsSCsrKSxpc05hTih6KSlicmVha31pZihpc05hTih6KSlicmVha31pZihpc05hTih6KSlicmVha315W1Yra109XCJhdmdcIj09PW4/Ry9IOnp9fX1yZXR1cm4gZy50b1RlbnNvcigpfSxvLnByb3RvdHlwZS5hdmdQb29sM2Q9ZnVuY3Rpb24odCxlKXtyZXR1cm4gSGgodCxcImF2Z1Bvb2wzZFwiKSx0aGlzLnBvb2wzZCh0LGUsXCJhdmdcIikudG9GbG9hdCgpfSxvLnByb3RvdHlwZS5hdmdQb29sM2RCYWNrcHJvcD1mdW5jdGlvbih0LGUsbil7SGgoW3QsZV0sXCJhdmdQb29sM2RCYWNrcHJvcFwiKTtmb3IodmFyIHI9bi5zdHJpZGVEZXB0aCxvPW4uc3RyaWRlSGVpZ2h0LGE9bi5zdHJpZGVXaWR0aCxpPW4uZmlsdGVyRGVwdGgscz1uLmZpbHRlckhlaWdodCx1PW4uZmlsdGVyV2lkdGgsYz1uLmRpbGF0aW9uRGVwdGgsbD1uLmRpbGF0aW9uSGVpZ2h0LGg9bi5kaWxhdGlvbldpZHRoLGY9bi5lZmZlY3RpdmVGaWx0ZXJEZXB0aCxkPW4uZWZmZWN0aXZlRmlsdGVySGVpZ2h0LHA9bi5lZmZlY3RpdmVGaWx0ZXJXaWR0aCx2PWYtMS1uLnBhZEluZm8uZnJvbnQsbT1wLTEtbi5wYWRJbmZvLmxlZnQsZz1kLTEtbi5wYWRJbmZvLnRvcCx5PWRyKGUuc2hhcGUsXCJmbG9hdDMyXCIpLHg9MS8oaSpzKnUpLGI9dGhpcy5idWZmZXJTeW5jKHQpLHc9MDt3PG4uYmF0Y2hTaXplOysrdylmb3IodmFyIEM9MDtDPG4uaW5DaGFubmVsczsrK0MpZm9yKHZhciBFPTA7RTxuLmluRGVwdGg7KytFKWZvcih2YXIgUj0wO1I8bi5pbkhlaWdodDsrK1IpZm9yKHZhciBJPTA7STxuLmluV2lkdGg7KytJKXtmb3IodmFyIGs9RS12LFM9Ui1nLEE9SS1tLEQ9MCxUPTA7VDxmO1QrPWMpe3ZhciBOPShrK1QpL3I7aWYoIShOPDB8fE4+PW4ub3V0RGVwdGh8fE1hdGguZmxvb3IoTikhPT1OKSlmb3IodmFyIEY9MDtGPGQ7Ris9bCl7dmFyIF89KFMrRikvbztpZighKF88MHx8Xz49bi5vdXRIZWlnaHR8fE1hdGguZmxvb3IoXykhPT1fKSlmb3IodmFyIE89MDtPPHA7Tys9aCl7dmFyIE09KEErTykvYTtpZighKE08MHx8TT49bi5vdXRXaWR0aHx8TWF0aC5mbG9vcihNKSE9PU0pKUQrPWIuZ2V0KHcsTixfLE0sQyl9fX15LnNldChEKngsdyxFLFIsSSxDKX1yZXR1cm4geS50b1RlbnNvcigpfSxvLnByb3RvdHlwZS5tYXhQb29sM2Q9ZnVuY3Rpb24odCxlKXtyZXR1cm4gSGgodCxcIm1heFBvb2wzZFwiKSx0aGlzLnBvb2wzZCh0LGUsXCJtYXhcIikudG9GbG9hdCgpfSxvLnByb3RvdHlwZS5tYXhQb29sM2RQb3NpdGlvbnM9ZnVuY3Rpb24odCxlKXtmb3IodmFyIG49ZHIoZS5vdXRTaGFwZSxcImludDMyXCIpLHI9ZS5zdHJpZGVEZXB0aCxvPWUuc3RyaWRlSGVpZ2h0LGE9ZS5zdHJpZGVXaWR0aCxpPWUuZGlsYXRpb25EZXB0aCxzPWUuZGlsYXRpb25IZWlnaHQsdT1lLmRpbGF0aW9uV2lkdGgsYz1lLmVmZmVjdGl2ZUZpbHRlckRlcHRoLGw9ZS5lZmZlY3RpdmVGaWx0ZXJIZWlnaHQsaD1lLmVmZmVjdGl2ZUZpbHRlcldpZHRoLGY9ZS5wYWRJbmZvLmZyb250LGQ9ZS5wYWRJbmZvLnRvcCxwPWUucGFkSW5mby5sZWZ0LHY9dGhpcy5idWZmZXJTeW5jKHQpLG09MDttPGUuYmF0Y2hTaXplOysrbSlmb3IodmFyIGc9MDtnPGUuaW5DaGFubmVsczsrK2cpZm9yKHZhciB5PTA7eTxlLm91dERlcHRoOysreSl7Zm9yKHZhciB4PXkqci1mLGI9eDtiPDA7KWIrPWk7Zm9yKHZhciB3PU1hdGgubWluKGUuaW5EZXB0aCxjK3gpLEM9MDtDPGUub3V0SGVpZ2h0OysrQyl7Zm9yKHZhciBFPUMqby1kLFI9RTtSPDA7KVIrPXM7Zm9yKHZhciBJPU1hdGgubWluKGUuaW5IZWlnaHQsbCtFKSxrPTA7azxlLm91dFdpZHRoOysrayl7Zm9yKHZhciBTPWsqYS1wLEE9UztBPDA7KUErPXU7Zm9yKHZhciBEPU1hdGgubWluKGUuaW5XaWR0aCxoK1MpLFQ9TnVtYmVyLk5FR0FUSVZFX0lORklOSVRZLE49LTEsRj1iO0Y8dztGKz1pKWZvcih2YXIgXz1GLXgsTz1SO088STtPKz1zKWZvcih2YXIgTT1PLUUsQj1BO0I8RDtCKz11KXt2YXIgUD1CLVMsTD12LmdldChtLEYsTyxCLGcpO0w+PVQmJihUPUwsTj1fKmwqaCtNKmwrUCl9bi5zZXQoTixtLHksQyxrLGcpfX19cmV0dXJuIG4udG9UZW5zb3IoKX0sby5wcm90b3R5cGUubWF4UG9vbDNkQmFja3Byb3A9ZnVuY3Rpb24odCxlLG4scil7SGgoW2Usbl0sXCJtYXhQb29sM2RCYWNrcHJvcFwiKTtmb3IodmFyIG89dGhpcy5tYXhQb29sM2RQb3NpdGlvbnMoZSxyKSxhPXIuc3RyaWRlRGVwdGgsaT1yLnN0cmlkZUhlaWdodCxzPXIuc3RyaWRlV2lkdGgsdT1yLmRpbGF0aW9uRGVwdGgsYz1yLmRpbGF0aW9uSGVpZ2h0LGw9ci5kaWxhdGlvbldpZHRoLGg9ci5lZmZlY3RpdmVGaWx0ZXJEZXB0aCxmPXIuZWZmZWN0aXZlRmlsdGVySGVpZ2h0LGQ9ci5lZmZlY3RpdmVGaWx0ZXJXaWR0aCxwPWgtMS1yLnBhZEluZm8uZnJvbnQsdj1kLTEtci5wYWRJbmZvLmxlZnQsbT1mLTEtci5wYWRJbmZvLnRvcCxnPWRyKGUuc2hhcGUsXCJmbG9hdDMyXCIpLHk9dGhpcy5idWZmZXJTeW5jKG8pLHg9dGhpcy5idWZmZXJTeW5jKHQpLGI9MDtiPHIuYmF0Y2hTaXplOysrYilmb3IodmFyIHc9MDt3PHIuaW5DaGFubmVsczsrK3cpZm9yKHZhciBDPTA7QzxyLmluRGVwdGg7KytDKWZvcih2YXIgRT0wO0U8ci5pbkhlaWdodDsrK0UpZm9yKHZhciBSPTA7UjxyLmluV2lkdGg7KytSKXtmb3IodmFyIEk9Qy1wLGs9RS1tLFM9Ui12LEE9MCxEPTA7RDxoO0QrPXUpe3ZhciBUPShJK0QpL2E7aWYoIShUPDB8fFQ+PXIub3V0RGVwdGh8fE1hdGguZmxvb3IoVCkhPT1UKSlmb3IodmFyIE49MDtOPGY7Tis9Yyl7dmFyIEY9KGsrTikvaTtpZighKEY8MHx8Rj49ci5vdXRIZWlnaHR8fE1hdGguZmxvb3IoRikhPT1GKSlmb3IodmFyIF89MDtfPGQ7Xys9bCl7dmFyIE89KFMrXykvcztpZighKE88MHx8Tz49ci5vdXRXaWR0aHx8TWF0aC5mbG9vcihPKSE9PU8pKXt2YXIgTT1oKmYqZC0xLXkuZ2V0KGIsVCxGLE8sdyk9PT1EKmYqZCtOKmQrXz8xOjA7aWYoMCE9PU0pQSs9eC5nZXQoYixULEYsTyx3KSpNfX19fWcuc2V0KEEsYixDLEUsUix3KX1yZXR1cm4gZy50b1RlbnNvcigpfSxvLnByb3RvdHlwZS5jYXN0PWZ1bmN0aW9uKHQsZSl7cmV0dXJuIFBvKHQsZSx0aGlzKX0sby5wcm90b3R5cGUucmVzaGFwZT1mdW5jdGlvbih0LGUpe3JldHVybiBMbyh0LGUpfSxvLnByb3RvdHlwZS5hdmdQb29sPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIEhoKHQsXCJhdmdQb29sXCIpLHRoaXMucG9vbCh0LGUsXCJhdmdcIikudG9GbG9hdCgpfSxvLnByb3RvdHlwZS5yZXNpemVCaWxpbmVhcj1mdW5jdGlvbih0LGUsbixyKXtIaCh0LFwicmVzaXplQmlsaW5lYXJcIik7Zm9yKHZhciBvPXQuc2hhcGUsYT1vWzBdLGk9b1sxXSxzPW9bMl0sdT1vWzNdLGM9dGhpcy5yZWFkU3luYyh0LmRhdGFJZCksbD1uZXcgRmxvYXQzMkFycmF5KGsoW2EsZSxuLHVdKSksaD1bciYmZT4xP2ktMTppLHImJm4+MT9zLTE6c10sZj1bciYmZT4xP2UtMTplLHImJm4+MT9uLTE6bl0sZD0wLHA9aFswXS9mWzBdLHY9aFsxXS9mWzFdLG09MDttPGE7bSsrKWZvcih2YXIgZz0wO2c8ZTtnKyspZm9yKHZhciB5PXAqZyx4PU1hdGguZmxvb3IoeSksYj15LXgsdz1NYXRoLm1pbihpLTEsTWF0aC5jZWlsKHkpKSxDPW0qdC5zdHJpZGVzWzBdK3gqdC5zdHJpZGVzWzFdLEU9bSp0LnN0cmlkZXNbMF0rdyp0LnN0cmlkZXNbMV0sUj0wO1I8bjtSKyspZm9yKHZhciBJPXYqUixTPU1hdGguZmxvb3IoSSksQT1JLVMsRD1NYXRoLm1pbihzLTEsTWF0aC5jZWlsKEkpKSxUPUMrUyp0LnN0cmlkZXNbMl0sTj1FK1MqdC5zdHJpZGVzWzJdLEY9QytEKnQuc3RyaWRlc1syXSxfPUUrRCp0LnN0cmlkZXNbMl0sTz0wO088dTtPKyspe3ZhciBNPWNbVCtPXSxCPWNbTitPXSxQPU0rKGNbRitPXS1NKSpBLEw9UCsoQisoY1tfK09dLUIpKkEtUCkqYjtsW2QrK109TH1yZXR1cm4gRm4obCxbYSxlLG4sdV0pfSxvLnByb3RvdHlwZS5yZXNpemVCaWxpbmVhckJhY2twcm9wPWZ1bmN0aW9uKHQsZSxuKXtIaChbdCxlXSxcInJlc2l6ZUJpbGluZWFyQmFja3Byb3BcIik7Zm9yKHZhciByPWUuc2hhcGUsbz1yWzBdLGE9clsxXSxpPXJbMl0scz1yWzNdLHU9dC5zaGFwZSxjPXVbMV0sbD11WzJdLGg9bmV3IEZsb2F0MzJBcnJheShvKmEqaSpzKSxmPVtuJiZjPjE/YS0xOmEsbiYmbD4xP2ktMTppXSxkPVtuJiZjPjE/Yy0xOmMsbiYmbD4xP2wtMTpsXSxwPWZbMF0vZFswXSx2PWZbMV0vZFsxXSxtPXRoaXMucmVhZFN5bmModC5kYXRhSWQpLGc9MCx5PTA7eTxvO3krKylmb3IodmFyIHg9eSplLnN0cmlkZXNbMF0sYj0wO2I8YztiKyspZm9yKHZhciB3PWIqcCxDPU1hdGguZmxvb3IodyksRT1NYXRoLm1pbihNYXRoLmNlaWwodyksYS0xKSxSPXgrQyplLnN0cmlkZXNbMV0sST14K0UqZS5zdHJpZGVzWzFdLGs9dy1DLFM9MS1rLEE9MDtBPGw7QSsrKWZvcih2YXIgRD1BKnYsVD1NYXRoLmZsb29yKEQpLE49TWF0aC5taW4oTWF0aC5jZWlsKEQpLGktMSksRj1ELVQsXz0xLUYsTz1SK1QqZS5zdHJpZGVzWzJdLE09UitOKmUuc3RyaWRlc1syXSxCPUkrVCplLnN0cmlkZXNbMl0sUD1JK04qZS5zdHJpZGVzWzJdLEw9UypfLFc9UypGLFU9aypfLFY9aypGLHo9MDt6PHM7eisrKXt2YXIgRz1tW2crK107aFtPK3pdKz1HKkwsaFtNK3pdKz1HKlcsaFtCK3pdKz1HKlUsaFtQK3pdKz1HKlZ9cmV0dXJuIExuKGgsW28saSxhLHNdLGUuZHR5cGUpfSxvLnByb3RvdHlwZS5yZXNpemVOZWFyZXN0TmVpZ2hib3I9ZnVuY3Rpb24odCxlLG4scil7SGgodCxcInJlc2l6ZU5lYXJlc3ROZWlnaGJvclwiKTtmb3IodmFyIG89dC5zaGFwZSxhPW9bMF0saT1vWzFdLHM9b1syXSx1PW9bM10sYz10aGlzLnJlYWRTeW5jKHQuZGF0YUlkKSxsPW5ldyBGbG9hdDMyQXJyYXkoYSplKm4qdSksaD1bciYmZT4xP2ktMTppLHImJm4+MT9zLTE6c10sZj1bciYmZT4xP2UtMTplLHImJm4+MT9uLTE6bl0sZD1oWzBdL2ZbMF0scD1oWzFdL2ZbMV0sdj0wLG09MDttPGE7bSsrKWZvcih2YXIgZz1tKnQuc3RyaWRlc1swXSx5PTA7eTxlO3krKylmb3IodmFyIHg9ZCp5LGI9ZytNYXRoLm1pbihpLTEscj9NYXRoLnJvdW5kKHgpOk1hdGguZmxvb3IoeCkpKnQuc3RyaWRlc1sxXSx3PTA7dzxuO3crKylmb3IodmFyIEM9cCp3LEU9YitNYXRoLm1pbihzLTEscj9NYXRoLnJvdW5kKEMpOk1hdGguZmxvb3IoQykpKnQuc3RyaWRlc1syXSxSPTA7Ujx1O1IrKyl7dmFyIEk9Y1tFK1JdO2xbdisrXT1JfXJldHVybiBGbihsLFthLGUsbix1XSx0LmR0eXBlKX0sby5wcm90b3R5cGUucmVzaXplTmVhcmVzdE5laWdoYm9yQmFja3Byb3A9ZnVuY3Rpb24odCxlLG4pe0hoKFt0LGVdLFwicmVzaXplTmVhcmVzdE5laWdoYm9yQmFja3Byb3BcIik7Zm9yKHZhciByPWUuc2hhcGUsbz1yWzBdLGE9clsxXSxpPXJbMl0scz1yWzNdLHU9dC5zaGFwZSxjPXVbMV0sbD11WzJdLGg9bmV3IEZsb2F0MzJBcnJheShvKmEqaSpzKSxmPXRoaXMucmVhZFN5bmModC5kYXRhSWQpLGQ9W24mJmM+MT9hLTE6YSxuJiZsPjE/aS0xOmldLHA9W24mJmM+MT9jLTE6YyxuJiZsPjE/bC0xOmxdLHY9ZFswXS9wWzBdLG09ZFsxXS9wWzFdLGc9MS92LHk9MS9tLHg9MipNYXRoLmNlaWwoZykrMixiPTIqTWF0aC5jZWlsKHkpKzIsdz0wO3c8bzt3KyspZm9yKHZhciBDPXcqZS5zdHJpZGVzWzBdLEU9MDtFPGE7RSsrKWZvcih2YXIgUj1DK0UqZS5zdHJpZGVzWzFdLEk9TWF0aC5mbG9vcihFKmcpLGs9TWF0aC5mbG9vcihJLXgvMiksUz0wO1M8aTtTKyspZm9yKHZhciBBPVIrUyplLnN0cmlkZXNbMl0sRD1NYXRoLmZsb29yKFMqeSksVD1NYXRoLmZsb29yKEQtYi8yKSxOPTA7TjxzO04rKyl7Zm9yKHZhciBGPTAsXz0wO188eDtfKyspe3ZhciBPPV8raztpZighKE88MHx8Tz49Yykpe3ZhciBNPUMrTyp0LnN0cmlkZXNbMV0sQj1PKnY7aWYoRT09PU1hdGgubWluKGEtMSxuP01hdGgucm91bmQoQik6TWF0aC5mbG9vcihCKSkpZm9yKHZhciBQPTA7UDxiO1ArKyl7dmFyIEw9UCtUO2lmKCEoTDwwfHxMPj1sKSl7dmFyIFc9TStMKnQuc3RyaWRlc1syXSxVPUwqbTtTPT09TWF0aC5taW4oaS0xLG4/TWF0aC5yb3VuZChVKTpNYXRoLmZsb29yKFUpKSYmKEYrPWZbVytOXSl9fX19aFtBK05dPUZ9cmV0dXJuIExuKGgsZS5zaGFwZSxlLmR0eXBlKX0sby5wcm90b3R5cGUuYmF0Y2hOb3JtYWxpemF0aW9uPWZ1bmN0aW9uKHQsZSxuLHIsbyxhKXtIaChbdCxlLG4sbyxhXSxcImJhdGNoTm9ybVwiKTtmb3IodmFyIGk9dGhpcy5yZWFkU3luYyh0LmRhdGFJZCkscz10aGlzLnJlYWRTeW5jKGUuZGF0YUlkKSx1PXRoaXMucmVhZFN5bmMobi5kYXRhSWQpLGM9bz90aGlzLnJlYWRTeW5jKG8uZGF0YUlkKTpuZXcgRmxvYXQzMkFycmF5KFsxXSksbD1hP3RoaXMucmVhZFN5bmMoYS5kYXRhSWQpOm5ldyBGbG9hdDMyQXJyYXkoWzBdKSxoPW5ldyBGbG9hdDMyQXJyYXkoaS5sZW5ndGgpLGY9bC5sZW5ndGgsZD1jLmxlbmd0aCxwPXUubGVuZ3RoLHY9cy5sZW5ndGgsbT0wLGc9MCx5PTAseD0wLGI9MDtiPGkubGVuZ3RoOysrYiloW2JdPWxbbSsrXSsoaVtiXS1zW2crK10pKmNbeSsrXS9NYXRoLnNxcnQodVt4KytdK3IpLG0+PWYmJihtPTApLGc+PXYmJihnPTApLHk+PWQmJih5PTApLHg+PXAmJih4PTApO3JldHVybiBMbihoLHQuc2hhcGUpfSxvLnByb3RvdHlwZS5sb2NhbFJlc3BvbnNlTm9ybWFsaXphdGlvbjREPWZ1bmN0aW9uKHQsZSxuLHIsbyl7SGgodCxcImxvY2FsUmVzcG9uc2VOb3JtYWxpemF0aW9uNERcIik7dmFyIGE9dC5zaGFwZVszXSxpPWEtMSxzPXRoaXMucmVhZFN5bmModC5kYXRhSWQpLHU9dC5zaXplLGM9bmV3IEZsb2F0MzJBcnJheSh1KTtmdW5jdGlvbiBsKHQpe2Zvcih2YXIgbj10JWEscj10LW4rTWF0aC5tYXgoMCxuLWUpLG89dC1uK01hdGgubWluKG4rZSxpKSx1PTA7cjw9bztyKyspe3ZhciBjPXNbcl07dSs9YypjfXJldHVybiB1fWZvcih2YXIgaD0wO2g8dTtoKyspe3ZhciBmPWwoaCksZD1zW2hdKk1hdGgucG93KG4rcipmLC1vKTtjW2hdPWR9cmV0dXJuIExuKGMsdC5zaGFwZSl9LG8ucHJvdG90eXBlLkxSTkdyYWQ9ZnVuY3Rpb24odCxlLG4scixvLGEsaSl7SGgodCxcIkxSTkdyYWRcIik7Zm9yKHZhciBzPXQuc2hhcGVbM10sdT10aGlzLnJlYWRTeW5jKHQuZGF0YUlkKSxjPXRoaXMucmVhZFN5bmMoZS5kYXRhSWQpLGw9dGhpcy5yZWFkU3luYyhuLmRhdGFJZCksaD1uZXcgRmxvYXQzMkFycmF5KHQuc2l6ZSksZj10LnNpemUsZD0wO2Q8ZjtkKyspe2Zvcih2YXIgcD1kJXMsdj1kLXArTWF0aC5tYXgoMCxwLXIpLG09ZC1wK01hdGgubWluKHMscCtyKzEpLGc9MCx5PXY7eTxtO3krKylnKz1NYXRoLnBvdyhjW3ldLDIpO2c9YSpnK287Zm9yKHk9djt5PG07eSsrKXt2YXIgeD0tMiphKmkqY1t5XSpsW2RdL2c7ZD09PXkmJih4Kz1NYXRoLnBvdyhnLC1pKSkseCo9dVtkXSxoW3ldKz14fX1yZXR1cm4gTG4oaCx0LnNoYXBlKX0sby5wcm90b3R5cGUubXVsdGlub21pYWw9ZnVuY3Rpb24odCxlLG4scil7SGgodCxcIm11bHRpbm9taWFsXCIpO2Zvcih2YXIgbz1lP3Q6Z28odCksYT1vLnNoYXBlWzBdLGk9by5zaGFwZVsxXSxzPUduKFthLG5dLFwiaW50MzJcIiksdT10aGlzLnJlYWRTeW5jKHMuZGF0YUlkKSxjPXRoaXMucmVhZFN5bmMoby5kYXRhSWQpLGw9MDtsPGE7KytsKXt2YXIgaD1sKmksZj1uZXcgRmxvYXQzMkFycmF5KGktMSk7ZlswXT1jW2hdO2Zvcih2YXIgZD0xO2Q8Zi5sZW5ndGg7KytkKWZbZF09ZltkLTFdK2NbaCtkXTtmb3IodmFyIHA9Y3Ioci50b1N0cmluZygpKSx2PWwqbixtPTA7bTxuOysrbSl7dmFyIGc9cCgpO3VbdittXT1mLmxlbmd0aDtmb3IodmFyIHk9MDt5PGYubGVuZ3RoO3krKylpZihnPGZbeV0pe3VbdittXT15O2JyZWFrfX19cmV0dXJuIHN9LG8ucHJvdG90eXBlLm9uZUhvdD1mdW5jdGlvbih0LGUsbixyKXtIaCh0LFwib25lSG90XCIpO3ZhciBvPW5ldyBGbG9hdDMyQXJyYXkodC5zaXplKmUpO28uZmlsbChyKTtmb3IodmFyIGE9dGhpcy5yZWFkU3luYyh0LmRhdGFJZCksaT0wO2k8dC5zaXplOysraSlhW2ldPj0wJiZhW2ldPGUmJihvW2kqZSthW2ldXT1uKTtyZXR1cm4gQm4obyxbdC5zaXplLGVdLFwiaW50MzJcIil9LG8ucHJvdG90eXBlLm5vbk1heFN1cHByZXNzaW9uPWZ1bmN0aW9uKHQsZSxuLHIsbyl7cmV0dXJuIEhoKHQsXCJub25NYXhTdXBwcmVzc2lvblwiKSxqbyh0aGlzLnJlYWRTeW5jKHQuZGF0YUlkKSx0aGlzLnJlYWRTeW5jKGUuZGF0YUlkKSxuLHIsbyl9LG8ucHJvdG90eXBlLmZmdD1mdW5jdGlvbih0KXtyZXR1cm4gdGhpcy5mZnRCYXRjaCh0LCExKX0sby5wcm90b3R5cGUuaWZmdD1mdW5jdGlvbih0KXtyZXR1cm4gdGhpcy5mZnRCYXRjaCh0LCEwKX0sby5wcm90b3R5cGUuZmZ0QmF0Y2g9ZnVuY3Rpb24odCxlKXtmb3IodmFyIG49dC5zaGFwZVswXSxyPXQuc2hhcGVbMV0sbz1kcih0LnNoYXBlLFwiZmxvYXQzMlwiKSxhPWRyKHQuc2hhcGUsXCJmbG9hdDMyXCIpLGk9VG4odCkuYXMyRChuLHIpLHM9Tm4odCkuYXMyRChuLHIpLHU9MDt1PG47dSsrKWZvcih2YXIgYz1pLnNsaWNlKFt1LDBdLFsxLHJdKSxsPXMuc2xpY2UoW3UsMF0sWzEscl0pLGg9RG4oYyxsKSxmPXRoaXMucmVhZFN5bmModGhpcy5mZnRJbXBsKGgsZSkuZGF0YUlkKSxkPTA7ZDxyO2QrKyl7dmFyIHA9em8oZixkKTtvLnZhbHVlc1t1KnIrZF09cC5yZWFsLGEudmFsdWVzW3UqcitkXT1wLmltYWd9cmV0dXJuIERuKG8udG9UZW5zb3IoKSxhLnRvVGVuc29yKCkpLmFzMkQobixyKX0sby5wcm90b3R5cGUuZmZ0SW1wbD1mdW5jdGlvbih0LGUpe3ZhciBuPXQuYXMxRCgpLHI9bi5zaXplO2lmKHRoaXMuaXNFeHBvbmVudE9mMihyKSl7dmFyIG89dGhpcy5mZnRSYWRpeDIobixyLGUpLmFzMkQodC5zaGFwZVswXSx0LnNoYXBlWzFdKTtyZXR1cm4gZSYmKG89RG4oVG4obykuZGl2KE9uKHIpKSxObihvKS5kaXYoT24ocikpKSksb312YXIgYT10aGlzLnJlYWRTeW5jKHQuZGF0YUlkKSxpPWZ1bmN0aW9uKHQpe2Zvcih2YXIgZT1uZXcgRmxvYXQzMkFycmF5KHQubGVuZ3RoLzIpLG49bmV3IEZsb2F0MzJBcnJheSh0Lmxlbmd0aC8yKSxyPTA7cjx0Lmxlbmd0aDtyKz0yKWVbci8yXT10W3JdLG5bci8yXT10W3IrMV07cmV0dXJue3JlYWw6ZSxpbWFnOm59fSh0aGlzLmZvdXJpZXJUcmFuc2Zvcm1CeU1hdG11bChhLHIsZSkpO3JldHVybiBEbihpLnJlYWwsaS5pbWFnKS5hczJEKHQuc2hhcGVbMF0sdC5zaGFwZVsxXSl9LG8ucHJvdG90eXBlLmlzRXhwb25lbnRPZjI9ZnVuY3Rpb24odCl7cmV0dXJuIDA9PSh0JnQtMSl9LG8ucHJvdG90eXBlLmZmdFJhZGl4Mj1mdW5jdGlvbih0LGUsbil7aWYoMT09PWUpcmV0dXJuIHQ7dmFyIHI9dGhpcy5yZWFkU3luYyh0LmRhdGFJZCksbz1lLzIsYT1mdW5jdGlvbih0KXtmb3IodmFyIGU9TWF0aC5jZWlsKHQubGVuZ3RoLzQpLG49bmV3IEZsb2F0MzJBcnJheShlKSxyPW5ldyBGbG9hdDMyQXJyYXkoZSksbz0wO288dC5sZW5ndGg7bys9NCluW01hdGguZmxvb3Ioby80KV09dFtvXSxyW01hdGguZmxvb3Ioby80KV09dFtvKzFdO3JldHVybntyZWFsOm4saW1hZzpyfX0ociksaT1EbihhLnJlYWwsYS5pbWFnKS5hczFEKCkscz1mdW5jdGlvbih0KXtmb3IodmFyIGU9TWF0aC5mbG9vcih0Lmxlbmd0aC80KSxuPW5ldyBGbG9hdDMyQXJyYXkoZSkscj1uZXcgRmxvYXQzMkFycmF5KGUpLG89MjtvPHQubGVuZ3RoO28rPTQpbltNYXRoLmZsb29yKG8vNCldPXRbb10scltNYXRoLmZsb29yKG8vNCldPXRbbysxXTtyZXR1cm57cmVhbDpuLGltYWc6cn19KHIpLHU9RG4ocy5yZWFsLHMuaW1hZykuYXMxRCgpO2k9dGhpcy5mZnRSYWRpeDIoaSxvLG4pLHU9dGhpcy5mZnRSYWRpeDIodSxvLG4pO3ZhciBjPWZ1bmN0aW9uKHQsZSl7Zm9yKHZhciBuPW5ldyBGbG9hdDMyQXJyYXkodC8yKSxyPW5ldyBGbG9hdDMyQXJyYXkodC8yKSxvPTA7bzxNYXRoLmNlaWwodC8yKTtvKyspe3ZhciBhPShlPzI6LTIpKk1hdGguUEkqKG8vdCk7bltvXT1NYXRoLmNvcyhhKSxyW29dPU1hdGguc2luKGEpfXJldHVybntyZWFsOm4saW1hZzpyfX0oZSxuKSxsPURuKGMucmVhbCxjLmltYWcpLm11bCh1KSxoPWkuYWRkKGwpLGY9aS5zdWIobCksZD1UbihoKS5jb25jYXQoVG4oZikpLHA9Tm4oaCkuY29uY2F0KE5uKGYpKTtyZXR1cm4gRG4oZCxwKS5hczFEKCl9LG8ucHJvdG90eXBlLmZvdXJpZXJUcmFuc2Zvcm1CeU1hdG11bD1mdW5jdGlvbih0LGUsbil7Zm9yKHZhciByPW5ldyBGbG9hdDMyQXJyYXkoMiplKSxvPTA7bzxlO28rKyl7Zm9yKHZhciBhPTAsaT0wLHM9MDtzPGU7cysrKXt2YXIgdT1IbyhvKnMsZSxuKSxjPXpvKHQscyk7YSs9Yy5yZWFsKnUucmVhbC1jLmltYWcqdS5pbWFnLGkrPWMucmVhbCp1LmltYWcrYy5pbWFnKnUucmVhbH1uJiYoYS89ZSxpLz1lKSxHbyhyLGEsaSxvKX1yZXR1cm4gcn0sby5wcm90b3R5cGUuZGVwdGhUb1NwYWNlPWZ1bmN0aW9uKHQsZSxuKXtDKFwiTkhXQ1wiPT09biwoZnVuY3Rpb24oKXtyZXR1cm5cIk9ubHkgTkhXQyBkYXRhRm9ybWF0IHN1cHBvcnRlZCBvbiBDUFUgZm9yIGRlcHRoVG9TcGFjZS4gR290IFwiK259KSksQyhlPjEsKGZ1bmN0aW9uKCl7cmV0dXJuXCJibG9ja1NpemUgc2hvdWxkIGJlID4gMSBmb3IgZGVwdGhUb1NwYWNlLCBidXQgd2FzOiBcIitlfSkpO2Zvcih2YXIgcj10LnNoYXBlWzBdLG89dC5zaGFwZVsxXSxhPXQuc2hhcGVbMl0saT10LnNoYXBlWzNdLHM9byplLHU9YSplLGM9aS8oZSplKSxsPXRoaXMucmVhZFN5bmModC5kYXRhSWQpLGg9bmV3IEZsb2F0MzJBcnJheShyKnMqdSpjKSxmPTAsZD0wO2Q8cjsrK2QpZm9yKHZhciBwPTA7cDxzOysrcClmb3IodmFyIHY9TWF0aC5mbG9vcihwL2UpLG09cCVlLGc9MDtnPHU7KytnKWZvcih2YXIgeT1NYXRoLmZsb29yKGcvZSkseD0obSplK2clZSkqYyxiPTA7YjxjOysrYil7dmFyIHc9Yit4K2kqKHkrYSooditvKmQpKTtoW2YrK109bFt3XX1yZXR1cm4gTG4oaCxbcixzLHUsY10pfSxvLnByb3RvdHlwZS5icm9hZGNhc3RlZEJpbmFyeU9wPWZ1bmN0aW9uKHQsZSxuLHIpe3ZhciBvPVJvKHQuc2hhcGUsZS5zaGFwZSksYT1kcihvLG4pLGk9dGhpcy5yZWFkU3luYyh0LmRhdGFJZCkscz10aGlzLnJlYWRTeW5jKGUuZGF0YUlkKSx1PUNvKHQuc2hhcGUsbyksYz1DbyhlLnNoYXBlLG8pLGw9YS52YWx1ZXM7aWYodS5sZW5ndGgrYy5sZW5ndGg9PT0wKWZvcih2YXIgaD0wO2g8bC5sZW5ndGg7KytoKWxbaF09cihpW2glaS5sZW5ndGhdLHNbaCVzLmxlbmd0aF0pO2Vsc2V7dmFyIGY9dGhpcy5idWZmZXJTeW5jKHQpLGQ9dGhpcy5idWZmZXJTeW5jKGUpLHA9ZnVuY3Rpb24obil7dmFyIG89YS5pbmRleFRvTG9jKG4pLGg9by5zbGljZSgtdC5yYW5rKTt1LmZvckVhY2goKGZ1bmN0aW9uKHQpe3JldHVybiBoW3RdPTB9KSk7dmFyIHA9Zi5sb2NUb0luZGV4KGgpLHY9by5zbGljZSgtZS5yYW5rKTtjLmZvckVhY2goKGZ1bmN0aW9uKHQpe3JldHVybiB2W3RdPTB9KSk7dmFyIG09ZC5sb2NUb0luZGV4KHYpO2xbbl09cihpW3BdLHNbbV0pfTtmb3IoaD0wO2g8bC5sZW5ndGg7KytoKXAoaCl9cmV0dXJuIGEudG9UZW5zb3IoKX0sby5wcm90b3R5cGUuYnJvYWRjYXN0ZWRCaW5hcnlDb21wbGV4T3A9ZnVuY3Rpb24odCxlLG4pe3ZhciByPVJvKHQuc2hhcGUsZS5zaGFwZSksbz1kcihyLFwiZmxvYXQzMlwiKSxhPWRyKHIsXCJmbG9hdDMyXCIpLGk9dGhpcy5yZWFkU3luYyh0LmRhdGFJZCkscz10aGlzLnJlYWRTeW5jKGUuZGF0YUlkKSx1PUNvKHQuc2hhcGUsciksYz1DbyhlLnNoYXBlLHIpLGw9by52YWx1ZXMsaD1hLnZhbHVlcztpZih1Lmxlbmd0aCtjLmxlbmd0aD09PTApZm9yKHZhciBmPTA7ZjxsLmxlbmd0aDtmKyspe3ZhciBkPWYlaS5sZW5ndGgscD1mJXMubGVuZ3RoLHY9bihpWzIqZF0saVsyKmQrMV0sc1syKnBdLHNbMipwKzFdKTtsW2ZdPXYucmVhbCxoW2ZdPXYuaW1hZ31lbHNle3ZhciBtPXRoaXMuYnVmZmVyU3luYyh0aGlzLmRhdGEuZ2V0KHQuZGF0YUlkKS5jb21wbGV4VGVuc29ycy5yZWFsKSxnPXRoaXMuYnVmZmVyU3luYyh0aGlzLmRhdGEuZ2V0KGUuZGF0YUlkKS5jb21wbGV4VGVuc29ycy5yZWFsKSx5PWZ1bmN0aW9uKHIpe3ZhciBhPW8uaW5kZXhUb0xvYyhyKSxmPWEuc2xpY2UoLXQucmFuayk7dS5mb3JFYWNoKChmdW5jdGlvbih0KXtyZXR1cm4gZlt0XT0wfSkpO3ZhciBkPW0ubG9jVG9JbmRleChmKSxwPWEuc2xpY2UoLWUucmFuayk7Yy5mb3JFYWNoKChmdW5jdGlvbih0KXtyZXR1cm4gcFt0XT0wfSkpO3ZhciB2PWcubG9jVG9JbmRleChwKSx5PW4oaVsyKmRdLGlbMipkKzFdLHNbMip2XSxzWzIqdisxXSk7bFtyXT15LnJlYWwsaFtyXT15LmltYWd9O2ZvcihmPTA7ZjxsLmxlbmd0aDtmKyspeShmKX1yZXR1cm4gdGhpcy5jb21wbGV4KG8udG9UZW5zb3IoKSxhLnRvVGVuc29yKCkpfSxvLnByb3RvdHlwZS5zcGxpdD1mdW5jdGlvbih0LGUsbil7cmV0dXJuIFpvKHQsZSxuKX0sby5wcm90b3R5cGUuZGlzcG9zZT1mdW5jdGlvbigpe30sby5wcm90b3R5cGUuZmxvYXRQcmVjaXNpb249ZnVuY3Rpb24oKXtyZXR1cm4gMzJ9LG8ucHJvdG90eXBlLmVwc2lsb249ZnVuY3Rpb24oKXtyZXR1cm4gMWUtN30sby5wcm90b3R5cGUuY3JvcEFuZFJlc2l6ZT1mdW5jdGlvbih0LGUsbixyLG8sYSl7Zm9yKHZhciBpPXQuc2hhcGUscz1pWzBdLHU9aVsxXSxjPWlbMl0sbD1pWzNdLGg9ZS5zaGFwZVswXSxmPXJbMF0sZD1yWzFdLHA9ZHIoW2gsZixkLGxdLFwiZmxvYXQzMlwiKSx2PXRoaXMucmVhZFN5bmMoZS5kYXRhSWQpLG09dGhpcy5yZWFkU3luYyhuLmRhdGFJZCksZz10aGlzLnJlYWRTeW5jKHQuZGF0YUlkKSx5PXQuc3RyaWRlcyx4PXAuc3RyaWRlcyxiPTA7YjxoO2IrKyl7dmFyIHc9NCpiLEM9dlt3XSxFPXZbdysxXSxSPXZbdysyXSxJPXZbdyszXSxrPW1bYl07aWYoIShrPj1zKSlmb3IodmFyIFM9Zj4xPyhSLUMpKih1LTEpLyhmLTEpOjAsQT1kPjE/KEktRSkqKGMtMSkvKGQtMSk6MCxEPTA7RDxmO0QrKyl7dmFyIFQ9Zj4xP0MqKHUtMSkrRCpTOi41KihDK1IpKih1LTEpO2lmKFQ8MHx8VD51LTEpZm9yKHZhciBOPTA7TjxkO04rKylmb3IodmFyIEY9MDtGPGw7RisrKXt2YXIgXz1GK04qeFsyXStEKnhbMV0rYip4WzBdO3AudmFsdWVzW19dPWF9ZWxzZSBpZihcImJpbGluZWFyXCI9PT1vKXt2YXIgTz1NYXRoLmZsb29yKFQpLE09TWF0aC5jZWlsKFQpLEI9VC1PO2ZvcihOPTA7TjxkO04rKyl7aWYoKHE9ZD4xP0UqKGMtMSkrTipBOi41KihFK0kpKihjLTEpKTwwfHxxPmMtMSlmb3IoRj0wO0Y8bDtGKyspe189RitOKnhbMl0rRCp4WzFdK2IqeFswXTtwLnZhbHVlc1tfXT1hfWVsc2V7dmFyIFA9TWF0aC5mbG9vcihxKSxMPU1hdGguY2VpbChxKSxXPXEtUDtmb3IoRj0wO0Y8bDtGKyspe3ZhciBVPWdbXz1GK1AqeVsyXStPKnlbMV0rayp5WzBdXSxWPWdbXz1GK0wqeVsyXStPKnlbMV0rayp5WzBdXSx6PWdbXz1GK1AqeVsyXStNKnlbMV0rayp5WzBdXSxHPVUrKFYtVSkqVyxIPXorKGdbXz1GK0wqeVsyXStNKnlbMV0rayp5WzBdXS16KSpXO189RitOKnhbMl0rRCp4WzFdK2IqeFswXSxwLnZhbHVlc1tfXT1HKyhILUcpKkJ9fX19ZWxzZSBmb3IoTj0wO048ZDsrK04pe3ZhciBxO2lmKChxPWQ+MT9FKihjLTEpK04qQTouNSooRStJKSooYy0xKSk8MHx8cT5jLTEpZm9yKEY9MDtGPGw7RisrKXtfPUYrTip4WzJdK0QqeFsxXStiKnhbMF07cC52YWx1ZXNbX109YX1lbHNle3ZhciBLPU1hdGgucm91bmQocSksaj1NYXRoLnJvdW5kKFQpO2ZvcihGPTA7RjxsO0YrKyl7dmFyIFg9RitLKnlbMl0raip5WzFdK2sqeVswXSxZPUYrTip4WzJdK0QqeFsxXStiKnhbMF07cC52YWx1ZXNbWV09Z1tYXX19fX19cmV0dXJuIHAudG9UZW5zb3IoKX0sby5wcm90b3R5cGUuc3BhcnNlVG9EZW5zZT1mdW5jdGlvbih0LGUsbixyKXt2YXIgbz1acigwLHQsbiksYT1vLnNsaWNlUmFuayxpPW8ubnVtVXBkYXRlcyxzPW8uc2xpY2VTaXplLHU9by5zdHJpZGVzLGM9by5vdXRwdXRTaXplO3JldHVybiB0aGlzLnNjYXR0ZXIodCxlLG4sYyxzLGksYSx1LHIsITEpfSxvLnByb3RvdHlwZS5nYXRoZXJORD1mdW5jdGlvbih0LGUpe3ZhciBuPWUuc2hhcGUscj1uW24ubGVuZ3RoLTFdLG89anIodCxlKSxhPW9bMF0saT1vWzFdLHM9b1syXSx1PW9bM107aWYoMD09PWkpcmV0dXJuIEZuKFtdLGEsdC5kdHlwZSk7Zm9yKHZhciBjPW5ldyBndChbaSxzXSx0LmR0eXBlKSxsPXRoaXMucmVhZFN5bmMoZS5kYXRhSWQpLGg9dGhpcy5yZWFkU3luYyh0LmRhdGFJZCksZj0wO2Y8aTtmKyspe2Zvcih2YXIgZD1bXSxwPTAsdj0wO3Y8cjt2Kyspe3ZhciBtPWxbZipyK3ZdO3ArPW0qdVt2XSxkLnB1c2gobSl9aWYocDwwfHxwPj10LnNpemUvcyl0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGluZGljZXM6IFwiK2QrXCIgZG9lcyBub3QgaW5kZXggaW50byBcIit0LnNoYXBlKTtmb3IodmFyIGc9MDtnPHM7ZysrKWMudmFsdWVzW2YqcytnXT1oW3AqcytnXX1yZXR1cm4gYy50b1RlbnNvcigpLnJlc2hhcGUoYSl9LG8ucHJvdG90eXBlLnNjYXR0ZXJORD1mdW5jdGlvbih0LGUsbil7dmFyIHI9WnIoMCx0LG4pLG89ci5zbGljZVJhbmssYT1yLm51bVVwZGF0ZXMsaT1yLnNsaWNlU2l6ZSxzPXIuc3RyaWRlcyx1PXIub3V0cHV0U2l6ZSxjPU9uKDApO3JldHVybiB0aGlzLnNjYXR0ZXIodCxlLG4sdSxpLGEsbyxzLGMsITApfSxvLnByb3RvdHlwZS5maWxsPWZ1bmN0aW9uKHQsZSxuKXt2YXIgcj1QKG49bnx8aihlKSxrKHQpKTtyZXR1cm4gci5maWxsKGUpLEx0Lm1ha2VUZW5zb3Iocix0LG4sdGhpcyl9LG8ucHJvdG90eXBlLm9uZXNMaWtlPWZ1bmN0aW9uKHQpe2lmKFwic3RyaW5nXCI9PT10LmR0eXBlKXRocm93IG5ldyBFcnJvcihcIm9uZXNMaWtlIGlzIG5vdCBzdXBwb3J0ZWQgZm9yIHN0cmluZyB0ZW5zb3JzXCIpO3JldHVybiB0aGlzLmZpbGwodC5zaGFwZSwxLHQuZHR5cGUpfSxvLnByb3RvdHlwZS56ZXJvc0xpa2U9ZnVuY3Rpb24odCl7dmFyIGU9UCh0LmR0eXBlLGsodC5zaGFwZSkpO3JldHVybiB0aGlzLm1ha2VPdXRwdXQoZSx0LnNoYXBlLHQuZHR5cGUpfSxvLnByb3RvdHlwZS5saW5zcGFjZT1mdW5jdGlvbih0LGUsbil7cmV0dXJuIFdvKHQsZSxuKX0sby5wcm90b3R5cGUuc2NhdHRlcj1mdW5jdGlvbih0LGUsbixyLG8sYSxpLHMsdSxjKXt2YXIgbD1bci9vLG9dLGg9dGhpcy5yZWFkU3luYyh0LmRhdGFJZCksZj10aGlzLnJlYWRTeW5jKGUuZGF0YUlkKTtpZigwPT09cilyZXR1cm4gRm4oW10sbixlLmR0eXBlKTt2YXIgZD1uZXcgZ3QobCxlLmR0eXBlKTtkLnZhbHVlcy5maWxsKHRoaXMucmVhZFN5bmModS5kYXRhSWQpWzBdKTtmb3IodmFyIHA9MDtwPGE7cCsrKXtmb3IodmFyIHY9W10sbT0wLGc9MDtnPGk7ZysrKXt2YXIgeT1oW3AqaStnXTt2LnB1c2goeSksbSs9eSpzW2ddfWlmKG08MHx8bT49ci9vKXRocm93IG5ldyBFcnJvcihcIkludmFsaWQgaW5kaWNlczogXCIrditcIiBkb2VzIG5vdCBpbmRleCBpbnRvIFwiK24pO2Zvcih2YXIgeD0wO3g8bzt4KyspYz9kLnZhbHVlc1ttKm8reF0rPWZbcCpvK3hdOmQudmFsdWVzW20qbyt4XT0wPT09ZS5yYW5rP2ZbMF06ZltwKm8reF19cmV0dXJuIGQudG9UZW5zb3IoKS5yZXNoYXBlKG4pfSxvfShibyk7THQucmVnaXN0ZXJCYWNrZW5kKFwiY3B1XCIsKGZ1bmN0aW9uKCl7cmV0dXJuIG5ldyBLaH0pLDEpO2Zvcih2YXIgamg9MCxYaD1be2tlcm5lbE5hbWU6XCJOb25NYXhTdXBwcmVzc2lvblY1XCIsYmFja2VuZE5hbWU6XCJjcHVcIixrZXJuZWxGdW5jOmZ1bmN0aW9uKHQpe3ZhciBlPXQuaW5wdXRzLG49dC5iYWNrZW5kLHI9dC5hdHRycyxvPWUsYT1vLmJveGVzLGk9by5zY29yZXMscz1yLHU9cy5tYXhPdXRwdXRTaXplLGM9cy5pb3VUaHJlc2hvbGQsbD1zLnNjb3JlVGhyZXNob2xkLGg9cy5zb2Z0Tm1zU2lnbWEsZj1uO0hoKGEsXCJOb25NYXhTdXBwcmVzc2lvbldpdGhTY29yZVwiKTt2YXIgZD1YbyhmLmRhdGEuZ2V0KGEuZGF0YUlkKS52YWx1ZXMsZi5kYXRhLmdldChpLmRhdGFJZCkudmFsdWVzLHUsYyxsLGgpO3JldHVybltkLnNlbGVjdGVkSW5kaWNlcyxkLnNlbGVjdGVkU2NvcmVzXX19LHtrZXJuZWxOYW1lOlwiU3F1YXJlXCIsYmFja2VuZE5hbWU6XCJjcHVcIixrZXJuZWxGdW5jOmZ1bmN0aW9uKHQpe3ZhciBlPXQuaW5wdXRzLG49dC5iYWNrZW5kLHI9ZS54LG89bjtIaChyLFwic3F1YXJlXCIpO2Zvcih2YXIgYT1vLmRhdGEuZ2V0KHIuZGF0YUlkKS52YWx1ZXMsaT1uZXcgRmxvYXQzMkFycmF5KGEubGVuZ3RoKSxzPTA7czxhLmxlbmd0aDsrK3Mpe3ZhciB1PWFbc107aVtzXT11KnV9cmV0dXJue2RhdGFJZDpvLndyaXRlKGksci5zaGFwZSxyLmR0eXBlKSxzaGFwZTpyLnNoYXBlLGR0eXBlOnIuZHR5cGV9fX0se2tlcm5lbE5hbWU6ZXUsYmFja2VuZE5hbWU6XCJjcHVcIixrZXJuZWxGdW5jOmZ1bmN0aW9uKHQpe3ZhciBlPXQuaW5wdXRzLG49dC5iYWNrZW5kLHI9ZSxvPXIuYSxhPXIuYixpPW47SGgoW28sYV0sZXUpO3ZhciBzPWkuZGF0YS5nZXQoby5kYXRhSWQpLnZhbHVlcyx1PWkuZGF0YS5nZXQoYS5kYXRhSWQpLnZhbHVlcyxjPWZ1bmN0aW9uKHQsZSxuLHIsbyxhKXt2YXIgaT1Sbyh0LGUpLHM9aS5sZW5ndGgsdT0kKGkpLGM9QihvLGsoaSkpLGw9dC5sZW5ndGgsaD1lLmxlbmd0aCxmPSQodCksZD0kKGUpLHA9Q28odCxpKSx2PUNvKGUsaSk7aWYocC5sZW5ndGgrdi5sZW5ndGg9PT0wKWZvcih2YXIgbT0wO208Yy5sZW5ndGg7KyttKWNbbV09YShuW20lbi5sZW5ndGhdLHJbbSVyLmxlbmd0aF0pO2Vsc2V7dmFyIGc9ZnVuY3Rpb24odCl7dmFyIGU9aXQodCxzLHUpLG89ZS5zbGljZSgtbCk7cC5mb3JFYWNoKChmdW5jdGlvbih0KXtyZXR1cm4gb1t0XT0wfSkpO3ZhciBpPWF0KG8sbCxmKSxtPWUuc2xpY2UoLWgpO3YuZm9yRWFjaCgoZnVuY3Rpb24odCl7cmV0dXJuIG1bdF09MH0pKTt2YXIgZz1hdChtLGgsZCk7Y1t0XT1hKG5baV0scltnXSl9O2ZvcihtPTA7bTxjLmxlbmd0aDsrK20pZyhtKX1yZXR1cm5bYyxpXX0oby5zaGFwZSxhLnNoYXBlLHMsdSxvLmR0eXBlLChmdW5jdGlvbih0LGUpe3ZhciBuPXQtZTtyZXR1cm4gbipufSkpLGw9Y1swXSxoPWNbMV07cmV0dXJue2RhdGFJZDppLndyaXRlKGwsaCxvLmR0eXBlKSxzaGFwZTpoLGR0eXBlOm8uZHR5cGV9fX1dO2poPFhoLmxlbmd0aDtqaCsrKXtkKFhoW2poXSl9dmFyIFloLCRoPWZ1bmN0aW9uKHQpe3RoaXMudmFyaWFibGVOYW1lcz1bXCJBXCJdO3ZhciBlPXVhKCksbj10WzBdLHI9dFsxXTt0aGlzLm91dHB1dFNoYXBlPXQsdGhpcy51c2VyQ29kZT1cIlxcbiAgICAgIHZvaWQgbWFpbigpIHtcXG4gICAgICAgIGl2ZWMzIGNvb3JkcyA9IGdldE91dHB1dENvb3JkcygpO1xcbiAgICAgICAgaW50IHRleFIgPSBjb29yZHNbMF07XFxuICAgICAgICBpbnQgdGV4QyA9IGNvb3Jkc1sxXTtcXG4gICAgICAgIGludCBkZXB0aCA9IGNvb3Jkc1syXTtcXG4gICAgICAgIHZlYzIgdXYgPSAodmVjMih0ZXhDLCB0ZXhSKSArIGhhbGZDUikgLyB2ZWMyKFwiK3IrXCIuMCwgXCIrbitcIi4wKTtcXG5cXG4gICAgICAgIHZlYzQgdmFsdWVzID0gXCIrZS50ZXh0dXJlMkQrXCIoQSwgdXYpO1xcbiAgICAgICAgZmxvYXQgdmFsdWU7XFxuICAgICAgICBpZiAoZGVwdGggPT0gMCkge1xcbiAgICAgICAgICB2YWx1ZSA9IHZhbHVlcy5yO1xcbiAgICAgICAgfSBlbHNlIGlmIChkZXB0aCA9PSAxKSB7XFxuICAgICAgICAgIHZhbHVlID0gdmFsdWVzLmc7XFxuICAgICAgICB9IGVsc2UgaWYgKGRlcHRoID09IDIpIHtcXG4gICAgICAgICAgdmFsdWUgPSB2YWx1ZXMuYjtcXG4gICAgICAgIH0gZWxzZSBpZiAoZGVwdGggPT0gMykge1xcbiAgICAgICAgICB2YWx1ZSA9IHZhbHVlcy5hO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgc2V0T3V0cHV0KGZsb29yKHZhbHVlICogMjU1LjAgKyAwLjUpKTtcXG4gICAgICB9XFxuICAgIFwifSxRaD1mdW5jdGlvbih0KXt0aGlzLnZhcmlhYmxlTmFtZXM9W1wiQVwiXSx0aGlzLnBhY2tlZElucHV0cz0hMSx0aGlzLnBhY2tlZE91dHB1dD0hMDt2YXIgZT11YSgpLG49dFswXSxyPXRbMV07dGhpcy5vdXRwdXRTaGFwZT10LHRoaXMudXNlckNvZGU9XCJcXG4gICAgICB2b2lkIG1haW4oKSB7XFxuICAgICAgICBpdmVjMyBjb29yZHMgPSBnZXRPdXRwdXRDb29yZHMoKTtcXG4gICAgICAgIGludCB0ZXhSID0gY29vcmRzWzBdO1xcbiAgICAgICAgaW50IHRleEMgPSBjb29yZHNbMV07XFxuICAgICAgICBpbnQgZGVwdGggPSBjb29yZHNbMl07XFxuXFxuICAgICAgICB2ZWM0IHJlc3VsdCA9IHZlYzQoMC4pO1xcblxcbiAgICAgICAgZm9yKGludCByb3c9MDsgcm93PD0xOyByb3crKykge1xcbiAgICAgICAgICBmb3IoaW50IGNvbD0wOyBjb2w8PTE7IGNvbCsrKSB7XFxuICAgICAgICAgICAgdGV4QyA9IGNvb3Jkc1sxXSArIHJvdztcXG4gICAgICAgICAgICBkZXB0aCA9IGNvb3Jkc1syXSArIGNvbDtcXG5cXG4gICAgICAgICAgICB2ZWMyIHV2ID0gKHZlYzIodGV4QywgdGV4UikgKyBoYWxmQ1IpIC9cXG4gICAgICAgICAgICAgICAgICAgICAgIHZlYzIoXCIrcitcIi4wLCBcIituK1wiLjApO1xcbiAgICAgICAgICAgIHZlYzQgdmFsdWVzID0gXCIrZS50ZXh0dXJlMkQrXCIoQSwgdXYpO1xcbiAgICAgICAgICAgIGZsb2F0IHZhbHVlO1xcbiAgICAgICAgICAgIGlmIChkZXB0aCA9PSAwKSB7XFxuICAgICAgICAgICAgICB2YWx1ZSA9IHZhbHVlcy5yO1xcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZGVwdGggPT0gMSkge1xcbiAgICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZXMuZztcXG4gICAgICAgICAgICB9IGVsc2UgaWYgKGRlcHRoID09IDIpIHtcXG4gICAgICAgICAgICAgIHZhbHVlID0gdmFsdWVzLmI7XFxuICAgICAgICAgICAgfSBlbHNlIGlmIChkZXB0aCA9PSAzKSB7XFxuICAgICAgICAgICAgICB2YWx1ZSA9IHZhbHVlcy5hO1xcbiAgICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgICByZXN1bHRbcm93ICogMiArIGNvbF0gPSBmbG9vcih2YWx1ZSAqIDI1NS4wICsgMC41KTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgfVxcblxcbiAgICAgICAgXCIrZS5vdXRwdXQrXCIgPSByZXN1bHQ7XFxuICAgICAgfVxcbiAgICBcIn07Zm9yKHZhciBKaD0wLFpoPVt7a2VybmVsTmFtZTpcIkZyb21QaXhlbHNcIixiYWNrZW5kTmFtZTpcIndlYmdsXCIsa2VybmVsRnVuYzpmdW5jdGlvbih0KXt2YXIgZT10LmlucHV0cyxuPXQuYmFja2VuZCxyPXQuYXR0cnMsbz1lLnBpeGVscyxhPXIubnVtQ2hhbm5lbHMscz1cInVuZGVmaW5lZFwiIT10eXBlb2YgSFRNTFZpZGVvRWxlbWVudCYmbyBpbnN0YW5jZW9mIEhUTUxWaWRlb0VsZW1lbnQsdT1cInVuZGVmaW5lZFwiIT10eXBlb2YgSFRNTEltYWdlRWxlbWVudCYmbyBpbnN0YW5jZW9mIEhUTUxJbWFnZUVsZW1lbnQsYz1zP1tvLnZpZGVvV2lkdGgsby52aWRlb0hlaWdodF06W28ud2lkdGgsby5oZWlnaHRdLGw9Y1swXSxoPWNbMV0sZj1baCxsXSxkPVtoLGwsYV07KHV8fHMpJiYobnVsbD09WWgmJihZaD1kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiY2FudmFzXCIpLmdldENvbnRleHQoXCIyZFwiKSksWWguY2FudmFzLndpZHRoPWwsWWguY2FudmFzLmhlaWdodD1oLFloLmRyYXdJbWFnZShvLDAsMCxsLGgpLG89WWguY2FudmFzKTt2YXIgcD1uLm1ha2VUZW5zb3JJbmZvKGYsXCJpbnQzMlwiKTtuLnRleERhdGEuZ2V0KHAuZGF0YUlkKS51c2FnZT16dC5QSVhFTFMsbi5ncGdwdS51cGxvYWRQaXhlbERhdGFUb1RleHR1cmUobi5nZXRUZXh0dXJlKHAuZGF0YUlkKSxvKTt2YXIgdj1pKCkuZ2V0Qm9vbChcIldFQkdMX1BBQ0tcIik/bmV3IFFoKGQpOm5ldyAkaChkKSxtPW4ucnVuV2ViR0xQcm9ncmFtKHYsW3BdLFwiaW50MzJcIik7cmV0dXJuIG4uZGlzcG9zZURhdGEocC5kYXRhSWQpLG19fSx7a2VybmVsTmFtZTpcIk5vbk1heFN1cHByZXNzaW9uVjVcIixiYWNrZW5kTmFtZTpcIndlYmdsXCIsa2VybmVsRnVuYzpmdW5jdGlvbih0KXt2YXIgZT10LmlucHV0cyxuPXQuYmFja2VuZCxyPXQuYXR0cnM7ZG4oXCJ0Zi5ub25NYXhTdXBwcmVzc2lvbigpIGluIHdlYmdsIGxvY2tzIHRoZSBVSSB0aHJlYWQuIENhbGwgdGYubm9uTWF4U3VwcHJlc3Npb25Bc3luYygpIGluc3RlYWRcIik7dmFyIG89ZSxhPW8uYm94ZXMsaT1vLnNjb3JlcyxzPXIsdT1zLm1heE91dHB1dFNpemUsYz1zLmlvdVRocmVzaG9sZCxsPXMuc2NvcmVUaHJlc2hvbGQsaD1zLnNvZnRObXNTaWdtYSxmPW4sZD1YbyhmLnJlYWRTeW5jKGEuZGF0YUlkKSxmLnJlYWRTeW5jKGkuZGF0YUlkKSx1LGMsbCxoKTtyZXR1cm5bZC5zZWxlY3RlZEluZGljZXMsZC5zZWxlY3RlZFNjb3Jlc119fSx7a2VybmVsTmFtZTpcIlNxdWFyZVwiLGJhY2tlbmROYW1lOlwid2ViZ2xcIixrZXJuZWxGdW5jOmZ1bmN0aW9uKHQpe3ZhciBlPXQuaW5wdXRzLG49dC5iYWNrZW5kLHI9ZS54LG89bixhPW5ldyBDcyhyLnNoYXBlLFwicmV0dXJuIHggKiB4O1wiKTtyZXR1cm4gby5ydW5XZWJHTFByb2dyYW0oYSxbcl0sci5kdHlwZSl9fSx7a2VybmVsTmFtZTpldSxiYWNrZW5kTmFtZTpcIndlYmdsXCIsa2VybmVsRnVuYzpmdW5jdGlvbih0KXt2YXIgZT10LmlucHV0cyxuPXQuYmFja2VuZCxyPWUsbz1yLmEsYT1yLmIscz1uLHU9aSgpLmdldEJvb2woXCJXRUJHTF9QQUNLX0JJTkFSWV9PUEVSQVRJT05TXCIpP25ldyBMYShcInJldHVybiAoYSAtIGIpICogKGEgLSBiKTtcIixvLnNoYXBlLGEuc2hhcGUpOm5ldyBCYShcInJldHVybiAoYSAtIGIpICogKGEgLSBiKTtcIixvLnNoYXBlLGEuc2hhcGUpO3JldHVybiBzLmNvbXBpbGVBbmRSdW4odSxbbyxhXSl9fV07Smg8WmgubGVuZ3RoO0poKyspe2QoWmhbSmhdKX1mb3IodmFyIHRmPTAsZWY9W3trZXJuZWxOYW1lOlwiU3F1YXJlXCIsZ3JhZEZ1bmM6ZnVuY3Rpb24odCxlKXt2YXIgbj1lWzBdO3JldHVybnt4OmZ1bmN0aW9uKCl7cmV0dXJuIHQubXVsKG4udG9GbG9hdCgpLm11bCgyKSl9fX19LHtrZXJuZWxOYW1lOmV1LGdyYWRGdW5jOmZ1bmN0aW9uKHQsZSl7dmFyIG49ZVswXSxyPWVbMV0sbz1PbigyKTtyZXR1cm57YTpmdW5jdGlvbigpe3JldHVybiBnYyh0LGdjKG8sQ2MobixyKSkpfSxiOmZ1bmN0aW9uKCl7cmV0dXJuIGdjKHQsZ2MobyxDYyhyLG4pKSl9fX19XTt0ZjxlZi5sZW5ndGg7dGYrKyl7cChlZlt0Zl0pfXZhciBuZj1mdW5jdGlvbigpe2Z1bmN0aW9uIHQoKXt9cmV0dXJuIHQucHJvdG90eXBlLmZldGNoPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIGZldGNoKHQsZSl9LHQucHJvdG90eXBlLm5vdz1mdW5jdGlvbigpe3JldHVybiBwZXJmb3JtYW5jZS5ub3coKX0sdC5wcm90b3R5cGUuZW5jb2RlPWZ1bmN0aW9uKHQsZSl7aWYoXCJ1dGYtOFwiIT09ZSYmXCJ1dGY4XCIhPT1lKXRocm93IG5ldyBFcnJvcihcIkJyb3dzZXIncyBlbmNvZGVyIG9ubHkgc3VwcG9ydHMgdXRmLTgsIGJ1dCBnb3QgXCIrZSk7cmV0dXJuIG51bGw9PXRoaXMudGV4dEVuY29kZXImJih0aGlzLnRleHRFbmNvZGVyPW5ldyBUZXh0RW5jb2RlciksdGhpcy50ZXh0RW5jb2Rlci5lbmNvZGUodCl9LHQucHJvdG90eXBlLmRlY29kZT1mdW5jdGlvbih0LGUpe3JldHVybiBuZXcgVGV4dERlY29kZXIoZSkuZGVjb2RlKHQpfSx0fSgpO2koKS5nZXQoXCJJU19CUk9XU0VSXCIpJiZpKCkuc2V0UGxhdGZvcm0oXCJicm93c2VyXCIsbmV3IG5mKTt2YXIgcmYsb2Y9ZnVuY3Rpb24oKXtyZXR1cm4gcmVxdWlyZShcIm5vZGUtZmV0Y2hcIil9LGFmPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gdCgpe3RoaXMudXRpbD1yZXF1aXJlKFwidXRpbFwiKSx0aGlzLnRleHRFbmNvZGVyPW5ldyB0aGlzLnV0aWwuVGV4dEVuY29kZXJ9cmV0dXJuIHQucHJvdG90eXBlLmZldGNoPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIG51bGwhPWkoKS5nbG9iYWwuZmV0Y2g/aSgpLmdsb2JhbC5mZXRjaCh0LGUpOihudWxsPT1yZiYmKHJmPW9mKCkpLHJmKHQsZSkpfSx0LnByb3RvdHlwZS5ub3c9ZnVuY3Rpb24oKXt2YXIgdD1wcm9jZXNzLmhydGltZSgpO3JldHVybiAxZTMqdFswXSt0WzFdLzFlNn0sdC5wcm90b3R5cGUuZW5jb2RlPWZ1bmN0aW9uKHQsZSl7aWYoXCJ1dGYtOFwiIT09ZSYmXCJ1dGY4XCIhPT1lKXRocm93IG5ldyBFcnJvcihcIk5vZGUgYnVpbHQtaW4gZW5jb2RlciBvbmx5IHN1cHBvcnRzIHV0Zi04LCBidXQgZ290IFwiK2UpO3JldHVybiB0aGlzLnRleHRFbmNvZGVyLmVuY29kZSh0KX0sdC5wcm90b3R5cGUuZGVjb2RlPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIDA9PT10Lmxlbmd0aD9cIlwiOm5ldyB0aGlzLnV0aWwuVGV4dERlY29kZXIoZSkuZGVjb2RlKHQpfSx0fSgpO2koKS5nZXQoXCJJU19OT0RFXCIpJiZpKCkuc2V0UGxhdGZvcm0oXCJub2RlXCIsbmV3IGFmKTt2YXIgc2Y9e2Zsb2F0MzI6NCxpbnQzMjo0LHVpbnQxNjoyLHVpbnQ4OjEsYm9vbDoxfSx1Zj00O2Z1bmN0aW9uIGNmKHQsZSl7Zm9yKHZhciBuPXt9LHI9MCxvPWZ1bmN0aW9uKGUpe3ZhciBvPWUubmFtZSxhPWUuZHR5cGUsaT1lLnNoYXBlLHM9ayhpKSx1PXZvaWQgMDtpZihcInF1YW50aXphdGlvblwiaW4gZSl7dmFyIGM9ZS5xdWFudGl6YXRpb247aWYoXCJ1aW50OFwiIT09Yy5kdHlwZSYmXCJ1aW50MTZcIiE9PWMuZHR5cGUpdGhyb3cgbmV3IEVycm9yKFwiV2VpZ2h0IFwiK2UubmFtZStcIiBoYXMgdW5rbm93biBxdWFudGl6YXRpb24gZHR5cGUgXCIrYy5kdHlwZStcIi4gU3VwcG9ydGVkIHF1YW50aXphdGlvbiBkdHlwZXMgYXJlOiAndWludDgnIGFuZCAndWludDE2Jy5cIik7dmFyIGw9c2ZbYy5kdHlwZV0saD10LnNsaWNlKHIscitzKmwpLGY9XCJ1aW50OFwiPT09Yy5kdHlwZT9uZXcgVWludDhBcnJheShoKTpuZXcgVWludDE2QXJyYXkoaCk7aWYoXCJmbG9hdDMyXCI9PT1hKXU9RmxvYXQzMkFycmF5LmZyb20oZiwoZnVuY3Rpb24odCl7cmV0dXJuIHQqYy5zY2FsZStjLm1pbn0pKTtlbHNle2lmKFwiaW50MzJcIiE9PWEpdGhyb3cgbmV3IEVycm9yKFwiVW5zdXBwb3J0ZWQgZHR5cGUgaW4gd2VpZ2h0ICdcIitvK1wiJzogXCIrYSk7dT1JbnQzMkFycmF5LmZyb20oZiwoZnVuY3Rpb24odCl7cmV0dXJuIE1hdGgucm91bmQodCpjLnNjYWxlK2MubWluKX0pKX1yKz1zKmx9ZWxzZSBpZihcInN0cmluZ1wiPT09YSl7dmFyIGQ9ayhlLnNoYXBlKTt1PVtdO2Zvcih2YXIgcD0wO3A8ZDtwKyspe3ZhciB2PW5ldyBVaW50MzJBcnJheSh0LnNsaWNlKHIscit1ZikpWzBdO3IrPXVmO3ZhciBtPW5ldyBVaW50OEFycmF5KHQuc2xpY2UocixyK3YpKTt1LnB1c2gobSkscis9dn19ZWxzZXt2YXIgZz1zZlthXTtoPXQuc2xpY2UocixyK3MqZyk7aWYoXCJmbG9hdDMyXCI9PT1hKXU9bmV3IEZsb2F0MzJBcnJheShoKTtlbHNlIGlmKFwiaW50MzJcIj09PWEpdT1uZXcgSW50MzJBcnJheShoKTtlbHNle2lmKFwiYm9vbFwiIT09YSl0aHJvdyBuZXcgRXJyb3IoXCJVbnN1cHBvcnRlZCBkdHlwZSBpbiB3ZWlnaHQgJ1wiK28rXCInOiBcIithKTt1PW5ldyBVaW50OEFycmF5KGgpfXIrPXMqZ31uW29dPUZuKHUsaSxhKX0sYT0wLGk9ZTthPGkubGVuZ3RoO2ErKyl7byhpW2FdKX1yZXR1cm4gbn1mdW5jdGlvbiBsZih0KXtpZihudWxsPT09dCl0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGlucHV0IHZhbHVlOiBcIitKU09OLnN0cmluZ2lmeSh0KSk7dmFyIGU9MCxuPVtdO3QuZm9yRWFjaCgoZnVuY3Rpb24odCl7aWYoZSs9dC5ieXRlTGVuZ3RoLG4ucHVzaCh0LmJ5dGVMZW5ndGg9PT10LmJ1ZmZlci5ieXRlTGVuZ3RoP3Q6bmV3IHQuY29uc3RydWN0b3IodCkpLCEodCBpbnN0YW5jZW9mIEZsb2F0MzJBcnJheXx8dCBpbnN0YW5jZW9mIEludDMyQXJyYXl8fHQgaW5zdGFuY2VvZiBVaW50OEFycmF5KSl0aHJvdyBuZXcgRXJyb3IoXCJVbnN1cHBvcnRlZCBUeXBlZEFycmF5IHN1YnR5cGU6IFwiK3QuY29uc3RydWN0b3IubmFtZSl9KSk7dmFyIHI9bmV3IFVpbnQ4QXJyYXkoZSksbz0wO3JldHVybiBuLmZvckVhY2goKGZ1bmN0aW9uKHQpe3Iuc2V0KG5ldyBVaW50OEFycmF5KHQuYnVmZmVyKSxvKSxvKz10LmJ5dGVMZW5ndGh9KSksci5idWZmZXJ9dmFyIGhmPVwidW5kZWZpbmVkXCIhPXR5cGVvZiBCdWZmZXImJihcInVuZGVmaW5lZFwiPT10eXBlb2YgQmxvYnx8XCJ1bmRlZmluZWRcIj09dHlwZW9mIGF0b2J8fFwidW5kZWZpbmVkXCI9PXR5cGVvZiBidG9hKTtmdW5jdGlvbiBmZih0KXtyZXR1cm4gaGY/QnVmZmVyLmJ5dGVMZW5ndGgodCk6bmV3IEJsb2IoW3RdKS5zaXplfWZ1bmN0aW9uIGRmKHQpe3ZhciBlPTA7dC5mb3JFYWNoKChmdW5jdGlvbih0KXtlKz10LmJ5dGVMZW5ndGh9KSk7dmFyIG49bmV3IFVpbnQ4QXJyYXkoZSkscj0wO3JldHVybiB0LmZvckVhY2goKGZ1bmN0aW9uKHQpe24uc2V0KG5ldyBVaW50OEFycmF5KHQpLHIpLHIrPXQuYnl0ZUxlbmd0aH0pKSxuLmJ1ZmZlcn1mdW5jdGlvbiBwZih0KXtmb3IodD10LnRyaW0oKTt0LmVuZHNXaXRoKFwiL1wiKTspdD10LnNsaWNlKDAsdC5sZW5ndGgtMSk7dmFyIGU9dC5zcGxpdChcIi9cIik7cmV0dXJuIGVbZS5sZW5ndGgtMV19ZnVuY3Rpb24gdmYodCl7aWYodC5tb2RlbFRvcG9sb2d5IGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpdGhyb3cgbmV3IEVycm9yKFwiRXhwZWN0ZWQgSlNPTiBtb2RlbCB0b3BvbG9neSwgcmVjZWl2ZWQgQXJyYXlCdWZmZXIuXCIpO3JldHVybntkYXRlU2F2ZWQ6bmV3IERhdGUsbW9kZWxUb3BvbG9neVR5cGU6XCJKU09OXCIsbW9kZWxUb3BvbG9neUJ5dGVzOm51bGw9PXQubW9kZWxUb3BvbG9neT8wOmZmKEpTT04uc3RyaW5naWZ5KHQubW9kZWxUb3BvbG9neSkpLHdlaWdodFNwZWNzQnl0ZXM6bnVsbD09dC53ZWlnaHRTcGVjcz8wOmZmKEpTT04uc3RyaW5naWZ5KHQud2VpZ2h0U3BlY3MpKSx3ZWlnaHREYXRhQnl0ZXM6bnVsbD09dC53ZWlnaHREYXRhPzA6dC53ZWlnaHREYXRhLmJ5dGVMZW5ndGh9fXZhciBtZj1mdW5jdGlvbigpe2Z1bmN0aW9uIHQoKXt0aGlzLnNhdmVSb3V0ZXJzPVtdLHRoaXMubG9hZFJvdXRlcnM9W119cmV0dXJuIHQuZ2V0SW5zdGFuY2U9ZnVuY3Rpb24oKXtyZXR1cm4gbnVsbD09dC5pbnN0YW5jZSYmKHQuaW5zdGFuY2U9bmV3IHQpLHQuaW5zdGFuY2V9LHQucmVnaXN0ZXJTYXZlUm91dGVyPWZ1bmN0aW9uKGUpe3QuZ2V0SW5zdGFuY2UoKS5zYXZlUm91dGVycy5wdXNoKGUpfSx0LnJlZ2lzdGVyTG9hZFJvdXRlcj1mdW5jdGlvbihlKXt0LmdldEluc3RhbmNlKCkubG9hZFJvdXRlcnMucHVzaChlKX0sdC5nZXRTYXZlSGFuZGxlcnM9ZnVuY3Rpb24oZSl7cmV0dXJuIHQuZ2V0SGFuZGxlcnMoZSxcInNhdmVcIil9LHQuZ2V0TG9hZEhhbmRsZXJzPWZ1bmN0aW9uKGUsbil7cmV0dXJuIHQuZ2V0SGFuZGxlcnMoZSxcImxvYWRcIixuKX0sdC5nZXRIYW5kbGVycz1mdW5jdGlvbihlLG4scil7dmFyIG89W107cmV0dXJuKFwibG9hZFwiPT09bj90LmdldEluc3RhbmNlKCkubG9hZFJvdXRlcnM6dC5nZXRJbnN0YW5jZSgpLnNhdmVSb3V0ZXJzKS5mb3JFYWNoKChmdW5jdGlvbih0KXt2YXIgbj10KGUscik7bnVsbCE9PW4mJm8ucHVzaChuKX0pKSxvfSx0fSgpLGdmPVwiOi8vXCIseWY9ZnVuY3Rpb24oKXtmdW5jdGlvbiB0KCl7dGhpcy5tYW5hZ2Vycz17fX1yZXR1cm4gdC5nZXRJbnN0YW5jZT1mdW5jdGlvbigpe3JldHVybiBudWxsPT10Lmluc3RhbmNlJiYodC5pbnN0YW5jZT1uZXcgdCksdC5pbnN0YW5jZX0sdC5yZWdpc3Rlck1hbmFnZXI9ZnVuY3Rpb24oZSxuKXtDKG51bGwhPWUsKGZ1bmN0aW9uKCl7cmV0dXJuXCJzY2hlbWUgbXVzdCBub3QgYmUgdW5kZWZpbmVkIG9yIG51bGwuXCJ9KSksZS5lbmRzV2l0aChnZikmJihlPWUuc2xpY2UoMCxlLmluZGV4T2YoZ2YpKSksQyhlLmxlbmd0aD4wLChmdW5jdGlvbigpe3JldHVyblwic2NoZW1lIG11c3Qgbm90IGJlIGFuIGVtcHR5IHN0cmluZy5cIn0pKTt2YXIgcj10LmdldEluc3RhbmNlKCk7QyhudWxsPT1yLm1hbmFnZXJzW2VdLChmdW5jdGlvbigpe3JldHVyblwiQSBtb2RlbCBzdG9yZSBtYW5hZ2VyIGlzIGFscmVhZHkgcmVnaXN0ZXJlZCBmb3Igc2NoZW1lICdcIitlK1wiJy5cIn0pKSxyLm1hbmFnZXJzW2VdPW59LHQuZ2V0TWFuYWdlcj1mdW5jdGlvbih0KXt2YXIgZT10aGlzLmdldEluc3RhbmNlKCkubWFuYWdlcnNbdF07aWYobnVsbD09ZSl0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgZmluZCBtb2RlbCBtYW5hZ2VyIGZvciBzY2hlbWUgJ1wiK3QrXCInXCIpO3JldHVybiBlfSx0LmdldFNjaGVtZXM9ZnVuY3Rpb24oKXtyZXR1cm4gT2JqZWN0LmtleXModGhpcy5nZXRJbnN0YW5jZSgpLm1hbmFnZXJzKX0sdH0oKTtmdW5jdGlvbiB4Zih0KXtpZigtMT09PXQuaW5kZXhPZihnZikpdGhyb3cgbmV3IEVycm9yKFwiVGhlIHVybCBzdHJpbmcgcHJvdmlkZWQgZG9lcyBub3QgY29udGFpbiBhIHNjaGVtZS4gU3VwcG9ydGVkIHNjaGVtZXMgYXJlOiBcIit5Zi5nZXRTY2hlbWVzKCkuam9pbihcIixcIikpO3JldHVybntzY2hlbWU6dC5zcGxpdChnZilbMF0scGF0aDp0LnNwbGl0KGdmKVsxXX19ZnVuY3Rpb24gYmYodCxlLG8pe3JldHVybiB2b2lkIDA9PT1vJiYobz0hMSksbih0aGlzLHZvaWQgMCx2b2lkIDAsKGZ1bmN0aW9uKCl7dmFyIG4sYSxpLHMsdSxjLGwsaCxmO3JldHVybiByKHRoaXMsKGZ1bmN0aW9uKHIpe3N3aXRjaChyLmxhYmVsKXtjYXNlIDA6cmV0dXJuIEModCE9PWUsKGZ1bmN0aW9uKCl7cmV0dXJuXCJPbGQgcGF0aCBhbmQgbmV3IHBhdGggYXJlIHRoZSBzYW1lOiAnXCIrdCtcIidcIn0pKSxDKChuPW1mLmdldExvYWRIYW5kbGVycyh0KSkubGVuZ3RoPjAsKGZ1bmN0aW9uKCl7cmV0dXJuXCJDb3B5aW5nIGZhaWxlZCBiZWNhdXNlIG5vIGxvYWQgaGFuZGxlciBpcyBmb3VuZCBmb3Igc291cmNlIFVSTCBcIit0K1wiLlwifSkpLEMobi5sZW5ndGg8MiwoZnVuY3Rpb24oKXtyZXR1cm5cIkNvcHlpbmcgZmFpbGVkIGJlY2F1c2UgbW9yZSB0aGFuIG9uZSAoXCIrbi5sZW5ndGgrXCIpIGxvYWQgaGFuZGxlcnMgZm9yIHNvdXJjZSBVUkwgXCIrdCtcIi5cIn0pKSxhPW5bMF0sQygoaT1tZi5nZXRTYXZlSGFuZGxlcnMoZSkpLmxlbmd0aD4wLChmdW5jdGlvbigpe3JldHVyblwiQ29weWluZyBmYWlsZWQgYmVjYXVzZSBubyBzYXZlIGhhbmRsZXIgaXMgZm91bmQgZm9yIGRlc3RpbmF0aW9uIFVSTCBcIitlK1wiLlwifSkpLEMoaS5sZW5ndGg8MiwoZnVuY3Rpb24oKXtyZXR1cm5cIkNvcHlpbmcgZmFpbGVkIGJlY2F1c2UgbW9yZSB0aGFuIG9uZSAoXCIrbi5sZW5ndGgrXCIpIHNhdmUgaGFuZGxlcnMgZm9yIGRlc3RpbmF0aW9uIFVSTCBcIitlK1wiLlwifSkpLHM9aVswXSx1PXhmKHQpLnNjaGVtZSxjPXhmKHQpLnBhdGgsbD11PT09eGYodCkuc2NoZW1lLFs0LGEubG9hZCgpXTtjYXNlIDE6cmV0dXJuIGg9ci5zZW50KCksbyYmbD9bNCx5Zi5nZXRNYW5hZ2VyKHUpLnJlbW92ZU1vZGVsKGMpXTpbMywzXTtjYXNlIDI6ci5zZW50KCksci5sYWJlbD0zO2Nhc2UgMzpyZXR1cm5bNCxzLnNhdmUoaCldO2Nhc2UgNDpyZXR1cm4gZj1yLnNlbnQoKSwhb3x8bD9bMyw2XTpbNCx5Zi5nZXRNYW5hZ2VyKHUpLnJlbW92ZU1vZGVsKGMpXTtjYXNlIDU6ci5zZW50KCksci5sYWJlbD02O2Nhc2UgNjpyZXR1cm5bMixmLm1vZGVsQXJ0aWZhY3RzSW5mb119fSkpfSkpfXZhciB3Zj1cIm1vZGVsc19zdG9yZVwiLENmPVwibW9kZWxfaW5mb19zdG9yZVwiO2Z1bmN0aW9uIEVmKCl7aWYoIWkoKS5nZXRCb29sKFwiSVNfQlJPV1NFUlwiKSl0aHJvdyBuZXcgRXJyb3IoXCJGYWlsZWQgdG8gb2J0YWluIEluZGV4ZWREQiBmYWN0b3J5IGJlY2F1c2UgdGhlIGN1cnJlbnQgZW52aXJvbm1lbnRpcyBub3QgYSB3ZWIgYnJvd3Nlci5cIik7dmFyIHQ9d2luZG93fHxzZWxmLGU9dC5pbmRleGVkREJ8fHQubW96SW5kZXhlZERCfHx0LndlYmtpdEluZGV4ZWREQnx8dC5tc0luZGV4ZWREQnx8dC5zaGltSW5kZXhlZERCO2lmKG51bGw9PWUpdGhyb3cgbmV3IEVycm9yKFwiVGhlIGN1cnJlbnQgYnJvd3NlciBkb2VzIG5vdCBhcHBlYXIgdG8gc3VwcG9ydCBJbmRleGVkREIuXCIpO3JldHVybiBlfWZ1bmN0aW9uIFJmKHQpe3ZhciBlPXQucmVzdWx0O2UuY3JlYXRlT2JqZWN0U3RvcmUod2Yse2tleVBhdGg6XCJtb2RlbFBhdGhcIn0pLGUuY3JlYXRlT2JqZWN0U3RvcmUoQ2Yse2tleVBhdGg6XCJtb2RlbFBhdGhcIn0pfXZhciBJZj1mdW5jdGlvbigpe2Z1bmN0aW9uIHQodCl7aWYodGhpcy5pbmRleGVkREI9RWYoKSxudWxsPT10fHwhdCl0aHJvdyBuZXcgRXJyb3IoXCJGb3IgSW5kZXhlZERCLCBtb2RlbFBhdGggbXVzdCBub3QgYmUgbnVsbCwgdW5kZWZpbmVkIG9yIGVtcHR5LlwiKTt0aGlzLm1vZGVsUGF0aD10fXJldHVybiB0LnByb3RvdHlwZS5zYXZlPWZ1bmN0aW9uKHQpe3JldHVybiBuKHRoaXMsdm9pZCAwLHZvaWQgMCwoZnVuY3Rpb24oKXtyZXR1cm4gcih0aGlzLChmdW5jdGlvbihlKXtpZih0Lm1vZGVsVG9wb2xvZ3kgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcil0aHJvdyBuZXcgRXJyb3IoXCJCcm93c2VyTG9jYWxTdG9yYWdlLnNhdmUoKSBkb2VzIG5vdCBzdXBwb3J0IHNhdmluZyBtb2RlbCB0b3BvbG9neSBpbiBiaW5hcnkgZm9ybWF0cyB5ZXQuXCIpO3JldHVyblsyLHRoaXMuZGF0YWJhc2VBY3Rpb24odGhpcy5tb2RlbFBhdGgsdCldfSkpfSkpfSx0LnByb3RvdHlwZS5sb2FkPWZ1bmN0aW9uKCl7cmV0dXJuIG4odGhpcyx2b2lkIDAsdm9pZCAwLChmdW5jdGlvbigpe3JldHVybiByKHRoaXMsKGZ1bmN0aW9uKHQpe3JldHVyblsyLHRoaXMuZGF0YWJhc2VBY3Rpb24odGhpcy5tb2RlbFBhdGgpXX0pKX0pKX0sdC5wcm90b3R5cGUuZGF0YWJhc2VBY3Rpb249ZnVuY3Rpb24odCxlKXt2YXIgbj10aGlzO3JldHVybiBuZXcgUHJvbWlzZSgoZnVuY3Rpb24odCxyKXt2YXIgbz1uLmluZGV4ZWREQi5vcGVuKFwidGVuc29yZmxvd2pzXCIsMSk7by5vbnVwZ3JhZGVuZWVkZWQ9ZnVuY3Rpb24oKXtyZXR1cm4gUmYobyl9LG8ub25zdWNjZXNzPWZ1bmN0aW9uKCl7dmFyIGE9by5yZXN1bHQ7aWYobnVsbD09ZSl7dmFyIGk9YS50cmFuc2FjdGlvbih3ZixcInJlYWRvbmx5XCIpLHM9aS5vYmplY3RTdG9yZSh3ZikuZ2V0KG4ubW9kZWxQYXRoKTtzLm9uc3VjY2Vzcz1mdW5jdGlvbigpe2lmKG51bGw9PXMucmVzdWx0KXJldHVybiBhLmNsb3NlKCkscihuZXcgRXJyb3IoXCJDYW5ub3QgZmluZCBtb2RlbCB3aXRoIHBhdGggJ1wiK24ubW9kZWxQYXRoK1wiJyBpbiBJbmRleGVkREIuXCIpKTt0KHMucmVzdWx0Lm1vZGVsQXJ0aWZhY3RzKX0scy5vbmVycm9yPWZ1bmN0aW9uKHQpe3JldHVybiBhLmNsb3NlKCkscihzLmVycm9yKX0saS5vbmNvbXBsZXRlPWZ1bmN0aW9uKCl7cmV0dXJuIGEuY2xvc2UoKX19ZWxzZXt2YXIgdSxjPXZmKGUpLGw9YS50cmFuc2FjdGlvbihDZixcInJlYWR3cml0ZVwiKSxoPWwub2JqZWN0U3RvcmUoQ2YpLGY9aC5wdXQoe21vZGVsUGF0aDpuLm1vZGVsUGF0aCxtb2RlbEFydGlmYWN0c0luZm86Y30pO2Yub25zdWNjZXNzPWZ1bmN0aW9uKCl7dmFyIG89KHU9YS50cmFuc2FjdGlvbih3ZixcInJlYWR3cml0ZVwiKSkub2JqZWN0U3RvcmUod2YpLnB1dCh7bW9kZWxQYXRoOm4ubW9kZWxQYXRoLG1vZGVsQXJ0aWZhY3RzOmUsbW9kZWxBcnRpZmFjdHNJbmZvOmN9KTtvLm9uc3VjY2Vzcz1mdW5jdGlvbigpe3JldHVybiB0KHttb2RlbEFydGlmYWN0c0luZm86Y30pfSxvLm9uZXJyb3I9ZnVuY3Rpb24odCl7dmFyIGU9KGg9bC5vYmplY3RTdG9yZShDZikpLmRlbGV0ZShuLm1vZGVsUGF0aCk7ZS5vbnN1Y2Nlc3M9ZnVuY3Rpb24oKXtyZXR1cm4gYS5jbG9zZSgpLHIoby5lcnJvcil9LGUub25lcnJvcj1mdW5jdGlvbih0KXtyZXR1cm4gYS5jbG9zZSgpLHIoby5lcnJvcil9fX0sZi5vbmVycm9yPWZ1bmN0aW9uKHQpe3JldHVybiBhLmNsb3NlKCkscihmLmVycm9yKX0sbC5vbmNvbXBsZXRlPWZ1bmN0aW9uKCl7bnVsbD09dT9hLmNsb3NlKCk6dS5vbmNvbXBsZXRlPWZ1bmN0aW9uKCl7cmV0dXJuIGEuY2xvc2UoKX19fX0sby5vbmVycm9yPWZ1bmN0aW9uKHQpe3JldHVybiByKG8uZXJyb3IpfX0pKX0sdC5VUkxfU0NIRU1FPVwiaW5kZXhlZGRiOi8vXCIsdH0oKSxrZj1mdW5jdGlvbih0KXtyZXR1cm4gaSgpLmdldEJvb2woXCJJU19CUk9XU0VSXCIpJiYhQXJyYXkuaXNBcnJheSh0KSYmdC5zdGFydHNXaXRoKElmLlVSTF9TQ0hFTUUpPyhlPXQuc2xpY2UoSWYuVVJMX1NDSEVNRS5sZW5ndGgpLG5ldyBJZihlKSk6bnVsbDt2YXIgZX07bWYucmVnaXN0ZXJTYXZlUm91dGVyKGtmKSxtZi5yZWdpc3RlckxvYWRSb3V0ZXIoa2YpO3ZhciBTZj1mdW5jdGlvbigpe2Z1bmN0aW9uIHQoKXt0aGlzLmluZGV4ZWREQj1FZigpfXJldHVybiB0LnByb3RvdHlwZS5saXN0TW9kZWxzPWZ1bmN0aW9uKCl7cmV0dXJuIG4odGhpcyx2b2lkIDAsdm9pZCAwLChmdW5jdGlvbigpe3ZhciB0PXRoaXM7cmV0dXJuIHIodGhpcywoZnVuY3Rpb24oZSl7cmV0dXJuWzIsbmV3IFByb21pc2UoKGZ1bmN0aW9uKGUsbil7dmFyIHI9dC5pbmRleGVkREIub3BlbihcInRlbnNvcmZsb3dqc1wiLDEpO3Iub251cGdyYWRlbmVlZGVkPWZ1bmN0aW9uKCl7cmV0dXJuIFJmKHIpfSxyLm9uc3VjY2Vzcz1mdW5jdGlvbigpe3ZhciB0PXIucmVzdWx0LG89dC50cmFuc2FjdGlvbihDZixcInJlYWRvbmx5XCIpLGE9by5vYmplY3RTdG9yZShDZikuZ2V0QWxsKCk7YS5vbnN1Y2Nlc3M9ZnVuY3Rpb24oKXtmb3IodmFyIHQ9e30sbj0wLHI9YS5yZXN1bHQ7bjxyLmxlbmd0aDtuKyspe3ZhciBvPXJbbl07dFtvLm1vZGVsUGF0aF09by5tb2RlbEFydGlmYWN0c0luZm99ZSh0KX0sYS5vbmVycm9yPWZ1bmN0aW9uKGUpe3JldHVybiB0LmNsb3NlKCksbihhLmVycm9yKX0sby5vbmNvbXBsZXRlPWZ1bmN0aW9uKCl7cmV0dXJuIHQuY2xvc2UoKX19LHIub25lcnJvcj1mdW5jdGlvbih0KXtyZXR1cm4gbihyLmVycm9yKX19KSldfSkpfSkpfSx0LnByb3RvdHlwZS5yZW1vdmVNb2RlbD1mdW5jdGlvbih0KXtyZXR1cm4gbih0aGlzLHZvaWQgMCx2b2lkIDAsKGZ1bmN0aW9uKCl7dmFyIGU9dGhpcztyZXR1cm4gcih0aGlzLChmdW5jdGlvbihuKXt2YXIgcjtyZXR1cm4gdD0ocj10KS5zdGFydHNXaXRoKElmLlVSTF9TQ0hFTUUpP3Iuc2xpY2UoSWYuVVJMX1NDSEVNRS5sZW5ndGgpOnIsWzIsbmV3IFByb21pc2UoKGZ1bmN0aW9uKG4scil7dmFyIG89ZS5pbmRleGVkREIub3BlbihcInRlbnNvcmZsb3dqc1wiLDEpO28ub251cGdyYWRlbmVlZGVkPWZ1bmN0aW9uKCl7cmV0dXJuIFJmKG8pfSxvLm9uc3VjY2Vzcz1mdW5jdGlvbigpe3ZhciBlLGE9by5yZXN1bHQsaT1hLnRyYW5zYWN0aW9uKENmLFwicmVhZHdyaXRlXCIpLHM9aS5vYmplY3RTdG9yZShDZiksdT1zLmdldCh0KTt1Lm9uc3VjY2Vzcz1mdW5jdGlvbigpe2lmKG51bGw9PXUucmVzdWx0KXJldHVybiBhLmNsb3NlKCkscihuZXcgRXJyb3IoXCJDYW5ub3QgZmluZCBtb2RlbCB3aXRoIHBhdGggJ1wiK3QrXCInIGluIEluZGV4ZWREQi5cIikpO3ZhciBvPXMuZGVsZXRlKHQpLGk9ZnVuY3Rpb24oKXt2YXIgbz0oZT1hLnRyYW5zYWN0aW9uKHdmLFwicmVhZHdyaXRlXCIpKS5vYmplY3RTdG9yZSh3ZikuZGVsZXRlKHQpO28ub25zdWNjZXNzPWZ1bmN0aW9uKCl7cmV0dXJuIG4odS5yZXN1bHQubW9kZWxBcnRpZmFjdHNJbmZvKX0sby5vbmVycm9yPWZ1bmN0aW9uKHQpe3JldHVybiByKHUuZXJyb3IpfX07by5vbnN1Y2Nlc3M9aSxvLm9uZXJyb3I9ZnVuY3Rpb24odCl7cmV0dXJuIGkoKSxhLmNsb3NlKCkscih1LmVycm9yKX19LHUub25lcnJvcj1mdW5jdGlvbih0KXtyZXR1cm4gYS5jbG9zZSgpLHIodS5lcnJvcil9LGkub25jb21wbGV0ZT1mdW5jdGlvbigpe251bGw9PWU/YS5jbG9zZSgpOmUub25jb21wbGV0ZT1mdW5jdGlvbigpe3JldHVybiBhLmNsb3NlKCl9fX0sby5vbmVycm9yPWZ1bmN0aW9uKHQpe3JldHVybiByKG8uZXJyb3IpfX0pKV19KSl9KSl9LHR9KCk7aWYoaSgpLmdldEJvb2woXCJJU19CUk9XU0VSXCIpKXRyeXt5Zi5yZWdpc3Rlck1hbmFnZXIoSWYuVVJMX1NDSEVNRSxuZXcgU2YpfWNhdGNoKHQpe312YXIgQWY9XCIvXCIsRGY9XCJ0ZW5zb3JmbG93anNfbW9kZWxzXCIsVGY9XCJpbmZvXCIsTmY9XCJtb2RlbF90b3BvbG9neVwiLEZmPVwid2VpZ2h0X3NwZWNzXCIsX2Y9XCJ3ZWlnaHRfZGF0YVwiLE9mPVwibW9kZWxfbWV0YWRhdGFcIjtmdW5jdGlvbiBNZih0KXtyZXR1cm57aW5mbzpbRGYsdCxUZl0uam9pbihBZiksdG9wb2xvZ3k6W0RmLHQsTmZdLmpvaW4oQWYpLHdlaWdodFNwZWNzOltEZix0LEZmXS5qb2luKEFmKSx3ZWlnaHREYXRhOltEZix0LF9mXS5qb2luKEFmKSxtb2RlbE1ldGFkYXRhOltEZix0LE9mXS5qb2luKEFmKX19ZnVuY3Rpb24gQmYodCl7dmFyIGU9dC5zcGxpdChBZik7aWYoZS5sZW5ndGg8Myl0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGtleSBmb3JtYXQ6IFwiK3QpO3JldHVybiBlLnNsaWNlKDEsZS5sZW5ndGgtMSkuam9pbihBZil9dmFyIFBmPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gdCh0KXtpZighaSgpLmdldEJvb2woXCJJU19CUk9XU0VSXCIpfHxcInVuZGVmaW5lZFwiPT10eXBlb2Ygd2luZG93fHx2b2lkIDA9PT13aW5kb3cubG9jYWxTdG9yYWdlKXRocm93IG5ldyBFcnJvcihcIlRoZSBjdXJyZW50IGVudmlyb25tZW50IGRvZXMgbm90IHN1cHBvcnQgbG9jYWwgc3RvcmFnZS5cIik7aWYodGhpcy5MUz13aW5kb3cubG9jYWxTdG9yYWdlLG51bGw9PXR8fCF0KXRocm93IG5ldyBFcnJvcihcIkZvciBsb2NhbCBzdG9yYWdlLCBtb2RlbFBhdGggbXVzdCBub3QgYmUgbnVsbCwgdW5kZWZpbmVkIG9yIGVtcHR5LlwiKTt0aGlzLm1vZGVsUGF0aD10LHRoaXMua2V5cz1NZih0aGlzLm1vZGVsUGF0aCl9cmV0dXJuIHQucHJvdG90eXBlLnNhdmU9ZnVuY3Rpb24odCl7cmV0dXJuIG4odGhpcyx2b2lkIDAsdm9pZCAwLChmdW5jdGlvbigpe3ZhciBlLG4sbztyZXR1cm4gcih0aGlzLChmdW5jdGlvbihyKXtpZih0Lm1vZGVsVG9wb2xvZ3kgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcil0aHJvdyBuZXcgRXJyb3IoXCJCcm93c2VyTG9jYWxTdG9yYWdlLnNhdmUoKSBkb2VzIG5vdCBzdXBwb3J0IHNhdmluZyBtb2RlbCB0b3BvbG9neSBpbiBiaW5hcnkgZm9ybWF0cyB5ZXQuXCIpO2U9SlNPTi5zdHJpbmdpZnkodC5tb2RlbFRvcG9sb2d5KSxuPUpTT04uc3RyaW5naWZ5KHQud2VpZ2h0U3BlY3MpLG89dmYodCk7dHJ5e3JldHVybiB0aGlzLkxTLnNldEl0ZW0odGhpcy5rZXlzLmluZm8sSlNPTi5zdHJpbmdpZnkobykpLHRoaXMuTFMuc2V0SXRlbSh0aGlzLmtleXMudG9wb2xvZ3ksZSksdGhpcy5MUy5zZXRJdGVtKHRoaXMua2V5cy53ZWlnaHRTcGVjcyxuKSx0aGlzLkxTLnNldEl0ZW0odGhpcy5rZXlzLndlaWdodERhdGEsZnVuY3Rpb24odCl7aWYoaGYpcmV0dXJuIEJ1ZmZlci5mcm9tKHQpLnRvU3RyaW5nKFwiYmFzZTY0XCIpO2Zvcih2YXIgZT1uZXcgVWludDhBcnJheSh0KSxuPVwiXCIscj0wLG89ZS5sZW5ndGg7cjxvO3IrKyluKz1TdHJpbmcuZnJvbUNoYXJDb2RlKGVbcl0pO3JldHVybiBidG9hKG4pfSh0LndlaWdodERhdGEpKSx0aGlzLkxTLnNldEl0ZW0odGhpcy5rZXlzLm1vZGVsTWV0YWRhdGEsSlNPTi5zdHJpbmdpZnkoe2Zvcm1hdDp0LmZvcm1hdCxnZW5lcmF0ZWRCeTp0LmdlbmVyYXRlZEJ5LGNvbnZlcnRlZEJ5OnQuY29udmVydGVkQnksdXNlckRlZmluZWRNZXRhZGF0YTp0LnVzZXJEZWZpbmVkTWV0YWRhdGF9KSksWzIse21vZGVsQXJ0aWZhY3RzSW5mbzpvfV19Y2F0Y2godCl7dGhyb3cgdGhpcy5MUy5yZW1vdmVJdGVtKHRoaXMua2V5cy5pbmZvKSx0aGlzLkxTLnJlbW92ZUl0ZW0odGhpcy5rZXlzLnRvcG9sb2d5KSx0aGlzLkxTLnJlbW92ZUl0ZW0odGhpcy5rZXlzLndlaWdodFNwZWNzKSx0aGlzLkxTLnJlbW92ZUl0ZW0odGhpcy5rZXlzLndlaWdodERhdGEpLHRoaXMuTFMucmVtb3ZlSXRlbSh0aGlzLmtleXMubW9kZWxNZXRhZGF0YSksbmV3IEVycm9yKFwiRmFpbGVkIHRvIHNhdmUgbW9kZWwgJ1wiK3RoaXMubW9kZWxQYXRoK1wiJyB0byBsb2NhbCBzdG9yYWdlOiBzaXplIHF1b3RhIGJlaW5nIGV4Y2VlZGVkIGlzIGEgcG9zc2libGUgY2F1c2Ugb2YgdGhpcyBmYWlsdXJlOiBtb2RlbFRvcG9sb2d5Qnl0ZXM9XCIrby5tb2RlbFRvcG9sb2d5Qnl0ZXMrXCIsIHdlaWdodFNwZWNzQnl0ZXM9XCIrby53ZWlnaHRTcGVjc0J5dGVzK1wiLCB3ZWlnaHREYXRhQnl0ZXM9XCIrby53ZWlnaHREYXRhQnl0ZXMrXCIuXCIpfXJldHVyblsyXX0pKX0pKX0sdC5wcm90b3R5cGUubG9hZD1mdW5jdGlvbigpe3JldHVybiBuKHRoaXMsdm9pZCAwLHZvaWQgMCwoZnVuY3Rpb24oKXt2YXIgdCxlLG4sbyxhLGkscztyZXR1cm4gcih0aGlzLChmdW5jdGlvbihyKXtpZihudWxsPT0odD1KU09OLnBhcnNlKHRoaXMuTFMuZ2V0SXRlbSh0aGlzLmtleXMuaW5mbykpKSl0aHJvdyBuZXcgRXJyb3IoXCJJbiBsb2NhbCBzdG9yYWdlLCB0aGVyZSBpcyBubyBtb2RlbCB3aXRoIG5hbWUgJ1wiK3RoaXMubW9kZWxQYXRoK1wiJ1wiKTtpZihcIkpTT05cIiE9PXQubW9kZWxUb3BvbG9neVR5cGUpdGhyb3cgbmV3IEVycm9yKFwiQnJvd3NlckxvY2FsU3RvcmFnZSBkb2VzIG5vdCBzdXBwb3J0IGxvYWRpbmcgbm9uLUpTT04gbW9kZWwgdG9wb2xvZ3kgeWV0LlwiKTtpZihlPXt9LG51bGw9PShuPUpTT04ucGFyc2UodGhpcy5MUy5nZXRJdGVtKHRoaXMua2V5cy50b3BvbG9neSkpKSl0aHJvdyBuZXcgRXJyb3IoXCJJbiBsb2NhbCBzdG9yYWdlLCB0aGUgdG9wb2xvZ3kgb2YgbW9kZWwgJ1wiK3RoaXMubW9kZWxQYXRoK1wiJyBpcyBtaXNzaW5nLlwiKTtpZihlLm1vZGVsVG9wb2xvZ3k9bixudWxsPT0obz1KU09OLnBhcnNlKHRoaXMuTFMuZ2V0SXRlbSh0aGlzLmtleXMud2VpZ2h0U3BlY3MpKSkpdGhyb3cgbmV3IEVycm9yKFwiSW4gbG9jYWwgc3RvcmFnZSwgdGhlIHdlaWdodCBzcGVjcyBvZiBtb2RlbCAnXCIrdGhpcy5tb2RlbFBhdGgrXCInIGFyZSBtaXNzaW5nLlwiKTtpZihlLndlaWdodFNwZWNzPW8sbnVsbCE9KGE9dGhpcy5MUy5nZXRJdGVtKHRoaXMua2V5cy5tb2RlbE1ldGFkYXRhKSkmJihpPUpTT04ucGFyc2UoYSksZS5mb3JtYXQ9aS5mb3JtYXQsZS5nZW5lcmF0ZWRCeT1pLmdlbmVyYXRlZEJ5LGUuY29udmVydGVkQnk9aS5jb252ZXJ0ZWRCeSxlLnVzZXJEZWZpbmVkTWV0YWRhdGE9aS51c2VyRGVmaW5lZE1ldGFkYXRhKSxudWxsPT0ocz10aGlzLkxTLmdldEl0ZW0odGhpcy5rZXlzLndlaWdodERhdGEpKSl0aHJvdyBuZXcgRXJyb3IoXCJJbiBsb2NhbCBzdG9yYWdlLCB0aGUgYmluYXJ5IHdlaWdodCB2YWx1ZXMgb2YgbW9kZWwgJ1wiK3RoaXMubW9kZWxQYXRoK1wiJyBhcmUgbWlzc2luZy5cIik7cmV0dXJuIGUud2VpZ2h0RGF0YT1mdW5jdGlvbih0KXtpZihoZil7dmFyIGU9QnVmZmVyLmZyb20odCxcImJhc2U2NFwiKTtyZXR1cm4gZS5idWZmZXIuc2xpY2UoZS5ieXRlT2Zmc2V0LGUuYnl0ZU9mZnNldCtlLmJ5dGVMZW5ndGgpfWZvcih2YXIgbj1hdG9iKHQpLHI9bmV3IFVpbnQ4QXJyYXkobi5sZW5ndGgpLG89MDtvPG4ubGVuZ3RoOysrbylyLnNldChbbi5jaGFyQ29kZUF0KG8pXSxvKTtyZXR1cm4gci5idWZmZXJ9KHMpLFsyLGVdfSkpfSkpfSx0LlVSTF9TQ0hFTUU9XCJsb2NhbHN0b3JhZ2U6Ly9cIix0fSgpLExmPWZ1bmN0aW9uKHQpe3JldHVybiBpKCkuZ2V0Qm9vbChcIklTX0JST1dTRVJcIikmJiFBcnJheS5pc0FycmF5KHQpJiZ0LnN0YXJ0c1dpdGgoUGYuVVJMX1NDSEVNRSk/KGU9dC5zbGljZShQZi5VUkxfU0NIRU1FLmxlbmd0aCksbmV3IFBmKGUpKTpudWxsO3ZhciBlfTttZi5yZWdpc3RlclNhdmVSb3V0ZXIoTGYpLG1mLnJlZ2lzdGVyTG9hZFJvdXRlcihMZik7dmFyIFdmPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gdCgpe0MoaSgpLmdldEJvb2woXCJJU19CUk9XU0VSXCIpLChmdW5jdGlvbigpe3JldHVyblwiQ3VycmVudCBlbnZpcm9ubWVudCBpcyBub3QgYSB3ZWIgYnJvd3NlclwifSkpLEMoXCJ1bmRlZmluZWRcIj09dHlwZW9mIHdpbmRvd3x8dm9pZCAwIT09d2luZG93LmxvY2FsU3RvcmFnZSwoZnVuY3Rpb24oKXtyZXR1cm5cIkN1cnJlbnQgYnJvd3NlciBkb2VzIG5vdCBhcHBlYXIgdG8gc3VwcG9ydCBsb2NhbFN0b3JhZ2VcIn0pKSx0aGlzLkxTPXdpbmRvdy5sb2NhbFN0b3JhZ2V9cmV0dXJuIHQucHJvdG90eXBlLmxpc3RNb2RlbHM9ZnVuY3Rpb24oKXtyZXR1cm4gbih0aGlzLHZvaWQgMCx2b2lkIDAsKGZ1bmN0aW9uKCl7dmFyIHQsZSxuLG8sYSxpO3JldHVybiByKHRoaXMsKGZ1bmN0aW9uKHIpe2Zvcih0PXt9LGU9RGYrQWYsbj1BZitUZixvPTA7bzx0aGlzLkxTLmxlbmd0aDsrK28pKGE9dGhpcy5MUy5rZXkobykpLnN0YXJ0c1dpdGgoZSkmJmEuZW5kc1dpdGgobikmJihpPUJmKGEpLHRbaV09SlNPTi5wYXJzZSh0aGlzLkxTLmdldEl0ZW0oYSkpKTtyZXR1cm5bMix0XX0pKX0pKX0sdC5wcm90b3R5cGUucmVtb3ZlTW9kZWw9ZnVuY3Rpb24odCl7cmV0dXJuIG4odGhpcyx2b2lkIDAsdm9pZCAwLChmdW5jdGlvbigpe3ZhciBlLG47cmV0dXJuIHIodGhpcywoZnVuY3Rpb24ocil7dmFyIG87aWYodD0obz10KS5zdGFydHNXaXRoKFBmLlVSTF9TQ0hFTUUpP28uc2xpY2UoUGYuVVJMX1NDSEVNRS5sZW5ndGgpOm8sZT1NZih0KSxudWxsPT10aGlzLkxTLmdldEl0ZW0oZS5pbmZvKSl0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgZmluZCBtb2RlbCBhdCBwYXRoICdcIit0K1wiJ1wiKTtyZXR1cm4gbj1KU09OLnBhcnNlKHRoaXMuTFMuZ2V0SXRlbShlLmluZm8pKSx0aGlzLkxTLnJlbW92ZUl0ZW0oZS5pbmZvKSx0aGlzLkxTLnJlbW92ZUl0ZW0oZS50b3BvbG9neSksdGhpcy5MUy5yZW1vdmVJdGVtKGUud2VpZ2h0U3BlY3MpLHRoaXMuTFMucmVtb3ZlSXRlbShlLndlaWdodERhdGEpLFsyLG5dfSkpfSkpfSx0fSgpO2lmKGkoKS5nZXRCb29sKFwiSVNfQlJPV1NFUlwiKSl0cnl7eWYucmVnaXN0ZXJNYW5hZ2VyKFBmLlVSTF9TQ0hFTUUsbmV3IFdmKX1jYXRjaCh0KXt9dmFyIFVmPVwibW9kZWxcIixWZj1cIi5qc29uXCIsemY9XCIud2VpZ2h0cy5iaW5cIjtmdW5jdGlvbiBHZih0KXtyZXR1cm4gbmV3IFByb21pc2UoKGZ1bmN0aW9uKHQpe3JldHVybiBzZXRUaW1lb3V0KHQpfSkpLnRoZW4odCl9dmFyIEhmPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gdChlKXtpZighaSgpLmdldEJvb2woXCJJU19CUk9XU0VSXCIpKXRocm93IG5ldyBFcnJvcihcImJyb3dzZXJEb3dubG9hZHMoKSBjYW5ub3QgcHJvY2VlZCBiZWNhdXNlIHRoZSBjdXJyZW50IGVudmlyb25tZW50IGlzIG5vdCBhIGJyb3dzZXIuXCIpO2Uuc3RhcnRzV2l0aCh0LlVSTF9TQ0hFTUUpJiYoZT1lLnNsaWNlKHQuVVJMX1NDSEVNRS5sZW5ndGgpKSxudWxsIT1lJiYwIT09ZS5sZW5ndGh8fChlPVVmKSx0aGlzLm1vZGVsVG9wb2xvZ3lGaWxlTmFtZT1lK1ZmLHRoaXMud2VpZ2h0RGF0YUZpbGVOYW1lPWUremZ9cmV0dXJuIHQucHJvdG90eXBlLnNhdmU9ZnVuY3Rpb24odCl7cmV0dXJuIG4odGhpcyx2b2lkIDAsdm9pZCAwLChmdW5jdGlvbigpe3ZhciBlLG4sbyxhLGkscztyZXR1cm4gcih0aGlzLChmdW5jdGlvbihyKXtzd2l0Y2goci5sYWJlbCl7Y2FzZSAwOmlmKFwidW5kZWZpbmVkXCI9PXR5cGVvZiBkb2N1bWVudCl0aHJvdyBuZXcgRXJyb3IoXCJCcm93c2VyIGRvd25sb2FkcyBhcmUgbm90IHN1cHBvcnRlZCBpbiB0aGlzIGVudmlyb25tZW50IHNpbmNlIGBkb2N1bWVudGAgaXMgbm90IHByZXNlbnRcIik7aWYoZT13aW5kb3cuVVJMLmNyZWF0ZU9iamVjdFVSTChuZXcgQmxvYihbdC53ZWlnaHREYXRhXSx7dHlwZTpcImFwcGxpY2F0aW9uL29jdGV0LXN0cmVhbVwifSkpLCEodC5tb2RlbFRvcG9sb2d5IGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpKXJldHVyblszLDFdO3Rocm93IG5ldyBFcnJvcihcIkJyb3dzZXJEb3dubG9hZHMuc2F2ZSgpIGRvZXMgbm90IHN1cHBvcnQgc2F2aW5nIG1vZGVsIHRvcG9sb2d5IGluIGJpbmFyeSBmb3JtYXRzIHlldC5cIik7Y2FzZSAxOnJldHVybiBuPVt7cGF0aHM6W1wiLi9cIit0aGlzLndlaWdodERhdGFGaWxlTmFtZV0sd2VpZ2h0czp0LndlaWdodFNwZWNzfV0sbz17bW9kZWxUb3BvbG9neTp0Lm1vZGVsVG9wb2xvZ3ksZm9ybWF0OnQuZm9ybWF0LGdlbmVyYXRlZEJ5OnQuZ2VuZXJhdGVkQnksY29udmVydGVkQnk6dC5jb252ZXJ0ZWRCeSx3ZWlnaHRzTWFuaWZlc3Q6bn0sYT13aW5kb3cuVVJMLmNyZWF0ZU9iamVjdFVSTChuZXcgQmxvYihbSlNPTi5zdHJpbmdpZnkobyldLHt0eXBlOlwiYXBwbGljYXRpb24vanNvblwifSkpLChpPW51bGw9PXRoaXMuanNvbkFuY2hvcj9kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiYVwiKTp0aGlzLmpzb25BbmNob3IpLmRvd25sb2FkPXRoaXMubW9kZWxUb3BvbG9neUZpbGVOYW1lLGkuaHJlZj1hLFs0LEdmKChmdW5jdGlvbigpe3JldHVybiBpLmRpc3BhdGNoRXZlbnQobmV3IE1vdXNlRXZlbnQoXCJjbGlja1wiKSl9KSldO2Nhc2UgMjpyZXR1cm4gci5zZW50KCksbnVsbD09dC53ZWlnaHREYXRhP1szLDRdOigocz1udWxsPT10aGlzLndlaWdodERhdGFBbmNob3I/ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImFcIik6dGhpcy53ZWlnaHREYXRhQW5jaG9yKS5kb3dubG9hZD10aGlzLndlaWdodERhdGFGaWxlTmFtZSxzLmhyZWY9ZSxbNCxHZigoZnVuY3Rpb24oKXtyZXR1cm4gcy5kaXNwYXRjaEV2ZW50KG5ldyBNb3VzZUV2ZW50KFwiY2xpY2tcIikpfSkpXSk7Y2FzZSAzOnIuc2VudCgpLHIubGFiZWw9NDtjYXNlIDQ6cmV0dXJuWzIse21vZGVsQXJ0aWZhY3RzSW5mbzp2Zih0KX1dfX0pKX0pKX0sdC5VUkxfU0NIRU1FPVwiZG93bmxvYWRzOi8vXCIsdH0oKSxxZj1mdW5jdGlvbigpe2Z1bmN0aW9uIHQodCl7aWYobnVsbD09dHx8dC5sZW5ndGg8MSl0aHJvdyBuZXcgRXJyb3IoXCJXaGVuIGNhbGxpbmcgYnJvd3NlckZpbGVzLCBhdCBsZWFzdCAxIGZpbGUgaXMgcmVxdWlyZWQsIGJ1dCByZWNlaXZlZCBcIit0KTt0aGlzLmZpbGVzPXR9cmV0dXJuIHQucHJvdG90eXBlLmxvYWQ9ZnVuY3Rpb24oKXtyZXR1cm4gbih0aGlzLHZvaWQgMCx2b2lkIDAsKGZ1bmN0aW9uKCl7dmFyIHQsZSxuPXRoaXM7cmV0dXJuIHIodGhpcywoZnVuY3Rpb24ocil7cmV0dXJuIHQ9dGhpcy5maWxlc1swXSxlPXRoaXMuZmlsZXMuc2xpY2UoMSksWzIsbmV3IFByb21pc2UoKGZ1bmN0aW9uKHIsbyl7dmFyIGE9bmV3IEZpbGVSZWFkZXI7YS5vbmxvYWQ9ZnVuY3Rpb24oYSl7dmFyIGk9SlNPTi5wYXJzZShhLnRhcmdldC5yZXN1bHQpLHM9aS5tb2RlbFRvcG9sb2d5O2lmKG51bGwhPXMpezA9PT1lLmxlbmd0aCYmcih7bW9kZWxUb3BvbG9neTpzfSk7dmFyIHU9aS53ZWlnaHRzTWFuaWZlc3Q7aWYobnVsbCE9dSl7dmFyIGM7dHJ5e2M9bi5jaGVja01hbmlmZXN0QW5kV2VpZ2h0RmlsZXModSxlKX1jYXRjaCh0KXtyZXR1cm4gdm9pZCBvKHQpfXZhciBsPVtdLGg9W10sZj1bXTt1LmZvckVhY2goKGZ1bmN0aW9uKHQpe3QucGF0aHMuZm9yRWFjaCgoZnVuY3Rpb24odCl7aC5wdXNoKHQpLGYucHVzaChudWxsKX0pKSxsLnB1c2guYXBwbHkobCx0LndlaWdodHMpfSkpLHUuZm9yRWFjaCgoZnVuY3Rpb24odCl7dC5wYXRocy5mb3JFYWNoKChmdW5jdGlvbih0KXt2YXIgZT1uZXcgRmlsZVJlYWRlcjtlLm9ubG9hZD1mdW5jdGlvbihlKXt2YXIgbj1lLnRhcmdldC5yZXN1bHQsbz1oLmluZGV4T2YodCk7ZltvXT1uLC0xPT09Zi5pbmRleE9mKG51bGwpJiZyKHttb2RlbFRvcG9sb2d5OnMsd2VpZ2h0U3BlY3M6bCx3ZWlnaHREYXRhOmRmKGYpLGZvcm1hdDppLmZvcm1hdCxnZW5lcmF0ZWRCeTppLmdlbmVyYXRlZEJ5LGNvbnZlcnRlZEJ5OmkuY29udmVydGVkQnksdXNlckRlZmluZWRNZXRhZGF0YTppLnVzZXJEZWZpbmVkTWV0YWRhdGF9KX0sZS5vbmVycm9yPWZ1bmN0aW9uKGUpe3JldHVybiBvKFwiRmFpbGVkIHRvIHdlaWdodHMgZGF0YSBmcm9tIGZpbGUgb2YgcGF0aCAnXCIrdCtcIicuXCIpfSxlLnJlYWRBc0FycmF5QnVmZmVyKGNbdF0pfSkpfSkpfWVsc2UgbyhuZXcgRXJyb3IoXCJ3ZWlnaHRNYW5pZmVzdCBmaWVsZCBpcyBtaXNzaW5nIGZyb20gZmlsZSBcIit0Lm5hbWUpKX1lbHNlIG8obmV3IEVycm9yKFwibW9kZWxUb3BvbG9neSBmaWVsZCBpcyBtaXNzaW5nIGZyb20gZmlsZSBcIit0Lm5hbWUpKX0sYS5vbmVycm9yPWZ1bmN0aW9uKGUpe3JldHVybiBvKFwiRmFpbGVkIHRvIHJlYWQgbW9kZWwgdG9wb2xvZ3kgYW5kIHdlaWdodHMgbWFuaWZlc3QgSlNPTiBmcm9tIGZpbGUgJ1wiK3QubmFtZStcIicuIEJyb3dzZXJGaWxlcyBzdXBwb3J0cyBsb2FkaW5nIEtlcmFzLXN0eWxlIHRmLk1vZGVsIGFydGlmYWN0cyBvbmx5LlwiKX0sYS5yZWFkQXNUZXh0KHQpfSkpXX0pKX0pKX0sdC5wcm90b3R5cGUuY2hlY2tNYW5pZmVzdEFuZFdlaWdodEZpbGVzPWZ1bmN0aW9uKHQsZSl7Zm9yKHZhciBuPVtdLHI9ZS5tYXAoKGZ1bmN0aW9uKHQpe3JldHVybiBwZih0Lm5hbWUpfSkpLG89e30sYT0wLGk9dDthPGkubGVuZ3RoO2ErKyl7aVthXS5wYXRocy5mb3JFYWNoKChmdW5jdGlvbih0KXt2YXIgYT1wZih0KTtpZigtMSE9PW4uaW5kZXhPZihhKSl0aHJvdyBuZXcgRXJyb3IoXCJEdXBsaWNhdGUgZmlsZSBiYXNlbmFtZSBmb3VuZCBpbiB3ZWlnaHRzIG1hbmlmZXN0OiAnXCIrYStcIidcIik7aWYobi5wdXNoKGEpLC0xPT09ci5pbmRleE9mKGEpKXRocm93IG5ldyBFcnJvcihcIldlaWdodCBmaWxlIHdpdGggYmFzZW5hbWUgJ1wiK2ErXCInIGlzIG5vdCBwcm92aWRlZC5cIik7b1t0XT1lW3IuaW5kZXhPZihhKV19KSl9aWYobi5sZW5ndGghPT1lLmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJNaXNtYXRjaCBpbiB0aGUgbnVtYmVyIG9mIGZpbGVzIGluIHdlaWdodHMgbWFuaWZlc3QgKFwiK24ubGVuZ3RoK1wiKSBhbmQgdGhlIG51bWJlciBvZiB3ZWlnaHQgZmlsZXMgcHJvdmlkZWQgKFwiK2UubGVuZ3RoK1wiKS5cIik7cmV0dXJuIG99LHR9KCk7ZnVuY3Rpb24gS2YodCxlLG4scil7IWZ1bmN0aW9uKHQpe0MobnVsbCE9dCYmQXJyYXkuaXNBcnJheSh0KSYmdC5sZW5ndGg+MCwoZnVuY3Rpb24oKXtyZXR1cm5cInByb21pc2VzIG11c3QgYmUgYSBub25lIGVtcHR5IGFycmF5XCJ9KSl9KHQpLGZ1bmN0aW9uKHQsZSl7Qyh0Pj0wJiZ0PD0xLChmdW5jdGlvbigpe3JldHVyblwiUHJvZ3Jlc3MgZnJhY3Rpb24gbXVzdCBiZSBpbiByYW5nZSBbMCwgMV0sIGJ1dCBnb3Qgc3RhcnRGcmFjdGlvbiBcIit0fSkpLEMoZT49MCYmZTw9MSwoZnVuY3Rpb24oKXtyZXR1cm5cIlByb2dyZXNzIGZyYWN0aW9uIG11c3QgYmUgaW4gcmFuZ2UgWzAsIDFdLCBidXQgZ290IGVuZEZyYWN0aW9uIFwiK2V9KSksQyhlPj10LChmdW5jdGlvbigpe3JldHVyblwic3RhcnRGcmFjdGlvbiBtdXN0IGJlIG5vIG1vcmUgdGhhbiBlbmRGcmFjdGlvbiwgYnV0IGdvdCBzdGFydEZyYWN0aW9uIFwiK3QrXCIgYW5kIGVuZEZyYWN0aW9uIFwiK2V9KSl9KG49bnVsbD09bj8wOm4scj1udWxsPT1yPzE6cik7dmFyIG89MDtyZXR1cm4gUHJvbWlzZS5hbGwodC5tYXAoKGZ1bmN0aW9uKGEpe3JldHVybiBhLnRoZW4oKGZ1bmN0aW9uKGEpe3ZhciBpPW4rICsrby90Lmxlbmd0aCooci1uKTtyZXR1cm4gZShpKSxhfSkpLGF9KSkpfWZ1bmN0aW9uIGpmKHQsZSl7cmV0dXJuIG4odGhpcyx2b2lkIDAsdm9pZCAwLChmdW5jdGlvbigpe3ZhciBuLG8sYSxzLHUsYyxsLGgsZjtyZXR1cm4gcih0aGlzLChmdW5jdGlvbihyKXtzd2l0Y2goci5sYWJlbCl7Y2FzZSAwOnJldHVybiBudWxsPT1lJiYoZT17fSksbj1udWxsPT1lLmZldGNoRnVuYz9pKCkucGxhdGZvcm0uZmV0Y2g6ZS5mZXRjaEZ1bmMsbz10Lm1hcCgoZnVuY3Rpb24odCl7cmV0dXJuIG4odCxlLnJlcXVlc3RJbml0LHtpc0JpbmFyeTohMH0pfSkpLGE9MCxzPS41LG51bGwhPWUub25Qcm9ncmVzcz9bMywyXTpbNCxQcm9taXNlLmFsbChvKV07Y2FzZSAxOnJldHVybiB1PXIuc2VudCgpLFszLDRdO2Nhc2UgMjpyZXR1cm5bNCxLZihvLGUub25Qcm9ncmVzcyxhLHMpXTtjYXNlIDM6dT1yLnNlbnQoKSxyLmxhYmVsPTQ7Y2FzZSA0OnJldHVybiBjPXUubWFwKChmdW5jdGlvbih0KXtyZXR1cm4gdC5hcnJheUJ1ZmZlcigpfSkpLGw9LjUsaD0xLG51bGwhPWUub25Qcm9ncmVzcz9bMyw2XTpbNCxQcm9taXNlLmFsbChjKV07Y2FzZSA1OnJldHVybiBmPXIuc2VudCgpLFszLDhdO2Nhc2UgNjpyZXR1cm5bNCxLZihjLGUub25Qcm9ncmVzcyxsLGgpXTtjYXNlIDc6Zj1yLnNlbnQoKSxyLmxhYmVsPTg7Y2FzZSA4OnJldHVyblsyLGZdfX0pKX0pKX1mdW5jdGlvbiBYZih0KXt2YXIgZT10aGlzO3JldHVybiBmdW5jdGlvbihvLGEsaSl7cmV0dXJuIHZvaWQgMD09PWEmJihhPVwiXCIpLG4oZSx2b2lkIDAsdm9pZCAwLChmdW5jdGlvbigpe3ZhciBlLG4scyx1LGMsbCxoLGYsZCxwO3JldHVybiByKHRoaXMsKGZ1bmN0aW9uKHIpe3N3aXRjaChyLmxhYmVsKXtjYXNlIDA6aWYoZT1vLm1hcCgoZnVuY3Rpb24oKXtyZXR1cm4hMX0pKSxuPXt9LHM9bnVsbCE9aT9pLm1hcCgoZnVuY3Rpb24oKXtyZXR1cm4hMX0pKTpbXSx1PVtdLG8uZm9yRWFjaCgoZnVuY3Rpb24odCxyKXt2YXIgbz0wO3Qud2VpZ2h0cy5mb3JFYWNoKChmdW5jdGlvbih0KXt2YXIgYT1cInF1YW50aXphdGlvblwiaW4gdD90LnF1YW50aXphdGlvbi5kdHlwZTp0LmR0eXBlLGM9c2ZbYV0qayh0LnNoYXBlKSxsPWZ1bmN0aW9uKCl7ZVtyXT0hMCxudWxsPT1uW3JdJiYobltyXT1bXSksbltyXS5wdXNoKHttYW5pZmVzdEVudHJ5OnQsZ3JvdXBPZmZzZXQ6byxzaXplQnl0ZXM6Y30pfTtudWxsIT1pP2kuZm9yRWFjaCgoZnVuY3Rpb24oZSxuKXtlPT09dC5uYW1lJiYobCgpLHNbbl09ITApfSkpOmwoKSx1LnB1c2godC5uYW1lKSxvKz1jfSkpfSkpLCFzLmV2ZXJ5KChmdW5jdGlvbih0KXtyZXR1cm4gdH0pKSl0aHJvdyBjPWkuZmlsdGVyKChmdW5jdGlvbih0LGUpe3JldHVybiFzW2VdfSkpLG5ldyBFcnJvcihcIkNvdWxkIG5vdCBmaW5kIHdlaWdodHMgaW4gbWFuaWZlc3Qgd2l0aCBuYW1lczogXCIrYy5qb2luKFwiLCBcIikrXCIuIFxcbk1hbmlmZXN0IEpTT04gaGFzIHdlaWdodHMgd2l0aCBuYW1lczogXCIrdS5qb2luKFwiLCBcIikrXCIuXCIpO3JldHVybiBsPWUucmVkdWNlKChmdW5jdGlvbih0LGUsbil7cmV0dXJuIGUmJnQucHVzaChuKSx0fSksW10pLGg9W10sbC5mb3JFYWNoKChmdW5jdGlvbih0KXtvW3RdLnBhdGhzLmZvckVhY2goKGZ1bmN0aW9uKHQpe3ZhciBlPWErKGEuZW5kc1dpdGgoXCIvXCIpP1wiXCI6XCIvXCIpK3Q7aC5wdXNoKGUpfSkpfSkpLFs0LHQoaCldO2Nhc2UgMTpyZXR1cm4gZj1yLnNlbnQoKSxkPXt9LHA9MCxsLmZvckVhY2goKGZ1bmN0aW9uKHQpe2Zvcih2YXIgZT1vW3RdLnBhdGhzLmxlbmd0aCxyPTAsYT0wO2E8ZTthKyspcis9ZltwK2FdLmJ5dGVMZW5ndGg7Zm9yKHZhciBpPW5ldyBBcnJheUJ1ZmZlcihyKSxzPW5ldyBVaW50OEFycmF5KGkpLHU9MCxjPTA7YzxlO2MrKyl7dmFyIGw9bmV3IFVpbnQ4QXJyYXkoZltwK2NdKTtzLnNldChsLHUpLHUrPWwuYnl0ZUxlbmd0aH1uW3RdLmZvckVhY2goKGZ1bmN0aW9uKHQpe3ZhciBlPWNmKGkuc2xpY2UodC5ncm91cE9mZnNldCx0Lmdyb3VwT2Zmc2V0K3Quc2l6ZUJ5dGVzKSxbdC5tYW5pZmVzdEVudHJ5XSk7Zm9yKHZhciBuIGluIGUpZFtuXT1lW25dfSkpLHArPWV9KSksWzIsZF19fSkpfSkpfX1tZi5yZWdpc3RlclNhdmVSb3V0ZXIoKGZ1bmN0aW9uKHQpe3JldHVybiBpKCkuZ2V0Qm9vbChcIklTX0JST1dTRVJcIikmJiFBcnJheS5pc0FycmF5KHQpJiZ0LnN0YXJ0c1dpdGgoSGYuVVJMX1NDSEVNRSk/ZnVuY3Rpb24odCl7dm9pZCAwPT09dCYmKHQ9XCJtb2RlbFwiKTtyZXR1cm4gbmV3IEhmKHQpfSh0LnNsaWNlKEhmLlVSTF9TQ0hFTUUubGVuZ3RoKSk6bnVsbH0pKTt2YXIgWWY9ZnVuY3Rpb24oKXtmdW5jdGlvbiB0KHQsZSl7aWYodGhpcy5ERUZBVUxUX01FVEhPRD1cIlBPU1RcIixudWxsPT1lJiYoZT17fSksdGhpcy53ZWlnaHRQYXRoUHJlZml4PWUud2VpZ2h0UGF0aFByZWZpeCx0aGlzLm9uUHJvZ3Jlc3M9ZS5vblByb2dyZXNzLG51bGwhPWUuZmV0Y2hGdW5jPyhDKFwiZnVuY3Rpb25cIj09dHlwZW9mIGUuZmV0Y2hGdW5jLChmdW5jdGlvbigpe3JldHVyblwiTXVzdCBwYXNzIGEgZnVuY3Rpb24gdGhhdCBtYXRjaGVzIHRoZSBzaWduYXR1cmUgb2YgYGZldGNoYCAoc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9GZXRjaF9BUEkpXCJ9KSksdGhpcy5mZXRjaD1lLmZldGNoRnVuYyk6dGhpcy5mZXRjaD1pKCkucGxhdGZvcm0uZmV0Y2gsQyhudWxsIT10JiZ0Lmxlbmd0aD4wLChmdW5jdGlvbigpe3JldHVyblwiVVJMIHBhdGggZm9yIGh0dHAgbXVzdCBub3QgYmUgbnVsbCwgdW5kZWZpbmVkIG9yIGVtcHR5LlwifSkpLEFycmF5LmlzQXJyYXkodCkmJkMoMj09PXQubGVuZ3RoLChmdW5jdGlvbigpe3JldHVyblwiVVJMIHBhdGhzIGZvciBodHRwIG11c3QgaGF2ZSBhIGxlbmd0aCBvZiAyLCAoYWN0dWFsIGxlbmd0aCBpcyBcIit0Lmxlbmd0aCtcIikuXCJ9KSksdGhpcy5wYXRoPXQsbnVsbCE9ZS5yZXF1ZXN0SW5pdCYmbnVsbCE9ZS5yZXF1ZXN0SW5pdC5ib2R5KXRocm93IG5ldyBFcnJvcihcInJlcXVlc3RJbml0IGlzIGV4cGVjdGVkIHRvIGhhdmUgbm8gcHJlLWV4aXN0aW5nIGJvZHksIGJ1dCBoYXMgb25lLlwiKTt0aGlzLnJlcXVlc3RJbml0PWUucmVxdWVzdEluaXR8fHt9fXJldHVybiB0LnByb3RvdHlwZS5zYXZlPWZ1bmN0aW9uKHQpe3JldHVybiBuKHRoaXMsdm9pZCAwLHZvaWQgMCwoZnVuY3Rpb24oKXt2YXIgZSxuLG8sYTtyZXR1cm4gcih0aGlzLChmdW5jdGlvbihyKXtzd2l0Y2goci5sYWJlbCl7Y2FzZSAwOmlmKHQubW9kZWxUb3BvbG9neSBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKXRocm93IG5ldyBFcnJvcihcIkJyb3dzZXJIVFRQUmVxdWVzdC5zYXZlKCkgZG9lcyBub3Qgc3VwcG9ydCBzYXZpbmcgbW9kZWwgdG9wb2xvZ3kgaW4gYmluYXJ5IGZvcm1hdHMgeWV0LlwiKTtyZXR1cm4oZT1PYmplY3QuYXNzaWduKHttZXRob2Q6dGhpcy5ERUZBVUxUX01FVEhPRH0sdGhpcy5yZXF1ZXN0SW5pdCkpLmJvZHk9bmV3IEZvcm1EYXRhLG49W3twYXRoczpbXCIuL21vZGVsLndlaWdodHMuYmluXCJdLHdlaWdodHM6dC53ZWlnaHRTcGVjc31dLG89e21vZGVsVG9wb2xvZ3k6dC5tb2RlbFRvcG9sb2d5LGZvcm1hdDp0LmZvcm1hdCxnZW5lcmF0ZWRCeTp0LmdlbmVyYXRlZEJ5LGNvbnZlcnRlZEJ5OnQuY29udmVydGVkQnksdXNlckRlZmluZWRNZXRhZGF0YTp0LnVzZXJEZWZpbmVkTWV0YWRhdGEsd2VpZ2h0c01hbmlmZXN0Om59LGUuYm9keS5hcHBlbmQoXCJtb2RlbC5qc29uXCIsbmV3IEJsb2IoW0pTT04uc3RyaW5naWZ5KG8pXSx7dHlwZTpcImFwcGxpY2F0aW9uL2pzb25cIn0pLFwibW9kZWwuanNvblwiKSxudWxsIT10LndlaWdodERhdGEmJmUuYm9keS5hcHBlbmQoXCJtb2RlbC53ZWlnaHRzLmJpblwiLG5ldyBCbG9iKFt0LndlaWdodERhdGFdLHt0eXBlOlwiYXBwbGljYXRpb24vb2N0ZXQtc3RyZWFtXCJ9KSxcIm1vZGVsLndlaWdodHMuYmluXCIpLFs0LHRoaXMuZmV0Y2godGhpcy5wYXRoLGUpXTtjYXNlIDE6aWYoKGE9ci5zZW50KCkpLm9rKXJldHVyblsyLHttb2RlbEFydGlmYWN0c0luZm86dmYodCkscmVzcG9uc2VzOlthXX1dO3Rocm93IG5ldyBFcnJvcihcIkJyb3dzZXJIVFRQUmVxdWVzdC5zYXZlKCkgZmFpbGVkIGR1ZSB0byBIVFRQIHJlc3BvbnNlIHN0YXR1cyBcIithLnN0YXR1cytcIi5cIil9fSkpfSkpfSx0LnByb3RvdHlwZS5sb2FkPWZ1bmN0aW9uKCl7cmV0dXJuIG4odGhpcyx2b2lkIDAsdm9pZCAwLChmdW5jdGlvbigpe3ZhciB0LGUsbixvLGEsaSxzLHUsYyxsLGgsZjtyZXR1cm4gcih0aGlzLChmdW5jdGlvbihyKXtzd2l0Y2goci5sYWJlbCl7Y2FzZSAwOnJldHVybls0LHRoaXMuZmV0Y2godGhpcy5wYXRoLHRoaXMucmVxdWVzdEluaXQpXTtjYXNlIDE6aWYoISh0PXIuc2VudCgpKS5vayl0aHJvdyBuZXcgRXJyb3IoXCJSZXF1ZXN0IHRvIFwiK3RoaXMucGF0aCtcIiBmYWlsZWQgd2l0aCBzdGF0dXMgY29kZSBcIit0LnN0YXR1cytcIi4gUGxlYXNlIHZlcmlmeSB0aGlzIFVSTCBwb2ludHMgdG8gdGhlIG1vZGVsIEpTT04gb2YgdGhlIG1vZGVsIHRvIGxvYWQuXCIpO3IubGFiZWw9MjtjYXNlIDI6cmV0dXJuIHIudHJ5cy5wdXNoKFsyLDQsLDVdKSxbNCx0Lmpzb24oKV07Y2FzZSAzOnJldHVybiBlPXIuc2VudCgpLFszLDVdO2Nhc2UgNDp0aHJvdyByLnNlbnQoKSxuPVwiRmFpbGVkIHRvIHBhcnNlIG1vZGVsIEpTT04gb2YgcmVzcG9uc2UgZnJvbSBcIit0aGlzLnBhdGgrXCIuXCIsdGhpcy5wYXRoLmVuZHNXaXRoKFwiLnBiXCIpP24rPVwiIFlvdXIgcGF0aCBjb250YWlucyBhIC5wYiBmaWxlIGV4dGVuc2lvbi4gU3VwcG9ydCBmb3IgLnBiIG1vZGVscyBoYXZlIGJlZW4gcmVtb3ZlZCBpbiBUZW5zb3JGbG93LmpzIDEuMCBpbiBmYXZvciBvZiAuanNvbiBtb2RlbHMuIFlvdSBjYW4gcmUtY29udmVydCB5b3VyIFB5dGhvbiBUZW5zb3JGbG93IG1vZGVsIHVzaW5nIHRoZSBUZW5zb3JGbG93LmpzIDEuMCBjb252ZXJzaW9uIHNjcmlwdHMgb3IgeW91IGNhbiBjb252ZXJ0IHlvdXIucGIgbW9kZWxzIHdpdGggdGhlICdwYjJqc29uJ05QTSBzY3JpcHQgaW4gdGhlIHRlbnNvcmZsb3cvdGZqcy1jb252ZXJ0ZXIgcmVwb3NpdG9yeS5cIjpuKz1cIiBQbGVhc2UgbWFrZSBzdXJlIHRoZSBzZXJ2ZXIgaXMgc2VydmluZyB2YWxpZCBKU09OIGZvciB0aGlzIHJlcXVlc3QuXCIsbmV3IEVycm9yKG4pO2Nhc2UgNTppZihvPWUubW9kZWxUb3BvbG9neSxhPWUud2VpZ2h0c01hbmlmZXN0LGk9ZS5nZW5lcmF0ZWRCeSxzPWUuY29udmVydGVkQnksdT1lLmZvcm1hdCxjPWUudXNlckRlZmluZWRNZXRhZGF0YSxudWxsPT1vJiZudWxsPT1hKXRocm93IG5ldyBFcnJvcihcIlRoZSBKU09OIGZyb20gSFRUUCBwYXRoIFwiK3RoaXMucGF0aCtcIiBjb250YWlucyBuZWl0aGVyIG1vZGVsIHRvcG9sb2d5IG9yIG1hbmlmZXN0IGZvciB3ZWlnaHRzLlwiKTtyZXR1cm4gbnVsbD09YT9bMyw3XTpbNCx0aGlzLmxvYWRXZWlnaHRzKGEpXTtjYXNlIDY6Zj1yLnNlbnQoKSxsPWZbMF0saD1mWzFdLHIubGFiZWw9NztjYXNlIDc6cmV0dXJuWzIse21vZGVsVG9wb2xvZ3k6byx3ZWlnaHRTcGVjczpsLHdlaWdodERhdGE6aCx1c2VyRGVmaW5lZE1ldGFkYXRhOmMsZ2VuZXJhdGVkQnk6aSxjb252ZXJ0ZWRCeTpzLGZvcm1hdDp1fV19fSkpfSkpfSx0LnByb3RvdHlwZS5sb2FkV2VpZ2h0cz1mdW5jdGlvbih0KXtyZXR1cm4gbih0aGlzLHZvaWQgMCx2b2lkIDAsKGZ1bmN0aW9uKCl7dmFyIGUsbixvLGEsaSxzLHUsYyxsLGgsZjtyZXR1cm4gcih0aGlzLChmdW5jdGlvbihyKXtzd2l0Y2goci5sYWJlbCl7Y2FzZSAwOmZvcihlPUFycmF5LmlzQXJyYXkodGhpcy5wYXRoKT90aGlzLnBhdGhbMV06dGhpcy5wYXRoLG49ZnVuY3Rpb24odCl7dmFyIGU9dC5sYXN0SW5kZXhPZihcIi9cIiksbj10Lmxhc3RJbmRleE9mKFwiP1wiKSxyPXQuc3Vic3RyaW5nKDAsZSksbz1uPmU/dC5zdWJzdHJpbmcobik6XCJcIjtyZXR1cm5bcitcIi9cIixvXX0oZSksbz1uWzBdLGE9blsxXSxpPXRoaXMud2VpZ2h0UGF0aFByZWZpeHx8byxzPVtdLHU9MCxjPXQ7dTxjLmxlbmd0aDt1KyspbD1jW3VdLHMucHVzaC5hcHBseShzLGwud2VpZ2h0cyk7cmV0dXJuIGg9W10sdC5mb3JFYWNoKChmdW5jdGlvbih0KXt0LnBhdGhzLmZvckVhY2goKGZ1bmN0aW9uKHQpe2gucHVzaChpK3QrYSl9KSl9KSksWzQsamYoaCx7cmVxdWVzdEluaXQ6dGhpcy5yZXF1ZXN0SW5pdCxmZXRjaEZ1bmM6dGhpcy5mZXRjaCxvblByb2dyZXNzOnRoaXMub25Qcm9ncmVzc30pXTtjYXNlIDE6cmV0dXJuIGY9ci5zZW50KCksWzIsW3MsZGYoZildXX19KSl9KSl9LHQuVVJMX1NDSEVNRV9SRUdFWD0vXmh0dHBzPzpcXC9cXC8vLHR9KCk7ZnVuY3Rpb24gJGYodCl7cmV0dXJuIG51bGwhPXQubWF0Y2goWWYuVVJMX1NDSEVNRV9SRUdFWCl9dmFyIFFmPWZ1bmN0aW9uKHQsZSl7aWYoXCJ1bmRlZmluZWRcIj09dHlwZW9mIGZldGNoKXJldHVybiBudWxsO3JldHVybihBcnJheS5pc0FycmF5KHQpP3QuZXZlcnkoKGZ1bmN0aW9uKHQpe3JldHVybiAkZih0KX0pKTokZih0KSk/SmYodCx7b25Qcm9ncmVzczplfSk6bnVsbH07ZnVuY3Rpb24gSmYodCxlKXtyZXR1cm4gbmV3IFlmKHQsZSl9bWYucmVnaXN0ZXJTYXZlUm91dGVyKFFmKSxtZi5yZWdpc3RlckxvYWRSb3V0ZXIoUWYpO3ZhciBaZj1mdW5jdGlvbigpe2Z1bmN0aW9uIHQodCl7dGhpcy5tb2RlbEFydGlmYWN0cz10fXJldHVybiB0LnByb3RvdHlwZS5sb2FkPWZ1bmN0aW9uKCl7cmV0dXJuIG4odGhpcyx2b2lkIDAsdm9pZCAwLChmdW5jdGlvbigpe3JldHVybiByKHRoaXMsKGZ1bmN0aW9uKHQpe3JldHVyblsyLHRoaXMubW9kZWxBcnRpZmFjdHNdfSkpfSkpfSx0fSgpLHRkPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gdCh0KXt0aGlzLnNhdmVIYW5kbGVyPXR9cmV0dXJuIHQucHJvdG90eXBlLnNhdmU9ZnVuY3Rpb24odCl7cmV0dXJuIG4odGhpcyx2b2lkIDAsdm9pZCAwLChmdW5jdGlvbigpe3JldHVybiByKHRoaXMsKGZ1bmN0aW9uKGUpe3JldHVyblsyLHRoaXMuc2F2ZUhhbmRsZXIodCldfSkpfSkpfSx0fSgpO3ZhciBlZD1PYmplY3QuZnJlZXplKHticm93c2VyRmlsZXM6ZnVuY3Rpb24odCl7cmV0dXJuIG5ldyBxZih0KX0sYnJvd3NlckhUVFBSZXF1ZXN0OmZ1bmN0aW9uKHQsZSl7cmV0dXJuIEpmKHQsZSl9LGNvbmNhdGVuYXRlQXJyYXlCdWZmZXJzOmRmLGRlY29kZVdlaWdodHM6Y2YsZW5jb2RlV2VpZ2h0czpmdW5jdGlvbih0LGUpe3JldHVybiBuKHRoaXMsdm9pZCAwLHZvaWQgMCwoZnVuY3Rpb24oKXt2YXIgbyxhLGkscyx1LGM9dGhpcztyZXR1cm4gcih0aGlzLChmdW5jdGlvbihsKXtzd2l0Y2gobC5sYWJlbCl7Y2FzZSAwOmZvcihvPVtdLGE9W10saT1BcnJheS5pc0FycmF5KHQpP3QubWFwKChmdW5jdGlvbih0KXtyZXR1cm4gdC5uYW1lfSkpOk9iamVjdC5rZXlzKHQpLHM9ZnVuY3Rpb24ocyl7dmFyIHU9aVtzXSxsPUFycmF5LmlzQXJyYXkodCk/dFtzXS50ZW5zb3I6dFt1XTtpZihcImZsb2F0MzJcIiE9PWwuZHR5cGUmJlwiaW50MzJcIiE9PWwuZHR5cGUmJlwiYm9vbFwiIT09bC5kdHlwZSYmXCJzdHJpbmdcIiE9PWwuZHR5cGUpdGhyb3cgbmV3IEVycm9yKFwiVW5zdXBwb3J0ZWQgZHR5cGUgaW4gd2VpZ2h0ICdcIit1K1wiJzogXCIrbC5kdHlwZSk7dmFyIGg9e25hbWU6dSxzaGFwZTpsLnNoYXBlLGR0eXBlOmwuZHR5cGV9O2lmKFwic3RyaW5nXCI9PT1sLmR0eXBlKXt2YXIgZj1uZXcgUHJvbWlzZSgoZnVuY3Rpb24odCl7cmV0dXJuIG4oYyx2b2lkIDAsdm9pZCAwLChmdW5jdGlvbigpe3ZhciBlLG4sbyxhLGkscyx1O3JldHVybiByKHRoaXMsKGZ1bmN0aW9uKHIpe3N3aXRjaChyLmxhYmVsKXtjYXNlIDA6cmV0dXJuWzQsbC5ieXRlcygpXTtjYXNlIDE6Zm9yKGU9ci5zZW50KCksbj1lLnJlZHVjZSgoZnVuY3Rpb24odCxlKXtyZXR1cm4gdCtlLmxlbmd0aH0pLDApK3VmKmUubGVuZ3RoLG89bmV3IFVpbnQ4QXJyYXkobiksYT0wLGk9MDtpPGUubGVuZ3RoO2krKylzPWVbaV0sdT1uZXcgVWludDhBcnJheShuZXcgVWludDMyQXJyYXkoW3MubGVuZ3RoXSkuYnVmZmVyKSxvLnNldCh1LGEpLGErPXVmLG8uc2V0KHMsYSksYSs9cy5sZW5ndGg7cmV0dXJuIHQobyksWzJdfX0pKX0pKX0pKTthLnB1c2goZil9ZWxzZSBhLnB1c2gobC5kYXRhKCkpO251bGwhPWUmJihoLmdyb3VwPWUpLG8ucHVzaChoKX0sdT0wO3U8aS5sZW5ndGg7Kyt1KXModSk7cmV0dXJuWzQsUHJvbWlzZS5hbGwoYSldO2Nhc2UgMTpyZXR1cm5bMix7ZGF0YTpsZihsLnNlbnQoKSksc3BlY3M6b31dfX0pKX0pKX0sZnJvbU1lbW9yeTpmdW5jdGlvbih0LGUsbixyKXtyZXR1cm4gMT09PWFyZ3VtZW50cy5sZW5ndGg/bnVsbCE9dC5tb2RlbFRvcG9sb2d5fHxudWxsIT10LndlaWdodFNwZWNzP25ldyBaZih0KTooY29uc29sZS53YXJuKFwiUGxlYXNlIGNhbGwgdGYuaW8uZnJvbU1lbW9yeSgpIHdpdGggb25seSBvbmUgYXJndW1lbnQuIFRoZSBhcmd1bWVudCBzaG91bGQgYmUgb2YgdHlwZSBNb2RlbEFydGlmYWN0cy4gVGhlIG11bHRpLWFyZ3VtZW50IHNpZ25hdHVyZSBvZiB0Zi5pby5mcm9tTWVtb3J5KCkgaGFzIGJlZW4gZGVwcmVjYXRlZCBhbmQgd2lsbCBiZSByZW1vdmVkIGluIGEgZnV0dXJlIHJlbGVhc2UuXCIpLG5ldyBaZih7bW9kZWxUb3BvbG9neTp0fSkpOihjb25zb2xlLndhcm4oXCJQbGVhc2UgY2FsbCB0Zi5pby5mcm9tTWVtb3J5KCkgd2l0aCBvbmx5IG9uZSBhcmd1bWVudC4gVGhlIGFyZ3VtZW50IHNob3VsZCBiZSBvZiB0eXBlIE1vZGVsQXJ0aWZhY3RzLiBUaGUgbXVsdGktYXJndW1lbnQgc2lnbmF0dXJlIG9mIHRmLmlvLmZyb21NZW1vcnkoKSBoYXMgYmVlbiBkZXByZWNhdGVkIGFuZCB3aWxsIGJlIHJlbW92ZWQgaW4gYSBmdXR1cmUgcmVsZWFzZS5cIiksbmV3IFpmKHttb2RlbFRvcG9sb2d5OnQsd2VpZ2h0U3BlY3M6ZSx3ZWlnaHREYXRhOm4sdHJhaW5pbmdDb25maWc6cn0pKX0sZ2V0TG9hZEhhbmRsZXJzOmZ1bmN0aW9uKHQsZSl7cmV0dXJuIG1mLmdldExvYWRIYW5kbGVycyh0LGUpfSxnZXRNb2RlbEFydGlmYWN0c0luZm9Gb3JKU09OOnZmLGdldFNhdmVIYW5kbGVyczpmdW5jdGlvbih0KXtyZXR1cm4gbWYuZ2V0U2F2ZUhhbmRsZXJzKHQpfSxodHRwOkpmLGlzSFRUUFNjaGVtZTokZixsb2FkV2VpZ2h0czpmdW5jdGlvbih0LGUsbyxhKXtyZXR1cm4gdm9pZCAwPT09ZSYmKGU9XCJcIiksbih0aGlzLHZvaWQgMCx2b2lkIDAsKGZ1bmN0aW9uKCl7cmV0dXJuIHIodGhpcywoZnVuY3Rpb24obil7cmV0dXJuWzIsWGYoKGZ1bmN0aW9uKHQpe3JldHVybiBqZih0LHtyZXF1ZXN0SW5pdDphfSl9KSkodCxlLG8pXX0pKX0pKX0scmVnaXN0ZXJMb2FkUm91dGVyOmZ1bmN0aW9uKHQpe3JldHVybiBtZi5yZWdpc3RlckxvYWRSb3V0ZXIodCl9LHJlZ2lzdGVyU2F2ZVJvdXRlcjpmdW5jdGlvbih0KXtyZXR1cm4gbWYucmVnaXN0ZXJTYXZlUm91dGVyKHQpfSx3ZWlnaHRzTG9hZGVyRmFjdG9yeTpYZix3aXRoU2F2ZUhhbmRsZXI6ZnVuY3Rpb24odCl7cmV0dXJuIG5ldyB0ZCh0KX0sY29weU1vZGVsOmZ1bmN0aW9uKHQsZSl7cmV0dXJuIG4odGhpcyx2b2lkIDAsdm9pZCAwLChmdW5jdGlvbigpe3JldHVybiByKHRoaXMsKGZ1bmN0aW9uKG4pe3JldHVybiExLFsyLGJmKHQsZSwhMSldfSkpfSkpfSxsaXN0TW9kZWxzOmZ1bmN0aW9uKCl7cmV0dXJuIG4odGhpcyx2b2lkIDAsdm9pZCAwLChmdW5jdGlvbigpe3ZhciB0LGUsbixvLGEsaSxzO3JldHVybiByKHRoaXMsKGZ1bmN0aW9uKHIpe3N3aXRjaChyLmxhYmVsKXtjYXNlIDA6dD15Zi5nZXRTY2hlbWVzKCksZT17fSxuPTAsbz10LHIubGFiZWw9MTtjYXNlIDE6cmV0dXJuIG48by5sZW5ndGg/KGE9b1tuXSxbNCx5Zi5nZXRNYW5hZ2VyKGEpLmxpc3RNb2RlbHMoKV0pOlszLDRdO2Nhc2UgMjpmb3IocyBpbiBpPXIuc2VudCgpKWVbYStnZitzXT1pW3NdO3IubGFiZWw9MztjYXNlIDM6cmV0dXJuIG4rKyxbMywxXTtjYXNlIDQ6cmV0dXJuWzIsZV19fSkpfSkpfSxtb3ZlTW9kZWw6ZnVuY3Rpb24odCxlKXtyZXR1cm4gbih0aGlzLHZvaWQgMCx2b2lkIDAsKGZ1bmN0aW9uKCl7cmV0dXJuIHIodGhpcywoZnVuY3Rpb24obil7cmV0dXJuITAsWzIsYmYodCxlLCEwKV19KSl9KSl9LHJlbW92ZU1vZGVsOmZ1bmN0aW9uKHQpe3JldHVybiBuKHRoaXMsdm9pZCAwLHZvaWQgMCwoZnVuY3Rpb24oKXt2YXIgZTtyZXR1cm4gcih0aGlzLChmdW5jdGlvbihuKXtyZXR1cm4gZT14Zih0KSxbMix5Zi5nZXRNYW5hZ2VyKGUuc2NoZW1lKS5yZW1vdmVNb2RlbChlLnBhdGgpXX0pKX0pKX19KTt2YXIgbmQscmQ9QW4oe2NvbmZ1c2lvbk1hdHJpeF86ZnVuY3Rpb24odCxlLG4pe3ZhciByPW1uKHQsXCJsYWJlbHNcIixcImNvbmZ1c2lvbk1hdHJpeFwiKSxvPW1uKGUsXCJwcmVkaWN0aW9uc1wiLFwiY29uZnVzaW9uTWF0cml4XCIpO0MobnVsbD09bnx8bj4wJiZOdW1iZXIuaXNJbnRlZ2VyKG4pLChmdW5jdGlvbigpe3JldHVyblwiSWYgcHJvdmlkZWQsIG51bUNsYXNzZXMgbXVzdCBiZSBhIHBvc2l0aXZlIGludGVnZXIsIGJ1dCBnb3QgXCIrbn0pKSxDKDE9PT1yLnJhbmssKGZ1bmN0aW9uKCl7cmV0dXJuXCJFeHBlY3RlZCB0aGUgcmFuayBvZiBsYWJlbHMgdG8gYmUgMSwgYnV0IGdvdCBcIityLnJhbmt9KSksQygxPT09by5yYW5rLChmdW5jdGlvbigpe3JldHVyblwiRXhwZWN0ZWQgdGhlIHJhbmsgb2YgcHJlZGljdGlvbnMgdG8gYmUgMSwgYnV0IGdvdCBcIitvLnJhbmt9KSksQyhyLnNoYXBlWzBdPT09by5zaGFwZVswXSwoZnVuY3Rpb24oKXtyZXR1cm5cIk1pc21hdGNoIGluIHRoZSBudW1iZXIgb2YgZXhhbXBsZXM6IFwiK3Iuc2hhcGVbMF0rXCIgdnMuIFwiK28uc2hhcGVbMF0rXCIuIExhYmVscyBhbmQgcHJlZGljdGlvbnMgc2hvdWxkIGhhdmUgdGhlIHNhbWUgbnVtYmVyIG9mIGVsZW1lbnRzLlwifSkpLEMobj4wJiZOdW1iZXIuaXNJbnRlZ2VyKG4pLChmdW5jdGlvbigpe3JldHVyblwibnVtQ2xhc3NlcyBpcyByZXF1aXJlZCB0byBiZSBhIHBvc2l0aXZlIGludGVnZXIsIGJ1dCBnb3QgXCIrbn0pKTt2YXIgYT1ScihyLmFzVHlwZShcImludDMyXCIpLG4pLGk9UnIoby5hc1R5cGUoXCJpbnQzMlwiKSxuKTtyZXR1cm4gYS50cmFuc3Bvc2UoKS5tYXRNdWwoaSkuYXNUeXBlKFwiaW50MzJcIil9fSksb2Q9T2JqZWN0LmZyZWV6ZSh7Y29uZnVzaW9uTWF0cml4OnJkfSk7dmFyIGFkPUFuKHtmcm9tUGl4ZWxzXzpmdW5jdGlvbih0LGUpe2lmKHZvaWQgMD09PWUmJihlPTMpLGU+NCl0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgY29uc3RydWN0IFRlbnNvciB3aXRoIG1vcmUgdGhhbiA0IGNoYW5uZWxzIGZyb20gcGl4ZWxzLlwiKTtpZihudWxsPT10KXRocm93IG5ldyBFcnJvcihcInBpeGVscyBwYXNzZWQgdG8gdGYuYnJvd3Nlci5mcm9tUGl4ZWxzKCkgY2FuIG5vdCBiZSBudWxsXCIpO3ZhciBuPSExLHI9ITEsbz0hMSxhPSExLGk9ITE7aWYodC5kYXRhIGluc3RhbmNlb2YgVWludDhBcnJheSluPSEwO2Vsc2UgaWYoXCJ1bmRlZmluZWRcIiE9dHlwZW9mIEltYWdlRGF0YSYmdCBpbnN0YW5jZW9mIEltYWdlRGF0YSlyPSEwO2Vsc2UgaWYoXCJ1bmRlZmluZWRcIiE9dHlwZW9mIEhUTUxWaWRlb0VsZW1lbnQmJnQgaW5zdGFuY2VvZiBIVE1MVmlkZW9FbGVtZW50KW89ITA7ZWxzZSBpZihcInVuZGVmaW5lZFwiIT10eXBlb2YgSFRNTEltYWdlRWxlbWVudCYmdCBpbnN0YW5jZW9mIEhUTUxJbWFnZUVsZW1lbnQpYT0hMDtlbHNle2lmKG51bGw9PXQuZ2V0Q29udGV4dCl0aHJvdyBuZXcgRXJyb3IoXCJwaXhlbHMgcGFzc2VkIHRvIHRmLmJyb3dzZXIuZnJvbVBpeGVscygpIG11c3QgYmUgZWl0aGVyIGFuIEhUTUxWaWRlb0VsZW1lbnQsIEhUTUxJbWFnZUVsZW1lbnQsIEhUTUxDYW52YXNFbGVtZW50LCBJbWFnZURhdGEgaW4gYnJvd3Nlciwgb3IgT2Zmc2NyZWVuQ2FudmFzLCBJbWFnZURhdGEgaW4gd2Vid29ya2VyIG9yIHtkYXRhOiBVaW50MzJBcnJheSwgd2lkdGg6IG51bWJlciwgaGVpZ2h0OiBudW1iZXJ9LCBidXQgd2FzIFwiK3QuY29uc3RydWN0b3IubmFtZSk7aT0hMH1pZihvKXtpZihvJiZ0LnJlYWR5U3RhdGU8Mil0aHJvdyBuZXcgRXJyb3IoXCJUaGUgdmlkZW8gZWxlbWVudCBoYXMgbm90IGxvYWRlZCBkYXRhIHlldC4gUGxlYXNlIHdhaXQgZm9yIGBsb2FkZWRkYXRhYCBldmVudCBvbiB0aGUgPHZpZGVvPiBlbGVtZW50LlwiKX1pZihudWxsIT1sKFwiRnJvbVBpeGVsc1wiLEx0LmJhY2tlbmROYW1lKSlyZXR1cm4gTHQucnVuS2VybmVsKFwiRnJvbVBpeGVsc1wiLHtwaXhlbHM6dH0se251bUNoYW5uZWxzOmV9KTt2YXIgcyx1LGM9bz9bdC52aWRlb1dpZHRoLHQudmlkZW9IZWlnaHRdOlt0LndpZHRoLHQuaGVpZ2h0XSxoPWNbMF0sZj1jWzFdO2lmKGk/cz10LmdldENvbnRleHQoXCIyZFwiKS5nZXRJbWFnZURhdGEoMCwwLGgsZikuZGF0YTpyfHxuP3M9dC5kYXRhOihhfHxvKSYmKG51bGw9PW5kJiYobmQ9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImNhbnZhc1wiKS5nZXRDb250ZXh0KFwiMmRcIikpLG5kLmNhbnZhcy53aWR0aD1oLG5kLmNhbnZhcy5oZWlnaHQ9ZixuZC5kcmF3SW1hZ2UodCwwLDAsaCxmKSxzPW5kLmdldEltYWdlRGF0YSgwLDAsaCxmKS5kYXRhKSw0PT09ZSl1PW5ldyBJbnQzMkFycmF5KHMpO2Vsc2V7dmFyIGQ9aCpmO3U9bmV3IEludDMyQXJyYXkoZCplKTtmb3IodmFyIHA9MDtwPGQ7cCsrKWZvcih2YXIgdj0wO3Y8ZTsrK3YpdVtwKmUrdl09c1s0KnArdl19cmV0dXJuIFBuKHUsW2YsaCxlXSxcImludDMyXCIpfX0pLGlkPU9iamVjdC5mcmVlemUoe3RvUGl4ZWxzOmZ1bmN0aW9uKHQsZSl7cmV0dXJuIG4odGhpcyx2b2lkIDAsdm9pZCAwLChmdW5jdGlvbigpe3ZhciBuLG8sYSxpLHMsdSxjLGwsaCxmLGQscCx2LG0sZyx5LHgsYix3LEMsRSxSLEk7cmV0dXJuIHIodGhpcywoZnVuY3Rpb24ocil7c3dpdGNoKHIubGFiZWwpe2Nhc2UgMDppZihuPW1uKHQsXCJpbWdcIixcInRvUGl4ZWxzXCIpLHQgaW5zdGFuY2VvZiB3dHx8KG49bi50b0ludCgpKSwyIT09bi5yYW5rJiYzIT09bi5yYW5rKXRocm93IG5ldyBFcnJvcihcInRvUGl4ZWxzIG9ubHkgc3VwcG9ydHMgcmFuayAyIG9yIDMgdGVuc29ycywgZ290IHJhbmsgXCIrbi5yYW5rK1wiLlwiKTtpZihvPW4uc2hhcGUuc2xpY2UoMCwyKSxhPW9bMF0saT1vWzFdLChzPTI9PT1uLnJhbms/MTpuLnNoYXBlWzJdKT40fHwyPT09cyl0aHJvdyBuZXcgRXJyb3IoXCJ0b1BpeGVscyBvbmx5IHN1cHBvcnRzIGRlcHRoIG9mIHNpemUgMSwgMyBvciA0IGJ1dCBnb3QgXCIrcyk7cmV0dXJuWzQsbi5kYXRhKCldO2Nhc2UgMTpyZXR1cm4gdT1yLnNlbnQoKSxjPW4ubWluKCksbD1uLm1heCgpLFs0LFByb21pc2UuYWxsKFtjLmRhdGEoKSxsLmRhdGEoKV0pXTtjYXNlIDI6aWYoaD1yLnNlbnQoKSxmPWhbMF0sZD1oWzFdLHA9ZlswXSx2PWRbMF0sYy5kaXNwb3NlKCksbC5kaXNwb3NlKCksXCJmbG9hdDMyXCI9PT1uLmR0eXBlKXtpZihwPDB8fHY+MSl0aHJvdyBuZXcgRXJyb3IoXCJUZW5zb3IgdmFsdWVzIGZvciBhIGZsb2F0MzIgVGVuc29yIG11c3QgYmUgaW4gdGhlIHJhbmdlIFswIC0gMV0gYnV0IGdvdCByYW5nZSBbXCIrcCtcIiAtIFwiK3YrXCJdLlwiKX1lbHNle2lmKFwiaW50MzJcIiE9PW4uZHR5cGUpdGhyb3cgbmV3IEVycm9yKFwiVW5zdXBwb3J0ZWQgdHlwZSBmb3IgdG9QaXhlbHM6IFwiK24uZHR5cGUrXCIuIFBsZWFzZSB1c2UgZmxvYXQzMiBvciBpbnQzMiB0ZW5zb3JzLlwiKTtpZihwPDB8fHY+MjU1KXRocm93IG5ldyBFcnJvcihcIlRlbnNvciB2YWx1ZXMgZm9yIGEgaW50MzIgVGVuc29yIG11c3QgYmUgaW4gdGhlIHJhbmdlIFswIC0gMjU1XSBidXQgZ290IHJhbmdlIFtcIitwK1wiIC0gXCIrditcIl0uXCIpfWZvcihtPVwiZmxvYXQzMlwiPT09bi5kdHlwZT8yNTU6MSxnPW5ldyBVaW50OENsYW1wZWRBcnJheShpKmEqNCkseT0wO3k8YSppOysreSl4PXZvaWQgMCxiPXZvaWQgMCx3PXZvaWQgMCxDPXZvaWQgMCwxPT09cz8oeD11W3ldKm0sYj11W3ldKm0sdz11W3ldKm0sQz0yNTUpOjM9PT1zPyh4PXVbMyp5XSptLGI9dVszKnkrMV0qbSx3PXVbMyp5KzJdKm0sQz0yNTUpOjQ9PT1zJiYoeD11WzQqeV0qbSxiPXVbNCp5KzFdKm0sdz11WzQqeSsyXSptLEM9dVs0KnkrM10qbSksZ1soRT00KnkpKzBdPU1hdGgucm91bmQoeCksZ1tFKzFdPU1hdGgucm91bmQoYiksZ1tFKzJdPU1hdGgucm91bmQodyksZ1tFKzNdPU1hdGgucm91bmQoQyk7cmV0dXJuIG51bGwhPWUmJihlLndpZHRoPWksZS5oZWlnaHQ9YSxSPWUuZ2V0Q29udGV4dChcIjJkXCIpLEk9bmV3IEltYWdlRGF0YShnLGksYSksUi5wdXRJbWFnZURhdGEoSSwwLDApKSxuIT09dCYmbi5kaXNwb3NlKCksWzIsZ119fSkpfSkpfSxmcm9tUGl4ZWxzOmFkfSksc2Q9ZnVuY3Rpb24oKXtmdW5jdGlvbiB0KCl7fXJldHVybiB0LnByb3RvdHlwZS5nZXRDbGFzc05hbWU9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5jb25zdHJ1Y3Rvci5jbGFzc05hbWV9LHQuZnJvbUNvbmZpZz1mdW5jdGlvbih0LGUpe3JldHVybiBuZXcgdChlKX0sdH0oKSx1ZD1mdW5jdGlvbigpe2Z1bmN0aW9uIHQoKXt0aGlzLmNsYXNzTmFtZU1hcD17fX1yZXR1cm4gdC5nZXRNYXA9ZnVuY3Rpb24oKXtyZXR1cm4gbnVsbD09dC5pbnN0YW5jZSYmKHQuaW5zdGFuY2U9bmV3IHQpLHQuaW5zdGFuY2V9LHQucmVnaXN0ZXI9ZnVuY3Rpb24oZSl7dC5nZXRNYXAoKS5jbGFzc05hbWVNYXBbZS5jbGFzc05hbWVdPVtlLGUuZnJvbUNvbmZpZ119LHR9KCk7ZnVuY3Rpb24gY2QodCl7QyhudWxsIT10LmNsYXNzTmFtZSwoZnVuY3Rpb24oKXtyZXR1cm5cIkNsYXNzIGJlaW5nIHJlZ2lzdGVyZWQgZG9lcyBub3QgaGF2ZSB0aGUgc3RhdGljIGNsYXNzTmFtZSBwcm9wZXJ0eSBkZWZpbmVkLlwifSkpLEMoXCJzdHJpbmdcIj09dHlwZW9mIHQuY2xhc3NOYW1lLChmdW5jdGlvbigpe3JldHVyblwiY2xhc3NOYW1lIGlzIHJlcXVpcmVkIHRvIGJlIGEgc3RyaW5nLCBidXQgZ290IHR5cGUgXCIrdHlwZW9mIHQuY2xhc3NOYW1lfSkpLEModC5jbGFzc05hbWUubGVuZ3RoPjAsKGZ1bmN0aW9uKCl7cmV0dXJuXCJDbGFzcyBiZWluZyByZWdpc3RlcmVkIGhhcyBhbiBlbXB0eS1zdHJpbmcgYXMgaXRzIGNsYXNzTmFtZSwgd2hpY2ggaXMgZGlzYWxsb3dlZC5cIn0pKSx1ZC5yZWdpc3Rlcih0KX12YXIgbGQ9T2JqZWN0LmZyZWV6ZSh7U2VyaWFsaXphYmxlOnNkLFNlcmlhbGl6YXRpb25NYXA6dWQscmVnaXN0ZXJDbGFzczpjZH0pLGhkPS4wMDEsZmQ9LjE7ZnVuY3Rpb24gZGQoKXtyZXR1cm4gMzI9PT1MdC5iYWNrZW5kLmZsb2F0UHJlY2lzaW9uKCk/aGQ6ZmR9ZnVuY3Rpb24gcGQodCxlLG4pe3ZhciByPSEwO2lmKChWKHQpfHxWKGUpKSYmKHI9ITEpLFYodCkmJlYoZSkmJihyPSEwKSxyKXt2YXIgbz10LmNvbnN0cnVjdG9yLm5hbWUsYT1lLmNvbnN0cnVjdG9yLm5hbWU7aWYobyE9PWEpdGhyb3cgbmV3IEVycm9yKFwiQXJyYXlzIGFyZSBvZiBkaWZmZXJlbnQgdHlwZS4gQWN0dWFsOiBcIitvK1wiLiBFeHBlY3RlZDogXCIrYSl9aWYoQXJyYXkuaXNBcnJheSh0KSYmQXJyYXkuaXNBcnJheShlKSl7dmFyIGk9cG4odCkscz1wbihlKTtpZighUyhpLHMpKXRocm93IG5ldyBFcnJvcihcIkFycmF5cyBoYXZlIGRpZmZlcmVudCBzaGFwZXMuIEFjdHVhbDogW1wiK2krXCJdLiBFeHBlY3RlZDogW1wiK3MrXCJdXCIpfXZhciB1PVYodCk/dDpJKHQpLGM9VihlKT9lOkkoZSk7aWYodS5sZW5ndGghPT1jLmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJBcnJheXMgaGF2ZSBkaWZmZXJlbnQgbGVuZ3RocyBhY3R1YWw6IFwiK3UubGVuZ3RoK1wiIHZzIGV4cGVjdGVkOiBcIitjLmxlbmd0aCtcIi5cXG5BY3R1YWw6ICAgXCIrdStcIi5cXG5FeHBlY3RlZDogXCIrYytcIi5cIik7Zm9yKHZhciBsPTA7bDxjLmxlbmd0aDsrK2wpe3ZhciBoPXVbbF0sZj1jW2xdO2lmKCFuKGgsZikpdGhyb3cgbmV3IEVycm9yKFwiQXJyYXlzIGRpZmZlcjogYWN0dWFsW1wiK2wrXCJdID0gXCIraCtcIiwgZXhwZWN0ZWRbXCIrbCtcIl0gPSBcIitmK1wiLlxcbkFjdHVhbDogICBcIit1K1wiLlxcbkV4cGVjdGVkOiBcIitjK1wiLlwiKX19ZnVuY3Rpb24gdmQodCxlLG4pe3JldHVybiFpc0Zpbml0ZSh0KSYmIWlzRmluaXRlKGUpfHwhKGlzTmFOKHQpfHxpc05hTihlKXx8TWF0aC5hYnModC1lKT5uKX12YXIgbWQ9T2JqZWN0LmZyZWV6ZSh7VEVTVF9FUFNJTE9OX0ZMT0FUMTY6ZmQsZXhwZWN0QXJyYXlzQ2xvc2U6ZnVuY3Rpb24odCxlLG4pe3JldHVybiBudWxsPT1uJiYobj1kZCgpKSxwZCh0LGUsKGZ1bmN0aW9uKHQsZSl7cmV0dXJuIHZkKHQsZSxuKX0pKX0sdGVzdEVwc2lsb246ZGQsZXhwZWN0UHJvbWlzZVRvRmFpbDpmdW5jdGlvbih0LGUpe3QoKS50aGVuKChmdW5jdGlvbigpe3JldHVybiBlLmZhaWwoKX0pLChmdW5jdGlvbigpe3JldHVybiBlKCl9KSl9LGV4cGVjdEFycmF5c0VxdWFsOmZ1bmN0aW9uKHQsZSl7dmFyIG49XCJzdHJpbmdcIj09dHlwZW9mIGV8fFwibnVtYmVyXCI9PXR5cGVvZiBlfHxcImJvb2xlYW5cIj09dHlwZW9mIGU/W2VdOmU7cmV0dXJuIEgodCl8fEgodFswXSl8fEgoZSl8fEgoZVswXSk/cGQodCxuLChmdW5jdGlvbih0LGUpe3JldHVybiB0PT1lfSkpOnBkKHQsZSwoZnVuY3Rpb24odCxlKXtyZXR1cm4gdmQodCxlLDApfSkpfSxleHBlY3ROdW1iZXJzQ2xvc2U6ZnVuY3Rpb24odCxlLG4pe2lmKG51bGw9PW4mJihuPWRkKCkpLCF2ZCh0LGUsbikpdGhyb3cgbmV3IEVycm9yKFwiTnVtYmVycyBkaWZmZXI6IGFjdHVhbCA9PT0gXCIrdCtcIiwgZXhwZWN0ZWQgPT09IFwiK2UpfSxleHBlY3RWYWx1ZXNJblJhbmdlOmZ1bmN0aW9uKHQsZSxuKXtmb3IodmFyIHI9MDtyPHQubGVuZ3RoO3IrKylpZih0W3JdPGV8fHRbcl0+bil0aHJvdyBuZXcgRXJyb3IoXCJWYWx1ZSBvdXQgb2YgcmFuZ2U6XCIrdFtyXStcIiBsb3c6IFwiK2UrXCIsIGhpZ2g6IFwiK24pfSxleHBlY3RBcnJheUJ1ZmZlcnNFcXVhbDpmdW5jdGlvbih0LGUpe2V4cGVjdChuZXcgRmxvYXQzMkFycmF5KHQpKS50b0VxdWFsKG5ldyBGbG9hdDMyQXJyYXkoZSkpfX0pLGdkPVwiMS43LjBcIjt2YXIgeWQ9T2JqZWN0LmZyZWV6ZSh7Z3BncHVfdXRpbDpNaSx3ZWJnbF91dGlsOkdlLGZvcmNlSGFsZkZsb2F0OmZ1bmN0aW9uKCl7aSgpLnNldChcIldFQkdMX0ZPUkNFX0YxNl9URVhUVVJFU1wiLCEwKX0sTWF0aEJhY2tlbmRXZWJHTDpacyxzZXRXZWJHTENvbnRleHQ6S3QsR1BHUFVDb250ZXh0OkJpfSkseGQ9ZnVuY3Rpb24odCl7ZnVuY3Rpb24gbygpe3JldHVybiBudWxsIT09dCYmdC5hcHBseSh0aGlzLGFyZ3VtZW50cyl8fHRoaXN9cmV0dXJuIGUobyx0KSxvLnByb3RvdHlwZS5taW5pbWl6ZT1mdW5jdGlvbih0LGUsbil7dm9pZCAwPT09ZSYmKGU9ITEpO3ZhciByPXRoaXMuY29tcHV0ZUdyYWRpZW50cyh0LG4pLG89ci52YWx1ZSxhPXIuZ3JhZHM7aWYobnVsbCE9bil7dmFyIGk9bi5tYXAoKGZ1bmN0aW9uKHQpe3JldHVybntuYW1lOnQubmFtZSx0ZW5zb3I6YVt0Lm5hbWVdfX0pKTt0aGlzLmFwcGx5R3JhZGllbnRzKGkpfWVsc2UgdGhpcy5hcHBseUdyYWRpZW50cyhhKTtyZXR1cm4gdG4oYSksZT9vOihvLmRpc3Bvc2UoKSxudWxsKX0sT2JqZWN0LmRlZmluZVByb3BlcnR5KG8ucHJvdG90eXBlLFwiaXRlcmF0aW9uc1wiLHtnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gbnVsbD09dGhpcy5pdGVyYXRpb25zXyYmKHRoaXMuaXRlcmF0aW9uc189MCksdGhpcy5pdGVyYXRpb25zX30sZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITB9KSxvLnByb3RvdHlwZS5pbmNyZW1lbnRJdGVyYXRpb25zPWZ1bmN0aW9uKCl7dGhpcy5pdGVyYXRpb25zXz10aGlzLml0ZXJhdGlvbnMrMX0sby5wcm90b3R5cGUuY29tcHV0ZUdyYWRpZW50cz1mdW5jdGlvbih0LGUpe3JldHVybiBwbyh0LGUpfSxvLnByb3RvdHlwZS5kaXNwb3NlPWZ1bmN0aW9uKCl7bnVsbCE9dGhpcy5pdGVyYXRpb25zXyYmdG4odGhpcy5pdGVyYXRpb25zXyl9LG8ucHJvdG90eXBlLnNhdmVJdGVyYXRpb25zPWZ1bmN0aW9uKCl7cmV0dXJuIG4odGhpcyx2b2lkIDAsdm9pZCAwLChmdW5jdGlvbigpe3JldHVybiByKHRoaXMsKGZ1bmN0aW9uKHQpe3JldHVybiBudWxsPT10aGlzLml0ZXJhdGlvbnNfJiYodGhpcy5pdGVyYXRpb25zXz0wKSxbMix7bmFtZTpcIml0ZXJcIix0ZW5zb3I6T24odGhpcy5pdGVyYXRpb25zXyxcImludDMyXCIpfV19KSl9KSl9LG8ucHJvdG90eXBlLmdldFdlaWdodHM9ZnVuY3Rpb24oKXtyZXR1cm4gbih0aGlzLHZvaWQgMCx2b2lkIDAsKGZ1bmN0aW9uKCl7cmV0dXJuIHIodGhpcywoZnVuY3Rpb24odCl7dGhyb3cgbmV3IEVycm9yKFwiZ2V0V2VpZ2h0cygpIGlzIG5vdCBpbXBsZW1lbnRlZCBmb3IgdGhpcyBvcHRpbWl6ZXIgeWV0LlwiKX0pKX0pKX0sby5wcm90b3R5cGUuc2V0V2VpZ2h0cz1mdW5jdGlvbih0KXtyZXR1cm4gbih0aGlzLHZvaWQgMCx2b2lkIDAsKGZ1bmN0aW9uKCl7cmV0dXJuIHIodGhpcywoZnVuY3Rpb24odCl7dGhyb3cgbmV3IEVycm9yKFwic2V0V2VpZ2h0cygpIGlzIG5vdCBpbXBsZW1lbnRlZCBmb3IgdGhpcyBvcHRpbWl6ZXIgY2xhc3MgXCIrdGhpcy5nZXRDbGFzc05hbWUoKSl9KSl9KSl9LG8ucHJvdG90eXBlLmV4dHJhY3RJdGVyYXRpb25zPWZ1bmN0aW9uKHQpe3JldHVybiBuKHRoaXMsdm9pZCAwLHZvaWQgMCwoZnVuY3Rpb24oKXt2YXIgZTtyZXR1cm4gcih0aGlzLChmdW5jdGlvbihuKXtzd2l0Y2gobi5sYWJlbCl7Y2FzZSAwOnJldHVybiBlPXRoaXMsWzQsdFswXS50ZW5zb3IuZGF0YSgpXTtjYXNlIDE6cmV0dXJuIGUuaXRlcmF0aW9uc189bi5zZW50KClbMF0sWzIsdC5zbGljZSgxKV19fSkpfSkpfSxvfShzZCk7T2JqZWN0LmRlZmluZVByb3BlcnR5KHhkLFN5bWJvbC5oYXNJbnN0YW5jZSx7dmFsdWU6ZnVuY3Rpb24odCl7cmV0dXJuIG51bGwhPXQubWluaW1pemUmJm51bGwhPXQuY29tcHV0ZUdyYWRpZW50cyYmbnVsbCE9dC5hcHBseUdyYWRpZW50c319KTt2YXIgYmQ9ZnVuY3Rpb24odCl7ZnVuY3Rpb24gbyhlLG4scil7dm9pZCAwPT09ciYmKHI9bnVsbCk7dmFyIG89dC5jYWxsKHRoaXMpfHx0aGlzO3JldHVybiBvLmxlYXJuaW5nUmF0ZT1lLG8ucmhvPW4sby5lcHNpbG9uPXIsby5hY2N1bXVsYXRlZEdyYWRzPVtdLG8uYWNjdW11bGF0ZWRVcGRhdGVzPVtdLG51bGw9PXImJihvLmVwc2lsb249THQuYmFja2VuZC5lcHNpbG9uKCkpLG99cmV0dXJuIGUobyx0KSxvLnByb3RvdHlwZS5hcHBseUdyYWRpZW50cz1mdW5jdGlvbih0KXt2YXIgZT10aGlzOyhBcnJheS5pc0FycmF5KHQpP3QubWFwKChmdW5jdGlvbih0KXtyZXR1cm4gdC5uYW1lfSkpOk9iamVjdC5rZXlzKHQpKS5mb3JFYWNoKChmdW5jdGlvbihuLHIpe3ZhciBvPUx0LnJlZ2lzdGVyZWRWYXJpYWJsZXNbbl07bnVsbD09ZS5hY2N1bXVsYXRlZEdyYWRzW3JdJiYoZS5hY2N1bXVsYXRlZEdyYWRzW3JdPXtvcmlnaW5hbE5hbWU6bitcIi9hY2N1bV9ncmFkXCIsdmFyaWFibGU6WmUoKGZ1bmN0aW9uKCl7cmV0dXJuIFhuKG8pLnZhcmlhYmxlKCExKX0pKX0pLG51bGw9PWUuYWNjdW11bGF0ZWRVcGRhdGVzW3JdJiYoZS5hY2N1bXVsYXRlZFVwZGF0ZXNbcl09e29yaWdpbmFsTmFtZTpuK1wiL2FjY3VtX3ZhclwiLHZhcmlhYmxlOlplKChmdW5jdGlvbigpe3JldHVybiBYbihvKS52YXJpYWJsZSghMSl9KSl9KTt2YXIgYT1BcnJheS5pc0FycmF5KHQpP3Rbcl0udGVuc29yOnRbbl07aWYobnVsbCE9YSl7dmFyIGk9ZS5hY2N1bXVsYXRlZEdyYWRzW3JdLnZhcmlhYmxlLHM9ZS5hY2N1bXVsYXRlZFVwZGF0ZXNbcl0udmFyaWFibGU7WmUoKGZ1bmN0aW9uKCl7dmFyIHQ9aS5tdWwoZS5yaG8pLmFkZChhLnNxdWFyZSgpLm11bCgxLWUucmhvKSksbj1zLmFkZChlLmVwc2lsb24pLnNxcnQoKS5kaXYoaS5hZGQoZS5lcHNpbG9uKS5zcXJ0KCkpLm11bChhKSxyPXMubXVsKGUucmhvKS5hZGQobi5zcXVhcmUoKS5tdWwoMS1lLnJobykpO2kuYXNzaWduKHQpLHMuYXNzaWduKHIpO3ZhciB1PW4ubXVsKC1lLmxlYXJuaW5nUmF0ZSkuYWRkKG8pO28uYXNzaWduKHUpfSkpfX0pKSx0aGlzLmluY3JlbWVudEl0ZXJhdGlvbnMoKX0sby5wcm90b3R5cGUuZGlzcG9zZT1mdW5jdGlvbigpe251bGwhPXRoaXMuYWNjdW11bGF0ZWRVcGRhdGVzJiYodG4odGhpcy5hY2N1bXVsYXRlZEdyYWRzLm1hcCgoZnVuY3Rpb24odCl7cmV0dXJuIHQudmFyaWFibGV9KSkpLHRuKHRoaXMuYWNjdW11bGF0ZWRVcGRhdGVzLm1hcCgoZnVuY3Rpb24odCl7cmV0dXJuIHQudmFyaWFibGV9KSkpKX0sby5wcm90b3R5cGUuZ2V0V2VpZ2h0cz1mdW5jdGlvbigpe3JldHVybiBuKHRoaXMsdm9pZCAwLHZvaWQgMCwoZnVuY3Rpb24oKXt2YXIgdDtyZXR1cm4gcih0aGlzLChmdW5jdGlvbihlKXtzd2l0Y2goZS5sYWJlbCl7Y2FzZSAwOnJldHVybiB0PXRoaXMuYWNjdW11bGF0ZWRHcmFkcy5jb25jYXQodGhpcy5hY2N1bXVsYXRlZFVwZGF0ZXMpLFs0LHRoaXMuc2F2ZUl0ZXJhdGlvbnMoKV07Y2FzZSAxOnJldHVyblsyLFtlLnNlbnQoKV0uY29uY2F0KHQubWFwKChmdW5jdGlvbih0KXtyZXR1cm57bmFtZTp0Lm9yaWdpbmFsTmFtZSx0ZW5zb3I6dC52YXJpYWJsZX19KSkpXX19KSl9KSl9LG8ucHJvdG90eXBlLnNldFdlaWdodHM9ZnVuY3Rpb24odCl7cmV0dXJuIG4odGhpcyx2b2lkIDAsdm9pZCAwLChmdW5jdGlvbigpe3ZhciBlO3JldHVybiByKHRoaXMsKGZ1bmN0aW9uKG4pe3N3aXRjaChuLmxhYmVsKXtjYXNlIDA6cmV0dXJuWzQsdGhpcy5leHRyYWN0SXRlcmF0aW9ucyh0KV07Y2FzZSAxOnJldHVybiB0PW4uc2VudCgpLGU9dC5sZW5ndGgvMiwhMSx0aGlzLmFjY3VtdWxhdGVkR3JhZHM9dC5zbGljZSgwLGUpLm1hcCgoZnVuY3Rpb24odCl7cmV0dXJue29yaWdpbmFsTmFtZTp0Lm5hbWUsdmFyaWFibGU6dC50ZW5zb3IudmFyaWFibGUoITEpfX0pKSx0aGlzLmFjY3VtdWxhdGVkVXBkYXRlcz10LnNsaWNlKGUsMiplKS5tYXAoKGZ1bmN0aW9uKHQpe3JldHVybntvcmlnaW5hbE5hbWU6dC5uYW1lLHZhcmlhYmxlOnQudGVuc29yLnZhcmlhYmxlKCExKX19KSksWzJdfX0pKX0pKX0sby5wcm90b3R5cGUuZ2V0Q29uZmlnPWZ1bmN0aW9uKCl7cmV0dXJue2xlYXJuaW5nUmF0ZTp0aGlzLmxlYXJuaW5nUmF0ZSxyaG86dGhpcy5yaG8sZXBzaWxvbjp0aGlzLmVwc2lsb259fSxvLmZyb21Db25maWc9ZnVuY3Rpb24odCxlKXtyZXR1cm4gbmV3IHQoZS5sZWFybmluZ1JhdGUsZS5yaG8sZS5lcHNpbG9uKX0sby5jbGFzc05hbWU9XCJBZGFkZWx0YVwiLG99KHhkKTtjZChiZCk7dmFyIHdkPWZ1bmN0aW9uKHQpe2Z1bmN0aW9uIG8oZSxuKXt2b2lkIDA9PT1uJiYobj0uMSk7dmFyIHI9dC5jYWxsKHRoaXMpfHx0aGlzO3JldHVybiByLmxlYXJuaW5nUmF0ZT1lLHIuaW5pdGlhbEFjY3VtdWxhdG9yVmFsdWU9bixyLmFjY3VtdWxhdGVkR3JhZHM9W10scn1yZXR1cm4gZShvLHQpLG8ucHJvdG90eXBlLmFwcGx5R3JhZGllbnRzPWZ1bmN0aW9uKHQpe3ZhciBlPXRoaXM7KEFycmF5LmlzQXJyYXkodCk/dC5tYXAoKGZ1bmN0aW9uKHQpe3JldHVybiB0Lm5hbWV9KSk6T2JqZWN0LmtleXModCkpLmZvckVhY2goKGZ1bmN0aW9uKG4scil7dmFyIG89THQucmVnaXN0ZXJlZFZhcmlhYmxlc1tuXTtpZihudWxsPT1lLmFjY3VtdWxhdGVkR3JhZHNbcl0pe2UuYWNjdW11bGF0ZWRHcmFkc1tyXT17b3JpZ2luYWxOYW1lOm4rXCIvYWNjdW11bGF0b3JcIix2YXJpYWJsZTpaZSgoZnVuY3Rpb24oKXtyZXR1cm4gSG4oby5zaGFwZSxlLmluaXRpYWxBY2N1bXVsYXRvclZhbHVlKS52YXJpYWJsZSghMSl9KSl9fXZhciBhPUFycmF5LmlzQXJyYXkodCk/dFtyXS50ZW5zb3I6dFtuXTtpZihudWxsIT1hKXt2YXIgaT1lLmFjY3VtdWxhdGVkR3JhZHNbcl0udmFyaWFibGU7WmUoKGZ1bmN0aW9uKCl7dmFyIHQ9aS5hZGQoYS5zcXVhcmUoKSk7aS5hc3NpZ24odCk7dmFyIG49YS5kaXYodC5hZGQoTHQuYmFja2VuZC5lcHNpbG9uKCkpLnNxcnQoKSkubXVsKC1lLmxlYXJuaW5nUmF0ZSkuYWRkKG8pO28uYXNzaWduKG4pfSkpfX0pKSx0aGlzLmluY3JlbWVudEl0ZXJhdGlvbnMoKX0sby5wcm90b3R5cGUuZGlzcG9zZT1mdW5jdGlvbigpe251bGwhPXRoaXMuYWNjdW11bGF0ZWRHcmFkcyYmdG4odGhpcy5hY2N1bXVsYXRlZEdyYWRzLm1hcCgoZnVuY3Rpb24odCl7cmV0dXJuIHQudmFyaWFibGV9KSkpfSxvLnByb3RvdHlwZS5nZXRXZWlnaHRzPWZ1bmN0aW9uKCl7cmV0dXJuIG4odGhpcyx2b2lkIDAsdm9pZCAwLChmdW5jdGlvbigpe3JldHVybiByKHRoaXMsKGZ1bmN0aW9uKHQpe3N3aXRjaCh0LmxhYmVsKXtjYXNlIDA6cmV0dXJuWzQsdGhpcy5zYXZlSXRlcmF0aW9ucygpXTtjYXNlIDE6cmV0dXJuWzIsW3Quc2VudCgpXS5jb25jYXQodGhpcy5hY2N1bXVsYXRlZEdyYWRzLm1hcCgoZnVuY3Rpb24odCl7cmV0dXJue25hbWU6dC5vcmlnaW5hbE5hbWUsdGVuc29yOnQudmFyaWFibGV9fSkpKV19fSkpfSkpfSxvLnByb3RvdHlwZS5zZXRXZWlnaHRzPWZ1bmN0aW9uKHQpe3JldHVybiBuKHRoaXMsdm9pZCAwLHZvaWQgMCwoZnVuY3Rpb24oKXtyZXR1cm4gcih0aGlzLChmdW5jdGlvbihlKXtzd2l0Y2goZS5sYWJlbCl7Y2FzZSAwOnJldHVybls0LHRoaXMuZXh0cmFjdEl0ZXJhdGlvbnModCldO2Nhc2UgMTpyZXR1cm4gdD1lLnNlbnQoKSwhMSx0aGlzLmFjY3VtdWxhdGVkR3JhZHM9dC5tYXAoKGZ1bmN0aW9uKHQpe3JldHVybntvcmlnaW5hbE5hbWU6dC5uYW1lLHZhcmlhYmxlOnQudGVuc29yLnZhcmlhYmxlKCExKX19KSksWzJdfX0pKX0pKX0sby5wcm90b3R5cGUuZ2V0Q29uZmlnPWZ1bmN0aW9uKCl7cmV0dXJue2xlYXJuaW5nUmF0ZTp0aGlzLmxlYXJuaW5nUmF0ZSxpbml0aWFsQWNjdW11bGF0b3JWYWx1ZTp0aGlzLmluaXRpYWxBY2N1bXVsYXRvclZhbHVlfX0sby5mcm9tQ29uZmlnPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIG5ldyB0KGUubGVhcm5pbmdSYXRlLGUuaW5pdGlhbEFjY3VtdWxhdG9yVmFsdWUpfSxvLmNsYXNzTmFtZT1cIkFkYWdyYWRcIixvfSh4ZCk7Y2Qod2QpO3ZhciBDZD1mdW5jdGlvbih0KXtmdW5jdGlvbiBvKGUsbixyLG8pe3ZvaWQgMD09PW8mJihvPW51bGwpO3ZhciBhPXQuY2FsbCh0aGlzKXx8dGhpcztyZXR1cm4gYS5sZWFybmluZ1JhdGU9ZSxhLmJldGExPW4sYS5iZXRhMj1yLGEuZXBzaWxvbj1vLGEuYWNjdW11bGF0ZWRGaXJzdE1vbWVudD1bXSxhLmFjY3VtdWxhdGVkU2Vjb25kTW9tZW50PVtdLFplKChmdW5jdGlvbigpe2EuYWNjQmV0YTE9T24obikudmFyaWFibGUoKSxhLmFjY0JldGEyPU9uKHIpLnZhcmlhYmxlKCl9KSksbnVsbD09byYmKGEuZXBzaWxvbj1MdC5iYWNrZW5kLmVwc2lsb24oKSksYX1yZXR1cm4gZShvLHQpLG8ucHJvdG90eXBlLmFwcGx5R3JhZGllbnRzPWZ1bmN0aW9uKHQpe3ZhciBlPXRoaXMsbj1BcnJheS5pc0FycmF5KHQpP3QubWFwKChmdW5jdGlvbih0KXtyZXR1cm4gdC5uYW1lfSkpOk9iamVjdC5rZXlzKHQpO1plKChmdW5jdGlvbigpe3ZhciByPUNjKDEsZS5hY2NCZXRhMSksbz1DYygxLGUuYWNjQmV0YTIpO24uZm9yRWFjaCgoZnVuY3Rpb24obixhKXt2YXIgaT1MdC5yZWdpc3RlcmVkVmFyaWFibGVzW25dO251bGw9PWUuYWNjdW11bGF0ZWRGaXJzdE1vbWVudFthXSYmKGUuYWNjdW11bGF0ZWRGaXJzdE1vbWVudFthXT17b3JpZ2luYWxOYW1lOm4rXCIvbVwiLHZhcmlhYmxlOlplKChmdW5jdGlvbigpe3JldHVybiBYbihpKS52YXJpYWJsZSghMSl9KSl9KSxudWxsPT1lLmFjY3VtdWxhdGVkU2Vjb25kTW9tZW50W2FdJiYoZS5hY2N1bXVsYXRlZFNlY29uZE1vbWVudFthXT17b3JpZ2luYWxOYW1lOm4rXCIvdlwiLHZhcmlhYmxlOlplKChmdW5jdGlvbigpe3JldHVybiBYbihpKS52YXJpYWJsZSghMSl9KSl9KTt2YXIgcz1BcnJheS5pc0FycmF5KHQpP3RbYV0udGVuc29yOnRbbl07aWYobnVsbCE9cyl7dmFyIHU9ZS5hY2N1bXVsYXRlZEZpcnN0TW9tZW50W2FdLnZhcmlhYmxlLGM9ZS5hY2N1bXVsYXRlZFNlY29uZE1vbWVudFthXS52YXJpYWJsZSxsPXUubXVsKGUuYmV0YTEpLmFkZChzLm11bCgxLWUuYmV0YTEpKSxoPWMubXVsKGUuYmV0YTIpLmFkZChzLnNxdWFyZSgpLm11bCgxLWUuYmV0YTIpKSxmPWwuZGl2KHIpLGQ9aC5kaXYobyk7dS5hc3NpZ24obCksYy5hc3NpZ24oaCk7dmFyIHA9Zi5kaXYoZC5zcXJ0KCkuYWRkKGUuZXBzaWxvbikpLm11bCgtZS5sZWFybmluZ1JhdGUpLmFkZChpKTtpLmFzc2lnbihwKX19KSksZS5hY2NCZXRhMS5hc3NpZ24oZS5hY2NCZXRhMS5tdWwoZS5iZXRhMSkpLGUuYWNjQmV0YTIuYXNzaWduKGUuYWNjQmV0YTIubXVsKGUuYmV0YTIpKX0pKSx0aGlzLmluY3JlbWVudEl0ZXJhdGlvbnMoKX0sby5wcm90b3R5cGUuZGlzcG9zZT1mdW5jdGlvbigpe3RoaXMuYWNjQmV0YTEuZGlzcG9zZSgpLHRoaXMuYWNjQmV0YTIuZGlzcG9zZSgpLG51bGwhPXRoaXMuYWNjdW11bGF0ZWRGaXJzdE1vbWVudCYmdG4odGhpcy5hY2N1bXVsYXRlZEZpcnN0TW9tZW50Lm1hcCgoZnVuY3Rpb24odCl7cmV0dXJuIHQudmFyaWFibGV9KSkpLG51bGwhPXRoaXMuYWNjdW11bGF0ZWRTZWNvbmRNb21lbnQmJnRuKHRoaXMuYWNjdW11bGF0ZWRTZWNvbmRNb21lbnQubWFwKChmdW5jdGlvbih0KXtyZXR1cm4gdC52YXJpYWJsZX0pKSl9LG8ucHJvdG90eXBlLmdldFdlaWdodHM9ZnVuY3Rpb24oKXtyZXR1cm4gbih0aGlzLHZvaWQgMCx2b2lkIDAsKGZ1bmN0aW9uKCl7dmFyIHQ7cmV0dXJuIHIodGhpcywoZnVuY3Rpb24oZSl7c3dpdGNoKGUubGFiZWwpe2Nhc2UgMDpyZXR1cm4gdD10aGlzLmFjY3VtdWxhdGVkRmlyc3RNb21lbnQuY29uY2F0KHRoaXMuYWNjdW11bGF0ZWRTZWNvbmRNb21lbnQpLFs0LHRoaXMuc2F2ZUl0ZXJhdGlvbnMoKV07Y2FzZSAxOnJldHVyblsyLFtlLnNlbnQoKV0uY29uY2F0KHQubWFwKChmdW5jdGlvbih0KXtyZXR1cm57bmFtZTp0Lm9yaWdpbmFsTmFtZSx0ZW5zb3I6dC52YXJpYWJsZX19KSkpXX19KSl9KSl9LG8ucHJvdG90eXBlLnNldFdlaWdodHM9ZnVuY3Rpb24odCl7cmV0dXJuIG4odGhpcyx2b2lkIDAsdm9pZCAwLChmdW5jdGlvbigpe3ZhciBlLG49dGhpcztyZXR1cm4gcih0aGlzLChmdW5jdGlvbihyKXtzd2l0Y2goci5sYWJlbCl7Y2FzZSAwOnJldHVybls0LHRoaXMuZXh0cmFjdEl0ZXJhdGlvbnModCldO2Nhc2UgMTpyZXR1cm4gdD1yLnNlbnQoKSxaZSgoZnVuY3Rpb24oKXtuLmFjY0JldGExLmFzc2lnbih4YyhuLmJldGExLG4uaXRlcmF0aW9uc18rMSkpLG4uYWNjQmV0YTIuYXNzaWduKHhjKG4uYmV0YTIsbi5pdGVyYXRpb25zXysxKSl9KSksZT10Lmxlbmd0aC8yLCExLHRoaXMuYWNjdW11bGF0ZWRGaXJzdE1vbWVudD10LnNsaWNlKDAsZSkubWFwKChmdW5jdGlvbih0KXtyZXR1cm57b3JpZ2luYWxOYW1lOnQubmFtZSx2YXJpYWJsZTp0LnRlbnNvci52YXJpYWJsZSghMSl9fSkpLHRoaXMuYWNjdW11bGF0ZWRTZWNvbmRNb21lbnQ9dC5zbGljZShlLDIqZSkubWFwKChmdW5jdGlvbih0KXtyZXR1cm57b3JpZ2luYWxOYW1lOnQubmFtZSx2YXJpYWJsZTp0LnRlbnNvci52YXJpYWJsZSghMSl9fSkpLFsyXX19KSl9KSl9LG8ucHJvdG90eXBlLmdldENvbmZpZz1mdW5jdGlvbigpe3JldHVybntsZWFybmluZ1JhdGU6dGhpcy5sZWFybmluZ1JhdGUsYmV0YTE6dGhpcy5iZXRhMSxiZXRhMjp0aGlzLmJldGEyLGVwc2lsb246dGhpcy5lcHNpbG9ufX0sby5mcm9tQ29uZmlnPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIG5ldyB0KGUubGVhcm5pbmdSYXRlLGUuYmV0YTEsZS5iZXRhMixlLmVwc2lsb24pfSxvLmNsYXNzTmFtZT1cIkFkYW1cIixvfSh4ZCk7Y2QoQ2QpO3ZhciBFZD1mdW5jdGlvbih0KXtmdW5jdGlvbiBvKGUsbixyLG8sYSl7dm9pZCAwPT09byYmKG89bnVsbCksdm9pZCAwPT09YSYmKGE9MCk7dmFyIGk9dC5jYWxsKHRoaXMpfHx0aGlzO3JldHVybiBpLmxlYXJuaW5nUmF0ZT1lLGkuYmV0YTE9bixpLmJldGEyPXIsaS5lcHNpbG9uPW8saS5kZWNheT1hLGkuYWNjdW11bGF0ZWRGaXJzdE1vbWVudD1bXSxpLmFjY3VtdWxhdGVkV2VpZ2h0ZWRJbmZOb3JtPVtdLFplKChmdW5jdGlvbigpe2kuaXRlcmF0aW9uPU9uKDApLnZhcmlhYmxlKCksaS5hY2NCZXRhMT1PbihuKS52YXJpYWJsZSgpfSkpLG51bGw9PW8mJihpLmVwc2lsb249THQuYmFja2VuZC5lcHNpbG9uKCkpLGl9cmV0dXJuIGUobyx0KSxvLnByb3RvdHlwZS5hcHBseUdyYWRpZW50cz1mdW5jdGlvbih0KXt2YXIgZT10aGlzLG49QXJyYXkuaXNBcnJheSh0KT90Lm1hcCgoZnVuY3Rpb24odCl7cmV0dXJuIHQubmFtZX0pKTpPYmplY3Qua2V5cyh0KTtaZSgoZnVuY3Rpb24oKXt2YXIgcj1DYygxLGUuYWNjQmV0YTEpLG89c2MoLWUubGVhcm5pbmdSYXRlLGUuaXRlcmF0aW9uLm11bChlLmRlY2F5KS5hZGQoMSkpO24uZm9yRWFjaCgoZnVuY3Rpb24obixhKXt2YXIgaT1MdC5yZWdpc3RlcmVkVmFyaWFibGVzW25dO251bGw9PWUuYWNjdW11bGF0ZWRGaXJzdE1vbWVudFthXSYmKGUuYWNjdW11bGF0ZWRGaXJzdE1vbWVudFthXT17b3JpZ2luYWxOYW1lOm4rXCIvbVwiLHZhcmlhYmxlOlhuKGkpLnZhcmlhYmxlKCExKX0pLG51bGw9PWUuYWNjdW11bGF0ZWRXZWlnaHRlZEluZk5vcm1bYV0mJihlLmFjY3VtdWxhdGVkV2VpZ2h0ZWRJbmZOb3JtW2FdPXtvcmlnaW5hbE5hbWU6bitcIi92XCIsdmFyaWFibGU6WG4oaSkudmFyaWFibGUoITEpfSk7dmFyIHM9QXJyYXkuaXNBcnJheSh0KT90W2FdLnRlbnNvcjp0W25dO2lmKG51bGwhPXMpe3ZhciB1PWUuYWNjdW11bGF0ZWRGaXJzdE1vbWVudFthXS52YXJpYWJsZSxjPWUuYWNjdW11bGF0ZWRXZWlnaHRlZEluZk5vcm1bYV0udmFyaWFibGUsbD11Lm11bChlLmJldGExKS5hZGQocy5tdWwoMS1lLmJldGExKSksaD1jLm11bChlLmJldGEyKSxmPXMuYWJzKCksZD1oLm1heGltdW0oZik7dS5hc3NpZ24obCksYy5hc3NpZ24oZCk7dmFyIHA9by5kaXYocikubXVsKGwuZGl2KGQuYWRkKGUuZXBzaWxvbikpKS5hZGQoaSk7aS5hc3NpZ24ocCl9fSkpLGUuaXRlcmF0aW9uLmFzc2lnbihlLml0ZXJhdGlvbi5hZGQoMSkpLGUuYWNjQmV0YTEuYXNzaWduKGUuYWNjQmV0YTEubXVsKGUuYmV0YTEpKX0pKSx0aGlzLmluY3JlbWVudEl0ZXJhdGlvbnMoKX0sby5wcm90b3R5cGUuZGlzcG9zZT1mdW5jdGlvbigpe3RoaXMuYWNjQmV0YTEuZGlzcG9zZSgpLHRoaXMuaXRlcmF0aW9uLmRpc3Bvc2UoKSxudWxsIT10aGlzLmFjY3VtdWxhdGVkRmlyc3RNb21lbnQmJnRuKHRoaXMuYWNjdW11bGF0ZWRGaXJzdE1vbWVudC5tYXAoKGZ1bmN0aW9uKHQpe3JldHVybiB0LnZhcmlhYmxlfSkpKSxudWxsIT10aGlzLmFjY3VtdWxhdGVkV2VpZ2h0ZWRJbmZOb3JtJiZ0bih0aGlzLmFjY3VtdWxhdGVkV2VpZ2h0ZWRJbmZOb3JtLm1hcCgoZnVuY3Rpb24odCl7cmV0dXJuIHQudmFyaWFibGV9KSkpfSxvLnByb3RvdHlwZS5nZXRXZWlnaHRzPWZ1bmN0aW9uKCl7cmV0dXJuIG4odGhpcyx2b2lkIDAsdm9pZCAwLChmdW5jdGlvbigpe3JldHVybiByKHRoaXMsKGZ1bmN0aW9uKHQpe3Rocm93IG5ldyBFcnJvcihcImdldFdlaWdodHMoKSBpcyBub3QgaW1wbGVtZW50ZWQgZm9yIEFkYW1heCB5ZXQuXCIpfSkpfSkpfSxvLnByb3RvdHlwZS5zZXRXZWlnaHRzPWZ1bmN0aW9uKHQpe3JldHVybiBuKHRoaXMsdm9pZCAwLHZvaWQgMCwoZnVuY3Rpb24oKXtyZXR1cm4gcih0aGlzLChmdW5jdGlvbih0KXt0aHJvdyBuZXcgRXJyb3IoXCJzZXRXZWlnaHRzKCkgaXMgbm90IGltcGxlbWVudGVkIGZvciBBZGFtYXggeWV0LlwiKX0pKX0pKX0sby5wcm90b3R5cGUuZ2V0Q29uZmlnPWZ1bmN0aW9uKCl7cmV0dXJue2xlYXJuaW5nUmF0ZTp0aGlzLmxlYXJuaW5nUmF0ZSxiZXRhMTp0aGlzLmJldGExLGJldGEyOnRoaXMuYmV0YTIsZXBzaWxvbjp0aGlzLmVwc2lsb24sZGVjYXk6dGhpcy5kZWNheX19LG8uZnJvbUNvbmZpZz1mdW5jdGlvbih0LGUpe3JldHVybiBuZXcgdChlLmxlYXJuaW5nUmF0ZSxlLmJldGExLGUuYmV0YTIsZS5lcHNpbG9uLGUuZGVjYXkpfSxvLmNsYXNzTmFtZT1cIkFkYW1heFwiLG99KHhkKTtjZChFZCk7dmFyIFJkPWZ1bmN0aW9uKHQpe2Z1bmN0aW9uIG8oZSl7dmFyIG49dC5jYWxsKHRoaXMpfHx0aGlzO3JldHVybiBuLmxlYXJuaW5nUmF0ZT1lLG4uc2V0TGVhcm5pbmdSYXRlKGUpLG59cmV0dXJuIGUobyx0KSxvLnByb3RvdHlwZS5hcHBseUdyYWRpZW50cz1mdW5jdGlvbih0KXt2YXIgZT10aGlzOyhBcnJheS5pc0FycmF5KHQpP3QubWFwKChmdW5jdGlvbih0KXtyZXR1cm4gdC5uYW1lfSkpOk9iamVjdC5rZXlzKHQpKS5mb3JFYWNoKChmdW5jdGlvbihuLHIpe3ZhciBvPUFycmF5LmlzQXJyYXkodCk/dFtyXS50ZW5zb3I6dFtuXTtpZihudWxsIT1vKXt2YXIgYT1MdC5yZWdpc3RlcmVkVmFyaWFibGVzW25dO1plKChmdW5jdGlvbigpe3ZhciB0PWUuYy5tdWwobykuYWRkKGEpO2EuYXNzaWduKHQpfSkpfX0pKSx0aGlzLmluY3JlbWVudEl0ZXJhdGlvbnMoKX0sby5wcm90b3R5cGUuc2V0TGVhcm5pbmdSYXRlPWZ1bmN0aW9uKHQpe3RoaXMubGVhcm5pbmdSYXRlPXQsbnVsbCE9dGhpcy5jJiZ0aGlzLmMuZGlzcG9zZSgpLHRoaXMuYz1lbihPbigtdCkpfSxvLnByb3RvdHlwZS5kaXNwb3NlPWZ1bmN0aW9uKCl7dGhpcy5jLmRpc3Bvc2UoKX0sby5wcm90b3R5cGUuZ2V0V2VpZ2h0cz1mdW5jdGlvbigpe3JldHVybiBuKHRoaXMsdm9pZCAwLHZvaWQgMCwoZnVuY3Rpb24oKXtyZXR1cm4gcih0aGlzLChmdW5jdGlvbih0KXtzd2l0Y2godC5sYWJlbCl7Y2FzZSAwOnJldHVybls0LHRoaXMuc2F2ZUl0ZXJhdGlvbnMoKV07Y2FzZSAxOnJldHVyblsyLFt0LnNlbnQoKV1dfX0pKX0pKX0sby5wcm90b3R5cGUuc2V0V2VpZ2h0cz1mdW5jdGlvbih0KXtyZXR1cm4gbih0aGlzLHZvaWQgMCx2b2lkIDAsKGZ1bmN0aW9uKCl7cmV0dXJuIHIodGhpcywoZnVuY3Rpb24oZSl7c3dpdGNoKGUubGFiZWwpe2Nhc2UgMDpyZXR1cm5bNCx0aGlzLmV4dHJhY3RJdGVyYXRpb25zKHQpXTtjYXNlIDE6aWYoMCE9PSh0PWUuc2VudCgpKS5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwiU0dEIG9wdGltaXplciBkb2VzIG5vdCBoYXZlIHNldHRhYmxlIHdlaWdodHMuXCIpO3JldHVyblsyXX19KSl9KSl9LG8ucHJvdG90eXBlLmdldENvbmZpZz1mdW5jdGlvbigpe3JldHVybntsZWFybmluZ1JhdGU6dGhpcy5sZWFybmluZ1JhdGV9fSxvLmZyb21Db25maWc9ZnVuY3Rpb24odCxlKXtyZXR1cm4gbmV3IHQoZS5sZWFybmluZ1JhdGUpfSxvLmNsYXNzTmFtZT1cIlNHRFwiLG99KHhkKTtjZChSZCk7dmFyIElkPWZ1bmN0aW9uKHQpe2Z1bmN0aW9uIG8oZSxuLHIpe3ZvaWQgMD09PXImJihyPSExKTt2YXIgbz10LmNhbGwodGhpcyxlKXx8dGhpcztyZXR1cm4gby5sZWFybmluZ1JhdGU9ZSxvLm1vbWVudHVtPW4sby51c2VOZXN0ZXJvdj1yLG8uYWNjdW11bGF0aW9ucz1bXSxvLm09T24oby5tb21lbnR1bSksb31yZXR1cm4gZShvLHQpLG8ucHJvdG90eXBlLmFwcGx5R3JhZGllbnRzPWZ1bmN0aW9uKHQpe3ZhciBlPXRoaXM7KEFycmF5LmlzQXJyYXkodCk/dC5tYXAoKGZ1bmN0aW9uKHQpe3JldHVybiB0Lm5hbWV9KSk6T2JqZWN0LmtleXModCkpLmZvckVhY2goKGZ1bmN0aW9uKG4scil7dmFyIG89THQucmVnaXN0ZXJlZFZhcmlhYmxlc1tuXTtpZihudWxsPT1lLmFjY3VtdWxhdGlvbnNbcl0pe2UuYWNjdW11bGF0aW9uc1tyXT17b3JpZ2luYWxOYW1lOm4rXCIvbW9tZW50dW1cIix2YXJpYWJsZTpaZSgoZnVuY3Rpb24oKXtyZXR1cm4gWG4obykudmFyaWFibGUoITEpfSkpfX12YXIgYT1lLmFjY3VtdWxhdGlvbnNbcl0udmFyaWFibGUsaT1BcnJheS5pc0FycmF5KHQpP3Rbcl0udGVuc29yOnRbbl07bnVsbCE9aSYmWmUoKGZ1bmN0aW9uKCl7dmFyIHQsbj1lLm0ubXVsKGEpLmFkZChpKTt0PWUudXNlTmVzdGVyb3Y/ZS5jLm11bChpLmFkZChuLm11bChlLm0pKSkuYWRkKG8pOmUuYy5tdWwobikuYWRkKG8pLGEuYXNzaWduKG4pLG8uYXNzaWduKHQpfSkpfSkpLHRoaXMuaW5jcmVtZW50SXRlcmF0aW9ucygpfSxvLnByb3RvdHlwZS5kaXNwb3NlPWZ1bmN0aW9uKCl7dGhpcy5tLmRpc3Bvc2UoKSxudWxsIT10aGlzLmFjY3VtdWxhdGlvbnMmJnRuKHRoaXMuYWNjdW11bGF0aW9ucy5tYXAoKGZ1bmN0aW9uKHQpe3JldHVybiB0LnZhcmlhYmxlfSkpKX0sby5wcm90b3R5cGUuc2V0TW9tZW50dW09ZnVuY3Rpb24odCl7dGhpcy5tb21lbnR1bT10fSxvLnByb3RvdHlwZS5nZXRXZWlnaHRzPWZ1bmN0aW9uKCl7cmV0dXJuIG4odGhpcyx2b2lkIDAsdm9pZCAwLChmdW5jdGlvbigpe3JldHVybiByKHRoaXMsKGZ1bmN0aW9uKHQpe3N3aXRjaCh0LmxhYmVsKXtjYXNlIDA6cmV0dXJuWzQsdGhpcy5zYXZlSXRlcmF0aW9ucygpXTtjYXNlIDE6cmV0dXJuWzIsW3Quc2VudCgpXS5jb25jYXQodGhpcy5hY2N1bXVsYXRpb25zLm1hcCgoZnVuY3Rpb24odCl7cmV0dXJue25hbWU6dC5vcmlnaW5hbE5hbWUsdGVuc29yOnQudmFyaWFibGV9fSkpKV19fSkpfSkpfSxvLnByb3RvdHlwZS5zZXRXZWlnaHRzPWZ1bmN0aW9uKHQpe3JldHVybiBuKHRoaXMsdm9pZCAwLHZvaWQgMCwoZnVuY3Rpb24oKXtyZXR1cm4gcih0aGlzLChmdW5jdGlvbihlKXtzd2l0Y2goZS5sYWJlbCl7Y2FzZSAwOnJldHVybls0LHRoaXMuZXh0cmFjdEl0ZXJhdGlvbnModCldO2Nhc2UgMTpyZXR1cm4gdD1lLnNlbnQoKSwhMSx0aGlzLmFjY3VtdWxhdGlvbnM9dC5tYXAoKGZ1bmN0aW9uKHQpe3JldHVybntvcmlnaW5hbE5hbWU6dC5uYW1lLHZhcmlhYmxlOnQudGVuc29yLnZhcmlhYmxlKCExKX19KSksWzJdfX0pKX0pKX0sby5wcm90b3R5cGUuZ2V0Q29uZmlnPWZ1bmN0aW9uKCl7cmV0dXJue2xlYXJuaW5nUmF0ZTp0aGlzLmxlYXJuaW5nUmF0ZSxtb21lbnR1bTp0aGlzLm1vbWVudHVtLHVzZU5lc3Rlcm92OnRoaXMudXNlTmVzdGVyb3Z9fSxvLmZyb21Db25maWc9ZnVuY3Rpb24odCxlKXtyZXR1cm4gbmV3IHQoZS5sZWFybmluZ1JhdGUsZS5tb21lbnR1bSxlLnVzZU5lc3Rlcm92KX0sby5jbGFzc05hbWU9XCJNb21lbnR1bVwiLG99KFJkKTtjZChJZCk7dmFyIGtkPWZ1bmN0aW9uKHQpe2Z1bmN0aW9uIG8oZSxuLHIsbyxhKXt2b2lkIDA9PT1uJiYobj0uOSksdm9pZCAwPT09ciYmKHI9MCksdm9pZCAwPT09byYmKG89bnVsbCksdm9pZCAwPT09YSYmKGE9ITEpO3ZhciBpPXQuY2FsbCh0aGlzKXx8dGhpcztpZihpLmxlYXJuaW5nUmF0ZT1lLGkuZGVjYXk9bixpLm1vbWVudHVtPXIsaS5lcHNpbG9uPW8saS5hY2N1bXVsYXRlZE1lYW5TcXVhcmVzPVtdLGkuYWNjdW11bGF0ZWRNb21lbnRzPVtdLGkuYWNjdW11bGF0ZWRNZWFuR3JhZHM9W10saS5jZW50ZXJlZD1hLG51bGw9PW8mJihpLmVwc2lsb249THQuYmFja2VuZC5lcHNpbG9uKCkpLG51bGw9PWUpdGhyb3cgbmV3IEVycm9yKFwibGVhcm5pbmdSYXRlIGZvciBSTVNQcm9wT3B0aW1pemVyIG11c3QgYmUgZGVmaW5lZC5cIik7cmV0dXJuIGl9cmV0dXJuIGUobyx0KSxvLnByb3RvdHlwZS5hcHBseUdyYWRpZW50cz1mdW5jdGlvbih0KXt2YXIgZT10aGlzOyhBcnJheS5pc0FycmF5KHQpP3QubWFwKChmdW5jdGlvbih0KXtyZXR1cm4gdC5uYW1lfSkpOk9iamVjdC5rZXlzKHQpKS5mb3JFYWNoKChmdW5jdGlvbihuLHIpe3ZhciBvPUx0LnJlZ2lzdGVyZWRWYXJpYWJsZXNbbl07bnVsbD09ZS5hY2N1bXVsYXRlZE1lYW5TcXVhcmVzW3JdJiYoZS5hY2N1bXVsYXRlZE1lYW5TcXVhcmVzW3JdPXtvcmlnaW5hbE5hbWU6bitcIi9ybXNcIix2YXJpYWJsZTpaZSgoZnVuY3Rpb24oKXtyZXR1cm4gWG4obykudmFyaWFibGUoITEpfSkpfSksbnVsbD09ZS5hY2N1bXVsYXRlZE1vbWVudHNbcl0mJihlLmFjY3VtdWxhdGVkTW9tZW50c1tyXT17b3JpZ2luYWxOYW1lOm4rXCIvbW9tZW50dW1cIix2YXJpYWJsZTpaZSgoZnVuY3Rpb24oKXtyZXR1cm4gWG4obykudmFyaWFibGUoITEpfSkpfSksbnVsbD09ZS5hY2N1bXVsYXRlZE1lYW5HcmFkc1tyXSYmZS5jZW50ZXJlZCYmKGUuYWNjdW11bGF0ZWRNZWFuR3JhZHNbcl09e29yaWdpbmFsTmFtZTpuK1wiL21nXCIsdmFyaWFibGU6WmUoKGZ1bmN0aW9uKCl7cmV0dXJuIFhuKG8pLnZhcmlhYmxlKCExKX0pKX0pO3ZhciBhPUFycmF5LmlzQXJyYXkodCk/dFtyXS50ZW5zb3I6dFtuXTtpZihudWxsIT1hKXt2YXIgaT1lLmFjY3VtdWxhdGVkTWVhblNxdWFyZXNbcl0udmFyaWFibGUscz1lLmFjY3VtdWxhdGVkTW9tZW50c1tyXS52YXJpYWJsZTtaZSgoZnVuY3Rpb24oKXt2YXIgdD1pLm11bChlLmRlY2F5KS5hZGQoYS5zcXVhcmUoKS5tdWwoMS1lLmRlY2F5KSk7aWYoZS5jZW50ZXJlZCl7dmFyIG49ZS5hY2N1bXVsYXRlZE1lYW5HcmFkc1tyXS52YXJpYWJsZSx1PW4ubXVsKGUuZGVjYXkpLmFkZChhLm11bCgxLWUuZGVjYXkpKSxjPXMubXVsKGUubW9tZW50dW0pLmFkZChhLm11bChlLmxlYXJuaW5nUmF0ZSkuZGl2KHQuc3ViKHUuc3F1YXJlKCkuYWRkKGUuZXBzaWxvbikpLnNxcnQoKSkpO2kuYXNzaWduKHQpLG4uYXNzaWduKHUpLHMuYXNzaWduKGMpO3ZhciBsPW8uc3ViKGMpO28uYXNzaWduKGwpfWVsc2V7dmFyIGg9aS5tdWwoZS5kZWNheSkuYWRkKGEuc3F1YXJlKCkubXVsKDEtZS5kZWNheSkpO2M9cy5tdWwoZS5tb21lbnR1bSkuYWRkKGEubXVsKGUubGVhcm5pbmdSYXRlKS5kaXYoaC5hZGQoZS5lcHNpbG9uKS5zcXJ0KCkpKTtpLmFzc2lnbihoKSxzLmFzc2lnbihjKTtsPW8uc3ViKGMpO28uYXNzaWduKGwpfX0pKX19KSksdGhpcy5pbmNyZW1lbnRJdGVyYXRpb25zKCl9LG8ucHJvdG90eXBlLmRpc3Bvc2U9ZnVuY3Rpb24oKXtudWxsIT10aGlzLmFjY3VtdWxhdGVkTWVhblNxdWFyZXMmJnRuKHRoaXMuYWNjdW11bGF0ZWRNZWFuU3F1YXJlcy5tYXAoKGZ1bmN0aW9uKHQpe3JldHVybiB0LnZhcmlhYmxlfSkpKSxudWxsIT10aGlzLmFjY3VtdWxhdGVkTWVhbkdyYWRzJiZ0aGlzLmNlbnRlcmVkJiZ0bih0aGlzLmFjY3VtdWxhdGVkTWVhbkdyYWRzLm1hcCgoZnVuY3Rpb24odCl7cmV0dXJuIHQudmFyaWFibGV9KSkpLG51bGwhPXRoaXMuYWNjdW11bGF0ZWRNb21lbnRzJiZ0bih0aGlzLmFjY3VtdWxhdGVkTW9tZW50cy5tYXAoKGZ1bmN0aW9uKHQpe3JldHVybiB0LnZhcmlhYmxlfSkpKX0sby5wcm90b3R5cGUuZ2V0V2VpZ2h0cz1mdW5jdGlvbigpe3JldHVybiBuKHRoaXMsdm9pZCAwLHZvaWQgMCwoZnVuY3Rpb24oKXt2YXIgdDtyZXR1cm4gcih0aGlzLChmdW5jdGlvbihlKXtzd2l0Y2goZS5sYWJlbCl7Y2FzZSAwOnJldHVybiB0PXRoaXMuYWNjdW11bGF0ZWRNZWFuU3F1YXJlcy5jb25jYXQodGhpcy5hY2N1bXVsYXRlZE1vbWVudHMpLHRoaXMuY2VudGVyZWQmJnQucHVzaC5hcHBseSh0LHRoaXMuYWNjdW11bGF0ZWRNZWFuR3JhZHMpLFs0LHRoaXMuc2F2ZUl0ZXJhdGlvbnMoKV07Y2FzZSAxOnJldHVyblsyLFtlLnNlbnQoKV0uY29uY2F0KHQubWFwKChmdW5jdGlvbih0KXtyZXR1cm57bmFtZTp0Lm9yaWdpbmFsTmFtZSx0ZW5zb3I6dC52YXJpYWJsZX19KSkpXX19KSl9KSl9LG8ucHJvdG90eXBlLnNldFdlaWdodHM9ZnVuY3Rpb24odCl7cmV0dXJuIG4odGhpcyx2b2lkIDAsdm9pZCAwLChmdW5jdGlvbigpe3ZhciBlO3JldHVybiByKHRoaXMsKGZ1bmN0aW9uKG4pe3N3aXRjaChuLmxhYmVsKXtjYXNlIDA6cmV0dXJuWzQsdGhpcy5leHRyYWN0SXRlcmF0aW9ucyh0KV07Y2FzZSAxOnJldHVybiB0PW4uc2VudCgpLGU9dGhpcy5jZW50ZXJlZD90Lmxlbmd0aC8zOnQubGVuZ3RoLzIsITEsdGhpcy5hY2N1bXVsYXRlZE1lYW5TcXVhcmVzPXQuc2xpY2UoMCxlKS5tYXAoKGZ1bmN0aW9uKHQpe3JldHVybntvcmlnaW5hbE5hbWU6dC5uYW1lLHZhcmlhYmxlOnQudGVuc29yLnZhcmlhYmxlKCExKX19KSksdGhpcy5hY2N1bXVsYXRlZE1vbWVudHM9dC5zbGljZShlLDIqZSkubWFwKChmdW5jdGlvbih0KXtyZXR1cm57b3JpZ2luYWxOYW1lOnQubmFtZSx2YXJpYWJsZTp0LnRlbnNvci52YXJpYWJsZSghMSl9fSkpLHRoaXMuY2VudGVyZWQmJih0aGlzLmFjY3VtdWxhdGVkTWVhbkdyYWRzPXQuc2xpY2UoMiplLDMqZSkubWFwKChmdW5jdGlvbih0KXtyZXR1cm57b3JpZ2luYWxOYW1lOnQubmFtZSx2YXJpYWJsZTp0LnRlbnNvci52YXJpYWJsZSghMSl9fSkpKSxbMl19fSkpfSkpfSxvLnByb3RvdHlwZS5nZXRDb25maWc9ZnVuY3Rpb24oKXtyZXR1cm57bGVhcm5pbmdSYXRlOnRoaXMubGVhcm5pbmdSYXRlLGRlY2F5OnRoaXMuZGVjYXksbW9tZW50dW06dGhpcy5tb21lbnR1bSxlcHNpbG9uOnRoaXMuZXBzaWxvbixjZW50ZXJlZDp0aGlzLmNlbnRlcmVkfX0sby5mcm9tQ29uZmlnPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIG5ldyB0KGUubGVhcm5pbmdSYXRlLGUuZGVjYXksZS5tb21lbnR1bSxlLmVwc2lsb24sZS5jZW50ZXJlZCl9LG8uY2xhc3NOYW1lPVwiUk1TUHJvcFwiLG99KHhkKTtjZChrZCk7dmFyIFNkPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gdCgpe31yZXR1cm4gdC5zZ2Q9ZnVuY3Rpb24odCl7cmV0dXJuIG5ldyBSZCh0KX0sdC5tb21lbnR1bT1mdW5jdGlvbih0LGUsbil7cmV0dXJuIHZvaWQgMD09PW4mJihuPSExKSxuZXcgSWQodCxlLG4pfSx0LnJtc3Byb3A9ZnVuY3Rpb24odCxlLG4scixvKXtyZXR1cm4gdm9pZCAwPT09ZSYmKGU9LjkpLHZvaWQgMD09PW4mJihuPTApLHZvaWQgMD09PXImJihyPW51bGwpLHZvaWQgMD09PW8mJihvPSExKSxuZXcga2QodCxlLG4scixvKX0sdC5hZGFtPWZ1bmN0aW9uKHQsZSxuLHIpe3JldHVybiB2b2lkIDA9PT10JiYodD0uMDAxKSx2b2lkIDA9PT1lJiYoZT0uOSksdm9pZCAwPT09biYmKG49Ljk5OSksdm9pZCAwPT09ciYmKHI9bnVsbCksbmV3IENkKHQsZSxuLHIpfSx0LmFkYWRlbHRhPWZ1bmN0aW9uKHQsZSxuKXtyZXR1cm4gdm9pZCAwPT09dCYmKHQ9LjAwMSksdm9pZCAwPT09ZSYmKGU9Ljk1KSx2b2lkIDA9PT1uJiYobj1udWxsKSxuZXcgYmQodCxlLG4pfSx0LmFkYW1heD1mdW5jdGlvbih0LGUsbixyLG8pe3JldHVybiB2b2lkIDA9PT10JiYodD0uMDAyKSx2b2lkIDA9PT1lJiYoZT0uOSksdm9pZCAwPT09biYmKG49Ljk5OSksdm9pZCAwPT09ciYmKHI9bnVsbCksdm9pZCAwPT09byYmKG89MCksbmV3IEVkKHQsZSxuLHIsbyl9LHQuYWRhZ3JhZD1mdW5jdGlvbih0LGUpe3JldHVybiB2b2lkIDA9PT1lJiYoZT0uMSksbmV3IHdkKHQsZSl9LHR9KCksQWQ9e3NnZDpTZC5zZ2QsbW9tZW50dW06U2QubW9tZW50dW0sYWRhZGVsdGE6U2QuYWRhZGVsdGEsYWRhZ3JhZDpTZC5hZGFncmFkLHJtc3Byb3A6U2Qucm1zcHJvcCxhZGFtYXg6U2QuYWRhbWF4LGFkYW06U2QuYWRhbX0sRGQ9XCJ1bmRlZmluZWRcIiE9dHlwZW9mIHJlcXVlc3RBbmltYXRpb25GcmFtZT9yZXF1ZXN0QW5pbWF0aW9uRnJhbWU6XCJ1bmRlZmluZWRcIiE9dHlwZW9mIHNldEltbWVkaWF0ZT9zZXRJbW1lZGlhdGU6ZnVuY3Rpb24odCl7cmV0dXJuIHQoKX07ZnVuY3Rpb24gVGQoKXtyZXR1cm4gbmV3IFByb21pc2UoKGZ1bmN0aW9uKHQpe3JldHVybiBEZCgoZnVuY3Rpb24oKXtyZXR1cm4gdCgpfSkpfSkpfXd0LnByb3RvdHlwZS5zcXVhcmVkRGlmZmVyZW5jZT1mdW5jdGlvbih0KXtyZXR1cm4gbnUodGhpcyx0KX0seHQ9R2g7ZXhwb3J0e2JkIGFzIEFkYWRlbHRhT3B0aW1pemVyLHdkIGFzIEFkYWdyYWRPcHRpbWl6ZXIsQ2QgYXMgQWRhbU9wdGltaXplcixFZCBhcyBBZGFtYXhPcHRpbWl6ZXIseG8gYXMgRGF0YVN0b3JhZ2UscyBhcyBFTlYsbyBhcyBFbnZpcm9ubWVudCxibyBhcyBLZXJuZWxCYWNrZW5kLElkIGFzIE1vbWVudHVtT3B0aW1pemVyLHhkIGFzIE9wdGltaXplcixrZCBhcyBSTVNQcm9wT3B0aW1pemVyLEN0IGFzIFJhbmssY2ggYXMgUmVkdWN0aW9uLFJkIGFzIFNHRE9wdGltaXplcix3dCBhcyBUZW5zb3IsZ3QgYXMgVGVuc29yQnVmZmVyLFN0IGFzIFZhcmlhYmxlLHJ1IGFzIGFicyxvdSBhcyBhY29zLGF1IGFzIGFjb3NoLHJjIGFzIGFkZCxvYyBhcyBhZGROLGFjIGFzIGFkZFN0cmljdCxDbCBhcyBhbGwsRWwgYXMgYW55LFJsIGFzIGFyZ01heCxJbCBhcyBhcmdNaW4saXUgYXMgYXNpbixzdSBhcyBhc2luaCx1dSBhcyBhdGFuLGljIGFzIGF0YW4yLGN1IGFzIGF0YW5oLGZsIGFzIGF2Z1Bvb2wsdmwgYXMgYXZnUG9vbDNkLGhuIGFzIGJhY2tlbmQsVW8gYXMgYmFja2VuZF91dGlsLHpsIGFzIGJhc2ljTFNUTUNlbGwsanUgYXMgYmF0Y2hOb3JtLFh1IGFzIGJhdGNoTm9ybTJkLFl1IGFzIGJhdGNoTm9ybTNkLCR1IGFzIGJhdGNoTm9ybTRkLEt1IGFzIGJhdGNoTm9ybWFsaXphdGlvbixHdSBhcyBiYXRjaE5vcm1hbGl6YXRpb24yZCxIdSBhcyBiYXRjaE5vcm1hbGl6YXRpb24zZCxxdSBhcyBiYXRjaE5vcm1hbGl6YXRpb240ZCx2ciBhcyBiYXRjaFRvU3BhY2VORCxVYyBhcyBib29sZWFuTWFza0FzeW5jLG1yIGFzIGJyb2FkY2FzdFRvLGlkIGFzIGJyb3dzZXIsZHIgYXMgYnVmZmVyLGdyIGFzIGNhc3QsbHUgYXMgY2VpbCxodSBhcyBjbGlwQnlWYWx1ZSx5ciBhcyBjbG9uZSxEbiBhcyBjb21wbGV4LFluIGFzIGNvbmNhdCwkbiBhcyBjb25jYXQxZCxRbiBhcyBjb25jYXQyZCxKbiBhcyBjb25jYXQzZCxabiBhcyBjb25jYXQ0ZCxIYyBhcyBjb252MWQscWMgYXMgY29udjJkLFpjIGFzIGNvbnYyZFRyYW5zcG9zZSxLYyBhcyBjb252M2QsdGwgYXMgY29udjNkVHJhbnNwb3NlLGZ1IGFzIGNvcyxkdSBhcyBjb3NoLHhyIGFzIGN1bXN1bSx2byBhcyBjdXN0b21HcmFkLFhlIGFzIGRlcHJlY2F0aW9uV2FybixiciBhcyBkZXB0aFRvU3BhY2UsWWMgYXMgZGVwdGh3aXNlQ29udjJkLGVoIGFzIGRpYWcsamUgYXMgZGlzYWJsZURlcHJlY2F0aW9uV2FybmluZ3MsdG4gYXMgZGlzcG9zZSxZZSBhcyBkaXNwb3NlVmFyaWFibGVzLHNjIGFzIGRpdix1YyBhcyBkaXZOb05hbixjYyBhcyBkaXZTdHJpY3QsbmwgYXMgZG90LG5oIGFzIGRyb3BvdXQsX2wgYXMgZWx1LEtlIGFzIGVuYWJsZURlYnVnTW9kZSxxZSBhcyBlbmFibGVQcm9kTW9kZSwkZSBhcyBlbmdpbmUsaSBhcyBlbnYsUmMgYXMgZXF1YWwsSWMgYXMgZXF1YWxTdHJpY3QscHUgYXMgZXJmLHZ1IGFzIGV4cCx3ciBhcyBleHBhbmREaW1zLG11IGFzIGV4cG0xLENyIGFzIGV5ZSxYbCBhcyBmZnQsSG4gYXMgZmlsbCx1biBhcyBmaW5kQmFja2VuZCxjbiBhcyBmaW5kQmFja2VuZEZhY3RvcnksZ3UgYXMgZmxvb3IsbGMgYXMgZmxvb3JEaXYsaWggYXMgZnJhbWUsemggYXMgZnVzZWQsTGMgYXMgZ2F0aGVyLHRoIGFzIGdhdGhlck5ELFhyIGFzIGdhdGhlcl91dGlsLGFuIGFzIGdldEJhY2tlbmQsaCBhcyBnZXRHcmFkaWVudCxsIGFzIGdldEtlcm5lbCxmIGFzIGdldEtlcm5lbHNGb3JCYWNrZW5kLGNvIGFzIGdyYWQsbG8gYXMgZ3JhZHMsa2MgYXMgZ3JlYXRlcixTYyBhcyBncmVhdGVyRXF1YWwsQWMgYXMgZ3JlYXRlckVxdWFsU3RyaWN0LERjIGFzIGdyZWF0ZXJTdHJpY3QsYWggYXMgaGFtbWluZ1dpbmRvdyxvaCBhcyBoYW5uV2luZG93LFlsIGFzIGlmZnQsTm4gYXMgaW1hZyxPaCBhcyBpbWFnZSxsaCBhcyBpblRvcEtBc3luYyxlZCBhcyBpbyxRbCBhcyBpcmZmdCxEdSBhcyBpc0Zpbml0ZSxBdSBhcyBpc0luZixTdSBhcyBpc05hTixlbiBhcyBrZWVwLE9sIGFzIGxlYWt5UmVsdSxUYyBhcyBsZXNzLE5jIGFzIGxlc3NFcXVhbCxGYyBhcyBsZXNzRXF1YWxTdHJpY3QsX2MgYXMgbGVzc1N0cmljdCxJaCBhcyBsaW5hbGcscW4gYXMgbGluc3BhY2UsVWwgYXMgbG9jYWxSZXNwb25zZU5vcm1hbGl6YXRpb24seXUgYXMgbG9nLHh1IGFzIGxvZzFwLGJ1IGFzIGxvZ1NpZ21vaWQseW8gYXMgbG9nU29mdG1heCxrbCBhcyBsb2dTdW1FeHAsUXUgYXMgbG9naWNhbEFuZCxKdSBhcyBsb2dpY2FsTm90LFp1IGFzIGxvZ2ljYWxPcix0YyBhcyBsb2dpY2FsWG9yLGJoIGFzIGxvc3NlcyxlbCBhcyBtYXRNdWwsb2QgYXMgbWF0aCxTbCBhcyBtYXgsaGwgYXMgbWF4UG9vbCxwbCBhcyBtYXhQb29sM2QsaGMgYXMgbWF4aW11bSxmYyBhcyBtYXhpbXVtU3RyaWN0LEFsIGFzIG1lYW4sUWUgYXMgbWVtb3J5LERsIGFzIG1pbixkYyBhcyBtaW5pbXVtLHBjIGFzIG1pbmltdW1TdHJpY3QsdmMgYXMgbW9kLG1jIGFzIG1vZFN0cmljdCxUbCBhcyBtb21lbnRzLEhsIGFzIG1vdmluZ0F2ZXJhZ2UsZ2MgYXMgbXVsLHljIGFzIG11bFN0cmljdCxHbCBhcyBtdWx0aVJOTkNlbGwsRXIgYXMgbXVsdGlub21pYWwsd3UgYXMgbmVnLFRkIGFzIG5leHRGcmFtZSxWbCBhcyBub3JtLE9jIGFzIG5vdEVxdWFsLE1jIGFzIG5vdEVxdWFsU3RyaWN0LFJyIGFzIG9uZUhvdCx6biBhcyBvbmVzLGpuIGFzIG9uZXNMaWtlLEFuIGFzIG9wLHJsIGFzIG91dGVyUHJvZHVjdCxJciBhcyBwYWQsa3IgYXMgcGFkMWQsU3IgYXMgcGFkMmQsQXIgYXMgcGFkM2QsRHIgYXMgcGFkNGQsZGwgYXMgcG9vbCx4YyBhcyBwb3csYmMgYXMgcG93U3RyaWN0LE1sIGFzIHByZWx1LHByIGFzIHByaW50LEZsIGFzIHByb2QsSmUgYXMgcHJvZmlsZSxUciBhcyByYW5kLEZyIGFzIHJhbmRvbUdhbW1hLE5yIGFzIHJhbmRvbU5vcm1hbCxfciBhcyByYW5kb21Vbmlmb3JtLEtuIGFzIHJhbmdlLG9uIGFzIHJlYWR5LFRuIGFzIHJlYWwsQ3UgYXMgcmVjaXByb2NhbCxsbiBhcyByZWdpc3RlckJhY2tlbmQscCBhcyByZWdpc3RlckdyYWRpZW50LGQgYXMgcmVnaXN0ZXJLZXJuZWwsQmwgYXMgcmVsdSxQbCBhcyByZWx1NixzbiBhcyByZW1vdmVCYWNrZW5kLE9yIGFzIHJlc2hhcGUsb2wgYXMgcmV2ZXJzZSxhbCBhcyByZXZlcnNlMWQsaWwgYXMgcmV2ZXJzZTJkLHNsIGFzIHJldmVyc2UzZCx1bCBhcyByZXZlcnNlNGQsJGwgYXMgcmZmdCxFdSBhcyByb3VuZCxSdSBhcyByc3FydCxPbiBhcyBzY2FsYXIsamwgYXMgc2NhdHRlck5ELHRvIGFzIHNjYXR0ZXJfdXRpbCxMbCBhcyBzZWx1LEpjIGFzIHNlcGFyYWJsZUNvbnYyZCxsZCBhcyBzZXJpYWxpemF0aW9uLHJuIGFzIHNldEJhY2tlbmQsZm4gYXMgc2V0UGxhdGZvcm0sVnIgYXMgc2V0ZGlmZjFkQXN5bmMsSXUgYXMgc2lnbW9pZCxrdSBhcyBzaWduLHVoIGFzIHNpZ25hbCxUdSBhcyBzaW4sTnUgYXMgc2luaCxtbCBhcyBzbGljZSxnbCBhcyBzbGljZTFkLHlsIGFzIHNsaWNlMmQseGwgYXMgc2xpY2UzZCxibCBhcyBzbGljZTRkLHVvIGFzIHNsaWNlX3V0aWwsZ28gYXMgc29mdG1heCxGdSBhcyBzb2Z0cGx1cyxNciBhcyBzcGFjZVRvQmF0Y2hORCxabCBhcyBzcGFyc2VUb0RlbnNlLEpsIGFzIHNwZWN0cmFsLHRyIGFzIHNwbGl0LF91IGFzIHNxcnQsdHUgYXMgc3F1YXJlLG51IGFzIHNxdWFyZWREaWZmZXJlbmNlLHdjIGFzIHNxdWFyZWREaWZmZXJlbmNlU3RyaWN0LEJyIGFzIHNxdWVlemUsUHIgYXMgc3RhY2ssT3UgYXMgc3RlcCxzaCBhcyBzdGZ0LHFsIGFzIHN0cmlkZWRTbGljZSxDYyBhcyBzdWIsRWMgYXMgc3ViU3RyaWN0LE5sIGFzIHN1bSxUdCBhcyBzdW1PdXRUeXBlLE11IGFzIHRhbixCdSBhcyB0YW5oLEZuIGFzIHRlbnNvcixNbiBhcyB0ZW5zb3IxZCxCbiBhcyB0ZW5zb3IyZCxQbiBhcyB0ZW5zb3IzZCxMbiBhcyB0ZW5zb3I0ZCxXbiBhcyB0ZW5zb3I1ZCxVbiBhcyB0ZW5zb3I2ZCxNdCBhcyB0ZW5zb3JfdXRpbCxtZCBhcyB0ZXN0X3V0aWwsWmUgYXMgdGlkeSxMciBhcyB0aWxlLG5uIGFzIHRpbWUsS2wgYXMgdG9wayxBZCBhcyB0cmFpbixXbCBhcyB0cmFuc3Bvc2UsV3IgYXMgdHJ1bmNhdGVkTm9ybWFsLG0gYXMgdW5yZWdpc3RlckdyYWRpZW50LHYgYXMgdW5yZWdpc3Rlcktlcm5lbCxXYyBhcyB1bnNvcnRlZFNlZ21lbnRTdW0sVXIgYXMgdW5zdGFjayxzdCBhcyB1dGlsLGhvIGFzIHZhbHVlQW5kR3JhZCxmbyBhcyB2YWx1ZUFuZEdyYWRzLFZuIGFzIHZhcmlhYmxlLHBvIGFzIHZhcmlhYmxlR3JhZHMsZ2QgYXMgdmVyc2lvbl9jb3JlLHlkIGFzIHdlYmdsLGVjIGFzIHdoZXJlLG5jIGFzIHdoZXJlQXN5bmMsR24gYXMgemVyb3MsWG4gYXMgemVyb3NMaWtlfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXRmLWNvcmUuZXNtLmpzLm1hcFxuIl0sIm5hbWVzIjpbInQiLCJlIiwibiIsIk9iamVjdCIsInNldFByb3RvdHlwZU9mIiwiX19wcm90b19fIiwiQXJyYXkiLCJoYXNPd25Qcm9wZXJ0eSIsInIiLCJjb25zdHJ1Y3RvciIsInByb3RvdHlwZSIsImNyZWF0ZSIsIlByb21pc2UiLCJvIiwiYSIsImkiLCJ1IiwibmV4dCIsInMiLCJ0aHJvdyIsImRvbmUiLCJ2YWx1ZSIsInRoZW4iLCJhcHBseSIsImxhYmVsIiwic2VudCIsInRyeXMiLCJvcHMiLCJyZXR1cm4iLCJTeW1ib2wiLCJpdGVyYXRvciIsIlR5cGVFcnJvciIsImNhbGwiLCJwb3AiLCJsZW5ndGgiLCJwdXNoIiwiZ2xvYmFsIiwiZmxhZ3MiLCJmbGFnUmVnaXN0cnkiLCJ1cmxGbGFncyIsInBvcHVsYXRlVVJMRmxhZ3MiLCJzZXRQbGF0Zm9ybSIsInBsYXRmb3JtIiwiY29uc29sZSIsIndhcm4iLCJwbGF0Zm9ybU5hbWUiLCJyZWdpc3RlckZsYWciLCJldmFsdWF0aW9uRm4iLCJzZXRIb29rIiwic2V0IiwiZ2V0IiwiZXZhbHVhdGVGbGFnIiwiZ2V0TnVtYmVyIiwiZ2V0Qm9vbCIsImdldEZsYWdzIiwiZGVmaW5lUHJvcGVydHkiLCJlbnVtZXJhYmxlIiwiY29uZmlndXJhYmxlIiwiRXJyb3IiLCJzZXRGbGFncyIsImFzc2lnbiIsInJlc2V0IiwibG9jYXRpb24iLCJzZWFyY2giLCJyZXBsYWNlIiwiYXJndW1lbnRzIiwiam9pbiIsInRmanNmbGFncyIsInNwbGl0IiwiZm9yRWFjaCIsInRvTG93ZXJDYXNlIiwiZGVjb2RlVVJJQ29tcG9uZW50IiwiTWFwIiwiYyIsImwiLCJnIiwiaCIsImYiLCJlbnRyaWVzIiwiZCIsImtlcm5lbE5hbWUiLCJiYWNrZW5kTmFtZSIsImhhcyIsInAiLCJ2IiwiZGVsZXRlIiwibSIsInkiLCJNYXRoIiwicmFuZG9tIiwieCIsIm1heCIsIm1pbiIsImIiLCJ3IiwiQyIsIkUiLCJTIiwiUiIsIkkiLCJpc0FycmF5IiwiViIsImsiLCJBIiwiRCIsInRhbmgiLCJleHAiLCJUIiwiY2VpbCIsInNxcnQiLCJOIiwicmVwZWF0IiwiRiIsInNldFRpbWVvdXQiLCJfIiwic2xpY2UiLCJPIiwibWFwIiwiY29uY2F0IiwiZXZlcnkiLCJNIiwic29ydCIsIm5ld1NoYXBlIiwia2VwdERpbXMiLCJCIiwiRmxvYXQzMkFycmF5IiwiSW50MzJBcnJheSIsIlVpbnQ4QXJyYXkiLCJQIiwiTCIsImlzTmFOIiwiaXNGaW5pdGUiLCJXIiwiVSIsInoiLCJHIiwiSCIsIlN0cmluZyIsInEiLCJLIiwiaiIsIlgiLCJZIiwiJCIsIlEiLCJyb3VuZCIsIkoiLCJyZWR1Y2UiLCJaIiwidHQiLCJldCIsIm5vdyIsIm50IiwiTnVtYmVyIiwiaXNJbnRlZ2VyIiwicnQiLCJlbmNvZGUiLCJvdCIsImRlY29kZSIsImF0IiwiaXQiLCJmbG9vciIsInN0IiwiZnJlZXplIiwic2h1ZmZsZSIsImNsYW1wIiwibmVhcmVzdExhcmdlckV2ZW4iLCJzdW0iLCJyYW5kVW5pZm9ybSIsImRpc3RTcXVhcmVkIiwiYXNzZXJ0IiwiYXNzZXJ0U2hhcGVzTWF0Y2giLCJhc3NlcnROb25OdWxsIiwiZmxhdHRlbiIsInNpemVGcm9tU2hhcGUiLCJpc1NjYWxhclNoYXBlIiwiYXJyYXlzRXF1YWwiLCJpc0ludCIsInNpemVUb1NxdWFyaXNoU2hhcGUiLCJjcmVhdGVTaHVmZmxlZEluZGljZXMiLCJVaW50MzJBcnJheSIsInJpZ2h0UGFkIiwicmVwZWF0ZWRUcnkiLCJpbmZlckZyb21JbXBsaWNpdFNoYXBlIiwicGFyc2VBeGlzUGFyYW0iLCJzcXVlZXplU2hhcGUiLCJnZXRUeXBlZEFycmF5RnJvbURUeXBlIiwiZ2V0QXJyYXlGcm9tRFR5cGUiLCJjaGVja0NvbnZlcnNpb25Gb3JFcnJvcnMiLCJpc1ZhbGlkRHR5cGUiLCJoYXNFbmNvZGluZ0xvc3MiLCJpc1R5cGVkQXJyYXkiLCJieXRlc1BlckVsZW1lbnQiLCJieXRlc0Zyb21TdHJpbmdBcnJheSIsImlzU3RyaW5nIiwiaXNCb29sZWFuIiwiaXNOdW1iZXIiLCJpbmZlckR0eXBlIiwiaXNGdW5jdGlvbiIsIm5lYXJlc3REaXZpc29yIiwiY29tcHV0ZVN0cmlkZXMiLCJ0b1R5cGVkQXJyYXkiLCJ0b05lc3RlZEFycmF5IiwibWFrZU9uZXNUeXBlZEFycmF5IiwibWFrZVplcm9zVHlwZWRBcnJheSIsImFzc2VydE5vbk5lZ2F0aXZlSW50ZWdlckRpbWVuc2lvbnMiLCJmZXRjaCIsImVuY29kZVN0cmluZyIsImRlY29kZVN0cmluZyIsImxvY1RvSW5kZXgiLCJpbmRleFRvTG9jIiwidXQiLCJiYWNrZW5kVGltZXIiLCJsb2dnZXIiLCJjdCIsInByb2ZpbGVLZXJuZWwiLCJ0aW1lIiwiZGF0YSIsImR0eXBlIiwiZ2V0RXh0cmFQcm9maWxlSW5mbyIsImxvZ0tlcm5lbFByb2ZpbGUiLCJrZXJuZWxNcyIsImVycm9yIiwicmFuayIsInNpemUiLCJzaGFwZSIsInRvU3RyaW5nIiwibG9nIiwibHQiLCJodCIsImZ0IiwiZHQiLCJmaWxsIiwibXQiLCJwdCIsInZ0IiwiZnJvbSIsInBhcnNlRmxvYXQiLCJ0b0ZpeGVkIiwiZ3QiLCJ2YWx1ZXMiLCJzdHJpZGVzIiwidG9UZW5zb3IiLCJ5dCIsIm1ha2VUZW5zb3IiLCJ4dCIsImJ0Iiwid3QiLCJrZXB0IiwiaXNEaXNwb3NlZEludGVybmFsIiwiZGF0YUlkIiwiaWQiLCJyYW5rVHlwZSIsInRocm93SWZEaXNwb3NlZCIsImFzMUQiLCJhc1NjYWxhciIsInJlc2hhcGUiLCJhczJEIiwiYXMzRCIsImFzNEQiLCJhczVEIiwiYXNUeXBlIiwiY2FzdCIsImJ1ZmZlciIsImJ1ZmZlclN5bmMiLCJkYXRhU3luYyIsImFycmF5IiwiYXJyYXlTeW5jIiwicmVhZCIsInJlYWRTeW5jIiwiYnl0ZXMiLCJkaXNwb3NlIiwiaXNEaXNwb3NlZCIsImRpc3Bvc2VUZW5zb3IiLCJ0b0Zsb2F0IiwidG9JbnQiLCJ0b0Jvb2wiLCJwcmludCIsInJlc2hhcGVBcyIsImV4cGFuZERpbXMiLCJjdW1zdW0iLCJzcXVlZXplIiwiY2xvbmUiLCJvbmVIb3QiLCJ0aWxlIiwiZ2F0aGVyIiwibWF0TXVsIiwiZG90Iiwibm9ybSIsInJldmVyc2UiLCJzdGFjayIsInVuc3RhY2siLCJwYWQiLCJiYXRjaE5vcm1hbGl6YXRpb24iLCJiYXRjaE5vcm0iLCJhbGwiLCJhbnkiLCJsb2dTdW1FeHAiLCJwcm9kIiwibWVhbiIsImFyZ01pbiIsImFyZ01heCIsImFkZCIsImFkZFN0cmljdCIsImF0YW4yIiwic3ViIiwic3ViU3RyaWN0IiwicG93IiwicG93U3RyaWN0IiwibXVsIiwibXVsU3RyaWN0IiwiZGl2IiwiZGl2Tm9OYW4iLCJmbG9vckRpdiIsImRpdlN0cmljdCIsIm1pbmltdW0iLCJtaW5pbXVtU3RyaWN0IiwibWF4aW11bSIsIm1heGltdW1TdHJpY3QiLCJtb2QiLCJtb2RTdHJpY3QiLCJzcXVhcmVkRGlmZmVyZW5jZVN0cmljdCIsInRyYW5zcG9zZSIsIm5vdEVxdWFsIiwibm90RXF1YWxTdHJpY3QiLCJsZXNzIiwibGVzc1N0cmljdCIsImVxdWFsIiwiZXF1YWxTdHJpY3QiLCJsZXNzRXF1YWwiLCJsZXNzRXF1YWxTdHJpY3QiLCJncmVhdGVyIiwiZ3JlYXRlclN0cmljdCIsImdyZWF0ZXJFcXVhbCIsImdyZWF0ZXJFcXVhbFN0cmljdCIsImxvZ2ljYWxBbmQiLCJsb2dpY2FsT3IiLCJsb2dpY2FsTm90IiwibG9naWNhbFhvciIsIndoZXJlIiwibmVnIiwic2lnbiIsImlzSW5mIiwiZXhwbTEiLCJsb2cxcCIsInJzcXJ0Iiwic3F1YXJlIiwicmVjaXByb2NhbCIsImFicyIsImNsaXBCeVZhbHVlIiwicmVsdSIsInJlbHU2IiwiZWx1Iiwic2VsdSIsImxlYWt5UmVsdSIsInByZWx1Iiwic2lnbW9pZCIsImxvZ1NpZ21vaWQiLCJzb2Z0cGx1cyIsInplcm9zTGlrZSIsIm9uZXNMaWtlIiwic2luIiwiY29zIiwidGFuIiwiYXNpbiIsImFjb3MiLCJhdGFuIiwic2luaCIsImNvc2giLCJhc2luaCIsImFjb3NoIiwiYXRhbmgiLCJlcmYiLCJzdGVwIiwic29mdG1heCIsImxvZ1NvZnRtYXgiLCJyZXNpemVCaWxpbmVhciIsImltYWdlIiwicmVzaXplTmVhcmVzdE5laWdoYm9yIiwiY29udjFkIiwiY29udjJkIiwiY29udjJkVHJhbnNwb3NlIiwiZGVwdGh3aXNlQ29udjJEIiwiZGVwdGh3aXNlQ29udjJkIiwic2VwYXJhYmxlQ29udjJkIiwiYXZnUG9vbCIsIm1heFBvb2wiLCJsb2NhbFJlc3BvbnNlTm9ybWFsaXphdGlvbiIsInBvb2wiLCJ2YXJpYWJsZSIsIm1ha2VWYXJpYWJsZSIsInVuc29ydGVkU2VnbWVudFN1bSIsImJhdGNoVG9TcGFjZU5EIiwic3BhY2VUb0JhdGNoTkQiLCJ0b3BrIiwic3RyaWRlZFNsaWNlIiwiZGVwdGhUb1NwYWNlIiwiZmZ0Iiwic3BlY3RyYWwiLCJpZmZ0IiwicmZmdCIsImlyZmZ0IiwiaGFzSW5zdGFuY2UiLCJDdCIsIkV0IiwiUnQiLCJJdCIsImt0IiwiU3QiLCJ0cmFpbmFibGUiLCJuYW1lIiwiaW5jUmVmIiwiZGlzcG9zZVZhcmlhYmxlIiwiRnVuY3Rpb24iLCJSMCIsIlIxIiwiUjIiLCJSMyIsIlI0IiwiUjUiLCJSNiIsImZsb2F0MzIiLCJpbnQzMiIsImJvb2wiLCJjb21wbGV4NjQiLCJBdCIsIkR0IiwiVHQiLCJOdCIsIkZ0IiwiX3QiLCJTZXQiLCJPdCIsIk10IiwibWFrZVR5cGVzTWF0Y2giLCJhc3NlcnRUeXBlc01hdGNoIiwiaXNUZW5zb3JJbkxpc3QiLCJzb21lIiwiZ2V0VGVuc29yc0luQ29udGFpbmVyIiwiQnQiLCJyZWdpc3RlcmVkVmFyaWFibGVzIiwibmV4dFRhcGVOb2RlSWQiLCJudW1CeXRlcyIsIm51bVRlbnNvcnMiLCJudW1TdHJpbmdUZW5zb3JzIiwibnVtRGF0YUJ1ZmZlcnMiLCJncmFkaWVudERlcHRoIiwia2VybmVsRGVwdGgiLCJzY29wZVN0YWNrIiwibnVtRGF0YU1vdmVzU3RhY2siLCJuZXh0U2NvcGVJZCIsInRlbnNvckluZm8iLCJXZWFrTWFwIiwicHJvZmlsaW5nIiwiYWN0aXZlUHJvZmlsZSIsIm5ld0J5dGVzIiwibmV3VGVuc29ycyIsInBlYWtCeXRlcyIsImtlcm5lbHMiLCJyZXN1bHQiLCJQdCIsIkVOViIsInJlZ2lzdHJ5IiwicmVnaXN0cnlGYWN0b3J5IiwicGVuZGluZ0JhY2tlbmRJbml0SWQiLCJzdGF0ZSIsInJlYWR5IiwicGVuZGluZ0JhY2tlbmRJbml0IiwiYmFja2VuZEluc3RhbmNlIiwiZ2V0U29ydGVkQmFja2VuZHMiLCJpbml0aWFsaXplQmFja2VuZCIsInN1Y2Nlc3MiLCJzZXRCYWNrZW5kIiwiaW5pdGlhbGl6ZUJhY2tlbmRzQW5kUmV0dXJuQmVzdCIsImFzeW5jSW5pdCIsImJhY2tlbmROYW1lcyIsImtleXMiLCJmaW5kQmFja2VuZCIsImZpbmRCYWNrZW5kRmFjdG9yeSIsImZhY3RvcnkiLCJyZWdpc3RlckJhY2tlbmQiLCJwcmlvcml0eSIsInNldHVwUmVnaXN0ZXJlZEtlcm5lbHMiLCJwcm9maWxlciIsInNldHVwRnVuYyIsImRpc3Bvc2VSZWdpc3RlcmVkS2VybmVscyIsImRpc3Bvc2VGdW5jIiwicmVzb2x2ZSIsImNhdGNoIiwibWVzc2FnZSIsInJlbW92ZUJhY2tlbmQiLCJtb3ZlRGF0YSIsImJhY2tlbmQiLCJkaXNwb3NlRGF0YSIsIm1vdmUiLCJzaG91bGRDaGVja0Zvck1lbUxlYWtzIiwidGlkeSIsInNjb3BlZFJ1biIsInN0YXJ0U2NvcGUiLCJlbmRTY29wZSIsIm5leHRUZW5zb3JJZCIsIm5leHRWYXJpYWJsZUlkIiwibWFrZVRlbnNvckZyb21EYXRhSWQiLCJhZGRUYXBlTm9kZSIsImFjdGl2ZVNjb3BlIiwicnVuS2VybmVsIiwicnVuS2VybmVsRnVuYyIsImNoZWNrS2VybmVsRm9yTWVtTGVhayIsIm51bURhdGFJZHMiLCJpc1RhcGVPbiIsImtlZXAiLCJrZXJuZWxGdW5jIiwiaW5wdXRzIiwiYXR0cnMiLCJmaWx0ZXIiLCJieXRlc0FkZGVkIiwidG90YWxCeXRlc1NuYXBzaG90IiwidGVuc29yc0FkZGVkIiwidG90YWxUZW5zb3JzU25hcHNob3QiLCJpbnB1dFNoYXBlcyIsIm91dHB1dFNoYXBlcyIsIndyaXRlIiwicmVmQ291bnQiLCJ0cmFjayIsImRpc3Bvc2VWYXJpYWJsZXMiLCJtZW1vcnkiLCJ1bnJlbGlhYmxlIiwicmVhc29ucyIsInByb2ZpbGUiLCJvdXRwdXRzIiwic2F2ZWQiLCJncmFkRnVuYyIsImdyYWRpZW50IiwiYWN0aXZlVGFwZSIsInN0YXJ0VGFwZSIsImVuZFRhcGUiLCJzY29wZUlkIiwiZ3JhZGllbnRzIiwiTHQiLCJncmFkcyIsImN1c3RvbUdyYWQiLCJ3YWxsTXMiLCJ3aW5kb3ciLCJwcm9jZXNzIiwic2VsZiIsIl90ZmVuZ2luZSIsIld0IiwiZG9jdW1lbnQiLCJXb3JrZXJHbG9iYWxTY29wZSIsIlV0IiwidmVyc2lvbnMiLCJub2RlIiwibmF2aWdhdG9yIiwidXNlckFnZW50IiwidGVzdCIsInZlbmRvciIsIlZ0IiwienQiLCJHdCIsIkh0IiwicXQiLCJhbHBoYSIsImFudGlhbGlhcyIsInByZW11bHRpcGxpZWRBbHBoYSIsInByZXNlcnZlRHJhd2luZ0J1ZmZlciIsImRlcHRoIiwic3RlbmNpbCIsImZhaWxJZk1ham9yUGVyZm9ybWFuY2VDYXZlYXQiLCJLdCIsImp0IiwiT2Zmc2NyZWVuQ2FudmFzIiwiY3JlYXRlRWxlbWVudCIsImFkZEV2ZW50TGlzdGVuZXIiLCJwcmV2ZW50RGVmYXVsdCIsImdldENvbnRleHQiLCJpc0NvbnRleHRMb3N0IiwiZGlzYWJsZSIsIkRFUFRIX1RFU1QiLCJTVEVOQ0lMX1RFU1QiLCJCTEVORCIsIkRJVEhFUiIsIlBPTFlHT05fT0ZGU0VUX0ZJTEwiLCJTQU1QTEVfQ09WRVJBR0UiLCJlbmFibGUiLCJTQ0lTU09SX1RFU1QiLCJDVUxMX0ZBQ0UiLCJjdWxsRmFjZSIsIkJBQ0siLCJYdCIsIll0IiwiJHQiLCJRdCIsIlIzMkYiLCJSMTZGIiwiUkdCQTE2RiIsIlJHQkEzMkYiLCJSRUQiLCJIQUxGX0ZMT0FUIiwiRkxPQVQiLCJSR0JBIiwiSEFMRl9GTE9BVF9PRVMiLCJpbnRlcm5hbEZvcm1hdEZsb2F0IiwiaW50ZXJuYWxGb3JtYXRIYWxmRmxvYXQiLCJpbnRlcm5hbEZvcm1hdFBhY2tlZEhhbGZGbG9hdCIsImludGVybmFsRm9ybWF0UGFja2VkRmxvYXQiLCJ0ZXh0dXJlRm9ybWF0RmxvYXQiLCJkb3dubG9hZFRleHR1cmVGb3JtYXQiLCJkb3dubG9hZFVucGFja051bUNoYW5uZWxzIiwiZGVmYXVsdE51bUNoYW5uZWxzIiwidGV4dHVyZVR5cGVIYWxmRmxvYXQiLCJ0ZXh0dXJlVHlwZUZsb2F0IiwiSnQiLCJnZXRFcnJvciIsIk5PX0VSUk9SIiwibmUiLCJERU5TRSIsIlNIQVJFRF9CQVRDSCIsIlJFTkRFUiIsIlVQTE9BRCIsIlBJWEVMUyIsIkRPV05MT0FEIiwiVU5QQUNLRURfRkxPQVQxNiIsIlVOUEFDS0VEX0ZMT0FUMzIiLCJQQUNLRURfNFgxX1VOU0lHTkVEX0JZVEUiLCJQQUNLRURfMlgyX0ZMT0FUMzIiLCJQQUNLRURfMlgyX0ZMT0FUMTYiLCJadCIsInRlIiwiZWUiLCJJTlZBTElEX0VOVU0iLCJJTlZBTElEX1ZBTFVFIiwiSU5WQUxJRF9PUEVSQVRJT04iLCJJTlZBTElEX0ZSQU1FQlVGRkVSX09QRVJBVElPTiIsIk9VVF9PRl9NRU1PUlkiLCJDT05URVhUX0xPU1RfV0VCR0wiLCJyZSIsImtlIiwiZ2V0RXh0ZW5zaW9uIiwib2UiLCJjcmVhdGVTaGFkZXIiLCJWRVJURVhfU0hBREVSIiwic2hhZGVyU291cmNlIiwiY29tcGlsZVNoYWRlciIsImdldFNoYWRlclBhcmFtZXRlciIsIkNPTVBJTEVfU1RBVFVTIiwiZ2V0U2hhZGVySW5mb0xvZyIsImFlIiwiRlJBR01FTlRfU0hBREVSIiwidWUiLCJleGVjIiwiaWUiLCJzZSIsImNlIiwiY3JlYXRlUHJvZ3JhbSIsImxlIiwibGlua1Byb2dyYW0iLCJnZXRQcm9ncmFtUGFyYW1ldGVyIiwiTElOS19TVEFUVVMiLCJnZXRQcm9ncmFtSW5mb0xvZyIsImhlIiwidmFsaWRhdGVQcm9ncmFtIiwiVkFMSURBVEVfU1RBVFVTIiwiZmUiLCJjcmVhdGVCdWZmZXIiLCJiaW5kQnVmZmVyIiwiQVJSQVlfQlVGRkVSIiwiYnVmZmVyRGF0YSIsIlNUQVRJQ19EUkFXIiwiZGUiLCJFTEVNRU5UX0FSUkFZX0JVRkZFUiIsInBlIiwiY3JlYXRlVGV4dHVyZSIsInZlIiwibWUiLCJjcmVhdGVGcmFtZWJ1ZmZlciIsImdlIiwiZ2V0QXR0cmliTG9jYXRpb24iLCJ2ZXJ0ZXhBdHRyaWJQb2ludGVyIiwiZW5hYmxlVmVydGV4QXR0cmliQXJyYXkiLCJ5ZSIsIlNlIiwiYWN0aXZlVGV4dHVyZSIsIlRFWFRVUkUwIiwiYmluZFRleHR1cmUiLCJURVhUVVJFXzJEIiwieGUiLCJnZXRVbmlmb3JtTG9jYXRpb24iLCJiZSIsIndlIiwidW5pZm9ybTFpIiwiQ2UiLCJiaW5kRnJhbWVidWZmZXIiLCJGUkFNRUJVRkZFUiIsImZyYW1lYnVmZmVyVGV4dHVyZTJEIiwiQ09MT1JfQVRUQUNITUVOVDAiLCJFZSIsIlJlIiwiY2hlY2tGcmFtZWJ1ZmZlclN0YXR1cyIsIkZSQU1FQlVGRkVSX0NPTVBMRVRFIiwiSWUiLCJGUkFNRUJVRkZFUl9JTkNPTVBMRVRFX0FUVEFDSE1FTlQiLCJGUkFNRUJVRkZFUl9JTkNPTVBMRVRFX01JU1NJTkdfQVRUQUNITUVOVCIsIkZSQU1FQlVGRkVSX0lOQ09NUExFVEVfRElNRU5TSU9OUyIsIkZSQU1FQlVGRkVSX1VOU1VQUE9SVEVEIiwiTUFYX0NPTUJJTkVEX1RFWFRVUkVfSU1BR0VfVU5JVFMiLCJBZSIsIkRlIiwiVGUiLCJOZSIsIkZlIiwiX2UiLCJPZSIsImdldFBhcmFtZXRlciIsIk1BWF9URVhUVVJFX1NJWkUiLCJNZSIsIk1BWF9URVhUVVJFX0lNQUdFX1VOSVRTIiwiQmUiLCJQZSIsIkxlIiwiV2UiLCJWZSIsIlVlIiwidGV4SW1hZ2UyRCIsImRlbGV0ZVRleHR1cmUiLCJkZWxldGVGcmFtZWJ1ZmZlciIsInplIiwiZmVuY2VTeW5jIiwiR2UiLCJjYWxsQW5kQ2hlY2siLCJjYW5CZVJlcHJlc2VudGVkIiwiZ2V0V2ViR0xFcnJvck1lc3NhZ2UiLCJnZXRFeHRlbnNpb25PclRocm93IiwiY3JlYXRlVmVydGV4U2hhZGVyIiwiY3JlYXRlRnJhZ21lbnRTaGFkZXIiLCJjcmVhdGVTdGF0aWNWZXJ0ZXhCdWZmZXIiLCJjcmVhdGVTdGF0aWNJbmRleEJ1ZmZlciIsImdldE51bUNoYW5uZWxzIiwidmFsaWRhdGVUZXh0dXJlU2l6ZSIsImJpbmRWZXJ0ZXhCdWZmZXJUb1Byb2dyYW1BdHRyaWJ1dGUiLCJiaW5kVGV4dHVyZVVuaXQiLCJ1bmJpbmRUZXh0dXJlVW5pdCIsImdldFByb2dyYW1Vbmlmb3JtTG9jYXRpb25PclRocm93IiwiZ2V0UHJvZ3JhbVVuaWZvcm1Mb2NhdGlvbiIsImJpbmRUZXh0dXJlVG9Qcm9ncmFtVW5pZm9ybVNhbXBsZXIiLCJiaW5kQ2FudmFzVG9GcmFtZWJ1ZmZlciIsInZpZXdwb3J0IiwiY2FudmFzIiwid2lkdGgiLCJoZWlnaHQiLCJzY2lzc29yIiwiYmluZENvbG9yVGV4dHVyZVRvRnJhbWVidWZmZXIiLCJ1bmJpbmRDb2xvclRleHR1cmVGcm9tRnJhbWVidWZmZXIiLCJ2YWxpZGF0ZUZyYW1lYnVmZmVyIiwiZ2V0RnJhbWVidWZmZXJFcnJvck1lc3NhZ2UiLCJnZXRCYXRjaERpbSIsImdldFJvd3NDb2xzIiwiZ2V0U2hhcGVBczNEIiwiZ2V0VGV4dHVyZVNoYXBlRnJvbUxvZ2ljYWxTaGFwZSIsImlzUmVzaGFwZUZyZWUiLCJnZXRXZWJHTE1heFRleHR1cmVTaXplIiwicmVzZXRNYXhUZXh0dXJlU2l6ZSIsInJlc2V0TWF4VGV4dHVyZXNJblNoYWRlciIsImdldE1heFRleHR1cmVzSW5TaGFkZXIiLCJnZXRXZWJHTERpc2pvaW50UXVlcnlUaW1lclZlcnNpb24iLCJoYXNFeHRlbnNpb24iLCJpc1dlYkdMVmVyc2lvbkVuYWJsZWQiLCJpc0NhcGFibGVPZlJlbmRlcmluZ1RvRmxvYXRUZXh0dXJlIiwiaXNEb3dubG9hZEZsb2F0VGV4dHVyZUVuYWJsZWQiLCJpc1dlYkdMRmVuY2VFbmFibGVkIiwiSGUiLCJxZSIsIktlIiwiamUiLCJYZSIsIlllIiwiJGUiLCJRZSIsIkplIiwiWmUiLCJ0biIsImVuIiwibm4iLCJybiIsIm9uIiwiYW4iLCJzbiIsInVuIiwiY24iLCJsbiIsImhuIiwiZm4iLCJkbiIsInBuIiwidm4iLCJtbiIsImluZGV4T2YiLCJnbiIsInluIiwieG4iLCJibiIsInduIiwiQ24iLCJFbiIsIlJuIiwiSW4iLCJrbiIsIlNuIiwiQW4iLCJlbmRzV2l0aCIsInN1YnN0cmluZyIsIm9wZXJhIiwic3Vic3RyIiwiRG4iLCJjb21wbGV4XyIsImNvbXBsZXgiLCIkcmVhbCIsIiRpbWFnIiwiVG4iLCJyZWFsXyIsInJlYWwiLCIkaW5wdXQiLCJObiIsImltYWdfIiwiaW1hZyIsIkZuIiwiX24iLCJPbiIsIk1uIiwiQm4iLCJQbiIsIkxuIiwiV24iLCJVbiIsIlZuIiwiem4iLCJHbiIsIkhuIiwicW4iLCJsaW5zcGFjZSIsIktuIiwiam4iLCJvbmVzTGlrZV8iLCJYbiIsIiR4IiwiemVyb3NMaWtlXyIsIlluIiwiY29uY2F0XyIsImF4aXMiLCJ0ciIsIiRuIiwiY29uY2F0MWRfIiwiUW4iLCJjb25jYXQyZF8iLCJKbiIsImNvbmNhdDNkXyIsIlpuIiwiY29uY2F0NGRfIiwic3BsaXRfIiwiZ2xvYmFsVGhpcyIsImVyIiwiZXhwb3J0cyIsIm5yIiwiY2hhckNvZGVBdCIsInMwIiwiczEiLCJzMiIsImRvdWJsZSIsInF1aWNrIiwiYW1kIiwiYWxlYSIsInJyIiwieG9yMTI4Iiwib3IiLCJ4b3J3b3ciLCJhciIsIkRhdGUiLCJ4b3JzaGlmdDciLCJpciIsInhvcjQwOTYiLCJzciIsInR5Y2hlaSIsInVyIiwiZW50cm9weSIsInJhbmRvbUJ5dGVzIiwiY3J5cHRvIiwibXNDcnlwdG8iLCJnZXRSYW5kb21WYWx1ZXMiLCJwbHVnaW5zIiwic2NyZWVuIiwicGFzcyIsImZyb21DaGFyQ29kZSIsInJlcXVpcmUiLCJjciIsImxyIiwic3RkRGV2IiwibmV4dFZhbCIsIk5hTiIsInRydW5jYXRlZCIsInVwcGVyIiwibG93ZXIiLCJuZXh0VmFsdWUiLCJpc1ZhbGlkVHJ1bmNhdGVkIiwiY29udmVydFZhbHVlIiwiaHIiLCJiZXRhIiwicmFuZHUiLCJyYW5kbiIsImZyIiwiY2FuUmV0dXJuRmxvYXQiLCJyYW5nZSIsImRyIiwicHIiLCJ2ciIsImJhdGNoVG9TcGFjZU5EXyIsIm1yIiwiYnJvYWRjYXN0VG9fIiwidW5zaGlmdCIsImlucHV0IiwiZ3IiLCJjYXN0XyIsInlyIiwiY2xvbmVfIiwieHIiLCJjdW1zdW1fIiwicGVybXV0ZWRYIiwiYnIiLCJkZXB0aFRvU3BhY2VfIiwid3IiLCJleHBhbmREaW1zXyIsInNwbGljZSIsIk9yIiwiQ3IiLCJleWVfIiwiTHIiLCJFciIsIm11bHRpbm9taWFsXyIsIm11bHRpbm9taWFsIiwibG9naXRzMkQiLCJSciIsIm9uZUhvdF8iLCIkaW5kaWNlcyIsIklyIiwicGFkXyIsInBhZGRpbmdzIiwiY29uc3RhbnRWYWx1ZSIsImtyIiwicGFkMWRfIiwiU3IiLCJwYWQyZF8iLCJBciIsInBhZDNkXyIsIkRyIiwicGFkNGRfIiwiVHIiLCJyYW5kXyIsIk5yIiwicmFuZG9tTm9ybWFsXyIsIkZyIiwicmFuZG9tR2FtbWFfIiwiX3IiLCJyYW5kb21Vbmlmb3JtXyIsInJlc2hhcGVfIiwiTXIiLCJzcGFjZVRvQmF0Y2hORF8iLCJCciIsInNxdWVlemVfIiwiUHIiLCJzdGFja18iLCJ0aWxlXyIsInJlcHMiLCJXciIsInRydW5jYXRlZE5vcm1hbF8iLCJVciIsInVuc3RhY2tfIiwiVnIiLCJ6ciIsIkdyIiwiSHIiLCJxciIsIktyIiwianIiLCJYciIsInByZXBhcmVBbmRWYWxpZGF0ZSIsIllyIiwiJHIiLCJRciIsIkpyIiwiWnIiLCJzbGljZVJhbmsiLCJudW1VcGRhdGVzIiwic2xpY2VTaXplIiwib3V0cHV0U2l6ZSIsInRvIiwidmFsaWRhdGVVcGRhdGVTaGFwZSIsInZhbGlkYXRlSW5wdXQiLCJjYWxjdWxhdGVTaGFwZXMiLCJlbyIsIm5vIiwicm8iLCJvbyIsIk1JTl9TQUZFX0lOVEVHRVIiLCJNQVhfU0FGRV9JTlRFR0VSIiwiYW8iLCJpbyIsInNvIiwidW8iLCJhc3NlcnRQYXJhbXNWYWxpZCIsIm1hc2tUb0F4ZXMiLCJjb21wdXRlT3V0U2hhcGUiLCJzdGFydEZvckF4aXMiLCJzdG9wRm9yQXhpcyIsImlzU2xpY2VDb250aW5vdXMiLCJjb21wdXRlRmxhdE9mZnNldCIsImNvIiwibW8iLCJsbyIsImhvIiwiZ3JhZCIsImZvIiwicG8iLCJ2byIsImdvIiwic29mdG1heF8iLCJsb2dpdHMiLCJkaW0iLCJ5byIsImxvZ1NvZnRtYXhfIiwieG8iLCJkYXRhTW92ZXIiLCJkYXRhSWRzQ291bnQiLCJibyIsIndvIiwiZmxvYXRQcmVjaXNpb24iLCJlcHNpbG9uIiwiYmF0Y2hNYXRNdWwiLCJmdXNlZEJhdGNoTWF0TXVsIiwidHJhbnNwb3NlQSIsInRyYW5zcG9zZUIiLCJiaWFzIiwiYWN0aXZhdGlvbiIsInByZWx1QWN0aXZhdGlvbldlaWdodHMiLCJhZGROIiwic3VidHJhY3QiLCJtdWx0aXBseSIsInJlYWxEaXZpZGUiLCJzZWxlY3QiLCJzcXVhcmVkRGlmZmVyZW5jZSIsImVsdURlciIsImludCIsImNsaXAiLCJjb21wbGV4QWJzIiwiZnVzZWRDb252MmQiLCJjb252SW5mbyIsImNvbnYyZERlcklucHV0IiwiY29udjJkRGVyRmlsdGVyIiwiZnVzZWREZXB0aHdpc2VDb252MkQiLCJkZXB0aHdpc2VDb252MkREZXJJbnB1dCIsImRlcHRod2lzZUNvbnYyRERlckZpbHRlciIsImNvbnYzZCIsImNvbnYzZERlcklucHV0IiwiY29udjNkRGVyRmlsdGVyIiwibWF4UG9vbEJhY2twcm9wIiwiYXZnUG9vbEJhY2twcm9wIiwiYXZnUG9vbDNkIiwiYXZnUG9vbDNkQmFja3Byb3AiLCJtYXhQb29sM2QiLCJtYXhQb29sM2RCYWNrcHJvcCIsImdhdGhlck5EIiwic2NhdHRlck5EIiwicmVzaXplQmlsaW5lYXJCYWNrcHJvcCIsInJlc2l6ZU5lYXJlc3ROZWlnaGJvckJhY2twcm9wIiwibG9jYWxSZXNwb25zZU5vcm1hbGl6YXRpb240RCIsIkxSTkdyYWQiLCJub25NYXhTdXBwcmVzc2lvbiIsImNyb3BBbmRSZXNpemUiLCJzcGFyc2VUb0RlbnNlIiwiZGlhZyIsIkNvIiwiRW8iLCJSbyIsIklvIiwiVG8iLCJTbyIsImtvIiwiTm8iLCJBbyIsIkZvIiwidG9wIiwiYm90dG9tIiwibGVmdCIsInJpZ2h0IiwidHlwZSIsIkRvIiwiX28iLCJwYWRJbmZvIiwib3V0SGVpZ2h0Iiwib3V0V2lkdGgiLCJiYXRjaFNpemUiLCJkYXRhRm9ybWF0IiwiaW5IZWlnaHQiLCJpbldpZHRoIiwiaW5DaGFubmVscyIsIm91dENoYW5uZWxzIiwic3RyaWRlSGVpZ2h0Iiwic3RyaWRlV2lkdGgiLCJmaWx0ZXJIZWlnaHQiLCJmaWx0ZXJXaWR0aCIsImVmZmVjdGl2ZUZpbHRlckhlaWdodCIsImVmZmVjdGl2ZUZpbHRlcldpZHRoIiwiZGlsYXRpb25IZWlnaHQiLCJkaWxhdGlvbldpZHRoIiwiaW5TaGFwZSIsIm91dFNoYXBlIiwiZmlsdGVyU2hhcGUiLCJmcm9udCIsImJhY2siLCJvdXREZXB0aCIsImluRGVwdGgiLCJzdHJpZGVEZXB0aCIsImZpbHRlckRlcHRoIiwiZWZmZWN0aXZlRmlsdGVyRGVwdGgiLCJkaWxhdGlvbkRlcHRoIiwiT28iLCJNbyIsIkJvIiwiUG8iLCJMbyIsIldvIiwiVW8iLCJjYXN0VGVuc29yIiwicmVzaGFwZVRlbnNvciIsImxpbnNwYWNlSW1wbCIsInVwY2FzdFR5cGUiLCJheGVzQXJlSW5uZXJNb3N0RGltcyIsImNvbWJpbmVMb2NhdGlvbnMiLCJjb21wdXRlT3V0QW5kUmVkdWNlU2hhcGVzIiwiZXhwYW5kU2hhcGVUb0tlZXBEaW0iLCJhc3NlcnRBeGVzQXJlSW5uZXJNb3N0RGltcyIsImdldEF4ZXNQZXJtdXRhdGlvbiIsImdldFVuZG9BeGVzUGVybXV0YXRpb24iLCJnZXRJbm5lck1vc3RBeGVzIiwiZ2V0QnJvYWRjYXN0RGltcyIsImdldFJlZHVjdGlvbkF4ZXMiLCJhc3NlcnRBbmRHZXRCcm9hZGNhc3RTaGFwZSIsImFzc2VydFBhcmFtc0NvbnNpc3RlbnQiLCJjb21wdXRlUG9vbDJESW5mbyIsImNvbXB1dGVQb29sM0RJbmZvIiwiY29tcHV0ZUNvbnYyREluZm8iLCJjb21wdXRlQ29udjNESW5mbyIsImNvbXB1dGVEZWZhdWx0UGFkIiwidHVwbGVWYWx1ZXNBcmVPbmUiLCJlaXRoZXJTdHJpZGVzT3JEaWxhdGlvbnNBcmVPbmUiLCJjb252ZXJ0Q29udjJERGF0YUZvcm1hdCIsIlBBUkFMTEVMSVpFX1RIUkVTSE9MRCIsImNvbXB1dGVPcHRpbWFsV2luZG93U2l6ZSIsIlZvIiwiem8iLCJHbyIsIkhvIiwiUEkiLCJxbyIsIktvIiwiam8iLCJZbyIsInNlbGVjdGVkSW5kaWNlcyIsIlhvIiwibnVtVmFsaWRPdXRwdXRzIiwic2VsZWN0ZWRTY29yZXMiLCJzY29yZSIsImJveEluZGV4Iiwic3VwcHJlc3NCZWdpbkluZGV4IiwiSm8iLCIkbyIsIlFvIiwic3ViYXJyYXkiLCJabyIsInRhIiwiZWEiLCJpbmRleCIsIm5hIiwicmEiLCJvdXRwdXRTaGFwZSIsInZhcmlhYmxlTmFtZXMiLCJ1c2VyQ29kZSIsIm9hIiwicGFja2VkSW5wdXRzIiwicGFja2VkT3V0cHV0IiwiYWEiLCJ3aW5kb3dTaXplIiwiaW5TaXplIiwiaWEiLCJzYSIsInVhIiwidmVyc2lvbiIsImF0dHJpYnV0ZSIsInZhcnlpbmdWcyIsInZhcnlpbmdGcyIsInRleHR1cmUyRCIsIm91dHB1dCIsImRlZmluZU91dHB1dCIsImRlZmluZVNwZWNpYWxOYU4iLCJkZWZpbmVTcGVjaWFsSW5mIiwiZGVmaW5lUm91bmQiLCJjYSIsImxhIiwiaGEiLCJmYSIsInNoYXBlSW5mbyIsImxvZ2ljYWxTaGFwZSIsImlzVW5pZm9ybSIsInBhIiwiZGEiLCJjaGFyQXQiLCJ0b1VwcGVyQ2FzZSIsIndhIiwidGV4U2hhcGUiLCJmbGF0T2Zmc2V0IiwidmEiLCJtYSIsImdhIiwiaXNQYWNrZWQiLCJ5YSIsInhhIiwiYmEiLCJDYSIsIkVhIiwiSlNPTiIsInBhcnNlIiwic3RyaW5naWZ5IiwiUmEiLCJJYSIsImthIiwiU2EiLCJBYSIsIkRhIiwiVGEiLCJOYSIsIkZhIiwiX2EiLCJPYSIsIk1hIiwiQmEiLCJQYSIsIkxhIiwic3VwcG9ydHNCcm9hZGNhc3RpbmciLCJXYSIsImdldEN1c3RvbVNldHVwRnVuYyIsIm1pbkxvYyIsImdldFVuaWZvcm1Mb2NhdGlvbk5vVGhyb3ciLCJtYXhMb2MiLCJnbCIsInVuaWZvcm0xZiIsIlVhIiwiVmEiLCJ6YSIsIkdhIiwiSGEiLCJxYSIsIkthIiwiamEiLCJYYSIsIllhIiwiJGEiLCJRYSIsIkphIiwiWmEiLCJ0aSIsImVpIiwibmkiLCJyaSIsIm9pIiwib3V0UGFja2luZ1NjaGVtZSIsImFpIiwiaWkiLCJibG9ja1NpemUiLCJnZXRIZWlnaHRDb29yZFN0cmluZyIsImdldFdpZHRoQ29vcmRTdHJpbmciLCJnZXREZXB0aENvb3JkU3RyaW5nIiwiZ2V0T3V0cHV0RGVwdGhTaXplIiwiZ2V0SW5wdXRTYW1wbGluZ1N0cmluZyIsInNpIiwidWkiLCJvdXRUZXhVc2FnZSIsImNpIiwibGkiLCJoaSIsImZpIiwiZGkiLCJwaSIsInZpIiwidmFsdWVMb2MiLCJtaSIsImdpIiwic2xpY2VEaW0iLCJ5aSIsInhpIiwiYmkiLCJVaW50MTZBcnJheSIsIndpIiwidGV4UGFyYW1ldGVyaSIsIlRFWFRVUkVfV1JBUF9TIiwiQ0xBTVBfVE9fRURHRSIsIlRFWFRVUkVfV1JBUF9UIiwiVEVYVFVSRV9NSU5fRklMVEVSIiwiTkVBUkVTVCIsIlRFWFRVUkVfTUFHX0ZJTFRFUiIsIkNpIiwiRWkiLCJSaSIsIlVOU0lHTkVEX0JZVEUiLCJJaSIsImtpIiwiU2kiLCJBaSIsIkRpIiwiVGkiLCJQSVhFTF9QQUNLX0JVRkZFUiIsIlNUUkVBTV9SRUFEIiwicmVhZFBpeGVscyIsIk5pIiwiZ2V0QnVmZmVyU3ViRGF0YSIsIkZpIiwiX2kiLCJPaSIsIk1pIiwiY3JlYXRlVmVydGV4QnVmZmVyIiwiY3JlYXRlSW5kZXhCdWZmZXIiLCJjcmVhdGVGbG9hdDMyTWF0cml4VGV4dHVyZSIsImNyZWF0ZUZsb2F0MTZNYXRyaXhUZXh0dXJlIiwiY3JlYXRlVW5zaWduZWRCeXRlc01hdHJpeFRleHR1cmUiLCJjcmVhdGVQYWNrZWRNYXRyaXhUZXh0dXJlIiwiY3JlYXRlRmxvYXQxNlBhY2tlZE1hdHJpeFRleHR1cmUiLCJiaW5kVmVydGV4UHJvZ3JhbUF0dHJpYnV0ZVN0cmVhbXMiLCJ1cGxvYWREZW5zZU1hdHJpeFRvVGV4dHVyZSIsInVwbG9hZFBpeGVsRGF0YVRvVGV4dHVyZSIsImNyZWF0ZUJ1ZmZlckZyb21PdXRwdXRUZXh0dXJlIiwiZG93bmxvYWRGbG9hdDMyTWF0cml4RnJvbUJ1ZmZlciIsImRvd25sb2FkQnl0ZUVuY29kZWRGbG9hdE1hdHJpeEZyb21PdXRwdXRUZXh0dXJlIiwiZG93bmxvYWRQYWNrZWRNYXRyaXhGcm9tQnVmZmVyIiwiZG93bmxvYWRNYXRyaXhGcm9tUGFja2VkT3V0cHV0VGV4dHVyZSIsIkJpIiwib3V0cHV0VGV4dHVyZSIsInByb2dyYW0iLCJkaXNwb3NlZCIsInZlcnRleEF0dHJzQXJlQm91bmQiLCJpdGVtc1RvUG9sbCIsInRleHR1cmVGbG9hdEV4dGVuc2lvbiIsImRlYnVnIiwidGV4dHVyZUhhbGZGbG9hdEV4dGVuc2lvbiIsImNvbG9yQnVmZmVyRmxvYXRFeHRlbnNpb24iLCJjb2xvckJ1ZmZlckhhbGZGbG9hdEV4dGVuc2lvbiIsInZlcnRleEJ1ZmZlciIsImluZGV4QnVmZmVyIiwiZnJhbWVidWZmZXIiLCJ0ZXh0dXJlQ29uZmlnIiwiZmluaXNoIiwiZGVsZXRlQnVmZmVyIiwiZGVsZXRlTWF0cml4VGV4dHVyZSIsImRvd25sb2FkTWF0cml4RHJpdmVyIiwiY3JlYXRlQnVmZmVyRnJvbVRleHR1cmUiLCJiaW5kVGV4dHVyZVRvRnJhbWVCdWZmZXIiLCJ1bmJpbmRUZXh0dXJlVG9GcmFtZUJ1ZmZlciIsImNyZWF0ZUFuZFdhaXRGb3JGZW5jZSIsImNyZWF0ZUZlbmNlIiwicG9sbEZlbmNlIiwiU1lOQ19HUFVfQ09NTUFORFNfQ09NUExFVEUiLCJmbHVzaCIsImNsaWVudFdhaXRTeW5jIiwiQUxSRUFEWV9TSUdOQUxFRCIsIkNPTkRJVElPTl9TQVRJU0ZJRUQiLCJiZWdpblF1ZXJ5IiwiZW5kUXVlcnkiLCJpc1F1ZXJ5QXZhaWxhYmxlIiwicXVlcnkiLCJpc0ZlbmNlUGFzc2VkIiwiZG93bmxvYWRNYXRyaXhGcm9tUGFja2VkVGV4dHVyZSIsImF0dGFjaFNoYWRlciIsInNldFByb2dyYW0iLCJkZWxldGVQcm9ncmFtIiwidXNlUHJvZ3JhbSIsImdldEF0dHJpYnV0ZUxvY2F0aW9uIiwic2V0SW5wdXRNYXRyaXhUZXh0dXJlIiwidGhyb3dJZk5vUHJvZ3JhbSIsInNldE91dHB1dE1hdHJpeFRleHR1cmUiLCJzZXRPdXRwdXRNYXRyaXhUZXh0dXJlRHJpdmVyIiwic2V0T3V0cHV0UGFja2VkTWF0cml4VGV4dHVyZSIsInNldE91dHB1dE1hdHJpeFdyaXRlUmVnaW9uIiwic2V0T3V0cHV0TWF0cml4V3JpdGVSZWdpb25Ecml2ZXIiLCJzZXRPdXRwdXRQYWNrZWRNYXRyaXhXcml0ZVJlZ2lvbiIsImRlYnVnVmFsaWRhdGUiLCJleGVjdXRlUHJvZ3JhbSIsImRyYXdFbGVtZW50cyIsIlRSSUFOR0xFUyIsIlVOU0lHTkVEX1NIT1JUIiwiYmxvY2tVbnRpbEFsbFByb2dyYW1zQ29tcGxldGVkIiwiZ2V0UXVlcnlUaW1lckV4dGVuc2lvbiIsImRpc2pvaW50UXVlcnlUaW1lckV4dGVuc2lvbiIsImdldFF1ZXJ5VGltZXJFeHRlbnNpb25XZWJHTDIiLCJnZXRRdWVyeVRpbWVyRXh0ZW5zaW9uV2ViR0wxIiwiY3JlYXRlUXVlcnkiLCJUSU1FX0VMQVBTRURfRVhUIiwiY3JlYXRlUXVlcnlFWFQiLCJiZWdpblF1ZXJ5RVhUIiwiZW5kUXVlcnlFWFQiLCJ3YWl0Rm9yUXVlcnlBbmRHZXRUaW1lIiwiZ2V0UXVlcnlUaW1lIiwiZ2V0UXVlcnlQYXJhbWV0ZXIiLCJRVUVSWV9SRVNVTFQiLCJnZXRRdWVyeU9iamVjdEVYVCIsIlFVRVJZX1JFU1VMVF9FWFQiLCJRVUVSWV9SRVNVTFRfQVZBSUxBQkxFIiwiZGlzam9pbnQiLCJHUFVfRElTSk9JTlRfRVhUIiwiUVVFUllfUkVTVUxUX0FWQUlMQUJMRV9FWFQiLCJhZGRJdGVtVG9Qb2xsIiwicG9sbEl0ZW1zIiwiaXNEb25lRm4iLCJyZXNvbHZlRm4iLCJQaSIsInRleERhdGEiLCJMaSIsIldpIiwiVWkiLCJkZXB0aFJhZGl1cyIsIlZpIiwiemkiLCJHaSIsIkhpIiwicWkiLCJzZWVkTG9jIiwiS2kiLCJqaSIsIlhpIiwiWWkiLCIkaSIsIlFpIiwiSmkiLCJaaSIsInRzIiwiZXMiLCJucyIsInJzIiwib3MiLCJhcyIsImlzIiwic3MiLCJ1cyIsIm51bVNlZ21lbnRzIiwiY3MiLCJscyIsImhzIiwic3RhcnRMb2MiLCJ1bmlmb3JtMWl2IiwiZnMiLCJkcyIsInBzIiwiZ3BncHUiLCJudW1Vc2VkVGV4dHVyZXMiLCJudW1GcmVlVGV4dHVyZXMiLCJmcmVlVGV4dHVyZXMiLCJsb2dFbmFibGVkIiwidXNlZFRleHR1cmVzIiwiYWNxdWlyZVRleHR1cmUiLCJ2cyIsIm1zIiwic2hpZnQiLCJyZWxlYXNlVGV4dHVyZSIsImdldE51bVVzZWRUZXh0dXJlcyIsImdldE51bUZyZWVUZXh0dXJlcyIsImdzIiwieXMiLCJ4cyIsImJzIiwid3MiLCJDcyIsIkVzIiwiUnMiLCJJcyIsImtzIiwiU3MiLCJBcyIsIkRzIiwiVHMiLCJOcyIsIkZzIiwiX3MiLCJPcyIsIk1zIiwiQnMiLCJQcyIsIkxzIiwiV3MiLCJVcyIsIlZzIiwienMiLCJHcyIsIkhzIiwicXMiLCJLcyIsImpzIiwiWHMiLCJZcyIsIiRzIiwiUXMiLCJKcyIsIlpzIiwicGVuZGluZ1JlYWQiLCJwZW5kaW5nRGlzcG9zYWwiLCJXZWFrU2V0IiwiZGF0YVJlZkNvdW50IiwibnVtQnl0ZXNJbkdQVSIsInVwbG9hZFdhaXRNcyIsImRvd25sb2FkV2FpdE1zIiwid2FybmVkQWJvdXRNZW1vcnkiLCJwZW5kaW5nRGVsZXRlcyIsImJpbmFyeUNhY2hlIiwiZ3BncHVDcmVhdGVkTG9jYWxseSIsInRleHR1cmVNYW5hZ2VyIiwibnVtTUJCZWZvcmVXYXJuaW5nIiwiZGV2aWNlUGl4ZWxSYXRpbyIsImNwdUJhY2tlbmQiLCJjaGVja051bWVyaWNhbFByb2JsZW1zIiwidXNhZ2UiLCJjb21wbGV4VGVuc29ycyIsInJ1bldlYkdMUHJvZ3JhbSIsImNvbnZlcnRBbmRDYWNoZU9uQ1BVIiwiYWN0aXZlVGltZXJzIiwiZ2V0VmFsdWVzRnJvbVRleHR1cmUiLCJ0ZXh0dXJlIiwicHJvZ3JhbVRpbWVyc1N0YWNrIiwic3RhcnRUaW1lciIsInN0YXJ0TXMiLCJlbmRNcyIsImVuZFRpbWVyIiwicmVsZWFzZUdQVURhdGEiLCJvcmlnRGF0YUlkIiwiY29tcHV0ZUJ5dGVzIiwiZ2V0VGV4dHVyZSIsInVwbG9hZFRvR1BVIiwiZ2V0RGF0YUluZm8iLCJnZXRDUFVCYWNrZW5kIiwic2hvdWxkRXhlY3V0ZU9uQ1BVIiwiZ2V0R1BHUFVDb250ZXh0IiwibWFrZU91dHB1dCIsImNvbXBpbGVBbmRSdW4iLCJzaGFsbG93U2xpY2UiLCJwYWNrZWRVbmFyeU9wIiwibWFrZUNvbXBsZXhDb21wb25lbnRUZW5zb3JJbmZvIiwicGFja2VkQmluYXJ5T3AiLCJhcmdSZWR1Y2UiLCJhcmdSZWR1Y2VQYWNrZWQiLCJzZWdPcENvbXB1dGUiLCJhcmdNaW5NYXhSZWR1Y2UiLCJjb21wbGV4U2VwYXJhYmxlQmluYXJ5T3AiLCJjb252MmRCeU1hdE11bCIsImNvbnYyZFdpdGhJbTJSb3ciLCJwYWNrZWRSZXNoYXBlIiwiZmZ0SW1wbCIsIm1ha2VUZW5zb3JJbmZvIiwidW5wYWNrVGVuc29yIiwicGFja1RlbnNvciIsInVuaWZvcm1WYWx1ZXMiLCJnZXRBbmRTYXZlQmluYXJ5Iiwic291cmNlIiwid2ViR0xQcm9ncmFtIiwidW5pZm9ybUxvY2F0aW9ucyIsImluU2hhcGVJbmZvcyIsIm91dFNoYXBlSW5mbyIsImluZkxvYyIsIm5hbkxvYyIsInVuaWZvcm0xZnYiLCJnZXRUZXh0dXJlTWFuYWdlciIsIkhUTUxDYW52YXNFbGVtZW50IiwicmVtb3ZlIiwiZmxvYXRQcmVjaXNpb25WYWx1ZSIsInR1Iiwic3F1YXJlXyIsImV1IiwibnUiLCJzcXVhcmVkRGlmZmVyZW5jZV8iLCJydSIsImFic18iLCJvdSIsImFjb3NfIiwiYXUiLCJhY29zaF8iLCJpdSIsImFzaW5fIiwic3UiLCJhc2luaF8iLCJ1dSIsImF0YW5fIiwiY3UiLCJhdGFuaF8iLCJsdSIsImNlaWxfIiwiaHUiLCJjbGlwQnlWYWx1ZV8iLCJmdSIsImNvc18iLCJkdSIsImNvc2hfIiwicHUiLCJlcmZfIiwidnUiLCJleHBfIiwibXUiLCJleHBtMV8iLCJndSIsImZsb29yXyIsInl1IiwibG9nXyIsInh1IiwibG9nMXBfIiwiYnUiLCJsb2dTaWdtb2lkXyIsInd1IiwibmVnXyIsIkN1IiwicmVjaXByb2NhbF8iLCJFdSIsInJvdW5kXyIsIlJ1IiwicnNxcnRfIiwiSXUiLCJzaWdtb2lkXyIsImt1Iiwic2lnbl8iLCJTdSIsImlzTmFOXyIsIkF1IiwiaXNJbmZfIiwiRHUiLCJpc0Zpbml0ZV8iLCJUdSIsInNpbl8iLCJOdSIsInNpbmhfIiwiRnUiLCJzb2Z0cGx1c18iLCJfdSIsInNxcnRfIiwiT3UiLCJzdGVwXyIsIk11IiwidGFuXyIsIkJ1IiwidGFuaF8iLCJQdSIsIlV1IiwiTHUiLCJXdSIsIlZ1IiwidmFyaWFuY2UiLCJzY2FsZSIsIm9mZnNldCIsInZhcmlhbmNlRXBzaWxvbiIsInp1IiwiR3UiLCJiYXRjaE5vcm1hbGl6YXRpb24yZF8iLCJIdSIsImJhdGNoTm9ybWFsaXphdGlvbjNkXyIsInF1IiwiYmF0Y2hOb3JtYWxpemF0aW9uNGRfIiwiS3UiLCJiYXRjaE5vcm1hbGl6YXRpb25fIiwianUiLCJiYXRjaE5vcm1fIiwiWHUiLCJiYXRjaE5vcm0yZF8iLCJZdSIsImJhdGNoTm9ybTNkXyIsIiR1IiwiYmF0Y2hOb3JtNGRfIiwiUXUiLCJsb2dpY2FsQW5kXyIsIkp1IiwibG9naWNhbE5vdF8iLCJadSIsImxvZ2ljYWxPcl8iLCIkYiIsInRjIiwibG9naWNhbFhvcl8iLCJlYyIsIndoZXJlXyIsIiRjb25kaXRpb24iLCJuYyIsInJjIiwiYWRkXyIsIm9jIiwiYWRkTl8iLCJhYyIsImFkZFN0cmljdF8iLCJpYyIsImF0YW4yXyIsInNjIiwiZGl2XyIsImxjIiwidWMiLCJkaXZOb05hbl8iLCJjYyIsImRpdlN0cmljdF8iLCJmbG9vckRpdl8iLCJoYyIsIm1heGltdW1fIiwiZmMiLCJtYXhpbXVtU3RyaWN0XyIsImRjIiwibWluaW11bV8iLCJwYyIsIm1pbmltdW1TdHJpY3RfIiwidmMiLCJtb2RfIiwibWMiLCJtb2RTdHJpY3RfIiwiZ2MiLCJtdWxfIiwieWMiLCJtdWxTdHJpY3RfIiwieGMiLCJwb3dfIiwiYmMiLCJwb3dTdHJpY3RfIiwid2MiLCJzcXVhcmVkRGlmZmVyZW5jZVN0cmljdF8iLCJDYyIsInN1Yl8iLCJFYyIsInN1YlN0cmljdF8iLCJSYyIsImVxdWFsXyIsIkljIiwiZXF1YWxTdHJpY3RfIiwia2MiLCJncmVhdGVyXyIsIlNjIiwiZ3JlYXRlckVxdWFsXyIsIkFjIiwiZ3JlYXRlckVxdWFsU3RyaWN0XyIsIkRjIiwiZ3JlYXRlclN0cmljdF8iLCJUYyIsImxlc3NfIiwiTmMiLCJsZXNzRXF1YWxfIiwiRmMiLCJsZXNzRXF1YWxTdHJpY3RfIiwiX2MiLCJsZXNzU3RyaWN0XyIsIk9jIiwibm90RXF1YWxfIiwiTWMiLCJub3RFcXVhbFN0cmljdF8iLCJCYyIsIlBjIiwiTGMiLCJnYXRoZXJfIiwiZGltU2l6ZSIsImluZGljZXMiLCJXYyIsInVuc29ydGVkU2VnbWVudFN1bV8iLCJVYyIsIlZjIiwiZHk0RCIsInFjIiwiamMiLCJ6YyIsIkdjIiwiZHk1RCIsIkhjIiwiY29udjFkXyIsImNvbnYyZF8iLCJYYyIsIktjIiwiY29udjNkXyIsIiRmaWx0ZXIiLCJ4NUQiLCJjb252MmREZXJGaWx0ZXJfIiwieDREIiwiY29udjJkRGVySW5wdXRfIiwiWWMiLCJkZXB0aHdpc2VDb252MmRfIiwiJGMiLCJRYyIsImRlcHRod2lzZUNvbnYyZERlcklucHV0XyIsImRlcHRod2lzZUNvbnYyZERlckZpbHRlcl8iLCJKYyIsInNlcGFyYWJsZUNvbnYyZF8iLCJaYyIsImNvbnYyZFRyYW5zcG9zZV8iLCJ0bCIsImNvbnYzZFRyYW5zcG9zZV8iLCJlbCIsIm1hdE11bF8iLCJubCIsImRvdF8iLCJybCIsIm91dGVyUHJvZHVjdF8iLCJvbCIsInJldmVyc2VfIiwiYWwiLCJyZXZlcnNlMWRfIiwiaWwiLCJyZXZlcnNlMmRfIiwic2wiLCJyZXZlcnNlM2RfIiwidWwiLCJyZXZlcnNlNGRfIiwiY2wiLCIkZHkiLCJsbCIsImlucHV0NEQiLCJobCIsIm1heFBvb2xfIiwiZmwiLCJhdmdQb29sXyIsImRsIiwicG9vbF8iLCJwbCIsIm1heFBvb2wzZF8iLCJpbnB1dDVEIiwidmwiLCJhdmdQb29sM2RfIiwibWwiLCJzbGljZV8iLCJiZWdpbiIsInNsaWNlMWRfIiwieWwiLCJzbGljZTJkXyIsInhsIiwic2xpY2UzZF8iLCJibCIsInNsaWNlNGRfIiwid2wiLCJDbCIsImFsbF8iLCJFbCIsImFueV8iLCJSbCIsImFyZ01heF8iLCJJbCIsImFyZ01pbl8iLCJrbCIsImxvZ1N1bUV4cF8iLCJTbCIsIm1heF8iLCJheGVzIiwiQWwiLCJtZWFuXyIsIkRsIiwibWluXyIsIlRsIiwibW9tZW50c18iLCJObCIsInN1bV8iLCJGbCIsInByb2RfIiwiX2wiLCJlbHVfIiwiZHkiLCJPbCIsImxlYWt5UmVsdV8iLCJNbCIsInByZWx1XyIsIkJsIiwicmVsdV8iLCJQbCIsInJlbHU2XyIsIkxsIiwic2VsdV8iLCJXbCIsInRyYW5zcG9zZV8iLCJwZXJtIiwiVWwiLCJsb2NhbFJlc3BvbnNlTm9ybWFsaXphdGlvbl8iLCJWbCIsIm5vcm1fIiwiemwiLCJiYXNpY0xTVE1DZWxsXyIsIkdsIiwibXVsdGlSTk5DZWxsXyIsIkhsIiwibW92aW5nQXZlcmFnZV8iLCJxbCIsInN0cmlkZWRTbGljZV8iLCJLbCIsInRvcGtfIiwiamwiLCJzY2F0dGVyTkRfIiwidXBkYXRlcyIsIlhsIiwiZmZ0XyIsIllsIiwiaWZmdF8iLCIkbCIsInJmZnRfIiwiUWwiLCJpcmZmdF8iLCJKbCIsIlpsIiwic3BhcnNlVG9EZW5zZV8iLCIkc3BhcnNlSW5kaWNlcyIsIiRzcGFyc2VWYWx1ZXMiLCIkZGVmYXVsdFZhbHVlIiwidGgiLCJnYXRoZXJORF8iLCJlaCIsImRpYWdfIiwibmgiLCJkcm9wb3V0XyIsInJoIiwib2giLCJoYW5uV2luZG93XyIsImFoIiwiaGFtbWluZ1dpbmRvd18iLCJpaCIsImZyYW1lXyIsInNoIiwic3RmdF8iLCJ1aCIsImhhbm5XaW5kb3ciLCJoYW1taW5nV2luZG93IiwiZnJhbWUiLCJzdGZ0IiwiY2giLCJsaCIsIk5PTkUiLCJNRUFOIiwiU1VNIiwiU1VNX0JZX05PTlpFUk9fV0VJR0hUUyIsImhoIiwiYWJzb2x1dGVEaWZmZXJlbmNlXyIsImZoIiwiY29tcHV0ZVdlaWdodGVkTG9zc18iLCJkaCIsImNvc2luZURpc3RhbmNlXyIsInBoIiwiaGluZ2VMb3NzXyIsInZoIiwiaHViZXJMb3NzXyIsIm1oIiwibG9nTG9zc18iLCJnaCIsIm1lYW5TcXVhcmVkRXJyb3JfIiwieWgiLCJzaWdtb2lkQ3Jvc3NFbnRyb3B5XyIsInhoIiwic29mdG1heENyb3NzRW50cm9weV8iLCJiaCIsIlJlZHVjdGlvbiIsImFic29sdXRlRGlmZmVyZW5jZSIsImNvbXB1dGVXZWlnaHRlZExvc3MiLCJjb3NpbmVEaXN0YW5jZSIsImhpbmdlTG9zcyIsImh1YmVyTG9zcyIsImxvZ0xvc3MiLCJtZWFuU3F1YXJlZEVycm9yIiwic2lnbW9pZENyb3NzRW50cm9weSIsInNvZnRtYXhDcm9zc0VudHJvcHkiLCJ3aCIsIkNoIiwiYmFuZFBhcnRfIiwiRWgiLCJncmFtU2NobWlkdF8iLCJSaCIsInFyXyIsIkloIiwiYmFuZFBhcnQiLCJncmFtU2NobWlkdCIsImtoIiwiTkVHQVRJVkVfSU5GSU5JVFkiLCJtYXhPdXRwdXRTaXplIiwiaW91VGhyZXNob2xkIiwic2NvcmVUaHJlc2hvbGQiLCJzb2Z0Tm1zU2lnbWEiLCJTaCIsInJlc2l6ZUJpbGluZWFyXyIsImFsaWduQ29ybmVycyIsIm5ld0hlaWdodCIsIm5ld1dpZHRoIiwiQWgiLCJyZXNpemVOZWFyZXN0TmVpZ2hib3JfIiwiYmF0Y2hJbWFnZXMiLCJEaCIsIm5vbk1heFN1cHByZXNzaW9uXyIsImJveGVzIiwic2NvcmVzIiwiVGgiLCJOaCIsIm5vbk1heFN1cHByZXNzaW9uV2l0aFNjb3JlXyIsIkZoIiwiX2giLCJjcm9wQW5kUmVzaXplXyIsImltYWdlcyIsImJveEluZCIsIm1ldGhvZCIsImV4dHJhcG9sYXRpb25WYWx1ZSIsImNyb3BTaXplIiwiT2giLCJub25NYXhTdXBwcmVzc2lvbkFzeW5jIiwibm9uTWF4U3VwcHJlc3Npb25XaXRoU2NvcmUiLCJub25NYXhTdXBwcmVzc2lvbldpdGhTY29yZUFzeW5jIiwiTWgiLCJCaCIsIlBoIiwiTGgiLCJXaCIsImZ1c2VkTWF0TXVsXyIsIlVoIiwiZnVzZWRDb252MmRfIiwiZGlsYXRpb25zIiwiZGltUm91bmRpbmdNb2RlIiwiVmgiLCJmdXNlZERlcHRod2lzZUNvbnYyZF8iLCJ6aCIsIkdoIiwibGluYWxnIiwibG9zc2VzIiwiZnVzZWQiLCJzaWduYWwiLCJjb252M2RUcmFuc3Bvc2UiLCJvcCIsImJhdGNoTm9ybWFsaXphdGlvbjJkIiwiYmF0Y2hOb3JtYWxpemF0aW9uM2QiLCJiYXRjaE5vcm1hbGl6YXRpb240ZCIsImJhdGNoTm9ybTJkIiwiYmF0Y2hOb3JtM2QiLCJiYXRjaE5vcm00ZCIsImJvb2xlYW5NYXNrQXN5bmMiLCJjb25jYXQxZCIsImNvbmNhdDJkIiwiY29uY2F0M2QiLCJjb25jYXQ0ZCIsIm91dGVyUHJvZHVjdCIsInJldmVyc2UxZCIsInJldmVyc2UyZCIsInJldmVyc2UzZCIsInJldmVyc2U0ZCIsInNsaWNlMWQiLCJzbGljZTJkIiwic2xpY2UzZCIsInNsaWNlNGQiLCJtb21lbnRzIiwid2hlcmVBc3luYyIsImJyb2FkY2FzdFRvIiwiZXllIiwicGFkMWQiLCJwYWQyZCIsInBhZDNkIiwicGFkNGQiLCJyYW5kIiwicmFuZG9tTm9ybWFsIiwicmFuZG9tR2FtbWEiLCJyYW5kb21Vbmlmb3JtIiwidHJ1bmNhdGVkTm9ybWFsIiwic2V0ZGlmZjFkQXN5bmMiLCJvbmVzIiwic2NhbGFyIiwidGVuc29yIiwidGVuc29yMWQiLCJ0ZW5zb3IyZCIsInRlbnNvcjNkIiwidGVuc29yNGQiLCJ0ZW5zb3I1ZCIsInRlbnNvcjZkIiwiemVyb3MiLCJiYXNpY0xTVE1DZWxsIiwibXVsdGlSTk5DZWxsIiwibW92aW5nQXZlcmFnZSIsImRyb3BvdXQiLCJpblRvcEtBc3luYyIsIkhoIiwicWgiLCJsaW5lYXIiLCJLaCIsImZpcnN0VXNlIiwiYnJvYWRjYXN0ZWRCaW5hcnlDb21wbGV4T3AiLCJicm9hZGNhc3RlZEJpbmFyeU9wIiwiaHlwb3QiLCJ0cnVuYyIsIlBPU0lUSVZFX0lORklOSVRZIiwibWF4UG9vbFBvc2l0aW9ucyIsInBvb2wzZCIsIm1heFBvb2wzZFBvc2l0aW9ucyIsImZmdEJhdGNoIiwiaXNFeHBvbmVudE9mMiIsImZmdFJhZGl4MiIsImZvdXJpZXJUcmFuc2Zvcm1CeU1hdG11bCIsInNjYXR0ZXIiLCJqaCIsIlhoIiwiWWgiLCIkaCIsIlFoIiwiSmgiLCJaaCIsInBpeGVscyIsIm51bUNoYW5uZWxzIiwiSFRNTFZpZGVvRWxlbWVudCIsIkhUTUxJbWFnZUVsZW1lbnQiLCJ2aWRlb1dpZHRoIiwidmlkZW9IZWlnaHQiLCJkcmF3SW1hZ2UiLCJ0ZiIsImVmIiwibmYiLCJwZXJmb3JtYW5jZSIsInRleHRFbmNvZGVyIiwiVGV4dEVuY29kZXIiLCJUZXh0RGVjb2RlciIsInJmIiwib2YiLCJhZiIsInV0aWwiLCJocnRpbWUiLCJzZiIsInVpbnQxNiIsInVpbnQ4IiwidWYiLCJjZiIsInF1YW50aXphdGlvbiIsImxmIiwiYnl0ZUxlbmd0aCIsImhmIiwiQnVmZmVyIiwiQmxvYiIsImF0b2IiLCJidG9hIiwiZmYiLCJkZiIsInBmIiwidHJpbSIsInZmIiwibW9kZWxUb3BvbG9neSIsIkFycmF5QnVmZmVyIiwiZGF0ZVNhdmVkIiwibW9kZWxUb3BvbG9neVR5cGUiLCJtb2RlbFRvcG9sb2d5Qnl0ZXMiLCJ3ZWlnaHRTcGVjc0J5dGVzIiwid2VpZ2h0U3BlY3MiLCJ3ZWlnaHREYXRhQnl0ZXMiLCJ3ZWlnaHREYXRhIiwibWYiLCJzYXZlUm91dGVycyIsImxvYWRSb3V0ZXJzIiwiZ2V0SW5zdGFuY2UiLCJpbnN0YW5jZSIsInJlZ2lzdGVyU2F2ZVJvdXRlciIsInJlZ2lzdGVyTG9hZFJvdXRlciIsImdldFNhdmVIYW5kbGVycyIsImdldEhhbmRsZXJzIiwiZ2V0TG9hZEhhbmRsZXJzIiwiZ2YiLCJ5ZiIsIm1hbmFnZXJzIiwicmVnaXN0ZXJNYW5hZ2VyIiwiZ2V0TWFuYWdlciIsImdldFNjaGVtZXMiLCJ4ZiIsInNjaGVtZSIsInBhdGgiLCJiZiIsImxvYWQiLCJyZW1vdmVNb2RlbCIsInNhdmUiLCJtb2RlbEFydGlmYWN0c0luZm8iLCJ3ZiIsIkNmIiwiRWYiLCJpbmRleGVkREIiLCJtb3pJbmRleGVkREIiLCJ3ZWJraXRJbmRleGVkREIiLCJtc0luZGV4ZWREQiIsInNoaW1JbmRleGVkREIiLCJSZiIsImNyZWF0ZU9iamVjdFN0b3JlIiwia2V5UGF0aCIsIklmIiwibW9kZWxQYXRoIiwiZGF0YWJhc2VBY3Rpb24iLCJvcGVuIiwib251cGdyYWRlbmVlZGVkIiwib25zdWNjZXNzIiwidHJhbnNhY3Rpb24iLCJvYmplY3RTdG9yZSIsImNsb3NlIiwibW9kZWxBcnRpZmFjdHMiLCJvbmVycm9yIiwib25jb21wbGV0ZSIsInB1dCIsIlVSTF9TQ0hFTUUiLCJrZiIsInN0YXJ0c1dpdGgiLCJTZiIsImxpc3RNb2RlbHMiLCJnZXRBbGwiLCJBZiIsIkRmIiwiVGYiLCJOZiIsIkZmIiwiX2YiLCJPZiIsIk1mIiwiaW5mbyIsInRvcG9sb2d5IiwibW9kZWxNZXRhZGF0YSIsIkJmIiwiUGYiLCJsb2NhbFN0b3JhZ2UiLCJMUyIsInNldEl0ZW0iLCJmb3JtYXQiLCJnZW5lcmF0ZWRCeSIsImNvbnZlcnRlZEJ5IiwidXNlckRlZmluZWRNZXRhZGF0YSIsInJlbW92ZUl0ZW0iLCJnZXRJdGVtIiwiYnl0ZU9mZnNldCIsIkxmIiwiV2YiLCJrZXkiLCJVZiIsIlZmIiwiemYiLCJHZiIsIkhmIiwibW9kZWxUb3BvbG9neUZpbGVOYW1lIiwid2VpZ2h0RGF0YUZpbGVOYW1lIiwiVVJMIiwiY3JlYXRlT2JqZWN0VVJMIiwicGF0aHMiLCJ3ZWlnaHRzIiwid2VpZ2h0c01hbmlmZXN0IiwianNvbkFuY2hvciIsImRvd25sb2FkIiwiaHJlZiIsImRpc3BhdGNoRXZlbnQiLCJNb3VzZUV2ZW50Iiwid2VpZ2h0RGF0YUFuY2hvciIsInFmIiwiZmlsZXMiLCJGaWxlUmVhZGVyIiwib25sb2FkIiwidGFyZ2V0IiwiY2hlY2tNYW5pZmVzdEFuZFdlaWdodEZpbGVzIiwicmVhZEFzQXJyYXlCdWZmZXIiLCJyZWFkQXNUZXh0IiwiS2YiLCJqZiIsImZldGNoRnVuYyIsInJlcXVlc3RJbml0IiwiaXNCaW5hcnkiLCJvblByb2dyZXNzIiwiYXJyYXlCdWZmZXIiLCJYZiIsIm1hbmlmZXN0RW50cnkiLCJncm91cE9mZnNldCIsInNpemVCeXRlcyIsIllmIiwiREVGQVVMVF9NRVRIT0QiLCJ3ZWlnaHRQYXRoUHJlZml4IiwiYm9keSIsIkZvcm1EYXRhIiwiYXBwZW5kIiwib2siLCJyZXNwb25zZXMiLCJzdGF0dXMiLCJqc29uIiwibG9hZFdlaWdodHMiLCJsYXN0SW5kZXhPZiIsIlVSTF9TQ0hFTUVfUkVHRVgiLCIkZiIsIm1hdGNoIiwiUWYiLCJKZiIsIlpmIiwidGQiLCJzYXZlSGFuZGxlciIsImVkIiwiYnJvd3NlckZpbGVzIiwiYnJvd3NlckhUVFBSZXF1ZXN0IiwiY29uY2F0ZW5hdGVBcnJheUJ1ZmZlcnMiLCJkZWNvZGVXZWlnaHRzIiwiZW5jb2RlV2VpZ2h0cyIsImdyb3VwIiwic3BlY3MiLCJmcm9tTWVtb3J5IiwidHJhaW5pbmdDb25maWciLCJnZXRNb2RlbEFydGlmYWN0c0luZm9Gb3JKU09OIiwiaHR0cCIsImlzSFRUUFNjaGVtZSIsIndlaWdodHNMb2FkZXJGYWN0b3J5Iiwid2l0aFNhdmVIYW5kbGVyIiwiY29weU1vZGVsIiwibW92ZU1vZGVsIiwibmQiLCJyZCIsImNvbmZ1c2lvbk1hdHJpeF8iLCJvZCIsImNvbmZ1c2lvbk1hdHJpeCIsImFkIiwiZnJvbVBpeGVsc18iLCJJbWFnZURhdGEiLCJyZWFkeVN0YXRlIiwiZ2V0SW1hZ2VEYXRhIiwidG9QaXhlbHMiLCJVaW50OENsYW1wZWRBcnJheSIsInB1dEltYWdlRGF0YSIsImZyb21QaXhlbHMiLCJzZCIsImdldENsYXNzTmFtZSIsImNsYXNzTmFtZSIsImZyb21Db25maWciLCJ1ZCIsImNsYXNzTmFtZU1hcCIsImdldE1hcCIsInJlZ2lzdGVyIiwiY2QiLCJsZCIsIlNlcmlhbGl6YWJsZSIsIlNlcmlhbGl6YXRpb25NYXAiLCJyZWdpc3RlckNsYXNzIiwiaGQiLCJmZCIsImRkIiwicGQiLCJ2ZCIsIm1kIiwiVEVTVF9FUFNJTE9OX0ZMT0FUMTYiLCJleHBlY3RBcnJheXNDbG9zZSIsInRlc3RFcHNpbG9uIiwiZXhwZWN0UHJvbWlzZVRvRmFpbCIsImZhaWwiLCJleHBlY3RBcnJheXNFcXVhbCIsImV4cGVjdE51bWJlcnNDbG9zZSIsImV4cGVjdFZhbHVlc0luUmFuZ2UiLCJleHBlY3RBcnJheUJ1ZmZlcnNFcXVhbCIsImV4cGVjdCIsInRvRXF1YWwiLCJnZCIsInlkIiwiZ3BncHVfdXRpbCIsIndlYmdsX3V0aWwiLCJmb3JjZUhhbGZGbG9hdCIsIk1hdGhCYWNrZW5kV2ViR0wiLCJzZXRXZWJHTENvbnRleHQiLCJHUEdQVUNvbnRleHQiLCJ4ZCIsIm1pbmltaXplIiwiY29tcHV0ZUdyYWRpZW50cyIsImFwcGx5R3JhZGllbnRzIiwiaXRlcmF0aW9uc18iLCJpbmNyZW1lbnRJdGVyYXRpb25zIiwiaXRlcmF0aW9ucyIsInNhdmVJdGVyYXRpb25zIiwiZ2V0V2VpZ2h0cyIsInNldFdlaWdodHMiLCJleHRyYWN0SXRlcmF0aW9ucyIsImJkIiwibGVhcm5pbmdSYXRlIiwicmhvIiwiYWNjdW11bGF0ZWRHcmFkcyIsImFjY3VtdWxhdGVkVXBkYXRlcyIsIm9yaWdpbmFsTmFtZSIsImdldENvbmZpZyIsIndkIiwiaW5pdGlhbEFjY3VtdWxhdG9yVmFsdWUiLCJDZCIsImJldGExIiwiYmV0YTIiLCJhY2N1bXVsYXRlZEZpcnN0TW9tZW50IiwiYWNjdW11bGF0ZWRTZWNvbmRNb21lbnQiLCJhY2NCZXRhMSIsImFjY0JldGEyIiwiRWQiLCJkZWNheSIsImFjY3VtdWxhdGVkV2VpZ2h0ZWRJbmZOb3JtIiwiaXRlcmF0aW9uIiwiUmQiLCJzZXRMZWFybmluZ1JhdGUiLCJJZCIsIm1vbWVudHVtIiwidXNlTmVzdGVyb3YiLCJhY2N1bXVsYXRpb25zIiwic2V0TW9tZW50dW0iLCJrZCIsImFjY3VtdWxhdGVkTWVhblNxdWFyZXMiLCJhY2N1bXVsYXRlZE1vbWVudHMiLCJhY2N1bXVsYXRlZE1lYW5HcmFkcyIsImNlbnRlcmVkIiwiU2QiLCJzZ2QiLCJybXNwcm9wIiwiYWRhbSIsImFkYWRlbHRhIiwiYWRhbWF4IiwiYWRhZ3JhZCIsIkFkIiwiRGQiLCJyZXF1ZXN0QW5pbWF0aW9uRnJhbWUiLCJzZXRJbW1lZGlhdGUiLCJUZCIsIkFkYWRlbHRhT3B0aW1pemVyIiwiQWRhZ3JhZE9wdGltaXplciIsIkFkYW1PcHRpbWl6ZXIiLCJBZGFtYXhPcHRpbWl6ZXIiLCJEYXRhU3RvcmFnZSIsIkVudmlyb25tZW50IiwiS2VybmVsQmFja2VuZCIsIk1vbWVudHVtT3B0aW1pemVyIiwiT3B0aW1pemVyIiwiUk1TUHJvcE9wdGltaXplciIsIlJhbmsiLCJTR0RPcHRpbWl6ZXIiLCJUZW5zb3IiLCJUZW5zb3JCdWZmZXIiLCJWYXJpYWJsZSIsImJhY2tlbmRfdXRpbCIsImJyb3dzZXIiLCJkZXByZWNhdGlvbldhcm4iLCJkaXNhYmxlRGVwcmVjYXRpb25XYXJuaW5ncyIsImVuYWJsZURlYnVnTW9kZSIsImVuYWJsZVByb2RNb2RlIiwiZW5naW5lIiwiZW52IiwiZ2F0aGVyX3V0aWwiLCJnZXRCYWNrZW5kIiwiZ2V0R3JhZGllbnQiLCJnZXRLZXJuZWwiLCJnZXRLZXJuZWxzRm9yQmFja2VuZCIsIm1hdGgiLCJuZXh0RnJhbWUiLCJyZWdpc3RlckdyYWRpZW50IiwicmVnaXN0ZXJLZXJuZWwiLCJzY2F0dGVyX3V0aWwiLCJzZXJpYWxpemF0aW9uIiwic2xpY2VfdXRpbCIsInN1bU91dFR5cGUiLCJ0ZW5zb3JfdXRpbCIsInRlc3RfdXRpbCIsInRyYWluIiwidW5yZWdpc3RlckdyYWRpZW50IiwidW5yZWdpc3Rlcktlcm5lbCIsInZhbHVlQW5kR3JhZCIsInZhbHVlQW5kR3JhZHMiLCJ2YXJpYWJsZUdyYWRzIiwidmVyc2lvbl9jb3JlIiwid2ViZ2wiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@tensorflow/tfjs-core/dist/tf-core.esm.js\n");

/***/ })

};
;